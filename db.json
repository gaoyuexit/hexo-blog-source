{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/doge-logo.png","path":"doge-logo.png","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"themes/apollo/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":0,"renderable":1},{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1459064683000},{"_id":"source/CNAME","hash":"98a1082c7af7861620be98ecdced49e66e8d1fe0","modified":1442473564000},{"_id":"source/doge-logo.png","hash":"2acf5097a19d30c01e1de6b8a72ece185efdeee4","modified":1458904002000},{"_id":"source/favicon.ico","hash":"d2aa673fa127c6a45f8c2db85c0eeda7871d6f39","modified":1442473564000},{"_id":"themes/apollo/.gitignore","hash":"a006beea0877a0aa3610ee00e73f62cb1d45125b","modified":1458979721000},{"_id":"themes/apollo/LICENSE","hash":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1458979721000},{"_id":"themes/apollo/README.md","hash":"fb6fbe42172a35cbdaa540a777cc4bc02add2278","modified":1458979721000},{"_id":"themes/apollo/_config.yml","hash":"babaac88e9fde894f6bcc42f6f2af2e7f97fcfd5","modified":1458983424000},{"_id":"themes/apollo/gulpfile.js","hash":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1458979721000},{"_id":"themes/apollo/package.json","hash":"9426138c09ebb95969021d951590c0c54b187a43","modified":1458979721000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1458981667000},{"_id":"source/_posts/64-bit-tips.md","hash":"802b7a91df98f1579f0654612b464a537e3dba4b","modified":1459065020000},{"_id":"source/_posts/behind-autorelease.md","hash":"20240dd08395d3c86008c20e029d030b533f83bb","modified":1459065203000},{"_id":"source/_posts/cell-height-calculation.md","hash":"d9f6b43805d36566ec4c88843249bee03ad294d9","modified":1458983881000},{"_id":"source/_posts/class-cluster.md","hash":"f7eb22a839c9ac6e52a30bd240793afaa6f584d6","modified":1459065079000},{"_id":"source/_posts/class-dependency-injection-and-architecture.md","hash":"305a93cfc0d541016230ed7d269bbe223feec649","modified":1459264791000},{"_id":"source/_posts/class-ivar-layout.md","hash":"6d330ee474ccae42a32affb6e14cdb366e321967","modified":1458984092000},{"_id":"source/_posts/fp-essential.md","hash":"a39197e24256f1de080fceeb17fe3d4d8c1b7f2e","modified":1459065260000},{"_id":"source/_posts/fullscreen-pop-gesture.md","hash":"db201791b9d60fb04b1673a90ff8969cb9d6241c","modified":1458982682000},{"_id":"source/_posts/hexo_customize.md","hash":"5568aebdadd54965b4f9cc1ba0364dbc39b7a6d6","modified":1459067981000},{"_id":"source/_posts/hexo_startup.md","hash":"32d0bc033f28b4b6f68deadb608ba3a98b62624f","modified":1459070526000},{"_id":"source/_posts/ios-hide-grouped-tableview-header.md","hash":"7068d1f8a4f3d90d746d98345b550241653ebebc","modified":1458741232000},{"_id":"source/_posts/ios-interview.md","hash":"1c84a1fe247418cf35613e15fbffc7cae394c3e0","modified":1458982278000},{"_id":"source/_posts/ios8-size-classes.md","hash":"7a0780b7d2067ff4fbcaea5b031b1394e82cfe01","modified":1458741232000},{"_id":"source/_posts/ios_0code_vc.md","hash":"18664ae3eee5e8901ce76f2394d5f45c25b82c3d","modified":1459066537000},{"_id":"source/_posts/ios_exam_0.md","hash":"be05fe746482324d91a093164769a013acadef46","modified":1459068209000},{"_id":"source/_posts/ios_exam_0_key.md","hash":"bf991bff9236c1775d450bfff2e6f70e058b82a9","modified":1459068119000},{"_id":"source/_posts/ios_ib_bridge.md","hash":"e90a9edacd2cdd69396f3f2507b28d7d28b18656","modified":1459066675000},{"_id":"source/_posts/ios_iterator.md","hash":"9fbaa6d63aac12de71110d59b15a36999957c9fb","modified":1459067519000},{"_id":"source/_posts/iphone6-resolution.md","hash":"1c9d01814c4c0e4c24f68cd27eb0ee0980203669","modified":1458741232000},{"_id":"source/_posts/multiple-char.md","hash":"d793ee5ddcdbdc9b45b8b7f706575c2675a085fc","modified":1459064723000},{"_id":"source/_posts/notification-once.md","hash":"24133728820c5e760f7b88f51610984d7ab11962","modified":1459064830000},{"_id":"source/_posts/objc-attribute-cleanup.md","hash":"80348c34f08d988d1a01e86d1b0e7a27beb760d7","modified":1459065338000},{"_id":"source/_posts/objc-duck-advanced.md","hash":"7dac564eb4cd0b03dfaf620340386dae6f383ddd","modified":1459066702000},{"_id":"source/_posts/objc-duck.md","hash":"622b4bb5b79ac04a387c8680f7057e9136db2c44","modified":1459066695000},{"_id":"source/_posts/objc-new-features-in-2015.md","hash":"452501fd697c6e8ca67285510793d8e2a407c48d","modified":1458981333000},{"_id":"source/_posts/objc-pre-main.md","hash":"80f6227c63586951b1f044bfff32af1775f9fec0","modified":1459065475000},{"_id":"source/_posts/objc-weird-code.md","hash":"4753bdc57bb1f6e9e65f34046a65dedcf296d0f1","modified":1459066713000},{"_id":"source/_posts/objc_arc_secret.md","hash":"f2f7a542d55b100dc7b0e07093cafbb852925a53","modified":1459067729000},{"_id":"source/_posts/objc_category_secret.md","hash":"922c5ecbcd2e4da9f34d598b20e5dc5b1be8fac2","modified":1459070428000},{"_id":"source/_posts/objc_dig_interface.md","hash":"325c8438ddae297a6ac90c4a10981842f6a68e43","modified":1459067543000},{"_id":"source/_posts/objc_dig_nslog.md","hash":"40f73c5f88805bd447d3afccfcdef0aa179ce320","modified":1459066879000},{"_id":"source/_posts/objc_kvo_secret.md","hash":"59381dd42903dc8f6ea64d05439af58e7ac30075","modified":1459067868000},{"_id":"source/_posts/rac_0_overview.md","hash":"8bd8148f6ee43930e957289ba8f9d324ed48719a","modified":1459070293000},{"_id":"source/_posts/rac_1_macros.md","hash":"51dd292cdc3d23d535d5a09d39cc02f8f2b40511","modified":1459070255000},{"_id":"source/_posts/rac_2_racstream.md","hash":"1a0cd5cee8cbc2fa828db17d7f0e38b559d204e8","modified":1459070193000},{"_id":"source/_posts/rac_3_racsignal.md","hash":"cec03dcff464488f93c9c10781cdec363eed83e1","modified":1459069876000},{"_id":"source/_posts/rac_4_filters.md","hash":"a7e4af3bc46b166330d6219975a82fa0ec3000a6","modified":1459067534000},{"_id":"source/_posts/runtime-nuts.md","hash":"1d8c6e8d00dfd2a6c17f25bae29c0f384a57a47d","modified":1459065107000},{"_id":"source/_posts/self-in-arc.md","hash":"8fabaf5ffb90b1e26315b8c45f881bf7120e104b","modified":1459064925000},{"_id":"source/_posts/self-manager-pattern-in-ios.md","hash":"2bc867ea64885e4a901592d63490ae050ce4dc76","modified":1458984128000},{"_id":"source/_posts/sublime_text_markdown.md","hash":"48fe2648133da40bf98f5affc557aaf7987977ac","modified":1459067572000},{"_id":"source/_posts/todo-macro.md","hash":"f5685f71a21d918d19e057101630b432f66200ef","modified":1459064879000},{"_id":"source/_posts/xcode-tips.md","hash":"1d59c44643ffffa6abcb9b242fbf9b33ea888e97","modified":1458741232000},{"_id":"source/_posts/xcode_plugins.md","hash":"f979c82624d2a9740e36ccc8324b2c6395e89a1b","modified":1459067760000},{"_id":"source/_posts/objc_dig_arc_dealloc.md","hash":"8bd6a65d226350cba249db069bc3b428c87e3754","modified":1459067562000},{"_id":"themes/apollo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1458979721000},{"_id":"themes/apollo/.git/config","hash":"e8486e77527181934f2dda23e50b879ab7641244","modified":1458979721000},{"_id":"themes/apollo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1458979712000},{"_id":"themes/apollo/.git/index","hash":"e8ecfe423b643dc9a29a087c8b85ae636f0b548c","modified":1458979721000},{"_id":"themes/apollo/.git/packed-refs","hash":"b1cb71aaeb66841a5f6fdbf6b7f85b13f25cd04d","modified":1458979721000},{"_id":"themes/apollo/doc/doc-en.md","hash":"3eec4f30b0cd66bbac6f9c550c25e8c67d222dba","modified":1458979721000},{"_id":"themes/apollo/doc/doc-zh.md","hash":"3aad2ed65922f6f5dd9731301195474d16a8a9be","modified":1458979721000},{"_id":"themes/apollo/languages/en.yml","hash":"65998758dd27a350b6d4f2dc803970a9c89978da","modified":1458979721000},{"_id":"themes/apollo/languages/zh-cn.yml","hash":"9e4b03e14c094000257ea254fd660dde4c7af63c","modified":1458979721000},{"_id":"themes/apollo/layout/archive.jade","hash":"62797414355bf4474092bc3a32726c8340820ffb","modified":1458979721000},{"_id":"themes/apollo/layout/index.jade","hash":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1458979721000},{"_id":"themes/apollo/layout/post.jade","hash":"33ab46ab3736e5d51388939858647942ce375b9b","modified":1458979721000},{"_id":"themes/apollo/source/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1458979721000},{"_id":"themes/apollo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1458979712000},{"_id":"themes/apollo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1458979712000},{"_id":"themes/apollo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1458979712000},{"_id":"themes/apollo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1458979712000},{"_id":"themes/apollo/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1458979712000},{"_id":"themes/apollo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1458979712000},{"_id":"themes/apollo/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1458979712000},{"_id":"themes/apollo/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1458979712000},{"_id":"themes/apollo/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1458979712000},{"_id":"themes/apollo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1458979712000},{"_id":"themes/apollo/.git/logs/HEAD","hash":"5ff43401c712b1e6794dd41372ff40eb930ade4d","modified":1458979721000},{"_id":"themes/apollo/layout/mixins/post.jade","hash":"90eedc680eff34bf297d0561d343c7bf118606a0","modified":1458979721000},{"_id":"themes/apollo/layout/mixins/paginator.jade","hash":"f4ee2fb61a32e199b48cf93771749edc8a007391","modified":1458979721000},{"_id":"themes/apollo/layout/partial/comment.jade","hash":"ff0a2c269c2434da2ac5529872f1d6184a71f96d","modified":1458979721000},{"_id":"themes/apollo/layout/partial/copyright.jade","hash":"2c72ae40fcf071bd17f484ab947873e64149a2f6","modified":1458980227000},{"_id":"themes/apollo/layout/partial/head.jade","hash":"51b2ba6a1cebb275730eb7131eea211c91f0986a","modified":1458979721000},{"_id":"themes/apollo/layout/partial/layout.jade","hash":"d596c281bbba02cf8837f25f8ac0ac06e3d10e72","modified":1458979721000},{"_id":"themes/apollo/layout/partial/nav.jade","hash":"c35d3061da4b053b73150d9741c542d660798270","modified":1458979721000},{"_id":"themes/apollo/layout/partial/scripts.jade","hash":"7920df1928b76f4a6751717a3b5d07f514dc4d78","modified":1458979721000},{"_id":"themes/apollo/source/css/apollo.css","hash":"fcd9355e1a5d656fba182734cd79594627ae0243","modified":1459241244000},{"_id":"themes/apollo/source/scss/apollo.scss","hash":"a3153dfedbaff08c20930b2bde95f2db49f6d518","modified":1458979721000},{"_id":"themes/apollo/.git/objects/pack/pack-0076672425721aa1ceef21e5d27cfeec43b2f3c6.idx","hash":"db8480102f9ad5636d485961bdd2640fcf4f4b2c","modified":1458979721000},{"_id":"themes/apollo/.git/refs/heads/master","hash":"d48671222bdedc6ba06efda6622dc862b0c73179","modified":1458979721000},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","hash":"04936d97f086dc67a9e48cee592d8b96d363f764","modified":1458979721000},{"_id":"themes/apollo/source/scss/_partial/base.scss","hash":"13ed6340bfe140278c1053f81c061a9e112fa27e","modified":1458979721000},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","hash":"7fc843c37a4dbf9f6e70770398841a73465ec642","modified":1458979721000},{"_id":"themes/apollo/source/scss/_partial/footer.scss","hash":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1458979721000},{"_id":"themes/apollo/source/scss/_partial/header.scss","hash":"d24cc6520f3faa7bb80610b858a92639eadcc289","modified":1458979721000},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","hash":"6b5c59f3d2295944f934aee2c1156012a3306d5d","modified":1458979721000},{"_id":"themes/apollo/source/scss/_partial/mq.scss","hash":"372725415b78d83f617730eb0a4468702623c330","modified":1458979721000},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1458979721000},{"_id":"themes/apollo/source/scss/_partial/post.scss","hash":"0d24fea250aada8b82baf95fcd819b8d6f4e9b1e","modified":1458979721000},{"_id":"themes/apollo/.git/logs/refs/heads/master","hash":"5ff43401c712b1e6794dd41372ff40eb930ade4d","modified":1458979721000},{"_id":"themes/apollo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1458979721000},{"_id":"themes/apollo/.git/objects/pack/pack-0076672425721aa1ceef21e5d27cfeec43b2f3c6.pack","hash":"2961a488640eb43d41d6f4380f6abe5fba45d9ee","modified":1458979721000},{"_id":"themes/apollo/.git/logs/refs/remotes/origin/HEAD","hash":"5ff43401c712b1e6794dd41372ff40eb930ade4d","modified":1458979721000}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"64-bit Tips","date":"2014-12-20T12:11:13.000Z","_content":"\n终究还是来了。Apple下发了支持64位的最后通牒：\n\n> As we announced in October, beginning February 1, 2015 new iOS apps submitted to the App Store must include 64-bit support and be built with the iOS 8 SDK. Beginning June 1, 2015 app updates will also need to follow the same requirements.\n\n早应该做的适配终于要开始动工了，苦了64位的CPU运行了这么久32位的程序。前段时间公司项目完成了64-bit包的适配，本没那么复杂的事被无数不标准的老代码搅和的不轻，总结几个Tip共勉。\n\n# Tips\n\n## 拒绝基本数据类型和隐式转换\n\n首当其冲的就是基本类型，比如下面4个类型在32-bit和64-bit下分别是多长呢？  \n\n``` objc\nsize_t s1 = sizeof(int);\nsize_t s2 = sizeof(long);\nsize_t s3 = sizeof(float);\nsize_t s4 = sizeof(double);\n```\n\n32-bit下：`4, 4, 4, 8`；64-bit下：`4, 8, 4, 8`  \n（PS： 这个结果随编译器，换其他平台可不一定）\n它们的长度变化可能并非我们对64-bit长度加倍的预期，所以说，程序中出现`sizeof`的代码多看两眼。而且，除非你明确知道自己在做什么，应该使用下面的类型代替基本类型：  \n\n - int -> NSInteger\n - unsigned -> NSUInteger\n - float -> CGFloat\n - 动画时间 -> NSTimeInterval\n - ...\n\n这些都是SDK中定义的类型，而我们大部分时间都在跟SDK的API们打交道，使用它们能将类型转换的影响降低很多。\n\n再比如说下面的代码：  \n\n``` objc\nNSArray *items = @[@1, @2, @3];\nfor (int i = -1; i < items.count; i++) {\n    NSLog(@\"%d\", i);\n}\n```\n\n结果是，for循环一次都没有进。  \n数组的`count`是`NSUInteger`类型的，-1与其比较时隐式转换成`NSUInteger`，变成了一个很大的数字：  \n\n``` objc\n(lldb) p i\n(int) $0 = -1\n(lldb) p (NSUInteger)i\n(NSUInteger) $1 = 18446744073709551615\n```\n\n这和64-bit到没啥关系，想要说明的是，这种隐式转换也需要小心，一定要注意和这个变量相关的所有操作（赋值、比较、转换）  \n老式for循环可以考虑写成：  \n\n``` objc\nfor (NSUInteger index = 0; index < items.count; index++) {}\n```\n\n当然，数组遍历还是更推荐用`for-in`或`block`版本的，它们之间的比较可以回顾下[这篇文章](http://blog.sunnyxx.com/2014/04/30/ios_iterator/)。\n\n## 使用新版枚举\n\n和上面的原因差不多，枚举应该使用新版的写法：  \n\n``` objc\ntypedef NS_ENUM(NSInteger, UIViewAnimationCurve) {\n    UIViewAnimationCurveEaseInOut,\n    UIViewAnimationCurveEaseIn,\n    UIViewAnimationCurveEaseOut,\n    UIViewAnimationCurveLinear\n};\n```\n\n不仅能为枚举值指定类型，而且当赋值赋错类型时，编译器还会给出警告，没理由不用这种写法。\n\n## 替代Format字符串\n\n适配64-bit时，你是否遇到了下面的恶心写法：  \n\n``` objc\nNSArray *items = @[@1, @2, @3];\nNSLog(@\"数组元素个数：%lu\", (unsigned long)items.count);\n```\n\n一般情况下，利用`NSNumber`的`@`语法糖就可以解决：  \n\n``` objc\nNSArray *items = @[@1, @2, @3];\nNSLog(@\"数组元素个数：%@\", @(items.count));\n```\n\n同理，int转string也可以：\n\n``` objc\nNSInteger i = 10086;\nNSString *string = @(i).stringValue;\n```\n\n当然，如需要`%.2f`这种Format就不适用了。\n\n## 64-bit下的BOOL\n\n32-bit下，BOOL被定义为`signed char`，@encode(BOOL)的结果是`'c'`  \n64-bit下，BOOL被定义为`bool`，@encode(BOOL)结果是`'B'`   \n更直观的解释是：   \n\n``` objc\n(lldb) p/t (signed char)7\n(BOOL) $0 = 0b00000111 (YES)\n(lldb) p/t (bool)7\n(bool) $1 = 0b00000001 (YES)\n```\n\n32-bit版本的BOOL包括了256个值的可能性，还会引起一些坑，像[这篇文章](http://www.bignerdranch.com/blog/bools-sharp-corners/)所说的。而64-bit下只有0（NO），1（YES）两种可能，终于给BOOL正了名。    \n\n## 不直接取isa指针\n\n编译器已经默认禁用了这种使用，isa指针在32位下是Class的地址，但在64位下利用bits mask才能取出来真正的地址，若真需要，使用runtime的`object_getClass` 和`object_setClass`方法。关于64位下isa的讲解可以看[这篇文章](http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html)\n\n## 解决第三方lib依赖和lipo命令\n\n以源码形式出现在工程中的第三方lib，只要把target加上`arm64`编译就好了。  \n恶心的就是直接拖进工程的那些静态库(.a)或者framework，就需要重新找支持64-bit的包了。这时候就能看出哪些是已无人维护的lib了，是时候找个替代品了（比如我全网找不到工程中用到的一个音频库的64位包，终于在一个哥们的github上找到，哭着给了个star- -）  \n\n### 打印Mach-O文件支持的架构\n\n如何看一个可执行文件是不是支持64-bit呢？   \n\n使用`lipo -info`命令，比如看看UIKit支持的架构：  \n\n``` objc\n// 当前在Xcode Frameworks目录\nsunnyxx$ lipo -info UIKit.framework/UIKit\nArchitectures in the fat file: UIKit.framework/UIKit are: arm64 armv7s  \n```\n\n想看的更详细的信息可以使用`lipo -detailed_info`：\n\n``` objc\nsunnyxx$ lipo -detailed_info UIKit.framework/UIKit\nFat header in: UIKit.framework/UIKit\nfat_magic 0xcafebabe\nnfat_arch 2\narchitecture arm64\n    cputype CPU_TYPE_ARM64\n    cpusubtype CPU_SUBTYPE_ARM64_ALL\n    offset 4096\n    size 16822272\n    align 2^12 (4096)\narchitecture armv7s\n    cputype CPU_TYPE_ARM\n    cpusubtype CPU_SUBTYPE_ARM_V7S\n    offset 16826368\n    size 14499840\n    align 2^12 (4096)\n```\n\n当然，还可以使用`file`命令：  \n\n``` shell\nsunnyxx$ file UIKit.framework/UIKit\nUIKit.framework/UIKit: Mach-O universal binary with 2 architectures\nUIKit.framework/UIKit (for architecture arm64):Mach-O 64-bit dynamically linked shared library\nUIKit.framework/UIKit (for architecture armv7s):Mach-O dynamically linked shared library arm\n```\n\n上述命令对`Mach-O`文件适用，静态库`.a`文件，framework中的`.a`文件，自己app的可执行文件都可以打印下看看。  \n\n### 合并多个架构的包\n\n如果，我们有`MyLib-32.a`和`MyLib-64.a`，可以使用`lipo -create`命令合并：  \n\n``` shell\nsunnyxx$ lipo -create MyLib-32.a MyLib-64.a -output MyLib.a\n```\n\n## 支持64-bit后程序包会变大么？\n\n会，支持64-bit后，多了一个`arm64`架构，理论上每个架构一套指令，但相比原来会大多少还不好说，我们这里增加了大概50%，还有听说会增加一倍的。\n\n## 一个lib包含了很多的架构，会打到最后的包里么？\n\n不会，如果lib中有`armv7, armv7s, arm64, i386`架构，而target architecture选择了`armv7s, arm64`，那么只会从lib中link指定的这两个架构的二进制代码，其他架构下的代码不会link到最终可执行文件中；反过来，一个lib需要在模拟器环境中正常link，也得包含i386架构的指令。\n\n## Checklist\n\n最后列一下官方文档中的注意点：  \n\n - 不要将指针强转成整数\n - 程序各处使用统一的数据类型\n - 对不同类型的整数做运算时一定要注意\n - 需要定长变量时，使用如`int32_t, int64_t`这种定长类型\n - 使用malloc时，不要写死size\n - 使用能同时适配两个架构的格式化字符串\n - 注意函数和函数指针（类型转换和可变参数）\n - 不要直接访问Objective-C的指针（isa）\n - 使用内建的同步原语（Primitives）\n - 不要硬编码虚存页大小\n - [Go Position Independent](https://developer.apple.com/library/ios/qa/qa1788/_index.html#//apple_ref/doc/uid/DTS40013354)\n\n# References\n\nhttps://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013501-CH1-SW1\nhttp://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html\nhttp://www.bignerdranch.com/blog/64-bit-smorgasbord/\nhttp://www.bignerdranch.com/blog/bools-sharp-corners/\n","source":"_posts/64-bit-tips.md","raw":"title: 64-bit Tips\ndate: 2014-12-20 20:11:13\ntags: ios最佳实践\n---\n\n终究还是来了。Apple下发了支持64位的最后通牒：\n\n> As we announced in October, beginning February 1, 2015 new iOS apps submitted to the App Store must include 64-bit support and be built with the iOS 8 SDK. Beginning June 1, 2015 app updates will also need to follow the same requirements.\n\n早应该做的适配终于要开始动工了，苦了64位的CPU运行了这么久32位的程序。前段时间公司项目完成了64-bit包的适配，本没那么复杂的事被无数不标准的老代码搅和的不轻，总结几个Tip共勉。\n\n# Tips\n\n## 拒绝基本数据类型和隐式转换\n\n首当其冲的就是基本类型，比如下面4个类型在32-bit和64-bit下分别是多长呢？  \n\n``` objc\nsize_t s1 = sizeof(int);\nsize_t s2 = sizeof(long);\nsize_t s3 = sizeof(float);\nsize_t s4 = sizeof(double);\n```\n\n32-bit下：`4, 4, 4, 8`；64-bit下：`4, 8, 4, 8`  \n（PS： 这个结果随编译器，换其他平台可不一定）\n它们的长度变化可能并非我们对64-bit长度加倍的预期，所以说，程序中出现`sizeof`的代码多看两眼。而且，除非你明确知道自己在做什么，应该使用下面的类型代替基本类型：  \n\n - int -> NSInteger\n - unsigned -> NSUInteger\n - float -> CGFloat\n - 动画时间 -> NSTimeInterval\n - ...\n\n这些都是SDK中定义的类型，而我们大部分时间都在跟SDK的API们打交道，使用它们能将类型转换的影响降低很多。\n\n再比如说下面的代码：  \n\n``` objc\nNSArray *items = @[@1, @2, @3];\nfor (int i = -1; i < items.count; i++) {\n    NSLog(@\"%d\", i);\n}\n```\n\n结果是，for循环一次都没有进。  \n数组的`count`是`NSUInteger`类型的，-1与其比较时隐式转换成`NSUInteger`，变成了一个很大的数字：  \n\n``` objc\n(lldb) p i\n(int) $0 = -1\n(lldb) p (NSUInteger)i\n(NSUInteger) $1 = 18446744073709551615\n```\n\n这和64-bit到没啥关系，想要说明的是，这种隐式转换也需要小心，一定要注意和这个变量相关的所有操作（赋值、比较、转换）  \n老式for循环可以考虑写成：  \n\n``` objc\nfor (NSUInteger index = 0; index < items.count; index++) {}\n```\n\n当然，数组遍历还是更推荐用`for-in`或`block`版本的，它们之间的比较可以回顾下[这篇文章](http://blog.sunnyxx.com/2014/04/30/ios_iterator/)。\n\n## 使用新版枚举\n\n和上面的原因差不多，枚举应该使用新版的写法：  \n\n``` objc\ntypedef NS_ENUM(NSInteger, UIViewAnimationCurve) {\n    UIViewAnimationCurveEaseInOut,\n    UIViewAnimationCurveEaseIn,\n    UIViewAnimationCurveEaseOut,\n    UIViewAnimationCurveLinear\n};\n```\n\n不仅能为枚举值指定类型，而且当赋值赋错类型时，编译器还会给出警告，没理由不用这种写法。\n\n## 替代Format字符串\n\n适配64-bit时，你是否遇到了下面的恶心写法：  \n\n``` objc\nNSArray *items = @[@1, @2, @3];\nNSLog(@\"数组元素个数：%lu\", (unsigned long)items.count);\n```\n\n一般情况下，利用`NSNumber`的`@`语法糖就可以解决：  \n\n``` objc\nNSArray *items = @[@1, @2, @3];\nNSLog(@\"数组元素个数：%@\", @(items.count));\n```\n\n同理，int转string也可以：\n\n``` objc\nNSInteger i = 10086;\nNSString *string = @(i).stringValue;\n```\n\n当然，如需要`%.2f`这种Format就不适用了。\n\n## 64-bit下的BOOL\n\n32-bit下，BOOL被定义为`signed char`，@encode(BOOL)的结果是`'c'`  \n64-bit下，BOOL被定义为`bool`，@encode(BOOL)结果是`'B'`   \n更直观的解释是：   \n\n``` objc\n(lldb) p/t (signed char)7\n(BOOL) $0 = 0b00000111 (YES)\n(lldb) p/t (bool)7\n(bool) $1 = 0b00000001 (YES)\n```\n\n32-bit版本的BOOL包括了256个值的可能性，还会引起一些坑，像[这篇文章](http://www.bignerdranch.com/blog/bools-sharp-corners/)所说的。而64-bit下只有0（NO），1（YES）两种可能，终于给BOOL正了名。    \n\n## 不直接取isa指针\n\n编译器已经默认禁用了这种使用，isa指针在32位下是Class的地址，但在64位下利用bits mask才能取出来真正的地址，若真需要，使用runtime的`object_getClass` 和`object_setClass`方法。关于64位下isa的讲解可以看[这篇文章](http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html)\n\n## 解决第三方lib依赖和lipo命令\n\n以源码形式出现在工程中的第三方lib，只要把target加上`arm64`编译就好了。  \n恶心的就是直接拖进工程的那些静态库(.a)或者framework，就需要重新找支持64-bit的包了。这时候就能看出哪些是已无人维护的lib了，是时候找个替代品了（比如我全网找不到工程中用到的一个音频库的64位包，终于在一个哥们的github上找到，哭着给了个star- -）  \n\n### 打印Mach-O文件支持的架构\n\n如何看一个可执行文件是不是支持64-bit呢？   \n\n使用`lipo -info`命令，比如看看UIKit支持的架构：  \n\n``` objc\n// 当前在Xcode Frameworks目录\nsunnyxx$ lipo -info UIKit.framework/UIKit\nArchitectures in the fat file: UIKit.framework/UIKit are: arm64 armv7s  \n```\n\n想看的更详细的信息可以使用`lipo -detailed_info`：\n\n``` objc\nsunnyxx$ lipo -detailed_info UIKit.framework/UIKit\nFat header in: UIKit.framework/UIKit\nfat_magic 0xcafebabe\nnfat_arch 2\narchitecture arm64\n    cputype CPU_TYPE_ARM64\n    cpusubtype CPU_SUBTYPE_ARM64_ALL\n    offset 4096\n    size 16822272\n    align 2^12 (4096)\narchitecture armv7s\n    cputype CPU_TYPE_ARM\n    cpusubtype CPU_SUBTYPE_ARM_V7S\n    offset 16826368\n    size 14499840\n    align 2^12 (4096)\n```\n\n当然，还可以使用`file`命令：  \n\n``` shell\nsunnyxx$ file UIKit.framework/UIKit\nUIKit.framework/UIKit: Mach-O universal binary with 2 architectures\nUIKit.framework/UIKit (for architecture arm64):Mach-O 64-bit dynamically linked shared library\nUIKit.framework/UIKit (for architecture armv7s):Mach-O dynamically linked shared library arm\n```\n\n上述命令对`Mach-O`文件适用，静态库`.a`文件，framework中的`.a`文件，自己app的可执行文件都可以打印下看看。  \n\n### 合并多个架构的包\n\n如果，我们有`MyLib-32.a`和`MyLib-64.a`，可以使用`lipo -create`命令合并：  \n\n``` shell\nsunnyxx$ lipo -create MyLib-32.a MyLib-64.a -output MyLib.a\n```\n\n## 支持64-bit后程序包会变大么？\n\n会，支持64-bit后，多了一个`arm64`架构，理论上每个架构一套指令，但相比原来会大多少还不好说，我们这里增加了大概50%，还有听说会增加一倍的。\n\n## 一个lib包含了很多的架构，会打到最后的包里么？\n\n不会，如果lib中有`armv7, armv7s, arm64, i386`架构，而target architecture选择了`armv7s, arm64`，那么只会从lib中link指定的这两个架构的二进制代码，其他架构下的代码不会link到最终可执行文件中；反过来，一个lib需要在模拟器环境中正常link，也得包含i386架构的指令。\n\n## Checklist\n\n最后列一下官方文档中的注意点：  \n\n - 不要将指针强转成整数\n - 程序各处使用统一的数据类型\n - 对不同类型的整数做运算时一定要注意\n - 需要定长变量时，使用如`int32_t, int64_t`这种定长类型\n - 使用malloc时，不要写死size\n - 使用能同时适配两个架构的格式化字符串\n - 注意函数和函数指针（类型转换和可变参数）\n - 不要直接访问Objective-C的指针（isa）\n - 使用内建的同步原语（Primitives）\n - 不要硬编码虚存页大小\n - [Go Position Independent](https://developer.apple.com/library/ios/qa/qa1788/_index.html#//apple_ref/doc/uid/DTS40013354)\n\n# References\n\nhttps://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013501-CH1-SW1\nhttp://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html\nhttp://www.bignerdranch.com/blog/64-bit-smorgasbord/\nhttp://www.bignerdranch.com/blog/bools-sharp-corners/\n","slug":"64-bit-tips","published":1,"updated":"2016-03-27T07:50:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxj80000ev120f5jx4co","content":"<p>终究还是来了。Apple下发了支持64位的最后通牒：</p>\n<blockquote>\n<p>As we announced in October, beginning February 1, 2015 new iOS apps submitted to the App Store must include 64-bit support and be built with the iOS 8 SDK. Beginning June 1, 2015 app updates will also need to follow the same requirements.</p>\n</blockquote>\n<p>早应该做的适配终于要开始动工了，苦了64位的CPU运行了这么久32位的程序。前段时间公司项目完成了64-bit包的适配，本没那么复杂的事被无数不标准的老代码搅和的不轻，总结几个Tip共勉。</p>\n<h1 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h1><h2 id=\"拒绝基本数据类型和隐式转换\"><a href=\"#拒绝基本数据类型和隐式转换\" class=\"headerlink\" title=\"拒绝基本数据类型和隐式转换\"></a>拒绝基本数据类型和隐式转换</h2><p>首当其冲的就是基本类型，比如下面4个类型在32-bit和64-bit下分别是多长呢？  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">size_t s1 = <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">size_t s2 = <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">long</span>);</span><br><span class=\"line\">size_t s3 = <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">float</span>);</span><br><span class=\"line\">size_t s4 = <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">double</span>);</span><br></pre></td></tr></table></figure>\n<p>32-bit下：<code>4, 4, 4, 8</code>；64-bit下：<code>4, 8, 4, 8</code><br>（PS： 这个结果随编译器，换其他平台可不一定）<br>它们的长度变化可能并非我们对64-bit长度加倍的预期，所以说，程序中出现<code>sizeof</code>的代码多看两眼。而且，除非你明确知道自己在做什么，应该使用下面的类型代替基本类型：  </p>\n<ul>\n<li>int -&gt; NSInteger</li>\n<li>unsigned -&gt; NSUInteger</li>\n<li>float -&gt; CGFloat</li>\n<li>动画时间 -&gt; NSTimeInterval</li>\n<li>…</li>\n</ul>\n<p>这些都是SDK中定义的类型，而我们大部分时间都在跟SDK的API们打交道，使用它们能将类型转换的影响降低很多。</p>\n<p>再比如说下面的代码：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *items = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">-1</span>; i &lt; items.count; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>, i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果是，for循环一次都没有进。<br>数组的<code>count</code>是<code>NSUInteger</code>类型的，-1与其比较时隐式转换成<code>NSUInteger</code>，变成了一个很大的数字：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) p i</span><br><span class=\"line\">(<span class=\"keyword\">int</span>) $<span class=\"number\">0</span> = <span class=\"number\">-1</span></span><br><span class=\"line\">(lldb) p (<span class=\"built_in\">NSUInteger</span>)i</span><br><span class=\"line\">(<span class=\"built_in\">NSUInteger</span>) $<span class=\"number\">1</span> = <span class=\"number\">18446744073709551615</span></span><br></pre></td></tr></table></figure>\n<p>这和64-bit到没啥关系，想要说明的是，这种隐式转换也需要小心，一定要注意和这个变量相关的所有操作（赋值、比较、转换）<br>老式for循环可以考虑写成：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSUInteger</span> index = <span class=\"number\">0</span>; index &lt; items.count; index++) &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，数组遍历还是更推荐用<code>for-in</code>或<code>block</code>版本的，它们之间的比较可以回顾下<a href=\"http://blog.sunnyxx.com/2014/04/30/ios_iterator/\">这篇文章</a>。</p>\n<h2 id=\"使用新版枚举\"><a href=\"#使用新版枚举\" class=\"headerlink\" title=\"使用新版枚举\"></a>使用新版枚举</h2><p>和上面的原因差不多，枚举应该使用新版的写法：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, <span class=\"built_in\">UIViewAnimationCurve</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIViewAnimationCurveEaseInOut</span>,</span><br><span class=\"line\">    <span class=\"built_in\">UIViewAnimationCurveEaseIn</span>,</span><br><span class=\"line\">    <span class=\"built_in\">UIViewAnimationCurveEaseOut</span>,</span><br><span class=\"line\">    <span class=\"built_in\">UIViewAnimationCurveLinear</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>不仅能为枚举值指定类型，而且当赋值赋错类型时，编译器还会给出警告，没理由不用这种写法。</p>\n<h2 id=\"替代Format字符串\"><a href=\"#替代Format字符串\" class=\"headerlink\" title=\"替代Format字符串\"></a>替代Format字符串</h2><p>适配64-bit时，你是否遇到了下面的恶心写法：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *items = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"数组元素个数：%lu\"</span>, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)items.count);</span><br></pre></td></tr></table></figure>\n<p>一般情况下，利用<code>NSNumber</code>的<code>@</code>语法糖就可以解决：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *items = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"数组元素个数：%@\"</span>, @(items.count));</span><br></pre></td></tr></table></figure>\n<p>同理，int转string也可以：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSInteger</span> i = <span class=\"number\">10086</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *string = @(i).stringValue;</span><br></pre></td></tr></table></figure>\n<p>当然，如需要<code>%.2f</code>这种Format就不适用了。</p>\n<h2 id=\"64-bit下的BOOL\"><a href=\"#64-bit下的BOOL\" class=\"headerlink\" title=\"64-bit下的BOOL\"></a>64-bit下的BOOL</h2><p>32-bit下，BOOL被定义为<code>signed char</code>，@encode(BOOL)的结果是<code>&#39;c&#39;</code><br>64-bit下，BOOL被定义为<code>bool</code>，@encode(BOOL)结果是<code>&#39;B&#39;</code><br>更直观的解释是：   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) p/t (<span class=\"keyword\">signed</span> <span class=\"keyword\">char</span>)<span class=\"number\">7</span></span><br><span class=\"line\">(<span class=\"built_in\">BOOL</span>) $<span class=\"number\">0</span> = <span class=\"number\">0</span>b00000111 (<span class=\"literal\">YES</span>)</span><br><span class=\"line\">(lldb) p/t (<span class=\"keyword\">bool</span>)<span class=\"number\">7</span></span><br><span class=\"line\">(<span class=\"keyword\">bool</span>) $<span class=\"number\">1</span> = <span class=\"number\">0</span>b00000001 (<span class=\"literal\">YES</span>)</span><br></pre></td></tr></table></figure>\n<p>32-bit版本的BOOL包括了256个值的可能性，还会引起一些坑，像<a href=\"http://www.bignerdranch.com/blog/bools-sharp-corners/\" target=\"_blank\" rel=\"external\">这篇文章</a>所说的。而64-bit下只有0（NO），1（YES）两种可能，终于给BOOL正了名。    </p>\n<h2 id=\"不直接取isa指针\"><a href=\"#不直接取isa指针\" class=\"headerlink\" title=\"不直接取isa指针\"></a>不直接取isa指针</h2><p>编译器已经默认禁用了这种使用，isa指针在32位下是Class的地址，但在64位下利用bits mask才能取出来真正的地址，若真需要，使用runtime的<code>object_getClass</code> 和<code>object_setClass</code>方法。关于64位下isa的讲解可以看<a href=\"http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html\" target=\"_blank\" rel=\"external\">这篇文章</a></p>\n<h2 id=\"解决第三方lib依赖和lipo命令\"><a href=\"#解决第三方lib依赖和lipo命令\" class=\"headerlink\" title=\"解决第三方lib依赖和lipo命令\"></a>解决第三方lib依赖和lipo命令</h2><p>以源码形式出现在工程中的第三方lib，只要把target加上<code>arm64</code>编译就好了。<br>恶心的就是直接拖进工程的那些静态库(.a)或者framework，就需要重新找支持64-bit的包了。这时候就能看出哪些是已无人维护的lib了，是时候找个替代品了（比如我全网找不到工程中用到的一个音频库的64位包，终于在一个哥们的github上找到，哭着给了个star- -）  </p>\n<h3 id=\"打印Mach-O文件支持的架构\"><a href=\"#打印Mach-O文件支持的架构\" class=\"headerlink\" title=\"打印Mach-O文件支持的架构\"></a>打印Mach-O文件支持的架构</h3><p>如何看一个可执行文件是不是支持64-bit呢？   </p>\n<p>使用<code>lipo -info</code>命令，比如看看UIKit支持的架构：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当前在Xcode Frameworks目录</span></span><br><span class=\"line\">sunnyxx$ lipo -info <span class=\"built_in\">UIKit</span>.framework/<span class=\"built_in\">UIKit</span></span><br><span class=\"line\">Architectures <span class=\"keyword\">in</span> the fat file: <span class=\"built_in\">UIKit</span>.framework/<span class=\"built_in\">UIKit</span> are: arm64 armv7s</span><br></pre></td></tr></table></figure>\n<p>想看的更详细的信息可以使用<code>lipo -detailed_info</code>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sunnyxx$ lipo -detailed_info <span class=\"built_in\">UIKit</span>.framework/<span class=\"built_in\">UIKit</span></span><br><span class=\"line\">Fat header <span class=\"keyword\">in</span>: <span class=\"built_in\">UIKit</span>.framework/<span class=\"built_in\">UIKit</span></span><br><span class=\"line\">fat_magic <span class=\"number\">0xcafebabe</span></span><br><span class=\"line\">nfat_arch <span class=\"number\">2</span></span><br><span class=\"line\">architecture arm64</span><br><span class=\"line\">    cputype CPU_TYPE_ARM64</span><br><span class=\"line\">    cpusubtype CPU_SUBTYPE_ARM64_ALL</span><br><span class=\"line\">    offset <span class=\"number\">4096</span></span><br><span class=\"line\">    size <span class=\"number\">16822272</span></span><br><span class=\"line\">    align <span class=\"number\">2</span>^<span class=\"number\">12</span> (<span class=\"number\">4096</span>)</span><br><span class=\"line\">architecture armv7s</span><br><span class=\"line\">    cputype CPU_TYPE_ARM</span><br><span class=\"line\">    cpusubtype CPU_SUBTYPE_ARM_V7S</span><br><span class=\"line\">    offset <span class=\"number\">16826368</span></span><br><span class=\"line\">    size <span class=\"number\">14499840</span></span><br><span class=\"line\">    align <span class=\"number\">2</span>^<span class=\"number\">12</span> (<span class=\"number\">4096</span>)</span><br></pre></td></tr></table></figure>\n<p>当然，还可以使用<code>file</code>命令：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sunnyxx$ file UIKit.framework/UIKit</span><br><span class=\"line\">UIKit.framework/UIKit: Mach-O universal binary with 2 architectures</span><br><span class=\"line\">UIKit.framework/UIKit (for architecture arm64):Mach-O 64-bit dynamically linked shared library</span><br><span class=\"line\">UIKit.framework/UIKit (for architecture armv7s):Mach-O dynamically linked shared library arm</span><br></pre></td></tr></table></figure>\n<p>上述命令对<code>Mach-O</code>文件适用，静态库<code>.a</code>文件，framework中的<code>.a</code>文件，自己app的可执行文件都可以打印下看看。  </p>\n<h3 id=\"合并多个架构的包\"><a href=\"#合并多个架构的包\" class=\"headerlink\" title=\"合并多个架构的包\"></a>合并多个架构的包</h3><p>如果，我们有<code>MyLib-32.a</code>和<code>MyLib-64.a</code>，可以使用<code>lipo -create</code>命令合并：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sunnyxx$ lipo -create MyLib-32.a MyLib-64.a -output MyLib.a</span><br></pre></td></tr></table></figure>\n<h2 id=\"支持64-bit后程序包会变大么？\"><a href=\"#支持64-bit后程序包会变大么？\" class=\"headerlink\" title=\"支持64-bit后程序包会变大么？\"></a>支持64-bit后程序包会变大么？</h2><p>会，支持64-bit后，多了一个<code>arm64</code>架构，理论上每个架构一套指令，但相比原来会大多少还不好说，我们这里增加了大概50%，还有听说会增加一倍的。</p>\n<h2 id=\"一个lib包含了很多的架构，会打到最后的包里么？\"><a href=\"#一个lib包含了很多的架构，会打到最后的包里么？\" class=\"headerlink\" title=\"一个lib包含了很多的架构，会打到最后的包里么？\"></a>一个lib包含了很多的架构，会打到最后的包里么？</h2><p>不会，如果lib中有<code>armv7, armv7s, arm64, i386</code>架构，而target architecture选择了<code>armv7s, arm64</code>，那么只会从lib中link指定的这两个架构的二进制代码，其他架构下的代码不会link到最终可执行文件中；反过来，一个lib需要在模拟器环境中正常link，也得包含i386架构的指令。</p>\n<h2 id=\"Checklist\"><a href=\"#Checklist\" class=\"headerlink\" title=\"Checklist\"></a>Checklist</h2><p>最后列一下官方文档中的注意点：  </p>\n<ul>\n<li>不要将指针强转成整数</li>\n<li>程序各处使用统一的数据类型</li>\n<li>对不同类型的整数做运算时一定要注意</li>\n<li>需要定长变量时，使用如<code>int32_t, int64_t</code>这种定长类型</li>\n<li>使用malloc时，不要写死size</li>\n<li>使用能同时适配两个架构的格式化字符串</li>\n<li>注意函数和函数指针（类型转换和可变参数）</li>\n<li>不要直接访问Objective-C的指针（isa）</li>\n<li>使用内建的同步原语（Primitives）</li>\n<li>不要硬编码虚存页大小</li>\n<li><a href=\"https://developer.apple.com/library/ios/qa/qa1788/_index.html#//apple_ref/doc/uid/DTS40013354\" target=\"_blank\" rel=\"external\">Go Position Independent</a></li>\n</ul>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013501-CH1-SW1\" target=\"_blank\" rel=\"external\">https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013501-CH1-SW1</a><br><a href=\"http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html\" target=\"_blank\" rel=\"external\">http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html</a><br><a href=\"http://www.bignerdranch.com/blog/64-bit-smorgasbord/\" target=\"_blank\" rel=\"external\">http://www.bignerdranch.com/blog/64-bit-smorgasbord/</a><br><a href=\"http://www.bignerdranch.com/blog/bools-sharp-corners/\" target=\"_blank\" rel=\"external\">http://www.bignerdranch.com/blog/bools-sharp-corners/</a></p>\n","excerpt":"","more":"<p>终究还是来了。Apple下发了支持64位的最后通牒：</p>\n<blockquote>\n<p>As we announced in October, beginning February 1, 2015 new iOS apps submitted to the App Store must include 64-bit support and be built with the iOS 8 SDK. Beginning June 1, 2015 app updates will also need to follow the same requirements.</p>\n</blockquote>\n<p>早应该做的适配终于要开始动工了，苦了64位的CPU运行了这么久32位的程序。前段时间公司项目完成了64-bit包的适配，本没那么复杂的事被无数不标准的老代码搅和的不轻，总结几个Tip共勉。</p>\n<h1 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h1><h2 id=\"拒绝基本数据类型和隐式转换\"><a href=\"#拒绝基本数据类型和隐式转换\" class=\"headerlink\" title=\"拒绝基本数据类型和隐式转换\"></a>拒绝基本数据类型和隐式转换</h2><p>首当其冲的就是基本类型，比如下面4个类型在32-bit和64-bit下分别是多长呢？  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">size_t s1 = <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">size_t s2 = <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">long</span>);</span><br><span class=\"line\">size_t s3 = <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">float</span>);</span><br><span class=\"line\">size_t s4 = <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">double</span>);</span><br></pre></td></tr></table></figure>\n<p>32-bit下：<code>4, 4, 4, 8</code>；64-bit下：<code>4, 8, 4, 8</code><br>（PS： 这个结果随编译器，换其他平台可不一定）<br>它们的长度变化可能并非我们对64-bit长度加倍的预期，所以说，程序中出现<code>sizeof</code>的代码多看两眼。而且，除非你明确知道自己在做什么，应该使用下面的类型代替基本类型：  </p>\n<ul>\n<li>int -&gt; NSInteger</li>\n<li>unsigned -&gt; NSUInteger</li>\n<li>float -&gt; CGFloat</li>\n<li>动画时间 -&gt; NSTimeInterval</li>\n<li>…</li>\n</ul>\n<p>这些都是SDK中定义的类型，而我们大部分时间都在跟SDK的API们打交道，使用它们能将类型转换的影响降低很多。</p>\n<p>再比如说下面的代码：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *items = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">-1</span>; i &lt; items.count; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>, i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果是，for循环一次都没有进。<br>数组的<code>count</code>是<code>NSUInteger</code>类型的，-1与其比较时隐式转换成<code>NSUInteger</code>，变成了一个很大的数字：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) p i</span><br><span class=\"line\">(<span class=\"keyword\">int</span>) $<span class=\"number\">0</span> = <span class=\"number\">-1</span></span><br><span class=\"line\">(lldb) p (<span class=\"built_in\">NSUInteger</span>)i</span><br><span class=\"line\">(<span class=\"built_in\">NSUInteger</span>) $<span class=\"number\">1</span> = <span class=\"number\">18446744073709551615</span></span><br></pre></td></tr></table></figure>\n<p>这和64-bit到没啥关系，想要说明的是，这种隐式转换也需要小心，一定要注意和这个变量相关的所有操作（赋值、比较、转换）<br>老式for循环可以考虑写成：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSUInteger</span> index = <span class=\"number\">0</span>; index &lt; items.count; index++) &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，数组遍历还是更推荐用<code>for-in</code>或<code>block</code>版本的，它们之间的比较可以回顾下<a href=\"http://blog.sunnyxx.com/2014/04/30/ios_iterator/\">这篇文章</a>。</p>\n<h2 id=\"使用新版枚举\"><a href=\"#使用新版枚举\" class=\"headerlink\" title=\"使用新版枚举\"></a>使用新版枚举</h2><p>和上面的原因差不多，枚举应该使用新版的写法：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, <span class=\"built_in\">UIViewAnimationCurve</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIViewAnimationCurveEaseInOut</span>,</span><br><span class=\"line\">    <span class=\"built_in\">UIViewAnimationCurveEaseIn</span>,</span><br><span class=\"line\">    <span class=\"built_in\">UIViewAnimationCurveEaseOut</span>,</span><br><span class=\"line\">    <span class=\"built_in\">UIViewAnimationCurveLinear</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>不仅能为枚举值指定类型，而且当赋值赋错类型时，编译器还会给出警告，没理由不用这种写法。</p>\n<h2 id=\"替代Format字符串\"><a href=\"#替代Format字符串\" class=\"headerlink\" title=\"替代Format字符串\"></a>替代Format字符串</h2><p>适配64-bit时，你是否遇到了下面的恶心写法：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *items = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"数组元素个数：%lu\"</span>, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)items.count);</span><br></pre></td></tr></table></figure>\n<p>一般情况下，利用<code>NSNumber</code>的<code>@</code>语法糖就可以解决：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *items = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"数组元素个数：%@\"</span>, @(items.count));</span><br></pre></td></tr></table></figure>\n<p>同理，int转string也可以：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSInteger</span> i = <span class=\"number\">10086</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *string = @(i).stringValue;</span><br></pre></td></tr></table></figure>\n<p>当然，如需要<code>%.2f</code>这种Format就不适用了。</p>\n<h2 id=\"64-bit下的BOOL\"><a href=\"#64-bit下的BOOL\" class=\"headerlink\" title=\"64-bit下的BOOL\"></a>64-bit下的BOOL</h2><p>32-bit下，BOOL被定义为<code>signed char</code>，@encode(BOOL)的结果是<code>&#39;c&#39;</code><br>64-bit下，BOOL被定义为<code>bool</code>，@encode(BOOL)结果是<code>&#39;B&#39;</code><br>更直观的解释是：   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) p/t (<span class=\"keyword\">signed</span> <span class=\"keyword\">char</span>)<span class=\"number\">7</span></span><br><span class=\"line\">(<span class=\"built_in\">BOOL</span>) $<span class=\"number\">0</span> = <span class=\"number\">0</span>b00000111 (<span class=\"literal\">YES</span>)</span><br><span class=\"line\">(lldb) p/t (<span class=\"keyword\">bool</span>)<span class=\"number\">7</span></span><br><span class=\"line\">(<span class=\"keyword\">bool</span>) $<span class=\"number\">1</span> = <span class=\"number\">0</span>b00000001 (<span class=\"literal\">YES</span>)</span><br></pre></td></tr></table></figure>\n<p>32-bit版本的BOOL包括了256个值的可能性，还会引起一些坑，像<a href=\"http://www.bignerdranch.com/blog/bools-sharp-corners/\">这篇文章</a>所说的。而64-bit下只有0（NO），1（YES）两种可能，终于给BOOL正了名。    </p>\n<h2 id=\"不直接取isa指针\"><a href=\"#不直接取isa指针\" class=\"headerlink\" title=\"不直接取isa指针\"></a>不直接取isa指针</h2><p>编译器已经默认禁用了这种使用，isa指针在32位下是Class的地址，但在64位下利用bits mask才能取出来真正的地址，若真需要，使用runtime的<code>object_getClass</code> 和<code>object_setClass</code>方法。关于64位下isa的讲解可以看<a href=\"http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html\">这篇文章</a></p>\n<h2 id=\"解决第三方lib依赖和lipo命令\"><a href=\"#解决第三方lib依赖和lipo命令\" class=\"headerlink\" title=\"解决第三方lib依赖和lipo命令\"></a>解决第三方lib依赖和lipo命令</h2><p>以源码形式出现在工程中的第三方lib，只要把target加上<code>arm64</code>编译就好了。<br>恶心的就是直接拖进工程的那些静态库(.a)或者framework，就需要重新找支持64-bit的包了。这时候就能看出哪些是已无人维护的lib了，是时候找个替代品了（比如我全网找不到工程中用到的一个音频库的64位包，终于在一个哥们的github上找到，哭着给了个star- -）  </p>\n<h3 id=\"打印Mach-O文件支持的架构\"><a href=\"#打印Mach-O文件支持的架构\" class=\"headerlink\" title=\"打印Mach-O文件支持的架构\"></a>打印Mach-O文件支持的架构</h3><p>如何看一个可执行文件是不是支持64-bit呢？   </p>\n<p>使用<code>lipo -info</code>命令，比如看看UIKit支持的架构：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当前在Xcode Frameworks目录</span></span><br><span class=\"line\">sunnyxx$ lipo -info <span class=\"built_in\">UIKit</span>.framework/<span class=\"built_in\">UIKit</span></span><br><span class=\"line\">Architectures <span class=\"keyword\">in</span> the fat file: <span class=\"built_in\">UIKit</span>.framework/<span class=\"built_in\">UIKit</span> are: arm64 armv7s</span><br></pre></td></tr></table></figure>\n<p>想看的更详细的信息可以使用<code>lipo -detailed_info</code>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sunnyxx$ lipo -detailed_info <span class=\"built_in\">UIKit</span>.framework/<span class=\"built_in\">UIKit</span></span><br><span class=\"line\">Fat header <span class=\"keyword\">in</span>: <span class=\"built_in\">UIKit</span>.framework/<span class=\"built_in\">UIKit</span></span><br><span class=\"line\">fat_magic <span class=\"number\">0xcafebabe</span></span><br><span class=\"line\">nfat_arch <span class=\"number\">2</span></span><br><span class=\"line\">architecture arm64</span><br><span class=\"line\">    cputype CPU_TYPE_ARM64</span><br><span class=\"line\">    cpusubtype CPU_SUBTYPE_ARM64_ALL</span><br><span class=\"line\">    offset <span class=\"number\">4096</span></span><br><span class=\"line\">    size <span class=\"number\">16822272</span></span><br><span class=\"line\">    align <span class=\"number\">2</span>^<span class=\"number\">12</span> (<span class=\"number\">4096</span>)</span><br><span class=\"line\">architecture armv7s</span><br><span class=\"line\">    cputype CPU_TYPE_ARM</span><br><span class=\"line\">    cpusubtype CPU_SUBTYPE_ARM_V7S</span><br><span class=\"line\">    offset <span class=\"number\">16826368</span></span><br><span class=\"line\">    size <span class=\"number\">14499840</span></span><br><span class=\"line\">    align <span class=\"number\">2</span>^<span class=\"number\">12</span> (<span class=\"number\">4096</span>)</span><br></pre></td></tr></table></figure>\n<p>当然，还可以使用<code>file</code>命令：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sunnyxx$ file UIKit.framework/UIKit</span><br><span class=\"line\">UIKit.framework/UIKit: Mach-O universal binary with 2 architectures</span><br><span class=\"line\">UIKit.framework/UIKit (for architecture arm64):Mach-O 64-bit dynamically linked shared library</span><br><span class=\"line\">UIKit.framework/UIKit (for architecture armv7s):Mach-O dynamically linked shared library arm</span><br></pre></td></tr></table></figure>\n<p>上述命令对<code>Mach-O</code>文件适用，静态库<code>.a</code>文件，framework中的<code>.a</code>文件，自己app的可执行文件都可以打印下看看。  </p>\n<h3 id=\"合并多个架构的包\"><a href=\"#合并多个架构的包\" class=\"headerlink\" title=\"合并多个架构的包\"></a>合并多个架构的包</h3><p>如果，我们有<code>MyLib-32.a</code>和<code>MyLib-64.a</code>，可以使用<code>lipo -create</code>命令合并：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sunnyxx$ lipo -create MyLib-32.a MyLib-64.a -output MyLib.a</span><br></pre></td></tr></table></figure>\n<h2 id=\"支持64-bit后程序包会变大么？\"><a href=\"#支持64-bit后程序包会变大么？\" class=\"headerlink\" title=\"支持64-bit后程序包会变大么？\"></a>支持64-bit后程序包会变大么？</h2><p>会，支持64-bit后，多了一个<code>arm64</code>架构，理论上每个架构一套指令，但相比原来会大多少还不好说，我们这里增加了大概50%，还有听说会增加一倍的。</p>\n<h2 id=\"一个lib包含了很多的架构，会打到最后的包里么？\"><a href=\"#一个lib包含了很多的架构，会打到最后的包里么？\" class=\"headerlink\" title=\"一个lib包含了很多的架构，会打到最后的包里么？\"></a>一个lib包含了很多的架构，会打到最后的包里么？</h2><p>不会，如果lib中有<code>armv7, armv7s, arm64, i386</code>架构，而target architecture选择了<code>armv7s, arm64</code>，那么只会从lib中link指定的这两个架构的二进制代码，其他架构下的代码不会link到最终可执行文件中；反过来，一个lib需要在模拟器环境中正常link，也得包含i386架构的指令。</p>\n<h2 id=\"Checklist\"><a href=\"#Checklist\" class=\"headerlink\" title=\"Checklist\"></a>Checklist</h2><p>最后列一下官方文档中的注意点：  </p>\n<ul>\n<li>不要将指针强转成整数</li>\n<li>程序各处使用统一的数据类型</li>\n<li>对不同类型的整数做运算时一定要注意</li>\n<li>需要定长变量时，使用如<code>int32_t, int64_t</code>这种定长类型</li>\n<li>使用malloc时，不要写死size</li>\n<li>使用能同时适配两个架构的格式化字符串</li>\n<li>注意函数和函数指针（类型转换和可变参数）</li>\n<li>不要直接访问Objective-C的指针（isa）</li>\n<li>使用内建的同步原语（Primitives）</li>\n<li>不要硬编码虚存页大小</li>\n<li><a href=\"https://developer.apple.com/library/ios/qa/qa1788/_index.html#//apple_ref/doc/uid/DTS40013354\">Go Position Independent</a></li>\n</ul>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013501-CH1-SW1\">https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013501-CH1-SW1</a><br><a href=\"http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html\">http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html</a><br><a href=\"http://www.bignerdranch.com/blog/64-bit-smorgasbord/\">http://www.bignerdranch.com/blog/64-bit-smorgasbord/</a><br><a href=\"http://www.bignerdranch.com/blog/bools-sharp-corners/\">http://www.bignerdranch.com/blog/bools-sharp-corners/</a></p>\n"},{"title":"黑幕背后的Autorelease","date":"2014-10-15T14:48:05.000Z","_content":"\n# 我是前言\n\nAutorelease机制是iOS开发者管理对象内存的好伙伴，MRC中，调用`[obj autorelease]`来延迟内存的释放是一件简单自然的事，ARC下，我们甚至可以完全不知道Autorelease就能管理好内存。而在这背后，objc和编译器都帮我们做了哪些事呢，它们是如何协作来正确管理内存的呢？刨根问底，一起来探究下黑幕背后的Autorelease机制。\n\n# Autorelease对象什么时候释放？\n\n这个问题拿来做面试题，问过很多人，没有几个能答对的。很多答案都是“当前作用域大括号结束时释放”，显然木有正确理解Autorelease机制。  \n在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的`runloop`迭代结束时释放的，而它能够释放的原因是**系统在每个runloop迭代中都加入了自动释放池Push和Pop**  \n\n## 小实验\n\n``` objc\n__weak id reference = nil;\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSString *str = [NSString stringWithFormat:@\"sunnyxx\"];\n    // str是一个autorelease对象，设置一个weak的引用来观察它\n    reference = str;\n}\n- (void)viewWillAppear:(BOOL)animated {\n    [super viewWillAppear:animated];\n    NSLog(@\"%@\", reference); // Console: sunnyxx\n}\n- (void)viewDidAppear:(BOOL)animated {\n    [super viewDidAppear:animated];\n    NSLog(@\"%@\", reference); // Console: (null)\n}\n```\n\n~~这个实验同时也证明了`viewDidLoad`和`viewWillAppear`是在同一个runloop调用的，而`viewDidAppear`是在之后的某个runloop调用的。~~   \n由于这个vc在loadView之后便add到了window层级上，所以`viewDidLoad`和`viewWillAppear`是在同一个runloop调用的，因此在`viewWillAppear`中，这个autorelease的变量依然有值。  \n\n当然，我们也可以手动干预Autorelease对象的释放时机：\n\n``` objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    @autoreleasepool {\n        NSString *str = [NSString stringWithFormat:@\"sunnyxx\"];\n    }\n    NSLog(@\"%@\", str); // Console: (null)\n}\n```\n\n# Autorelease原理\n\n\n## AutoreleasePoolPage\n\nARC下，我们使用`@autoreleasepool{}`来使用一个AutoreleasePool，随后编译器将其改写成下面的样子：  \n\n```\nvoid *context = objc_autoreleasePoolPush();\n// {}中的代码\nobjc_autoreleasePoolPop(context);\n```\n\n而这两个函数都是对`AutoreleasePoolPage`的简单封装，所以自动释放机制的核心就在于这个类。  \n\nAutoreleasePoolPage是一个C++实现的类\n\n![](http://ww2.sinaimg.cn/mw690/51530583gw1elj2ugt21wj20f109m3zl.jpg)\n\n - AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以`双向链表`的形式组合而成（分别对应结构中的parent指针和child指针）\n - AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）\n - AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址\n - 上面的`id *next`指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置\n - 一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入\n\n所以，若当前线程中只有一个AutoreleasePoolPage对象，并记录了很多autorelease对象地址时内存如下图：\n\n![](http://ww2.sinaimg.cn/mw690/51530583gw1elj5gvphtqj20dy0cx756.jpg)\n\n图中的情况，这一页再加入一个autorelease对象就要满了（也就是next指针马上指向栈顶），这时就要执行上面说的操作，建立下一页page对象，与这一页链表连接完成后，新page的`next`指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。\n\n**所以，向一个对象发送`- autorelease`消息，就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置**\n\n## 释放时刻\n\n每当进行一次`objc_autoreleasePoolPush`调用时，runtime向当前的AutoreleasePoolPage中add进一个`哨兵对象`，值为0（也就是个nil），那么这一个page就变成了下面的样子：  \n\n![](http://ww2.sinaimg.cn/large/51530583gw1elj5z7hawej20ji0dewff.jpg)\n\n`objc_autoreleasePoolPush`的返回值正是这个哨兵对象的地址，被`objc_autoreleasePoolPop(哨兵对象)`作为入参，于是：\n\n1. 根据传入的哨兵对象地址找到哨兵对象所处的page\n2. 在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次`- release`消息，并向回移动`next`指针到正确位置\n3. 补充2：从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page\n\n刚才的objc_autoreleasePoolPop执行后，最终变成了下面的样子：  \n\n![](http://ww3.sinaimg.cn/mw690/51530583gw1elj6u2i3fyj20dz0bqdgi.jpg)\n\n## 嵌套的AutoreleasePool\n\n知道了上面的原理，嵌套的AutoreleasePool就非常简单了，pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响。\n\n---\n\n【附加内容】\n\n# Autorelease返回值的快速释放机制\n\n值得一提的是，ARC下，runtime有一套对autorelease返回值的优化策略。\n比如一个工厂方法：\n\n``` objc\n+ (instancetype)createSark {\n    return [self new];\n}\n// caller\nSark *sark = [Sark createSark];\n```\n\n秉着谁创建谁释放的原则，返回值需要是一个autorelease对象才能配合调用方正确管理内存，于是乎编译器改写成了形如下面的代码：\n\n``` objc\n+ (instancetype)createSark {\n    id tmp = [self new];\n    return objc_autoreleaseReturnValue(tmp); // 代替我们调用autorelease\n}\n// caller\nid tmp = objc_retainAutoreleasedReturnValue([Sark createSark]) // 代替我们调用retain\nSark *sark = tmp;\nobjc_storeStrong(&sark, nil); // 相当于代替我们调用了release\n```\n\n一切看上去都很好，不过既然编译器知道了这么多信息，干嘛还要劳烦autorelease这个开销不小的机制呢？于是乎，runtime使用了一些黑魔法将这个问题解决了。\n\n## 黑魔法之Thread Local Storage\n\nThread Local Storage（TLS）线程局部存储，目的很简单，将一块内存作为某个线程专有的存储，以key-value的形式进行读写，比如在非arm架构下，使用pthread提供的方法实现：  \n\n``` objc\nvoid* pthread_getspecific(pthread_key_t);\nint pthread_setspecific(pthread_key_t , const void *);\n```\n\n说它是黑魔法可能被懂pthread的笑话- -  \n\n在返回值身上调用`objc_autoreleaseReturnValue`方法时，runtime将这个返回值object储存在TLS中，然后直接返回这个object（不调用autorelease）；同时，在外部接收这个返回值的`objc_retainAutoreleasedReturnValue`里，发现TLS中正好存了这个对象，那么直接返回这个object（不调用retain）。  \n于是乎，调用方和被调方利用TLS做中转，很有默契的免去了对返回值的内存管理。  \n\n于是问题又来了，假如被调方和主调方只有一边是ARC环境编译的该咋办？（比如我们在ARC环境下用了非ARC编译的第三方库，或者反之）  \n只能动用更高级的黑魔法。  \n\n\n## 黑魔法之__builtin_return_address\n\n这个内建函数原型是`char *__builtin_return_address(int level)`，作用是得到函数的返回地址，参数表示层数，如__builtin_return_address(0)表示当前函数体返回地址，传1是调用这个函数的外层函数的返回值地址，以此类推。\n\n``` objc\n- (int)foo {\n    NSLog(@\"%p\", __builtin_return_address(0)); // 根据这个地址能找到下面ret的地址\n    return 1;\n}\n// caller\nint ret = [sark foo];\n```\n\n看上去也没啥厉害的，不过要知道，函数的返回值地址，也就对应着调用者结束这次调用的地址（或者相差某个固定的偏移量，根据编译器决定）  \n也就是说，被调用的函数也有翻身做地主的机会了，可以反过来对主调方干点坏事。  \n回到上面的问题，**如果一个函数返回前知道调用方是ARC还是非ARC，就有机会对于不同情况做不同的处理**\n\n## 黑魔法之反查汇编指令\n\n通过上面的__builtin_return_address加某些偏移量，被调方可以定位到主调方在返回值后面的`汇编指令`：  \n\n``` objc\n// caller\nint ret = [sark foo];\n// 内存中接下来的汇编指令（x86，我不懂汇编，瞎写的）\nmovq ??? ???\ncallq ???\n```\n\n而这些汇编指令在内存中的值是固定的，比如movq对应着0x48。  \n于是乎，就有了下面的这个函数，入参是调用方__builtin_return_address传入值\n\n``` objc\nstatic bool callerAcceptsFastAutorelease(const void * const ra0) {\n    const uint8_t *ra1 = (const uint8_t *)ra0;\n    const uint16_t *ra2;\n    const uint32_t *ra4 = (const uint32_t *)ra1;\n    const void **sym;\n    // 48 89 c7    movq  %rax,%rdi\n    // e8          callq symbol\n    if (*ra4 != 0xe8c78948) {\n        return false;\n    }\n    ra1 += (long)*(const int32_t *)(ra1 + 4) + 8l;\n    ra2 = (const uint16_t *)ra1;\n    // ff 25       jmpq *symbol@DYLDMAGIC(%rip)\n    if (*ra2 != 0x25ff) {\n        return false;\n    }\n    ra1 += 6l + (long)*(const int32_t *)(ra1 + 2);\n    sym = (const void **)ra1;\n    if (*sym != objc_retainAutoreleasedReturnValue)\n    {\n        return false;\n    }\n    return true;\n}\n```\n\n它检验了主调方在返回值之后是否紧接着调用了`objc_retainAutoreleasedReturnValue`，如果是，就知道了外部是ARC环境，反之就走没被优化的老逻辑。\n\n\n\n# 其他Autorelease相关知识点\n\n使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool：  \n\n``` objc\n[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {\n    // 这里被一个局部@autoreleasepool包围着\n}];\n```\n\n当然，在普通for循环和for in循环中没有，所以，还是新版的block版本枚举器更加方便。for循环中遍历产生大量autorelease变量时，就需要手加局部AutoreleasePool咯。\n","source":"_posts/behind-autorelease.md","raw":"title: 黑幕背后的Autorelease\ndate: 2014-10-15 22:48:05\ntags: objc刨根问底\n---\n\n# 我是前言\n\nAutorelease机制是iOS开发者管理对象内存的好伙伴，MRC中，调用`[obj autorelease]`来延迟内存的释放是一件简单自然的事，ARC下，我们甚至可以完全不知道Autorelease就能管理好内存。而在这背后，objc和编译器都帮我们做了哪些事呢，它们是如何协作来正确管理内存的呢？刨根问底，一起来探究下黑幕背后的Autorelease机制。\n\n# Autorelease对象什么时候释放？\n\n这个问题拿来做面试题，问过很多人，没有几个能答对的。很多答案都是“当前作用域大括号结束时释放”，显然木有正确理解Autorelease机制。  \n在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的`runloop`迭代结束时释放的，而它能够释放的原因是**系统在每个runloop迭代中都加入了自动释放池Push和Pop**  \n\n## 小实验\n\n``` objc\n__weak id reference = nil;\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSString *str = [NSString stringWithFormat:@\"sunnyxx\"];\n    // str是一个autorelease对象，设置一个weak的引用来观察它\n    reference = str;\n}\n- (void)viewWillAppear:(BOOL)animated {\n    [super viewWillAppear:animated];\n    NSLog(@\"%@\", reference); // Console: sunnyxx\n}\n- (void)viewDidAppear:(BOOL)animated {\n    [super viewDidAppear:animated];\n    NSLog(@\"%@\", reference); // Console: (null)\n}\n```\n\n~~这个实验同时也证明了`viewDidLoad`和`viewWillAppear`是在同一个runloop调用的，而`viewDidAppear`是在之后的某个runloop调用的。~~   \n由于这个vc在loadView之后便add到了window层级上，所以`viewDidLoad`和`viewWillAppear`是在同一个runloop调用的，因此在`viewWillAppear`中，这个autorelease的变量依然有值。  \n\n当然，我们也可以手动干预Autorelease对象的释放时机：\n\n``` objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    @autoreleasepool {\n        NSString *str = [NSString stringWithFormat:@\"sunnyxx\"];\n    }\n    NSLog(@\"%@\", str); // Console: (null)\n}\n```\n\n# Autorelease原理\n\n\n## AutoreleasePoolPage\n\nARC下，我们使用`@autoreleasepool{}`来使用一个AutoreleasePool，随后编译器将其改写成下面的样子：  \n\n```\nvoid *context = objc_autoreleasePoolPush();\n// {}中的代码\nobjc_autoreleasePoolPop(context);\n```\n\n而这两个函数都是对`AutoreleasePoolPage`的简单封装，所以自动释放机制的核心就在于这个类。  \n\nAutoreleasePoolPage是一个C++实现的类\n\n![](http://ww2.sinaimg.cn/mw690/51530583gw1elj2ugt21wj20f109m3zl.jpg)\n\n - AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以`双向链表`的形式组合而成（分别对应结构中的parent指针和child指针）\n - AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）\n - AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址\n - 上面的`id *next`指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置\n - 一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入\n\n所以，若当前线程中只有一个AutoreleasePoolPage对象，并记录了很多autorelease对象地址时内存如下图：\n\n![](http://ww2.sinaimg.cn/mw690/51530583gw1elj5gvphtqj20dy0cx756.jpg)\n\n图中的情况，这一页再加入一个autorelease对象就要满了（也就是next指针马上指向栈顶），这时就要执行上面说的操作，建立下一页page对象，与这一页链表连接完成后，新page的`next`指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。\n\n**所以，向一个对象发送`- autorelease`消息，就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置**\n\n## 释放时刻\n\n每当进行一次`objc_autoreleasePoolPush`调用时，runtime向当前的AutoreleasePoolPage中add进一个`哨兵对象`，值为0（也就是个nil），那么这一个page就变成了下面的样子：  \n\n![](http://ww2.sinaimg.cn/large/51530583gw1elj5z7hawej20ji0dewff.jpg)\n\n`objc_autoreleasePoolPush`的返回值正是这个哨兵对象的地址，被`objc_autoreleasePoolPop(哨兵对象)`作为入参，于是：\n\n1. 根据传入的哨兵对象地址找到哨兵对象所处的page\n2. 在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次`- release`消息，并向回移动`next`指针到正确位置\n3. 补充2：从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page\n\n刚才的objc_autoreleasePoolPop执行后，最终变成了下面的样子：  \n\n![](http://ww3.sinaimg.cn/mw690/51530583gw1elj6u2i3fyj20dz0bqdgi.jpg)\n\n## 嵌套的AutoreleasePool\n\n知道了上面的原理，嵌套的AutoreleasePool就非常简单了，pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响。\n\n---\n\n【附加内容】\n\n# Autorelease返回值的快速释放机制\n\n值得一提的是，ARC下，runtime有一套对autorelease返回值的优化策略。\n比如一个工厂方法：\n\n``` objc\n+ (instancetype)createSark {\n    return [self new];\n}\n// caller\nSark *sark = [Sark createSark];\n```\n\n秉着谁创建谁释放的原则，返回值需要是一个autorelease对象才能配合调用方正确管理内存，于是乎编译器改写成了形如下面的代码：\n\n``` objc\n+ (instancetype)createSark {\n    id tmp = [self new];\n    return objc_autoreleaseReturnValue(tmp); // 代替我们调用autorelease\n}\n// caller\nid tmp = objc_retainAutoreleasedReturnValue([Sark createSark]) // 代替我们调用retain\nSark *sark = tmp;\nobjc_storeStrong(&sark, nil); // 相当于代替我们调用了release\n```\n\n一切看上去都很好，不过既然编译器知道了这么多信息，干嘛还要劳烦autorelease这个开销不小的机制呢？于是乎，runtime使用了一些黑魔法将这个问题解决了。\n\n## 黑魔法之Thread Local Storage\n\nThread Local Storage（TLS）线程局部存储，目的很简单，将一块内存作为某个线程专有的存储，以key-value的形式进行读写，比如在非arm架构下，使用pthread提供的方法实现：  \n\n``` objc\nvoid* pthread_getspecific(pthread_key_t);\nint pthread_setspecific(pthread_key_t , const void *);\n```\n\n说它是黑魔法可能被懂pthread的笑话- -  \n\n在返回值身上调用`objc_autoreleaseReturnValue`方法时，runtime将这个返回值object储存在TLS中，然后直接返回这个object（不调用autorelease）；同时，在外部接收这个返回值的`objc_retainAutoreleasedReturnValue`里，发现TLS中正好存了这个对象，那么直接返回这个object（不调用retain）。  \n于是乎，调用方和被调方利用TLS做中转，很有默契的免去了对返回值的内存管理。  \n\n于是问题又来了，假如被调方和主调方只有一边是ARC环境编译的该咋办？（比如我们在ARC环境下用了非ARC编译的第三方库，或者反之）  \n只能动用更高级的黑魔法。  \n\n\n## 黑魔法之__builtin_return_address\n\n这个内建函数原型是`char *__builtin_return_address(int level)`，作用是得到函数的返回地址，参数表示层数，如__builtin_return_address(0)表示当前函数体返回地址，传1是调用这个函数的外层函数的返回值地址，以此类推。\n\n``` objc\n- (int)foo {\n    NSLog(@\"%p\", __builtin_return_address(0)); // 根据这个地址能找到下面ret的地址\n    return 1;\n}\n// caller\nint ret = [sark foo];\n```\n\n看上去也没啥厉害的，不过要知道，函数的返回值地址，也就对应着调用者结束这次调用的地址（或者相差某个固定的偏移量，根据编译器决定）  \n也就是说，被调用的函数也有翻身做地主的机会了，可以反过来对主调方干点坏事。  \n回到上面的问题，**如果一个函数返回前知道调用方是ARC还是非ARC，就有机会对于不同情况做不同的处理**\n\n## 黑魔法之反查汇编指令\n\n通过上面的__builtin_return_address加某些偏移量，被调方可以定位到主调方在返回值后面的`汇编指令`：  \n\n``` objc\n// caller\nint ret = [sark foo];\n// 内存中接下来的汇编指令（x86，我不懂汇编，瞎写的）\nmovq ??? ???\ncallq ???\n```\n\n而这些汇编指令在内存中的值是固定的，比如movq对应着0x48。  \n于是乎，就有了下面的这个函数，入参是调用方__builtin_return_address传入值\n\n``` objc\nstatic bool callerAcceptsFastAutorelease(const void * const ra0) {\n    const uint8_t *ra1 = (const uint8_t *)ra0;\n    const uint16_t *ra2;\n    const uint32_t *ra4 = (const uint32_t *)ra1;\n    const void **sym;\n    // 48 89 c7    movq  %rax,%rdi\n    // e8          callq symbol\n    if (*ra4 != 0xe8c78948) {\n        return false;\n    }\n    ra1 += (long)*(const int32_t *)(ra1 + 4) + 8l;\n    ra2 = (const uint16_t *)ra1;\n    // ff 25       jmpq *symbol@DYLDMAGIC(%rip)\n    if (*ra2 != 0x25ff) {\n        return false;\n    }\n    ra1 += 6l + (long)*(const int32_t *)(ra1 + 2);\n    sym = (const void **)ra1;\n    if (*sym != objc_retainAutoreleasedReturnValue)\n    {\n        return false;\n    }\n    return true;\n}\n```\n\n它检验了主调方在返回值之后是否紧接着调用了`objc_retainAutoreleasedReturnValue`，如果是，就知道了外部是ARC环境，反之就走没被优化的老逻辑。\n\n\n\n# 其他Autorelease相关知识点\n\n使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool：  \n\n``` objc\n[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {\n    // 这里被一个局部@autoreleasepool包围着\n}];\n```\n\n当然，在普通for循环和for in循环中没有，所以，还是新版的block版本枚举器更加方便。for循环中遍历产生大量autorelease变量时，就需要手加局部AutoreleasePool咯。\n","slug":"behind-autorelease","published":1,"updated":"2016-03-27T07:53:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxjg0001ev12ufix4l5u","content":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>Autorelease机制是iOS开发者管理对象内存的好伙伴，MRC中，调用<code>[obj autorelease]</code>来延迟内存的释放是一件简单自然的事，ARC下，我们甚至可以完全不知道Autorelease就能管理好内存。而在这背后，objc和编译器都帮我们做了哪些事呢，它们是如何协作来正确管理内存的呢？刨根问底，一起来探究下黑幕背后的Autorelease机制。</p>\n<h1 id=\"Autorelease对象什么时候释放？\"><a href=\"#Autorelease对象什么时候释放？\" class=\"headerlink\" title=\"Autorelease对象什么时候释放？\"></a>Autorelease对象什么时候释放？</h1><p>这个问题拿来做面试题，问过很多人，没有几个能答对的。很多答案都是“当前作用域大括号结束时释放”，显然木有正确理解Autorelease机制。<br>在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的<code>runloop</code>迭代结束时释放的，而它能够释放的原因是<strong>系统在每个runloop迭代中都加入了自动释放池Push和Pop</strong>  </p>\n<h2 id=\"小实验\"><a href=\"#小实验\" class=\"headerlink\" title=\"小实验\"></a>小实验</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">id</span> reference = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *str = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"sunnyxx\"</span>];</span><br><span class=\"line\">    <span class=\"comment\">// str是一个autorelease对象，设置一个weak的引用来观察它</span></span><br><span class=\"line\">    reference = str;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewWillAppear:(<span class=\"built_in\">BOOL</span>)animated &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewWillAppear:animated];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, reference); <span class=\"comment\">// Console: sunnyxx</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidAppear:(<span class=\"built_in\">BOOL</span>)animated &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidAppear:animated];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, reference); <span class=\"comment\">// Console: (null)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><del>这个实验同时也证明了<code>viewDidLoad</code>和<code>viewWillAppear</code>是在同一个runloop调用的，而<code>viewDidAppear</code>是在之后的某个runloop调用的。</del><br>由于这个vc在loadView之后便add到了window层级上，所以<code>viewDidLoad</code>和<code>viewWillAppear</code>是在同一个runloop调用的，因此在<code>viewWillAppear</code>中，这个autorelease的变量依然有值。  </p>\n<p>当然，我们也可以手动干预Autorelease对象的释放时机：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> *str = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"sunnyxx\"</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, str); <span class=\"comment\">// Console: (null)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Autorelease原理\"><a href=\"#Autorelease原理\" class=\"headerlink\" title=\"Autorelease原理\"></a>Autorelease原理</h1><h2 id=\"AutoreleasePoolPage\"><a href=\"#AutoreleasePoolPage\" class=\"headerlink\" title=\"AutoreleasePoolPage\"></a>AutoreleasePoolPage</h2><p>ARC下，我们使用<code>@autoreleasepool{}</code>来使用一个AutoreleasePool，随后编译器将其改写成下面的样子：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *context = objc_autoreleasePoolPush();</span><br><span class=\"line\">// &#123;&#125;中的代码</span><br><span class=\"line\">objc_autoreleasePoolPop(context);</span><br></pre></td></tr></table></figure>\n<p>而这两个函数都是对<code>AutoreleasePoolPage</code>的简单封装，所以自动释放机制的核心就在于这个类。  </p>\n<p>AutoreleasePoolPage是一个C++实现的类</p>\n<p><img src=\"http://ww2.sinaimg.cn/mw690/51530583gw1elj2ugt21wj20f109m3zl.jpg\" alt=\"\"></p>\n<ul>\n<li>AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以<code>双向链表</code>的形式组合而成（分别对应结构中的parent指针和child指针）</li>\n<li>AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）</li>\n<li>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址</li>\n<li>上面的<code>id *next</code>指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置</li>\n<li>一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入</li>\n</ul>\n<p>所以，若当前线程中只有一个AutoreleasePoolPage对象，并记录了很多autorelease对象地址时内存如下图：</p>\n<p><img src=\"http://ww2.sinaimg.cn/mw690/51530583gw1elj5gvphtqj20dy0cx756.jpg\" alt=\"\"></p>\n<p>图中的情况，这一页再加入一个autorelease对象就要满了（也就是next指针马上指向栈顶），这时就要执行上面说的操作，建立下一页page对象，与这一页链表连接完成后，新page的<code>next</code>指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。</p>\n<p><strong>所以，向一个对象发送<code>- autorelease</code>消息，就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置</strong></p>\n<h2 id=\"释放时刻\"><a href=\"#释放时刻\" class=\"headerlink\" title=\"释放时刻\"></a>释放时刻</h2><p>每当进行一次<code>objc_autoreleasePoolPush</code>调用时，runtime向当前的AutoreleasePoolPage中add进一个<code>哨兵对象</code>，值为0（也就是个nil），那么这一个page就变成了下面的样子：  </p>\n<p><img src=\"http://ww2.sinaimg.cn/large/51530583gw1elj5z7hawej20ji0dewff.jpg\" alt=\"\"></p>\n<p><code>objc_autoreleasePoolPush</code>的返回值正是这个哨兵对象的地址，被<code>objc_autoreleasePoolPop(哨兵对象)</code>作为入参，于是：</p>\n<ol>\n<li>根据传入的哨兵对象地址找到哨兵对象所处的page</li>\n<li>在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次<code>- release</code>消息，并向回移动<code>next</code>指针到正确位置</li>\n<li>补充2：从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page</li>\n</ol>\n<p>刚才的objc_autoreleasePoolPop执行后，最终变成了下面的样子：  </p>\n<p><img src=\"http://ww3.sinaimg.cn/mw690/51530583gw1elj6u2i3fyj20dz0bqdgi.jpg\" alt=\"\"></p>\n<h2 id=\"嵌套的AutoreleasePool\"><a href=\"#嵌套的AutoreleasePool\" class=\"headerlink\" title=\"嵌套的AutoreleasePool\"></a>嵌套的AutoreleasePool</h2><p>知道了上面的原理，嵌套的AutoreleasePool就非常简单了，pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响。</p>\n<hr>\n<p>【附加内容】</p>\n<h1 id=\"Autorelease返回值的快速释放机制\"><a href=\"#Autorelease返回值的快速释放机制\" class=\"headerlink\" title=\"Autorelease返回值的快速释放机制\"></a>Autorelease返回值的快速释放机制</h1><p>值得一提的是，ARC下，runtime有一套对autorelease返回值的优化策略。<br>比如一个工厂方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (instancetype)createSark &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> new];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// caller</span></span><br><span class=\"line\">Sark *sark = [Sark createSark];</span><br></pre></td></tr></table></figure>\n<p>秉着谁创建谁释放的原则，返回值需要是一个autorelease对象才能配合调用方正确管理内存，于是乎编译器改写成了形如下面的代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (instancetype)createSark &#123;</span><br><span class=\"line\">    <span class=\"keyword\">id</span> tmp = [<span class=\"keyword\">self</span> new];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_autoreleaseReturnValue(tmp); <span class=\"comment\">// 代替我们调用autorelease</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// caller</span></span><br><span class=\"line\"><span class=\"keyword\">id</span> tmp = objc_retainAutoreleasedReturnValue([Sark createSark]) <span class=\"comment\">// 代替我们调用retain</span></span><br><span class=\"line\">Sark *sark = tmp;</span><br><span class=\"line\">objc_storeStrong(&amp;sark, <span class=\"literal\">nil</span>); <span class=\"comment\">// 相当于代替我们调用了release</span></span><br></pre></td></tr></table></figure>\n<p>一切看上去都很好，不过既然编译器知道了这么多信息，干嘛还要劳烦autorelease这个开销不小的机制呢？于是乎，runtime使用了一些黑魔法将这个问题解决了。</p>\n<h2 id=\"黑魔法之Thread-Local-Storage\"><a href=\"#黑魔法之Thread-Local-Storage\" class=\"headerlink\" title=\"黑魔法之Thread Local Storage\"></a>黑魔法之Thread Local Storage</h2><p>Thread Local Storage（TLS）线程局部存储，目的很简单，将一块内存作为某个线程专有的存储，以key-value的形式进行读写，比如在非arm架构下，使用pthread提供的方法实现：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span>* pthread_getspecific(pthread_key_t);</span><br><span class=\"line\"><span class=\"keyword\">int</span> pthread_setspecific(pthread_key_t , <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *);</span><br></pre></td></tr></table></figure>\n<p>说它是黑魔法可能被懂pthread的笑话- -  </p>\n<p>在返回值身上调用<code>objc_autoreleaseReturnValue</code>方法时，runtime将这个返回值object储存在TLS中，然后直接返回这个object（不调用autorelease）；同时，在外部接收这个返回值的<code>objc_retainAutoreleasedReturnValue</code>里，发现TLS中正好存了这个对象，那么直接返回这个object（不调用retain）。<br>于是乎，调用方和被调方利用TLS做中转，很有默契的免去了对返回值的内存管理。  </p>\n<p>于是问题又来了，假如被调方和主调方只有一边是ARC环境编译的该咋办？（比如我们在ARC环境下用了非ARC编译的第三方库，或者反之）<br>只能动用更高级的黑魔法。  </p>\n<h2 id=\"黑魔法之-builtin-return-address\"><a href=\"#黑魔法之-builtin-return-address\" class=\"headerlink\" title=\"黑魔法之__builtin_return_address\"></a>黑魔法之__builtin_return_address</h2><p>这个内建函数原型是<code>char *__builtin_return_address(int level)</code>，作用是得到函数的返回地址，参数表示层数，如__builtin_return_address(0)表示当前函数体返回地址，传1是调用这个函数的外层函数的返回值地址，以此类推。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">int</span>)foo &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%p\"</span>, __builtin_return_address(<span class=\"number\">0</span>)); <span class=\"comment\">// 根据这个地址能找到下面ret的地址</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// caller</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ret = [sark foo];</span><br></pre></td></tr></table></figure>\n<p>看上去也没啥厉害的，不过要知道，函数的返回值地址，也就对应着调用者结束这次调用的地址（或者相差某个固定的偏移量，根据编译器决定）<br>也就是说，被调用的函数也有翻身做地主的机会了，可以反过来对主调方干点坏事。<br>回到上面的问题，<strong>如果一个函数返回前知道调用方是ARC还是非ARC，就有机会对于不同情况做不同的处理</strong></p>\n<h2 id=\"黑魔法之反查汇编指令\"><a href=\"#黑魔法之反查汇编指令\" class=\"headerlink\" title=\"黑魔法之反查汇编指令\"></a>黑魔法之反查汇编指令</h2><p>通过上面的__builtin_return_address加某些偏移量，被调方可以定位到主调方在返回值后面的<code>汇编指令</code>：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// caller</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ret = [sark foo];</span><br><span class=\"line\"><span class=\"comment\">// 内存中接下来的汇编指令（x86，我不懂汇编，瞎写的）</span></span><br><span class=\"line\">movq ??? ???</span><br><span class=\"line\">callq ???</span><br></pre></td></tr></table></figure>\n<p>而这些汇编指令在内存中的值是固定的，比如movq对应着0x48。<br>于是乎，就有了下面的这个函数，入参是调用方__builtin_return_address传入值</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> callerAcceptsFastAutorelease(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> * <span class=\"keyword\">const</span> ra0) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> uint8_t *ra1 = (<span class=\"keyword\">const</span> uint8_t *)ra0;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> uint16_t *ra2;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> uint32_t *ra4 = (<span class=\"keyword\">const</span> uint32_t *)ra1;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> **sym;</span><br><span class=\"line\">    <span class=\"comment\">// 48 89 c7    movq  %rax,%rdi</span></span><br><span class=\"line\">    <span class=\"comment\">// e8          callq symbol</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*ra4 != <span class=\"number\">0xe8c78948</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ra1 += (<span class=\"keyword\">long</span>)*(<span class=\"keyword\">const</span> int32_t *)(ra1 + <span class=\"number\">4</span>) + <span class=\"number\">8</span>l;</span><br><span class=\"line\">    ra2 = (<span class=\"keyword\">const</span> uint16_t *)ra1;</span><br><span class=\"line\">    <span class=\"comment\">// ff 25       jmpq *symbol@DYLDMAGIC(%rip)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*ra2 != <span class=\"number\">0x25ff</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ra1 += <span class=\"number\">6</span>l + (<span class=\"keyword\">long</span>)*(<span class=\"keyword\">const</span> int32_t *)(ra1 + <span class=\"number\">2</span>);</span><br><span class=\"line\">    sym = (<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> **)ra1;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*sym != objc_retainAutoreleasedReturnValue)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它检验了主调方在返回值之后是否紧接着调用了<code>objc_retainAutoreleasedReturnValue</code>，如果是，就知道了外部是ARC环境，反之就走没被优化的老逻辑。</p>\n<h1 id=\"其他Autorelease相关知识点\"><a href=\"#其他Autorelease相关知识点\" class=\"headerlink\" title=\"其他Autorelease相关知识点\"></a>其他Autorelease相关知识点</h1><p>使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[array enumerateObjectsUsingBlock:^(<span class=\"keyword\">id</span> obj, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> *stop) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里被一个局部@autoreleasepool包围着</span></span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>当然，在普通for循环和for in循环中没有，所以，还是新版的block版本枚举器更加方便。for循环中遍历产生大量autorelease变量时，就需要手加局部AutoreleasePool咯。</p>\n","excerpt":"","more":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>Autorelease机制是iOS开发者管理对象内存的好伙伴，MRC中，调用<code>[obj autorelease]</code>来延迟内存的释放是一件简单自然的事，ARC下，我们甚至可以完全不知道Autorelease就能管理好内存。而在这背后，objc和编译器都帮我们做了哪些事呢，它们是如何协作来正确管理内存的呢？刨根问底，一起来探究下黑幕背后的Autorelease机制。</p>\n<h1 id=\"Autorelease对象什么时候释放？\"><a href=\"#Autorelease对象什么时候释放？\" class=\"headerlink\" title=\"Autorelease对象什么时候释放？\"></a>Autorelease对象什么时候释放？</h1><p>这个问题拿来做面试题，问过很多人，没有几个能答对的。很多答案都是“当前作用域大括号结束时释放”，显然木有正确理解Autorelease机制。<br>在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的<code>runloop</code>迭代结束时释放的，而它能够释放的原因是<strong>系统在每个runloop迭代中都加入了自动释放池Push和Pop</strong>  </p>\n<h2 id=\"小实验\"><a href=\"#小实验\" class=\"headerlink\" title=\"小实验\"></a>小实验</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">id</span> reference = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *str = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"sunnyxx\"</span>];</span><br><span class=\"line\">    <span class=\"comment\">// str是一个autorelease对象，设置一个weak的引用来观察它</span></span><br><span class=\"line\">    reference = str;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewWillAppear:(<span class=\"built_in\">BOOL</span>)animated &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewWillAppear:animated];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, reference); <span class=\"comment\">// Console: sunnyxx</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidAppear:(<span class=\"built_in\">BOOL</span>)animated &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidAppear:animated];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, reference); <span class=\"comment\">// Console: (null)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><del>这个实验同时也证明了<code>viewDidLoad</code>和<code>viewWillAppear</code>是在同一个runloop调用的，而<code>viewDidAppear</code>是在之后的某个runloop调用的。</del><br>由于这个vc在loadView之后便add到了window层级上，所以<code>viewDidLoad</code>和<code>viewWillAppear</code>是在同一个runloop调用的，因此在<code>viewWillAppear</code>中，这个autorelease的变量依然有值。  </p>\n<p>当然，我们也可以手动干预Autorelease对象的释放时机：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> *str = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"sunnyxx\"</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, str); <span class=\"comment\">// Console: (null)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Autorelease原理\"><a href=\"#Autorelease原理\" class=\"headerlink\" title=\"Autorelease原理\"></a>Autorelease原理</h1><h2 id=\"AutoreleasePoolPage\"><a href=\"#AutoreleasePoolPage\" class=\"headerlink\" title=\"AutoreleasePoolPage\"></a>AutoreleasePoolPage</h2><p>ARC下，我们使用<code>@autoreleasepool{}</code>来使用一个AutoreleasePool，随后编译器将其改写成下面的样子：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *context = objc_autoreleasePoolPush();</span><br><span class=\"line\">// &#123;&#125;中的代码</span><br><span class=\"line\">objc_autoreleasePoolPop(context);</span><br></pre></td></tr></table></figure>\n<p>而这两个函数都是对<code>AutoreleasePoolPage</code>的简单封装，所以自动释放机制的核心就在于这个类。  </p>\n<p>AutoreleasePoolPage是一个C++实现的类</p>\n<p><img src=\"http://ww2.sinaimg.cn/mw690/51530583gw1elj2ugt21wj20f109m3zl.jpg\" alt=\"\"></p>\n<ul>\n<li>AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以<code>双向链表</code>的形式组合而成（分别对应结构中的parent指针和child指针）</li>\n<li>AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）</li>\n<li>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址</li>\n<li>上面的<code>id *next</code>指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置</li>\n<li>一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入</li>\n</ul>\n<p>所以，若当前线程中只有一个AutoreleasePoolPage对象，并记录了很多autorelease对象地址时内存如下图：</p>\n<p><img src=\"http://ww2.sinaimg.cn/mw690/51530583gw1elj5gvphtqj20dy0cx756.jpg\" alt=\"\"></p>\n<p>图中的情况，这一页再加入一个autorelease对象就要满了（也就是next指针马上指向栈顶），这时就要执行上面说的操作，建立下一页page对象，与这一页链表连接完成后，新page的<code>next</code>指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。</p>\n<p><strong>所以，向一个对象发送<code>- autorelease</code>消息，就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置</strong></p>\n<h2 id=\"释放时刻\"><a href=\"#释放时刻\" class=\"headerlink\" title=\"释放时刻\"></a>释放时刻</h2><p>每当进行一次<code>objc_autoreleasePoolPush</code>调用时，runtime向当前的AutoreleasePoolPage中add进一个<code>哨兵对象</code>，值为0（也就是个nil），那么这一个page就变成了下面的样子：  </p>\n<p><img src=\"http://ww2.sinaimg.cn/large/51530583gw1elj5z7hawej20ji0dewff.jpg\" alt=\"\"></p>\n<p><code>objc_autoreleasePoolPush</code>的返回值正是这个哨兵对象的地址，被<code>objc_autoreleasePoolPop(哨兵对象)</code>作为入参，于是：</p>\n<ol>\n<li>根据传入的哨兵对象地址找到哨兵对象所处的page</li>\n<li>在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次<code>- release</code>消息，并向回移动<code>next</code>指针到正确位置</li>\n<li>补充2：从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page</li>\n</ol>\n<p>刚才的objc_autoreleasePoolPop执行后，最终变成了下面的样子：  </p>\n<p><img src=\"http://ww3.sinaimg.cn/mw690/51530583gw1elj6u2i3fyj20dz0bqdgi.jpg\" alt=\"\"></p>\n<h2 id=\"嵌套的AutoreleasePool\"><a href=\"#嵌套的AutoreleasePool\" class=\"headerlink\" title=\"嵌套的AutoreleasePool\"></a>嵌套的AutoreleasePool</h2><p>知道了上面的原理，嵌套的AutoreleasePool就非常简单了，pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响。</p>\n<hr>\n<p>【附加内容】</p>\n<h1 id=\"Autorelease返回值的快速释放机制\"><a href=\"#Autorelease返回值的快速释放机制\" class=\"headerlink\" title=\"Autorelease返回值的快速释放机制\"></a>Autorelease返回值的快速释放机制</h1><p>值得一提的是，ARC下，runtime有一套对autorelease返回值的优化策略。<br>比如一个工厂方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (instancetype)createSark &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> new];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// caller</span></span><br><span class=\"line\">Sark *sark = [Sark createSark];</span><br></pre></td></tr></table></figure>\n<p>秉着谁创建谁释放的原则，返回值需要是一个autorelease对象才能配合调用方正确管理内存，于是乎编译器改写成了形如下面的代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (instancetype)createSark &#123;</span><br><span class=\"line\">    <span class=\"keyword\">id</span> tmp = [<span class=\"keyword\">self</span> new];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_autoreleaseReturnValue(tmp); <span class=\"comment\">// 代替我们调用autorelease</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// caller</span></span><br><span class=\"line\"><span class=\"keyword\">id</span> tmp = objc_retainAutoreleasedReturnValue([Sark createSark]) <span class=\"comment\">// 代替我们调用retain</span></span><br><span class=\"line\">Sark *sark = tmp;</span><br><span class=\"line\">objc_storeStrong(&amp;sark, <span class=\"literal\">nil</span>); <span class=\"comment\">// 相当于代替我们调用了release</span></span><br></pre></td></tr></table></figure>\n<p>一切看上去都很好，不过既然编译器知道了这么多信息，干嘛还要劳烦autorelease这个开销不小的机制呢？于是乎，runtime使用了一些黑魔法将这个问题解决了。</p>\n<h2 id=\"黑魔法之Thread-Local-Storage\"><a href=\"#黑魔法之Thread-Local-Storage\" class=\"headerlink\" title=\"黑魔法之Thread Local Storage\"></a>黑魔法之Thread Local Storage</h2><p>Thread Local Storage（TLS）线程局部存储，目的很简单，将一块内存作为某个线程专有的存储，以key-value的形式进行读写，比如在非arm架构下，使用pthread提供的方法实现：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span>* pthread_getspecific(pthread_key_t);</span><br><span class=\"line\"><span class=\"keyword\">int</span> pthread_setspecific(pthread_key_t , <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *);</span><br></pre></td></tr></table></figure>\n<p>说它是黑魔法可能被懂pthread的笑话- -  </p>\n<p>在返回值身上调用<code>objc_autoreleaseReturnValue</code>方法时，runtime将这个返回值object储存在TLS中，然后直接返回这个object（不调用autorelease）；同时，在外部接收这个返回值的<code>objc_retainAutoreleasedReturnValue</code>里，发现TLS中正好存了这个对象，那么直接返回这个object（不调用retain）。<br>于是乎，调用方和被调方利用TLS做中转，很有默契的免去了对返回值的内存管理。  </p>\n<p>于是问题又来了，假如被调方和主调方只有一边是ARC环境编译的该咋办？（比如我们在ARC环境下用了非ARC编译的第三方库，或者反之）<br>只能动用更高级的黑魔法。  </p>\n<h2 id=\"黑魔法之-builtin-return-address\"><a href=\"#黑魔法之-builtin-return-address\" class=\"headerlink\" title=\"黑魔法之__builtin_return_address\"></a>黑魔法之__builtin_return_address</h2><p>这个内建函数原型是<code>char *__builtin_return_address(int level)</code>，作用是得到函数的返回地址，参数表示层数，如__builtin_return_address(0)表示当前函数体返回地址，传1是调用这个函数的外层函数的返回值地址，以此类推。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">int</span>)foo &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%p\"</span>, __builtin_return_address(<span class=\"number\">0</span>)); <span class=\"comment\">// 根据这个地址能找到下面ret的地址</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// caller</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ret = [sark foo];</span><br></pre></td></tr></table></figure>\n<p>看上去也没啥厉害的，不过要知道，函数的返回值地址，也就对应着调用者结束这次调用的地址（或者相差某个固定的偏移量，根据编译器决定）<br>也就是说，被调用的函数也有翻身做地主的机会了，可以反过来对主调方干点坏事。<br>回到上面的问题，<strong>如果一个函数返回前知道调用方是ARC还是非ARC，就有机会对于不同情况做不同的处理</strong></p>\n<h2 id=\"黑魔法之反查汇编指令\"><a href=\"#黑魔法之反查汇编指令\" class=\"headerlink\" title=\"黑魔法之反查汇编指令\"></a>黑魔法之反查汇编指令</h2><p>通过上面的__builtin_return_address加某些偏移量，被调方可以定位到主调方在返回值后面的<code>汇编指令</code>：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// caller</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ret = [sark foo];</span><br><span class=\"line\"><span class=\"comment\">// 内存中接下来的汇编指令（x86，我不懂汇编，瞎写的）</span></span><br><span class=\"line\">movq ??? ???</span><br><span class=\"line\">callq ???</span><br></pre></td></tr></table></figure>\n<p>而这些汇编指令在内存中的值是固定的，比如movq对应着0x48。<br>于是乎，就有了下面的这个函数，入参是调用方__builtin_return_address传入值</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> callerAcceptsFastAutorelease(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> * <span class=\"keyword\">const</span> ra0) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> uint8_t *ra1 = (<span class=\"keyword\">const</span> uint8_t *)ra0;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> uint16_t *ra2;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> uint32_t *ra4 = (<span class=\"keyword\">const</span> uint32_t *)ra1;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> **sym;</span><br><span class=\"line\">    <span class=\"comment\">// 48 89 c7    movq  %rax,%rdi</span></span><br><span class=\"line\">    <span class=\"comment\">// e8          callq symbol</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*ra4 != <span class=\"number\">0xe8c78948</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ra1 += (<span class=\"keyword\">long</span>)*(<span class=\"keyword\">const</span> int32_t *)(ra1 + <span class=\"number\">4</span>) + <span class=\"number\">8</span>l;</span><br><span class=\"line\">    ra2 = (<span class=\"keyword\">const</span> uint16_t *)ra1;</span><br><span class=\"line\">    <span class=\"comment\">// ff 25       jmpq *symbol@DYLDMAGIC(%rip)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*ra2 != <span class=\"number\">0x25ff</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ra1 += <span class=\"number\">6</span>l + (<span class=\"keyword\">long</span>)*(<span class=\"keyword\">const</span> int32_t *)(ra1 + <span class=\"number\">2</span>);</span><br><span class=\"line\">    sym = (<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> **)ra1;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*sym != objc_retainAutoreleasedReturnValue)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它检验了主调方在返回值之后是否紧接着调用了<code>objc_retainAutoreleasedReturnValue</code>，如果是，就知道了外部是ARC环境，反之就走没被优化的老逻辑。</p>\n<h1 id=\"其他Autorelease相关知识点\"><a href=\"#其他Autorelease相关知识点\" class=\"headerlink\" title=\"其他Autorelease相关知识点\"></a>其他Autorelease相关知识点</h1><p>使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[array enumerateObjectsUsingBlock:^(<span class=\"keyword\">id</span> obj, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> *stop) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里被一个局部@autoreleasepool包围着</span></span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>当然，在普通for循环和for in循环中没有，所以，还是新版的block版本枚举器更加方便。for循环中遍历产生大量autorelease变量时，就需要手加局部AutoreleasePool咯。</p>\n"},{"title":"优化UITableViewCell高度计算的那些事","date":"2015-05-17T10:50:08.000Z","_content":"\n# 我是前言\n\n这篇文章是我和我们团队最近对 **UITableViewCell** 利用 **AutoLayout** 自动高度计算和 **UITableView** 滑动优化的一个总结。  \n我们也在维护一个开源的扩展，`UITableView+FDTemplateLayoutCell`，让高度计算这个事情变的前所未有的简单，也受到了很多星星的支持，[github链接请戳我](https://github.com/forkingdog/UITableView-FDTemplateLayoutCell)\n\n这篇总结你可以读到：\n- UITableView高度计算和估算的机制\n- 不同iOS系统在高度计算上的差异\n- iOS8 self-sizing cell\n- UITableView+FDTemplateLayoutCell如何用一句话解决高度问题\n- UITableView+FDTemplateLayoutCell中对RunLoop的使用技巧\n\n---\n\n# UITableViewCell高度计算\n\n## rowHeight\n\n`UITableView`是我们再熟悉不过的视图了，它的 **delegate** 和 **data source** 回调不知写了多少次，也不免遇到 UITableViewCell 高度计算的事。UITableView 询问 cell 高度有两种方式。  \n一种是针对所有 Cell 具有固定高度的情况，通过：\n\n``` objc\nself.tableView.rowHeight = 88;\n```\n\n上面的代码指定了一个所有 cell 都是 88 高度的 UITableView，对于定高需求的表格，**强烈建议**使用这种（而非下面的）方式保证不必要的高度计算和调用。`rowHeight`属性的默认值是 44，所以一个空的 UITableView 显示成那个样子。\n\n另一种方式就是实现 UITableViewDelegate 中的：\n\n``` objc\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {\n    // return xxx\n}\n```\n\n需要注意的是，实现了这个方法后，`rowHeight` 的设置将无效。所以，这个方法适用于具有多种 cell 高度的 UITableView。\n\n## estimatedRowHeight\n\n这个属性 iOS7 就出现了， 文档是这么描述它的作用的：\n\n> If the table contains variable height rows, it might be expensive to calculate all their heights when the table loads. Using estimation allows you to defer some of the cost of geometry calculation from load time to scrolling time.\n\n恩，听上去蛮靠谱的。我们知道，UITableView 是个 UIScrollView，就像平时使用 UIScrollView 一样，加载时指定 `contentSize` 后它才能根据自己的 bounds、contentInset、contentOffset 等属性共同决定是否可以滑动以及滚动条的长度。而 UITableView 在一开始并不知道自己会被填充多少内容，于是询问 data source 个数和创建 cell，同时询问 delegate 这些 cell 应该显示的高度，这就造成它在加载的时候浪费了多余的计算在**屏幕外边**的 cell 上。和上面的 `rowHeight` 很类似，设置这个估算高度有两种方法：  \n\n``` objc\nself.tableView.estimatedRowHeight = 88;\n// or\n- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath {\n    // return xxx\n}\n```\n\n有所不同的是，即使面对种类不同的 cell，我们依然可以使用简单的 `estimatedRowHeight` 属性赋值，只要**整体估算值接近**就可以，比如大概有一半 cell 高度是 44， 一半 cell 高度是 88， 那就可以估算一个 66，基本符合预期。  \n\n说完了估算高度的基本使用，可以开始吐槽了：  \n1. 设置估算高度后，contentSize.height 根据“cell估算值 x cell个数”计算，这就导致滚动条的大小处于不稳定的状态，contentSize 会随着滚动从估算高度慢慢替换成真实高度，肉眼可见滚动条突然变化甚至“跳跃”。\n2. 若是有设计不好的下拉刷新或上拉加载控件，或是 KVO 了 contentSize 或 contentOffset 属性，有可能使表格滑动时跳动。\n3. 估算高度设计初衷是好的，让加载速度更快，那凭啥要去侵害滑动的流畅性呢，用户可能对进入页面时多零点几秒加载时间感觉不大，但是滑动时实时计算高度带来的卡顿是明显能体验到的，个人觉得还不如一开始都算好了呢（iOS8更过分，即使都算好了也会边划边计算）\n\n---\n\n# iOS8 self-sizing cell\n\n具有动态高度内容的 cell 一直是个头疼的问题，比如聊天气泡的 cell， frame 布局时代通常是用数据内容反算高度：\n\n``` objc\nCGFloat height = textHeightWithFont() + imageHeight + topMargin + bottomMargin + ...;\n```\n\n供 UITableViewDelegate 调用时很可能是个 cell 的类方法：\n\n``` objc\n@interface BubbleCell : UITableViewCell\n+ (CGFloat)heightWithEntity:(id)entity;\n@end\n```\n\n各种魔法 margin 加上耦合了屏幕宽度。\n\nAutoLayout 时代好了不少，提供了`-systemLayoutSizeFittingSize:`的 API，在 contentView 中设置约束后，就能计算出准确的值；缺点是计算速度肯定没有手算快，而且这是个实例方法，需要维护专门为计算高度而生的 `template layout cell`，它还要求使用者对约束设置的比较熟练，要保证 contentView 内部上下左右所有方向都有约束支撑，设置不合理的话计算的高度就成了0。  \n\n这里还不得不提到一个 UILabel 的蛋疼问题，当 UILabel 行数大于0时，需要指定 `preferredMaxLayoutWidth` 后它才知道自己什么时候该折行。这是个“鸡生蛋蛋生鸡”的问题，因为 UILabel 需要知道 superview 的宽度才能折行，而 superview 的宽度还依仗着子 view 宽度的累加才能确定。这个问题好像到 iOS8 才能够自动解决（不过我们找到了解决方案）\n\n\n回到正题，iOS8 WWDC 中推出了 `self-sizing cell` 的概念，旨在让 cell 自己负责自己的高度计算，使用 frame layout 和 auto layout 都可以享受到：\n\n<img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1es3hwpsb71j20pe0f2ab4.jpg\" width=\"320\">\n\n这个特性首先要求是 iOS8，要是最低支持的系统版本小于8的话，还得针对老版本单写套老式的算高（囧），不过用的 API 到不是新面孔：  \n\n``` objc\nself.tableView.estimatedRowHeight = 213;\nself.tableView.rowHeight = UITableViewAutomaticDimension;\n```\n\n这里又不得不吐槽了，自动计算 rowHeight 跟 estimatedRowHeight 到底是有什么仇，如果不加上估算高度的设置，自动算高就失效了- -\nPS：iOS8 系统中 rowHeight 的默认值已经设置成了 UITableViewAutomaticDimension，所以第二行代码可以省略。  \n\n问题：  \n1. 这个自动算高在 push 到下一个页面或者转屏时会出现高度特别诡异的情况，不过现在的版本修复了。  \n2. 求一个能让最低支持 iOS8 的公司- -\n\n---\n\n# iOS8抽风的算高机制\n\n相同的代码在 iOS7 和 iOS8 上滑动顺畅程度完全不同，iOS8 莫名奇妙的卡。很大一部分原因是 iOS8 上的算高机制大不相同，这是我做的小测试：  \n\n<img src=\"http://ww1.sinaimg.cn/mw690/51530583jw1es3j7avlelj20w4084jsv.jpg\" width=\"640\">\n\n研究后发现这么多次额外计算有下面的原因：\n\n1. 不开启高度估算时，UITableView 上来就要对所有 cell 调用算高来确定 contentSize\n2. `dequeueReusableCellWithIdentifier:forIndexPath:` 相比不带 \"forIndexPath\" 的版本会多调用一次高度计算\n3. iOS7 计算高度后有”缓存“机制，不会重复计算；而 iOS8 不论何时都会重新计算 cell 高度\n\niOS8 把高度计算搞成这个样子，从 WWDC 也倒是能找到点解释，cell 被认为随时都可能改变高度（如从设置中调整动态字体大小），所以每次滑动出来后都要重新计算高度。  \n\n说了这么多，究竟有没有既能省去算高烦恼，又能保证顺畅的滑动，还能支持 iOS6+ 的一站式解决方案呢？\n\n---\n\n# UITableView+FDTemplateLayoutCell\n\n使用 `UITableView+FDTemplateLayoutCell` 无疑是解决算高问题的最佳实践之一，既有 iOS8 self-sizing 功能简单的 API，又可以达到 iOS7 流畅的滑动效果，还保持了最低支持 iOS6。  \n使用起来大概是这样：  \n\n``` objc\n#import <UITableView+FDTemplateLayoutCell.h>\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {\n    return [tableView fd_heightForCellWithIdentifier:@\"identifer\" cacheByIndexPath:indexPath configuration:^(id cell) {\n        // 配置 cell 的数据源，和 \"cellForRow\" 干的事一致，比如：\n        cell.entity = self.feedEntities[indexPath.row];\n    }];\n}\n```\n\n写完上面的代码后，你就已经使用到了：  \n\n- **和每个 UITableViewCell ReuseID 一一对应的 template layout cell**\n这个 cell 只为了参加高度计算，不会真的显示到屏幕上；它通过 UITableView 的 `-dequeueCellForReuseIdentifier:` 方法 lazy 创建并保存，所以要求这个 ReuseID 必须已经被注册到了 UITableView 中，也就是说，要么是 Storyboard 中的原型 cell，要么就是使用了 UITableView 的 `-registerClass:forCellReuseIdentifier:` 或 `-registerNib:forCellReuseIdentifier:`其中之一的注册方法。  \n- **根据 autolayout 约束自动计算高度**\n使用了系统在 iOS6 就提供的 API：`-systemLayoutSizeFittingSize:`\n- **根据 index path 的一套高度缓存机制**\n计算出的高度会自动进行缓存，所以滑动时每个 cell 真正的高度计算只会发生一次，后面的高度询问都会命中缓存，减少了非常可观的多余计算。\n- **自动的缓存失效机制**\n无须担心你数据源的变化引起的缓存失效，当调用如`-reloadData`，`-deleteRowsAtIndexPaths:withRowAnimation:`等任何一个触发 UITableView 刷新机制的方法时，已有的高度缓存将以**最小的代价**执行失效。如删除一个 indexPath 为 [0:5] 的 cell 时，[0:0] ~ [0:4] 的高度缓存不受影响，而 [0:5] 后面所有的缓存值都向前移动一个位置。自动缓存失效机制对 UITableView 的 9 个公有 API 都进行了分别的处理，以保证没有一次多余的高度计算。  \n- **预缓存机制**\n预缓存机制将在 UITableView 没有滑动的空闲时刻执行，计算和缓存那些还没有显示到屏幕中的 cell，整个缓存过程完全没有感知，这使得完整列表的高度计算既没有发生在加载时，又没有发生在滑动时，同时保证了加载速度和滑动流畅性，下文会着重讲下这块的实现原理。\n\n我们在设计这个工具的 API 时斟酌了非常长的时间，既要保证功能的强大，也要保证接口的精简，一行调用背后隐藏着很多功能。\n\n这一套缓存机制能对滑动起多大影响呢？除了肉眼能明显的感知到外，我还做了个小测试：  \n一个有 54 个内容和高度不同 cell 的 table view，从头滑动到尾，再从尾滑动到头，iOS8 系统下，iPhone6，使用 `Time Profiler` 监测算高函数所花费的时间：  \n\n未使用缓存API、未使用估算，共花费 877 ms：\n<img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1es7f5l357cj213k0g07eh.jpg\" width=\"640\">\n\n使用缓存API、开启估算，共花费 77 ms：\n<img src=\"http://ww2.sinaimg.cn/mw690/51530583jw1es7f5lefy3j21440hsgw8.jpg\" width=\"640\">\n\n测试数据的精度先不管，从量级上就差了一个数量级，说实话自己也没想到差距有这么大- -  \n\n同时，工具也顺手解决了`-preferredMaxLayoutWidth`的问题，在计算高度前向 contentView 加了一条和 table view 宽度相同的宽度约束，强行让 contentView 内部的控件知道了自己父 view 的宽度，再反算自己被外界约束的宽度，破除“鸡生蛋蛋生鸡”的问题，这里比较 tricky，就不展开说了。下面说说利用 RunLoop 预缓存的实现。\n\n---\n\n# 利用RunLoop空闲时间执行预缓存任务\n\nFDTemplateLayoutCell 的高度预缓存是一个优化功能，它要求页面处于**空闲**状态时才执行计算，当用户正在滑动列表时显然不应该执行计算任务影响滑动体验。  \n一般来说，这个功能要耦合 UITableView 的滑动状态才行，但这种实现十分不优雅且可能破坏外部的 delegate 结构，但好在我们还有`RunLoop`这个工具，了解它的运行机制后，可以用很简单的代码实现上面的功能。  \n\n## 空闲RunLoopMode\n\n在曾经的 RunLoop 线下分享会（[视频可戳](http://yun.baidu.com/share/link?shareid=2268593032&uk=2885973690)）中介绍了 RunLoopMode 的概念。  \n当用户正在滑动 UIScrollView 时，RunLoop 将切换到 `UITrackingRunLoopMode` 接受滑动手势和处理滑动事件（包括减速和弹簧效果），此时，其他 Mode （除 NSRunLoopCommonModes 这个组合 Mode）下的事件将全部暂停执行，来保证滑动事件的优先处理，这也是 iOS 滑动顺畅的重要原因。  \n当 UI 没在滑动时，默认的 Mode 是 `NSDefaultRunLoopMode`（同 CF 中的 kCFRunLoopDefaultMode），同时也是 CF 中定义的 “空闲状态 Mode”。当用户啥也不点，此时也没有什么网络 IO 时，就是在这个 Mode 下。\n\n## 用RunLoopObserver找准时机\n\n注册 RunLoopObserver 可以观测当前 RunLoop 的运行状态，并在状态机切换时收到通知：  \n1. RunLoop开始\n2. RunLoop即将处理Timer\n3. RunLoop即将处理Source\n4. RunLoop即将进入休眠状态\n5. RunLoop即将从休眠状态被事件唤醒\n6. RunLoop退出\n\n因为“预缓存高度”的任务需要在最无感知的时刻进行，所以应该同时满足：\n\n1. RunLoop 处于“空闲”状态 Mode\n2. 当这一次 RunLoop 迭代处理完成了所有事件，马上要休眠时\n\n使用 CF 的带 block 版本的注册函数可以让代码更简洁：  \n\n``` objc\nCFRunLoopRef runLoop = CFRunLoopGetCurrent();\nCFStringRef runLoopMode = kCFRunLoopDefaultMode;\nCFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler\n(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, true, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity _) {\n    // TODO here\n});\nCFRunLoopAddObserver(runLoop, observer, runLoopMode);\n```\n\n在其中的 TODO 位置，就可以开始任务的收集和分发了，当然，不能忘记适时的移除这个 observer  \n\n## 分解成多个RunLoop Source任务\n\n假设列表有 20 个 cell，加载后展示了前 5 个，那么开启估算后 table view 只计算了这 5 个的高度，此时剩下 15 个就是“预缓存”的任务，而我们并不希望这 15 个计算任务在同一个 RunLoop 迭代中同步执行，这样会卡顿 UI，所以应该把它们**分别分解**到 15 个 RunLoop 迭代中执行，这时就需要手动向 RunLoop 中添加 Source 任务（由应用发起和处理的是 Source 0 任务）  \nFoundation 层没对 RunLoopSource 提供直接构建的 API，但是提供了一个间接的、既熟悉又陌生的 API：\n\n``` objc\n- (void)performSelector:(SEL)aSelector\n               onThread:(NSThread *)thr\n             withObject:(id)arg\n          waitUntilDone:(BOOL)wait\n                  modes:(NSArray *)array;\n```\n\n这个方法将创建一个 Source 0 任务，分发到指定线程的 RunLoop 中，在给定的 Mode 下执行，若指定的 RunLoop 处于休眠状态，则唤醒它处理事件，简单来说就是“睡你xx，起来嗨！”  \n于是，我们用一个可变数组装载当前所有需要“预缓存”的 index path，每个 RunLoopObserver 回调时都把第一个任务拿出来分发:\n\n``` objc\nNSMutableArray *mutableIndexPathsToBePrecached = self.fd_allIndexPathsToBePrecached.mutableCopy;\nCFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, true, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity _) {\n    if (mutableIndexPathsToBePrecached.count == 0) {\n        CFRunLoopRemoveObserver(runLoop, observer, runLoopMode);\n        CFRelease(observer); // 注意释放，否则会造成内存泄露\n        return;\n    }\n    NSIndexPath *indexPath = mutableIndexPathsToBePrecached.firstObject;\n    [mutableIndexPathsToBePrecached removeObject:indexPath];\n    [self performSelector:@selector(fd_precacheIndexPathIfNeeded:)\n                 onThread:[NSThread mainThread]\n               withObject:indexPath\n            waitUntilDone:NO\n                    modes:@[NSDefaultRunLoopMode]];\n});\n```\n\n这样，每个任务都被分配到下个“空闲” RunLoop 迭代中执行，其间但凡有滑动事件开始，Mode 切换成 UITrackingRunLoopMode，所有的“预缓存”任务的分发和执行都会自动暂定，最大程度保证滑动流畅。  \n\nPS: 预缓存功能因为下拉刷新的冲突和不明显的收益已经废弃\n\n---\n\n# 开始使用UITableView+FDTemplateLayoutCell\n\n如果你觉得这个工具能帮得到你，整合到工程也十分简单。\n使用 cocoapods：\n\n```\npod search UITableView+FDTemplateLayoutCell\n```\n\n写这篇文章时的最新版本为 1.2，去除了前一个版本的黑魔法，增加了预缓存功能。  \n欢迎使用和支持这个工具，有 bug 请随时反馈哦~  \n再复习下 github 地址： [https://github.com/forkingdog/UITableView-FDTemplateLayoutCell](https://github.com/forkingdog/UITableView-FDTemplateLayoutCell)  \n\n<img src=\"https://cloud.githubusercontent.com/assets/219689/7244961/4209de32-e816-11e4-87bc-b161c442d348.png\" width=\"640\">\n","source":"_posts/cell-height-calculation.md","raw":"title: 优化UITableViewCell高度计算的那些事\ndate: 2015-05-17 18:50:08\ntags: ios最佳实践\n-------------\n\n# 我是前言\n\n这篇文章是我和我们团队最近对 **UITableViewCell** 利用 **AutoLayout** 自动高度计算和 **UITableView** 滑动优化的一个总结。  \n我们也在维护一个开源的扩展，`UITableView+FDTemplateLayoutCell`，让高度计算这个事情变的前所未有的简单，也受到了很多星星的支持，[github链接请戳我](https://github.com/forkingdog/UITableView-FDTemplateLayoutCell)\n\n这篇总结你可以读到：\n- UITableView高度计算和估算的机制\n- 不同iOS系统在高度计算上的差异\n- iOS8 self-sizing cell\n- UITableView+FDTemplateLayoutCell如何用一句话解决高度问题\n- UITableView+FDTemplateLayoutCell中对RunLoop的使用技巧\n\n---\n\n# UITableViewCell高度计算\n\n## rowHeight\n\n`UITableView`是我们再熟悉不过的视图了，它的 **delegate** 和 **data source** 回调不知写了多少次，也不免遇到 UITableViewCell 高度计算的事。UITableView 询问 cell 高度有两种方式。  \n一种是针对所有 Cell 具有固定高度的情况，通过：\n\n``` objc\nself.tableView.rowHeight = 88;\n```\n\n上面的代码指定了一个所有 cell 都是 88 高度的 UITableView，对于定高需求的表格，**强烈建议**使用这种（而非下面的）方式保证不必要的高度计算和调用。`rowHeight`属性的默认值是 44，所以一个空的 UITableView 显示成那个样子。\n\n另一种方式就是实现 UITableViewDelegate 中的：\n\n``` objc\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {\n    // return xxx\n}\n```\n\n需要注意的是，实现了这个方法后，`rowHeight` 的设置将无效。所以，这个方法适用于具有多种 cell 高度的 UITableView。\n\n## estimatedRowHeight\n\n这个属性 iOS7 就出现了， 文档是这么描述它的作用的：\n\n> If the table contains variable height rows, it might be expensive to calculate all their heights when the table loads. Using estimation allows you to defer some of the cost of geometry calculation from load time to scrolling time.\n\n恩，听上去蛮靠谱的。我们知道，UITableView 是个 UIScrollView，就像平时使用 UIScrollView 一样，加载时指定 `contentSize` 后它才能根据自己的 bounds、contentInset、contentOffset 等属性共同决定是否可以滑动以及滚动条的长度。而 UITableView 在一开始并不知道自己会被填充多少内容，于是询问 data source 个数和创建 cell，同时询问 delegate 这些 cell 应该显示的高度，这就造成它在加载的时候浪费了多余的计算在**屏幕外边**的 cell 上。和上面的 `rowHeight` 很类似，设置这个估算高度有两种方法：  \n\n``` objc\nself.tableView.estimatedRowHeight = 88;\n// or\n- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath {\n    // return xxx\n}\n```\n\n有所不同的是，即使面对种类不同的 cell，我们依然可以使用简单的 `estimatedRowHeight` 属性赋值，只要**整体估算值接近**就可以，比如大概有一半 cell 高度是 44， 一半 cell 高度是 88， 那就可以估算一个 66，基本符合预期。  \n\n说完了估算高度的基本使用，可以开始吐槽了：  \n1. 设置估算高度后，contentSize.height 根据“cell估算值 x cell个数”计算，这就导致滚动条的大小处于不稳定的状态，contentSize 会随着滚动从估算高度慢慢替换成真实高度，肉眼可见滚动条突然变化甚至“跳跃”。\n2. 若是有设计不好的下拉刷新或上拉加载控件，或是 KVO 了 contentSize 或 contentOffset 属性，有可能使表格滑动时跳动。\n3. 估算高度设计初衷是好的，让加载速度更快，那凭啥要去侵害滑动的流畅性呢，用户可能对进入页面时多零点几秒加载时间感觉不大，但是滑动时实时计算高度带来的卡顿是明显能体验到的，个人觉得还不如一开始都算好了呢（iOS8更过分，即使都算好了也会边划边计算）\n\n---\n\n# iOS8 self-sizing cell\n\n具有动态高度内容的 cell 一直是个头疼的问题，比如聊天气泡的 cell， frame 布局时代通常是用数据内容反算高度：\n\n``` objc\nCGFloat height = textHeightWithFont() + imageHeight + topMargin + bottomMargin + ...;\n```\n\n供 UITableViewDelegate 调用时很可能是个 cell 的类方法：\n\n``` objc\n@interface BubbleCell : UITableViewCell\n+ (CGFloat)heightWithEntity:(id)entity;\n@end\n```\n\n各种魔法 margin 加上耦合了屏幕宽度。\n\nAutoLayout 时代好了不少，提供了`-systemLayoutSizeFittingSize:`的 API，在 contentView 中设置约束后，就能计算出准确的值；缺点是计算速度肯定没有手算快，而且这是个实例方法，需要维护专门为计算高度而生的 `template layout cell`，它还要求使用者对约束设置的比较熟练，要保证 contentView 内部上下左右所有方向都有约束支撑，设置不合理的话计算的高度就成了0。  \n\n这里还不得不提到一个 UILabel 的蛋疼问题，当 UILabel 行数大于0时，需要指定 `preferredMaxLayoutWidth` 后它才知道自己什么时候该折行。这是个“鸡生蛋蛋生鸡”的问题，因为 UILabel 需要知道 superview 的宽度才能折行，而 superview 的宽度还依仗着子 view 宽度的累加才能确定。这个问题好像到 iOS8 才能够自动解决（不过我们找到了解决方案）\n\n\n回到正题，iOS8 WWDC 中推出了 `self-sizing cell` 的概念，旨在让 cell 自己负责自己的高度计算，使用 frame layout 和 auto layout 都可以享受到：\n\n<img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1es3hwpsb71j20pe0f2ab4.jpg\" width=\"320\">\n\n这个特性首先要求是 iOS8，要是最低支持的系统版本小于8的话，还得针对老版本单写套老式的算高（囧），不过用的 API 到不是新面孔：  \n\n``` objc\nself.tableView.estimatedRowHeight = 213;\nself.tableView.rowHeight = UITableViewAutomaticDimension;\n```\n\n这里又不得不吐槽了，自动计算 rowHeight 跟 estimatedRowHeight 到底是有什么仇，如果不加上估算高度的设置，自动算高就失效了- -\nPS：iOS8 系统中 rowHeight 的默认值已经设置成了 UITableViewAutomaticDimension，所以第二行代码可以省略。  \n\n问题：  \n1. 这个自动算高在 push 到下一个页面或者转屏时会出现高度特别诡异的情况，不过现在的版本修复了。  \n2. 求一个能让最低支持 iOS8 的公司- -\n\n---\n\n# iOS8抽风的算高机制\n\n相同的代码在 iOS7 和 iOS8 上滑动顺畅程度完全不同，iOS8 莫名奇妙的卡。很大一部分原因是 iOS8 上的算高机制大不相同，这是我做的小测试：  \n\n<img src=\"http://ww1.sinaimg.cn/mw690/51530583jw1es3j7avlelj20w4084jsv.jpg\" width=\"640\">\n\n研究后发现这么多次额外计算有下面的原因：\n\n1. 不开启高度估算时，UITableView 上来就要对所有 cell 调用算高来确定 contentSize\n2. `dequeueReusableCellWithIdentifier:forIndexPath:` 相比不带 \"forIndexPath\" 的版本会多调用一次高度计算\n3. iOS7 计算高度后有”缓存“机制，不会重复计算；而 iOS8 不论何时都会重新计算 cell 高度\n\niOS8 把高度计算搞成这个样子，从 WWDC 也倒是能找到点解释，cell 被认为随时都可能改变高度（如从设置中调整动态字体大小），所以每次滑动出来后都要重新计算高度。  \n\n说了这么多，究竟有没有既能省去算高烦恼，又能保证顺畅的滑动，还能支持 iOS6+ 的一站式解决方案呢？\n\n---\n\n# UITableView+FDTemplateLayoutCell\n\n使用 `UITableView+FDTemplateLayoutCell` 无疑是解决算高问题的最佳实践之一，既有 iOS8 self-sizing 功能简单的 API，又可以达到 iOS7 流畅的滑动效果，还保持了最低支持 iOS6。  \n使用起来大概是这样：  \n\n``` objc\n#import <UITableView+FDTemplateLayoutCell.h>\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {\n    return [tableView fd_heightForCellWithIdentifier:@\"identifer\" cacheByIndexPath:indexPath configuration:^(id cell) {\n        // 配置 cell 的数据源，和 \"cellForRow\" 干的事一致，比如：\n        cell.entity = self.feedEntities[indexPath.row];\n    }];\n}\n```\n\n写完上面的代码后，你就已经使用到了：  \n\n- **和每个 UITableViewCell ReuseID 一一对应的 template layout cell**\n这个 cell 只为了参加高度计算，不会真的显示到屏幕上；它通过 UITableView 的 `-dequeueCellForReuseIdentifier:` 方法 lazy 创建并保存，所以要求这个 ReuseID 必须已经被注册到了 UITableView 中，也就是说，要么是 Storyboard 中的原型 cell，要么就是使用了 UITableView 的 `-registerClass:forCellReuseIdentifier:` 或 `-registerNib:forCellReuseIdentifier:`其中之一的注册方法。  \n- **根据 autolayout 约束自动计算高度**\n使用了系统在 iOS6 就提供的 API：`-systemLayoutSizeFittingSize:`\n- **根据 index path 的一套高度缓存机制**\n计算出的高度会自动进行缓存，所以滑动时每个 cell 真正的高度计算只会发生一次，后面的高度询问都会命中缓存，减少了非常可观的多余计算。\n- **自动的缓存失效机制**\n无须担心你数据源的变化引起的缓存失效，当调用如`-reloadData`，`-deleteRowsAtIndexPaths:withRowAnimation:`等任何一个触发 UITableView 刷新机制的方法时，已有的高度缓存将以**最小的代价**执行失效。如删除一个 indexPath 为 [0:5] 的 cell 时，[0:0] ~ [0:4] 的高度缓存不受影响，而 [0:5] 后面所有的缓存值都向前移动一个位置。自动缓存失效机制对 UITableView 的 9 个公有 API 都进行了分别的处理，以保证没有一次多余的高度计算。  \n- **预缓存机制**\n预缓存机制将在 UITableView 没有滑动的空闲时刻执行，计算和缓存那些还没有显示到屏幕中的 cell，整个缓存过程完全没有感知，这使得完整列表的高度计算既没有发生在加载时，又没有发生在滑动时，同时保证了加载速度和滑动流畅性，下文会着重讲下这块的实现原理。\n\n我们在设计这个工具的 API 时斟酌了非常长的时间，既要保证功能的强大，也要保证接口的精简，一行调用背后隐藏着很多功能。\n\n这一套缓存机制能对滑动起多大影响呢？除了肉眼能明显的感知到外，我还做了个小测试：  \n一个有 54 个内容和高度不同 cell 的 table view，从头滑动到尾，再从尾滑动到头，iOS8 系统下，iPhone6，使用 `Time Profiler` 监测算高函数所花费的时间：  \n\n未使用缓存API、未使用估算，共花费 877 ms：\n<img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1es7f5l357cj213k0g07eh.jpg\" width=\"640\">\n\n使用缓存API、开启估算，共花费 77 ms：\n<img src=\"http://ww2.sinaimg.cn/mw690/51530583jw1es7f5lefy3j21440hsgw8.jpg\" width=\"640\">\n\n测试数据的精度先不管，从量级上就差了一个数量级，说实话自己也没想到差距有这么大- -  \n\n同时，工具也顺手解决了`-preferredMaxLayoutWidth`的问题，在计算高度前向 contentView 加了一条和 table view 宽度相同的宽度约束，强行让 contentView 内部的控件知道了自己父 view 的宽度，再反算自己被外界约束的宽度，破除“鸡生蛋蛋生鸡”的问题，这里比较 tricky，就不展开说了。下面说说利用 RunLoop 预缓存的实现。\n\n---\n\n# 利用RunLoop空闲时间执行预缓存任务\n\nFDTemplateLayoutCell 的高度预缓存是一个优化功能，它要求页面处于**空闲**状态时才执行计算，当用户正在滑动列表时显然不应该执行计算任务影响滑动体验。  \n一般来说，这个功能要耦合 UITableView 的滑动状态才行，但这种实现十分不优雅且可能破坏外部的 delegate 结构，但好在我们还有`RunLoop`这个工具，了解它的运行机制后，可以用很简单的代码实现上面的功能。  \n\n## 空闲RunLoopMode\n\n在曾经的 RunLoop 线下分享会（[视频可戳](http://yun.baidu.com/share/link?shareid=2268593032&uk=2885973690)）中介绍了 RunLoopMode 的概念。  \n当用户正在滑动 UIScrollView 时，RunLoop 将切换到 `UITrackingRunLoopMode` 接受滑动手势和处理滑动事件（包括减速和弹簧效果），此时，其他 Mode （除 NSRunLoopCommonModes 这个组合 Mode）下的事件将全部暂停执行，来保证滑动事件的优先处理，这也是 iOS 滑动顺畅的重要原因。  \n当 UI 没在滑动时，默认的 Mode 是 `NSDefaultRunLoopMode`（同 CF 中的 kCFRunLoopDefaultMode），同时也是 CF 中定义的 “空闲状态 Mode”。当用户啥也不点，此时也没有什么网络 IO 时，就是在这个 Mode 下。\n\n## 用RunLoopObserver找准时机\n\n注册 RunLoopObserver 可以观测当前 RunLoop 的运行状态，并在状态机切换时收到通知：  \n1. RunLoop开始\n2. RunLoop即将处理Timer\n3. RunLoop即将处理Source\n4. RunLoop即将进入休眠状态\n5. RunLoop即将从休眠状态被事件唤醒\n6. RunLoop退出\n\n因为“预缓存高度”的任务需要在最无感知的时刻进行，所以应该同时满足：\n\n1. RunLoop 处于“空闲”状态 Mode\n2. 当这一次 RunLoop 迭代处理完成了所有事件，马上要休眠时\n\n使用 CF 的带 block 版本的注册函数可以让代码更简洁：  \n\n``` objc\nCFRunLoopRef runLoop = CFRunLoopGetCurrent();\nCFStringRef runLoopMode = kCFRunLoopDefaultMode;\nCFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler\n(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, true, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity _) {\n    // TODO here\n});\nCFRunLoopAddObserver(runLoop, observer, runLoopMode);\n```\n\n在其中的 TODO 位置，就可以开始任务的收集和分发了，当然，不能忘记适时的移除这个 observer  \n\n## 分解成多个RunLoop Source任务\n\n假设列表有 20 个 cell，加载后展示了前 5 个，那么开启估算后 table view 只计算了这 5 个的高度，此时剩下 15 个就是“预缓存”的任务，而我们并不希望这 15 个计算任务在同一个 RunLoop 迭代中同步执行，这样会卡顿 UI，所以应该把它们**分别分解**到 15 个 RunLoop 迭代中执行，这时就需要手动向 RunLoop 中添加 Source 任务（由应用发起和处理的是 Source 0 任务）  \nFoundation 层没对 RunLoopSource 提供直接构建的 API，但是提供了一个间接的、既熟悉又陌生的 API：\n\n``` objc\n- (void)performSelector:(SEL)aSelector\n               onThread:(NSThread *)thr\n             withObject:(id)arg\n          waitUntilDone:(BOOL)wait\n                  modes:(NSArray *)array;\n```\n\n这个方法将创建一个 Source 0 任务，分发到指定线程的 RunLoop 中，在给定的 Mode 下执行，若指定的 RunLoop 处于休眠状态，则唤醒它处理事件，简单来说就是“睡你xx，起来嗨！”  \n于是，我们用一个可变数组装载当前所有需要“预缓存”的 index path，每个 RunLoopObserver 回调时都把第一个任务拿出来分发:\n\n``` objc\nNSMutableArray *mutableIndexPathsToBePrecached = self.fd_allIndexPathsToBePrecached.mutableCopy;\nCFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, true, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity _) {\n    if (mutableIndexPathsToBePrecached.count == 0) {\n        CFRunLoopRemoveObserver(runLoop, observer, runLoopMode);\n        CFRelease(observer); // 注意释放，否则会造成内存泄露\n        return;\n    }\n    NSIndexPath *indexPath = mutableIndexPathsToBePrecached.firstObject;\n    [mutableIndexPathsToBePrecached removeObject:indexPath];\n    [self performSelector:@selector(fd_precacheIndexPathIfNeeded:)\n                 onThread:[NSThread mainThread]\n               withObject:indexPath\n            waitUntilDone:NO\n                    modes:@[NSDefaultRunLoopMode]];\n});\n```\n\n这样，每个任务都被分配到下个“空闲” RunLoop 迭代中执行，其间但凡有滑动事件开始，Mode 切换成 UITrackingRunLoopMode，所有的“预缓存”任务的分发和执行都会自动暂定，最大程度保证滑动流畅。  \n\nPS: 预缓存功能因为下拉刷新的冲突和不明显的收益已经废弃\n\n---\n\n# 开始使用UITableView+FDTemplateLayoutCell\n\n如果你觉得这个工具能帮得到你，整合到工程也十分简单。\n使用 cocoapods：\n\n```\npod search UITableView+FDTemplateLayoutCell\n```\n\n写这篇文章时的最新版本为 1.2，去除了前一个版本的黑魔法，增加了预缓存功能。  \n欢迎使用和支持这个工具，有 bug 请随时反馈哦~  \n再复习下 github 地址： [https://github.com/forkingdog/UITableView-FDTemplateLayoutCell](https://github.com/forkingdog/UITableView-FDTemplateLayoutCell)  \n\n<img src=\"https://cloud.githubusercontent.com/assets/219689/7244961/4209de32-e816-11e4-87bc-b161c442d348.png\" width=\"640\">\n","slug":"cell-height-calculation","published":1,"updated":"2016-03-26T09:18:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxjo0003ev12xnfojjnz","content":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>这篇文章是我和我们团队最近对 <strong>UITableViewCell</strong> 利用 <strong>AutoLayout</strong> 自动高度计算和 <strong>UITableView</strong> 滑动优化的一个总结。<br>我们也在维护一个开源的扩展，<code>UITableView+FDTemplateLayoutCell</code>，让高度计算这个事情变的前所未有的简单，也受到了很多星星的支持，<a href=\"https://github.com/forkingdog/UITableView-FDTemplateLayoutCell\" target=\"_blank\" rel=\"external\">github链接请戳我</a></p>\n<p>这篇总结你可以读到：</p>\n<ul>\n<li>UITableView高度计算和估算的机制</li>\n<li>不同iOS系统在高度计算上的差异</li>\n<li>iOS8 self-sizing cell</li>\n<li>UITableView+FDTemplateLayoutCell如何用一句话解决高度问题</li>\n<li>UITableView+FDTemplateLayoutCell中对RunLoop的使用技巧</li>\n</ul>\n<hr>\n<h1 id=\"UITableViewCell高度计算\"><a href=\"#UITableViewCell高度计算\" class=\"headerlink\" title=\"UITableViewCell高度计算\"></a>UITableViewCell高度计算</h1><h2 id=\"rowHeight\"><a href=\"#rowHeight\" class=\"headerlink\" title=\"rowHeight\"></a>rowHeight</h2><p><code>UITableView</code>是我们再熟悉不过的视图了，它的 <strong>delegate</strong> 和 <strong>data source</strong> 回调不知写了多少次，也不免遇到 UITableViewCell 高度计算的事。UITableView 询问 cell 高度有两种方式。<br>一种是针对所有 Cell 具有固定高度的情况，通过：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.tableView.rowHeight = <span class=\"number\">88</span>;</span><br></pre></td></tr></table></figure>\n<p>上面的代码指定了一个所有 cell 都是 88 高度的 UITableView，对于定高需求的表格，<strong>强烈建议</strong>使用这种（而非下面的）方式保证不必要的高度计算和调用。<code>rowHeight</code>属性的默认值是 44，所以一个空的 UITableView 显示成那个样子。</p>\n<p>另一种方式就是实现 UITableViewDelegate 中的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</span><br><span class=\"line\">    <span class=\"comment\">// return xxx</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，实现了这个方法后，<code>rowHeight</code> 的设置将无效。所以，这个方法适用于具有多种 cell 高度的 UITableView。</p>\n<h2 id=\"estimatedRowHeight\"><a href=\"#estimatedRowHeight\" class=\"headerlink\" title=\"estimatedRowHeight\"></a>estimatedRowHeight</h2><p>这个属性 iOS7 就出现了， 文档是这么描述它的作用的：</p>\n<blockquote>\n<p>If the table contains variable height rows, it might be expensive to calculate all their heights when the table loads. Using estimation allows you to defer some of the cost of geometry calculation from load time to scrolling time.</p>\n</blockquote>\n<p>恩，听上去蛮靠谱的。我们知道，UITableView 是个 UIScrollView，就像平时使用 UIScrollView 一样，加载时指定 <code>contentSize</code> 后它才能根据自己的 bounds、contentInset、contentOffset 等属性共同决定是否可以滑动以及滚动条的长度。而 UITableView 在一开始并不知道自己会被填充多少内容，于是询问 data source 个数和创建 cell，同时询问 delegate 这些 cell 应该显示的高度，这就造成它在加载的时候浪费了多余的计算在<strong>屏幕外边</strong>的 cell 上。和上面的 <code>rowHeight</code> 很类似，设置这个估算高度有两种方法：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.tableView.estimatedRowHeight = <span class=\"number\">88</span>;</span><br><span class=\"line\"><span class=\"comment\">// or</span></span><br><span class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView estimatedHeightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</span><br><span class=\"line\">    <span class=\"comment\">// return xxx</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有所不同的是，即使面对种类不同的 cell，我们依然可以使用简单的 <code>estimatedRowHeight</code> 属性赋值，只要<strong>整体估算值接近</strong>就可以，比如大概有一半 cell 高度是 44， 一半 cell 高度是 88， 那就可以估算一个 66，基本符合预期。  </p>\n<p>说完了估算高度的基本使用，可以开始吐槽了：  </p>\n<ol>\n<li>设置估算高度后，contentSize.height 根据“cell估算值 x cell个数”计算，这就导致滚动条的大小处于不稳定的状态，contentSize 会随着滚动从估算高度慢慢替换成真实高度，肉眼可见滚动条突然变化甚至“跳跃”。</li>\n<li>若是有设计不好的下拉刷新或上拉加载控件，或是 KVO 了 contentSize 或 contentOffset 属性，有可能使表格滑动时跳动。</li>\n<li>估算高度设计初衷是好的，让加载速度更快，那凭啥要去侵害滑动的流畅性呢，用户可能对进入页面时多零点几秒加载时间感觉不大，但是滑动时实时计算高度带来的卡顿是明显能体验到的，个人觉得还不如一开始都算好了呢（iOS8更过分，即使都算好了也会边划边计算）</li>\n</ol>\n<hr>\n<h1 id=\"iOS8-self-sizing-cell\"><a href=\"#iOS8-self-sizing-cell\" class=\"headerlink\" title=\"iOS8 self-sizing cell\"></a>iOS8 self-sizing cell</h1><p>具有动态高度内容的 cell 一直是个头疼的问题，比如聊天气泡的 cell， frame 布局时代通常是用数据内容反算高度：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGFloat</span> height = textHeightWithFont() + imageHeight + topMargin + bottomMargin + ...;</span><br></pre></td></tr></table></figure>\n<p>供 UITableViewDelegate 调用时很可能是个 cell 的类方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BubbleCell</span> : <span class=\"title\">UITableViewCell</span></span></span><br><span class=\"line\">+ (<span class=\"built_in\">CGFloat</span>)heightWithEntity:(<span class=\"keyword\">id</span>)entity;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>各种魔法 margin 加上耦合了屏幕宽度。</p>\n<p>AutoLayout 时代好了不少，提供了<code>-systemLayoutSizeFittingSize:</code>的 API，在 contentView 中设置约束后，就能计算出准确的值；缺点是计算速度肯定没有手算快，而且这是个实例方法，需要维护专门为计算高度而生的 <code>template layout cell</code>，它还要求使用者对约束设置的比较熟练，要保证 contentView 内部上下左右所有方向都有约束支撑，设置不合理的话计算的高度就成了0。  </p>\n<p>这里还不得不提到一个 UILabel 的蛋疼问题，当 UILabel 行数大于0时，需要指定 <code>preferredMaxLayoutWidth</code> 后它才知道自己什么时候该折行。这是个“鸡生蛋蛋生鸡”的问题，因为 UILabel 需要知道 superview 的宽度才能折行，而 superview 的宽度还依仗着子 view 宽度的累加才能确定。这个问题好像到 iOS8 才能够自动解决（不过我们找到了解决方案）</p>\n<p>回到正题，iOS8 WWDC 中推出了 <code>self-sizing cell</code> 的概念，旨在让 cell 自己负责自己的高度计算，使用 frame layout 和 auto layout 都可以享受到：</p>\n<p><img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1es3hwpsb71j20pe0f2ab4.jpg\" width=\"320\"></p>\n<p>这个特性首先要求是 iOS8，要是最低支持的系统版本小于8的话，还得针对老版本单写套老式的算高（囧），不过用的 API 到不是新面孔：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.tableView.estimatedRowHeight = <span class=\"number\">213</span>;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.tableView.rowHeight = <span class=\"built_in\">UITableViewAutomaticDimension</span>;</span><br></pre></td></tr></table></figure>\n<p>这里又不得不吐槽了，自动计算 rowHeight 跟 estimatedRowHeight 到底是有什么仇，如果不加上估算高度的设置，自动算高就失效了- -<br>PS：iOS8 系统中 rowHeight 的默认值已经设置成了 UITableViewAutomaticDimension，所以第二行代码可以省略。  </p>\n<p>问题：  </p>\n<ol>\n<li>这个自动算高在 push 到下一个页面或者转屏时会出现高度特别诡异的情况，不过现在的版本修复了。  </li>\n<li>求一个能让最低支持 iOS8 的公司- -</li>\n</ol>\n<hr>\n<h1 id=\"iOS8抽风的算高机制\"><a href=\"#iOS8抽风的算高机制\" class=\"headerlink\" title=\"iOS8抽风的算高机制\"></a>iOS8抽风的算高机制</h1><p>相同的代码在 iOS7 和 iOS8 上滑动顺畅程度完全不同，iOS8 莫名奇妙的卡。很大一部分原因是 iOS8 上的算高机制大不相同，这是我做的小测试：  </p>\n<p><img src=\"http://ww1.sinaimg.cn/mw690/51530583jw1es3j7avlelj20w4084jsv.jpg\" width=\"640\"></p>\n<p>研究后发现这么多次额外计算有下面的原因：</p>\n<ol>\n<li>不开启高度估算时，UITableView 上来就要对所有 cell 调用算高来确定 contentSize</li>\n<li><code>dequeueReusableCellWithIdentifier:forIndexPath:</code> 相比不带 “forIndexPath” 的版本会多调用一次高度计算</li>\n<li>iOS7 计算高度后有”缓存“机制，不会重复计算；而 iOS8 不论何时都会重新计算 cell 高度</li>\n</ol>\n<p>iOS8 把高度计算搞成这个样子，从 WWDC 也倒是能找到点解释，cell 被认为随时都可能改变高度（如从设置中调整动态字体大小），所以每次滑动出来后都要重新计算高度。  </p>\n<p>说了这么多，究竟有没有既能省去算高烦恼，又能保证顺畅的滑动，还能支持 iOS6+ 的一站式解决方案呢？</p>\n<hr>\n<h1 id=\"UITableView-FDTemplateLayoutCell\"><a href=\"#UITableView-FDTemplateLayoutCell\" class=\"headerlink\" title=\"UITableView+FDTemplateLayoutCell\"></a>UITableView+FDTemplateLayoutCell</h1><p>使用 <code>UITableView+FDTemplateLayoutCell</code> 无疑是解决算高问题的最佳实践之一，既有 iOS8 self-sizing 功能简单的 API，又可以达到 iOS7 流畅的滑动效果，还保持了最低支持 iOS6。<br>使用起来大概是这样：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;UITableView+FDTemplateLayoutCell.h&gt;</span></span></span><br><span class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [tableView fd_heightForCellWithIdentifier:<span class=\"string\">@\"identifer\"</span> cacheByIndexPath:indexPath configuration:^(<span class=\"keyword\">id</span> cell) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 配置 cell 的数据源，和 \"cellForRow\" 干的事一致，比如：</span></span><br><span class=\"line\">        cell.entity = <span class=\"keyword\">self</span>.feedEntities[indexPath.row];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>写完上面的代码后，你就已经使用到了：  </p>\n<ul>\n<li><strong>和每个 UITableViewCell ReuseID 一一对应的 template layout cell</strong><br>这个 cell 只为了参加高度计算，不会真的显示到屏幕上；它通过 UITableView 的 <code>-dequeueCellForReuseIdentifier:</code> 方法 lazy 创建并保存，所以要求这个 ReuseID 必须已经被注册到了 UITableView 中，也就是说，要么是 Storyboard 中的原型 cell，要么就是使用了 UITableView 的 <code>-registerClass:forCellReuseIdentifier:</code> 或 <code>-registerNib:forCellReuseIdentifier:</code>其中之一的注册方法。  </li>\n<li><strong>根据 autolayout 约束自动计算高度</strong><br>使用了系统在 iOS6 就提供的 API：<code>-systemLayoutSizeFittingSize:</code></li>\n<li><strong>根据 index path 的一套高度缓存机制</strong><br>计算出的高度会自动进行缓存，所以滑动时每个 cell 真正的高度计算只会发生一次，后面的高度询问都会命中缓存，减少了非常可观的多余计算。</li>\n<li><strong>自动的缓存失效机制</strong><br>无须担心你数据源的变化引起的缓存失效，当调用如<code>-reloadData</code>，<code>-deleteRowsAtIndexPaths:withRowAnimation:</code>等任何一个触发 UITableView 刷新机制的方法时，已有的高度缓存将以<strong>最小的代价</strong>执行失效。如删除一个 indexPath 为 [0:5] 的 cell 时，[0:0] ~ [0:4] 的高度缓存不受影响，而 [0:5] 后面所有的缓存值都向前移动一个位置。自动缓存失效机制对 UITableView 的 9 个公有 API 都进行了分别的处理，以保证没有一次多余的高度计算。  </li>\n<li><strong>预缓存机制</strong><br>预缓存机制将在 UITableView 没有滑动的空闲时刻执行，计算和缓存那些还没有显示到屏幕中的 cell，整个缓存过程完全没有感知，这使得完整列表的高度计算既没有发生在加载时，又没有发生在滑动时，同时保证了加载速度和滑动流畅性，下文会着重讲下这块的实现原理。</li>\n</ul>\n<p>我们在设计这个工具的 API 时斟酌了非常长的时间，既要保证功能的强大，也要保证接口的精简，一行调用背后隐藏着很多功能。</p>\n<p>这一套缓存机制能对滑动起多大影响呢？除了肉眼能明显的感知到外，我还做了个小测试：<br>一个有 54 个内容和高度不同 cell 的 table view，从头滑动到尾，再从尾滑动到头，iOS8 系统下，iPhone6，使用 <code>Time Profiler</code> 监测算高函数所花费的时间：  </p>\n<p>未使用缓存API、未使用估算，共花费 877 ms：<br><img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1es7f5l357cj213k0g07eh.jpg\" width=\"640\"></p>\n<p>使用缓存API、开启估算，共花费 77 ms：<br><img src=\"http://ww2.sinaimg.cn/mw690/51530583jw1es7f5lefy3j21440hsgw8.jpg\" width=\"640\"></p>\n<p>测试数据的精度先不管，从量级上就差了一个数量级，说实话自己也没想到差距有这么大- -  </p>\n<p>同时，工具也顺手解决了<code>-preferredMaxLayoutWidth</code>的问题，在计算高度前向 contentView 加了一条和 table view 宽度相同的宽度约束，强行让 contentView 内部的控件知道了自己父 view 的宽度，再反算自己被外界约束的宽度，破除“鸡生蛋蛋生鸡”的问题，这里比较 tricky，就不展开说了。下面说说利用 RunLoop 预缓存的实现。</p>\n<hr>\n<h1 id=\"利用RunLoop空闲时间执行预缓存任务\"><a href=\"#利用RunLoop空闲时间执行预缓存任务\" class=\"headerlink\" title=\"利用RunLoop空闲时间执行预缓存任务\"></a>利用RunLoop空闲时间执行预缓存任务</h1><p>FDTemplateLayoutCell 的高度预缓存是一个优化功能，它要求页面处于<strong>空闲</strong>状态时才执行计算，当用户正在滑动列表时显然不应该执行计算任务影响滑动体验。<br>一般来说，这个功能要耦合 UITableView 的滑动状态才行，但这种实现十分不优雅且可能破坏外部的 delegate 结构，但好在我们还有<code>RunLoop</code>这个工具，了解它的运行机制后，可以用很简单的代码实现上面的功能。  </p>\n<h2 id=\"空闲RunLoopMode\"><a href=\"#空闲RunLoopMode\" class=\"headerlink\" title=\"空闲RunLoopMode\"></a>空闲RunLoopMode</h2><p>在曾经的 RunLoop 线下分享会（<a href=\"http://yun.baidu.com/share/link?shareid=2268593032&amp;uk=2885973690\" target=\"_blank\" rel=\"external\">视频可戳</a>）中介绍了 RunLoopMode 的概念。<br>当用户正在滑动 UIScrollView 时，RunLoop 将切换到 <code>UITrackingRunLoopMode</code> 接受滑动手势和处理滑动事件（包括减速和弹簧效果），此时，其他 Mode （除 NSRunLoopCommonModes 这个组合 Mode）下的事件将全部暂停执行，来保证滑动事件的优先处理，这也是 iOS 滑动顺畅的重要原因。<br>当 UI 没在滑动时，默认的 Mode 是 <code>NSDefaultRunLoopMode</code>（同 CF 中的 kCFRunLoopDefaultMode），同时也是 CF 中定义的 “空闲状态 Mode”。当用户啥也不点，此时也没有什么网络 IO 时，就是在这个 Mode 下。</p>\n<h2 id=\"用RunLoopObserver找准时机\"><a href=\"#用RunLoopObserver找准时机\" class=\"headerlink\" title=\"用RunLoopObserver找准时机\"></a>用RunLoopObserver找准时机</h2><p>注册 RunLoopObserver 可以观测当前 RunLoop 的运行状态，并在状态机切换时收到通知：  </p>\n<ol>\n<li>RunLoop开始</li>\n<li>RunLoop即将处理Timer</li>\n<li>RunLoop即将处理Source</li>\n<li>RunLoop即将进入休眠状态</li>\n<li>RunLoop即将从休眠状态被事件唤醒</li>\n<li>RunLoop退出</li>\n</ol>\n<p>因为“预缓存高度”的任务需要在最无感知的时刻进行，所以应该同时满足：</p>\n<ol>\n<li>RunLoop 处于“空闲”状态 Mode</li>\n<li>当这一次 RunLoop 迭代处理完成了所有事件，马上要休眠时</li>\n</ol>\n<p>使用 CF 的带 block 版本的注册函数可以让代码更简洁：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> runLoop = <span class=\"built_in\">CFRunLoopGetCurrent</span>();</span><br><span class=\"line\"><span class=\"built_in\">CFStringRef</span> runLoopMode = k<span class=\"built_in\">CFRunLoopDefaultMode</span>;</span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopObserverRef</span> observer = <span class=\"built_in\">CFRunLoopObserverCreateWithHandler</span></span><br><span class=\"line\">(k<span class=\"built_in\">CFAllocatorDefault</span>, k<span class=\"built_in\">CFRunLoopBeforeWaiting</span>, <span class=\"literal\">true</span>, <span class=\"number\">0</span>, ^(<span class=\"built_in\">CFRunLoopObserverRef</span> observer, <span class=\"built_in\">CFRunLoopActivity</span> _) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO here</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopAddObserver</span>(runLoop, observer, runLoopMode);</span><br></pre></td></tr></table></figure>\n<p>在其中的 TODO 位置，就可以开始任务的收集和分发了，当然，不能忘记适时的移除这个 observer  </p>\n<h2 id=\"分解成多个RunLoop-Source任务\"><a href=\"#分解成多个RunLoop-Source任务\" class=\"headerlink\" title=\"分解成多个RunLoop Source任务\"></a>分解成多个RunLoop Source任务</h2><p>假设列表有 20 个 cell，加载后展示了前 5 个，那么开启估算后 table view 只计算了这 5 个的高度，此时剩下 15 个就是“预缓存”的任务，而我们并不希望这 15 个计算任务在同一个 RunLoop 迭代中同步执行，这样会卡顿 UI，所以应该把它们<strong>分别分解</strong>到 15 个 RunLoop 迭代中执行，这时就需要手动向 RunLoop 中添加 Source 任务（由应用发起和处理的是 Source 0 任务）<br>Foundation 层没对 RunLoopSource 提供直接构建的 API，但是提供了一个间接的、既熟悉又陌生的 API：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)performSelector:(SEL)aSelector</span><br><span class=\"line\">               onThread:(<span class=\"built_in\">NSThread</span> *)thr</span><br><span class=\"line\">             withObject:(<span class=\"keyword\">id</span>)arg</span><br><span class=\"line\">          waitUntilDone:(<span class=\"built_in\">BOOL</span>)wait</span><br><span class=\"line\">                  modes:(<span class=\"built_in\">NSArray</span> *)array;</span><br></pre></td></tr></table></figure>\n<p>这个方法将创建一个 Source 0 任务，分发到指定线程的 RunLoop 中，在给定的 Mode 下执行，若指定的 RunLoop 处于休眠状态，则唤醒它处理事件，简单来说就是“睡你xx，起来嗨！”<br>于是，我们用一个可变数组装载当前所有需要“预缓存”的 index path，每个 RunLoopObserver 回调时都把第一个任务拿出来分发:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *mutableIndexPathsToBePrecached = <span class=\"keyword\">self</span>.fd_allIndexPathsToBePrecached.mutableCopy;</span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopObserverRef</span> observer = <span class=\"built_in\">CFRunLoopObserverCreateWithHandler</span>(k<span class=\"built_in\">CFAllocatorDefault</span>, k<span class=\"built_in\">CFRunLoopBeforeWaiting</span>, <span class=\"literal\">true</span>, <span class=\"number\">0</span>, ^(<span class=\"built_in\">CFRunLoopObserverRef</span> observer, <span class=\"built_in\">CFRunLoopActivity</span> _) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mutableIndexPathsToBePrecached.count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CFRunLoopRemoveObserver</span>(runLoop, observer, runLoopMode);</span><br><span class=\"line\">        <span class=\"built_in\">CFRelease</span>(observer); <span class=\"comment\">// 注意释放，否则会造成内存泄露</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSIndexPath</span> *indexPath = mutableIndexPathsToBePrecached.firstObject;</span><br><span class=\"line\">    [mutableIndexPathsToBePrecached removeObject:indexPath];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(fd_precacheIndexPathIfNeeded:)</span><br><span class=\"line\">                 onThread:[<span class=\"built_in\">NSThread</span> mainThread]</span><br><span class=\"line\">               withObject:indexPath</span><br><span class=\"line\">            waitUntilDone:<span class=\"literal\">NO</span></span><br><span class=\"line\">                    modes:@[<span class=\"built_in\">NSDefaultRunLoopMode</span>]];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这样，每个任务都被分配到下个“空闲” RunLoop 迭代中执行，其间但凡有滑动事件开始，Mode 切换成 UITrackingRunLoopMode，所有的“预缓存”任务的分发和执行都会自动暂定，最大程度保证滑动流畅。  </p>\n<p>PS: 预缓存功能因为下拉刷新的冲突和不明显的收益已经废弃</p>\n<hr>\n<h1 id=\"开始使用UITableView-FDTemplateLayoutCell\"><a href=\"#开始使用UITableView-FDTemplateLayoutCell\" class=\"headerlink\" title=\"开始使用UITableView+FDTemplateLayoutCell\"></a>开始使用UITableView+FDTemplateLayoutCell</h1><p>如果你觉得这个工具能帮得到你，整合到工程也十分简单。<br>使用 cocoapods：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod search UITableView+FDTemplateLayoutCell</span><br></pre></td></tr></table></figure>\n<p>写这篇文章时的最新版本为 1.2，去除了前一个版本的黑魔法，增加了预缓存功能。<br>欢迎使用和支持这个工具，有 bug 请随时反馈哦~<br>再复习下 github 地址： <a href=\"https://github.com/forkingdog/UITableView-FDTemplateLayoutCell\" target=\"_blank\" rel=\"external\">https://github.com/forkingdog/UITableView-FDTemplateLayoutCell</a>  </p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/219689/7244961/4209de32-e816-11e4-87bc-b161c442d348.png\" width=\"640\"></p>\n","excerpt":"","more":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>这篇文章是我和我们团队最近对 <strong>UITableViewCell</strong> 利用 <strong>AutoLayout</strong> 自动高度计算和 <strong>UITableView</strong> 滑动优化的一个总结。<br>我们也在维护一个开源的扩展，<code>UITableView+FDTemplateLayoutCell</code>，让高度计算这个事情变的前所未有的简单，也受到了很多星星的支持，<a href=\"https://github.com/forkingdog/UITableView-FDTemplateLayoutCell\">github链接请戳我</a></p>\n<p>这篇总结你可以读到：</p>\n<ul>\n<li>UITableView高度计算和估算的机制</li>\n<li>不同iOS系统在高度计算上的差异</li>\n<li>iOS8 self-sizing cell</li>\n<li>UITableView+FDTemplateLayoutCell如何用一句话解决高度问题</li>\n<li>UITableView+FDTemplateLayoutCell中对RunLoop的使用技巧</li>\n</ul>\n<hr>\n<h1 id=\"UITableViewCell高度计算\"><a href=\"#UITableViewCell高度计算\" class=\"headerlink\" title=\"UITableViewCell高度计算\"></a>UITableViewCell高度计算</h1><h2 id=\"rowHeight\"><a href=\"#rowHeight\" class=\"headerlink\" title=\"rowHeight\"></a>rowHeight</h2><p><code>UITableView</code>是我们再熟悉不过的视图了，它的 <strong>delegate</strong> 和 <strong>data source</strong> 回调不知写了多少次，也不免遇到 UITableViewCell 高度计算的事。UITableView 询问 cell 高度有两种方式。<br>一种是针对所有 Cell 具有固定高度的情况，通过：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.tableView.rowHeight = <span class=\"number\">88</span>;</span><br></pre></td></tr></table></figure>\n<p>上面的代码指定了一个所有 cell 都是 88 高度的 UITableView，对于定高需求的表格，<strong>强烈建议</strong>使用这种（而非下面的）方式保证不必要的高度计算和调用。<code>rowHeight</code>属性的默认值是 44，所以一个空的 UITableView 显示成那个样子。</p>\n<p>另一种方式就是实现 UITableViewDelegate 中的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</span><br><span class=\"line\">    <span class=\"comment\">// return xxx</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，实现了这个方法后，<code>rowHeight</code> 的设置将无效。所以，这个方法适用于具有多种 cell 高度的 UITableView。</p>\n<h2 id=\"estimatedRowHeight\"><a href=\"#estimatedRowHeight\" class=\"headerlink\" title=\"estimatedRowHeight\"></a>estimatedRowHeight</h2><p>这个属性 iOS7 就出现了， 文档是这么描述它的作用的：</p>\n<blockquote>\n<p>If the table contains variable height rows, it might be expensive to calculate all their heights when the table loads. Using estimation allows you to defer some of the cost of geometry calculation from load time to scrolling time.</p>\n</blockquote>\n<p>恩，听上去蛮靠谱的。我们知道，UITableView 是个 UIScrollView，就像平时使用 UIScrollView 一样，加载时指定 <code>contentSize</code> 后它才能根据自己的 bounds、contentInset、contentOffset 等属性共同决定是否可以滑动以及滚动条的长度。而 UITableView 在一开始并不知道自己会被填充多少内容，于是询问 data source 个数和创建 cell，同时询问 delegate 这些 cell 应该显示的高度，这就造成它在加载的时候浪费了多余的计算在<strong>屏幕外边</strong>的 cell 上。和上面的 <code>rowHeight</code> 很类似，设置这个估算高度有两种方法：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.tableView.estimatedRowHeight = <span class=\"number\">88</span>;</span><br><span class=\"line\"><span class=\"comment\">// or</span></span><br><span class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView estimatedHeightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</span><br><span class=\"line\">    <span class=\"comment\">// return xxx</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有所不同的是，即使面对种类不同的 cell，我们依然可以使用简单的 <code>estimatedRowHeight</code> 属性赋值，只要<strong>整体估算值接近</strong>就可以，比如大概有一半 cell 高度是 44， 一半 cell 高度是 88， 那就可以估算一个 66，基本符合预期。  </p>\n<p>说完了估算高度的基本使用，可以开始吐槽了：  </p>\n<ol>\n<li>设置估算高度后，contentSize.height 根据“cell估算值 x cell个数”计算，这就导致滚动条的大小处于不稳定的状态，contentSize 会随着滚动从估算高度慢慢替换成真实高度，肉眼可见滚动条突然变化甚至“跳跃”。</li>\n<li>若是有设计不好的下拉刷新或上拉加载控件，或是 KVO 了 contentSize 或 contentOffset 属性，有可能使表格滑动时跳动。</li>\n<li>估算高度设计初衷是好的，让加载速度更快，那凭啥要去侵害滑动的流畅性呢，用户可能对进入页面时多零点几秒加载时间感觉不大，但是滑动时实时计算高度带来的卡顿是明显能体验到的，个人觉得还不如一开始都算好了呢（iOS8更过分，即使都算好了也会边划边计算）</li>\n</ol>\n<hr>\n<h1 id=\"iOS8-self-sizing-cell\"><a href=\"#iOS8-self-sizing-cell\" class=\"headerlink\" title=\"iOS8 self-sizing cell\"></a>iOS8 self-sizing cell</h1><p>具有动态高度内容的 cell 一直是个头疼的问题，比如聊天气泡的 cell， frame 布局时代通常是用数据内容反算高度：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGFloat</span> height = textHeightWithFont() + imageHeight + topMargin + bottomMargin + ...;</span><br></pre></td></tr></table></figure>\n<p>供 UITableViewDelegate 调用时很可能是个 cell 的类方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BubbleCell</span> : <span class=\"title\">UITableViewCell</span></span></span><br><span class=\"line\">+ (<span class=\"built_in\">CGFloat</span>)heightWithEntity:(<span class=\"keyword\">id</span>)entity;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>各种魔法 margin 加上耦合了屏幕宽度。</p>\n<p>AutoLayout 时代好了不少，提供了<code>-systemLayoutSizeFittingSize:</code>的 API，在 contentView 中设置约束后，就能计算出准确的值；缺点是计算速度肯定没有手算快，而且这是个实例方法，需要维护专门为计算高度而生的 <code>template layout cell</code>，它还要求使用者对约束设置的比较熟练，要保证 contentView 内部上下左右所有方向都有约束支撑，设置不合理的话计算的高度就成了0。  </p>\n<p>这里还不得不提到一个 UILabel 的蛋疼问题，当 UILabel 行数大于0时，需要指定 <code>preferredMaxLayoutWidth</code> 后它才知道自己什么时候该折行。这是个“鸡生蛋蛋生鸡”的问题，因为 UILabel 需要知道 superview 的宽度才能折行，而 superview 的宽度还依仗着子 view 宽度的累加才能确定。这个问题好像到 iOS8 才能够自动解决（不过我们找到了解决方案）</p>\n<p>回到正题，iOS8 WWDC 中推出了 <code>self-sizing cell</code> 的概念，旨在让 cell 自己负责自己的高度计算，使用 frame layout 和 auto layout 都可以享受到：</p>\n<p><img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1es3hwpsb71j20pe0f2ab4.jpg\" width=\"320\"></p>\n<p>这个特性首先要求是 iOS8，要是最低支持的系统版本小于8的话，还得针对老版本单写套老式的算高（囧），不过用的 API 到不是新面孔：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.tableView.estimatedRowHeight = <span class=\"number\">213</span>;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.tableView.rowHeight = <span class=\"built_in\">UITableViewAutomaticDimension</span>;</span><br></pre></td></tr></table></figure>\n<p>这里又不得不吐槽了，自动计算 rowHeight 跟 estimatedRowHeight 到底是有什么仇，如果不加上估算高度的设置，自动算高就失效了- -<br>PS：iOS8 系统中 rowHeight 的默认值已经设置成了 UITableViewAutomaticDimension，所以第二行代码可以省略。  </p>\n<p>问题：  </p>\n<ol>\n<li>这个自动算高在 push 到下一个页面或者转屏时会出现高度特别诡异的情况，不过现在的版本修复了。  </li>\n<li>求一个能让最低支持 iOS8 的公司- -</li>\n</ol>\n<hr>\n<h1 id=\"iOS8抽风的算高机制\"><a href=\"#iOS8抽风的算高机制\" class=\"headerlink\" title=\"iOS8抽风的算高机制\"></a>iOS8抽风的算高机制</h1><p>相同的代码在 iOS7 和 iOS8 上滑动顺畅程度完全不同，iOS8 莫名奇妙的卡。很大一部分原因是 iOS8 上的算高机制大不相同，这是我做的小测试：  </p>\n<p><img src=\"http://ww1.sinaimg.cn/mw690/51530583jw1es3j7avlelj20w4084jsv.jpg\" width=\"640\"></p>\n<p>研究后发现这么多次额外计算有下面的原因：</p>\n<ol>\n<li>不开启高度估算时，UITableView 上来就要对所有 cell 调用算高来确定 contentSize</li>\n<li><code>dequeueReusableCellWithIdentifier:forIndexPath:</code> 相比不带 “forIndexPath” 的版本会多调用一次高度计算</li>\n<li>iOS7 计算高度后有”缓存“机制，不会重复计算；而 iOS8 不论何时都会重新计算 cell 高度</li>\n</ol>\n<p>iOS8 把高度计算搞成这个样子，从 WWDC 也倒是能找到点解释，cell 被认为随时都可能改变高度（如从设置中调整动态字体大小），所以每次滑动出来后都要重新计算高度。  </p>\n<p>说了这么多，究竟有没有既能省去算高烦恼，又能保证顺畅的滑动，还能支持 iOS6+ 的一站式解决方案呢？</p>\n<hr>\n<h1 id=\"UITableView-FDTemplateLayoutCell\"><a href=\"#UITableView-FDTemplateLayoutCell\" class=\"headerlink\" title=\"UITableView+FDTemplateLayoutCell\"></a>UITableView+FDTemplateLayoutCell</h1><p>使用 <code>UITableView+FDTemplateLayoutCell</code> 无疑是解决算高问题的最佳实践之一，既有 iOS8 self-sizing 功能简单的 API，又可以达到 iOS7 流畅的滑动效果，还保持了最低支持 iOS6。<br>使用起来大概是这样：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;UITableView+FDTemplateLayoutCell.h&gt;</span></span></span><br><span class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [tableView fd_heightForCellWithIdentifier:<span class=\"string\">@\"identifer\"</span> cacheByIndexPath:indexPath configuration:^(<span class=\"keyword\">id</span> cell) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 配置 cell 的数据源，和 \"cellForRow\" 干的事一致，比如：</span></span><br><span class=\"line\">        cell.entity = <span class=\"keyword\">self</span>.feedEntities[indexPath.row];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>写完上面的代码后，你就已经使用到了：  </p>\n<ul>\n<li><strong>和每个 UITableViewCell ReuseID 一一对应的 template layout cell</strong><br>这个 cell 只为了参加高度计算，不会真的显示到屏幕上；它通过 UITableView 的 <code>-dequeueCellForReuseIdentifier:</code> 方法 lazy 创建并保存，所以要求这个 ReuseID 必须已经被注册到了 UITableView 中，也就是说，要么是 Storyboard 中的原型 cell，要么就是使用了 UITableView 的 <code>-registerClass:forCellReuseIdentifier:</code> 或 <code>-registerNib:forCellReuseIdentifier:</code>其中之一的注册方法。  </li>\n<li><strong>根据 autolayout 约束自动计算高度</strong><br>使用了系统在 iOS6 就提供的 API：<code>-systemLayoutSizeFittingSize:</code></li>\n<li><strong>根据 index path 的一套高度缓存机制</strong><br>计算出的高度会自动进行缓存，所以滑动时每个 cell 真正的高度计算只会发生一次，后面的高度询问都会命中缓存，减少了非常可观的多余计算。</li>\n<li><strong>自动的缓存失效机制</strong><br>无须担心你数据源的变化引起的缓存失效，当调用如<code>-reloadData</code>，<code>-deleteRowsAtIndexPaths:withRowAnimation:</code>等任何一个触发 UITableView 刷新机制的方法时，已有的高度缓存将以<strong>最小的代价</strong>执行失效。如删除一个 indexPath 为 [0:5] 的 cell 时，[0:0] ~ [0:4] 的高度缓存不受影响，而 [0:5] 后面所有的缓存值都向前移动一个位置。自动缓存失效机制对 UITableView 的 9 个公有 API 都进行了分别的处理，以保证没有一次多余的高度计算。  </li>\n<li><strong>预缓存机制</strong><br>预缓存机制将在 UITableView 没有滑动的空闲时刻执行，计算和缓存那些还没有显示到屏幕中的 cell，整个缓存过程完全没有感知，这使得完整列表的高度计算既没有发生在加载时，又没有发生在滑动时，同时保证了加载速度和滑动流畅性，下文会着重讲下这块的实现原理。</li>\n</ul>\n<p>我们在设计这个工具的 API 时斟酌了非常长的时间，既要保证功能的强大，也要保证接口的精简，一行调用背后隐藏着很多功能。</p>\n<p>这一套缓存机制能对滑动起多大影响呢？除了肉眼能明显的感知到外，我还做了个小测试：<br>一个有 54 个内容和高度不同 cell 的 table view，从头滑动到尾，再从尾滑动到头，iOS8 系统下，iPhone6，使用 <code>Time Profiler</code> 监测算高函数所花费的时间：  </p>\n<p>未使用缓存API、未使用估算，共花费 877 ms：<br><img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1es7f5l357cj213k0g07eh.jpg\" width=\"640\"></p>\n<p>使用缓存API、开启估算，共花费 77 ms：<br><img src=\"http://ww2.sinaimg.cn/mw690/51530583jw1es7f5lefy3j21440hsgw8.jpg\" width=\"640\"></p>\n<p>测试数据的精度先不管，从量级上就差了一个数量级，说实话自己也没想到差距有这么大- -  </p>\n<p>同时，工具也顺手解决了<code>-preferredMaxLayoutWidth</code>的问题，在计算高度前向 contentView 加了一条和 table view 宽度相同的宽度约束，强行让 contentView 内部的控件知道了自己父 view 的宽度，再反算自己被外界约束的宽度，破除“鸡生蛋蛋生鸡”的问题，这里比较 tricky，就不展开说了。下面说说利用 RunLoop 预缓存的实现。</p>\n<hr>\n<h1 id=\"利用RunLoop空闲时间执行预缓存任务\"><a href=\"#利用RunLoop空闲时间执行预缓存任务\" class=\"headerlink\" title=\"利用RunLoop空闲时间执行预缓存任务\"></a>利用RunLoop空闲时间执行预缓存任务</h1><p>FDTemplateLayoutCell 的高度预缓存是一个优化功能，它要求页面处于<strong>空闲</strong>状态时才执行计算，当用户正在滑动列表时显然不应该执行计算任务影响滑动体验。<br>一般来说，这个功能要耦合 UITableView 的滑动状态才行，但这种实现十分不优雅且可能破坏外部的 delegate 结构，但好在我们还有<code>RunLoop</code>这个工具，了解它的运行机制后，可以用很简单的代码实现上面的功能。  </p>\n<h2 id=\"空闲RunLoopMode\"><a href=\"#空闲RunLoopMode\" class=\"headerlink\" title=\"空闲RunLoopMode\"></a>空闲RunLoopMode</h2><p>在曾经的 RunLoop 线下分享会（<a href=\"http://yun.baidu.com/share/link?shareid=2268593032&amp;uk=2885973690\">视频可戳</a>）中介绍了 RunLoopMode 的概念。<br>当用户正在滑动 UIScrollView 时，RunLoop 将切换到 <code>UITrackingRunLoopMode</code> 接受滑动手势和处理滑动事件（包括减速和弹簧效果），此时，其他 Mode （除 NSRunLoopCommonModes 这个组合 Mode）下的事件将全部暂停执行，来保证滑动事件的优先处理，这也是 iOS 滑动顺畅的重要原因。<br>当 UI 没在滑动时，默认的 Mode 是 <code>NSDefaultRunLoopMode</code>（同 CF 中的 kCFRunLoopDefaultMode），同时也是 CF 中定义的 “空闲状态 Mode”。当用户啥也不点，此时也没有什么网络 IO 时，就是在这个 Mode 下。</p>\n<h2 id=\"用RunLoopObserver找准时机\"><a href=\"#用RunLoopObserver找准时机\" class=\"headerlink\" title=\"用RunLoopObserver找准时机\"></a>用RunLoopObserver找准时机</h2><p>注册 RunLoopObserver 可以观测当前 RunLoop 的运行状态，并在状态机切换时收到通知：  </p>\n<ol>\n<li>RunLoop开始</li>\n<li>RunLoop即将处理Timer</li>\n<li>RunLoop即将处理Source</li>\n<li>RunLoop即将进入休眠状态</li>\n<li>RunLoop即将从休眠状态被事件唤醒</li>\n<li>RunLoop退出</li>\n</ol>\n<p>因为“预缓存高度”的任务需要在最无感知的时刻进行，所以应该同时满足：</p>\n<ol>\n<li>RunLoop 处于“空闲”状态 Mode</li>\n<li>当这一次 RunLoop 迭代处理完成了所有事件，马上要休眠时</li>\n</ol>\n<p>使用 CF 的带 block 版本的注册函数可以让代码更简洁：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> runLoop = <span class=\"built_in\">CFRunLoopGetCurrent</span>();</span><br><span class=\"line\"><span class=\"built_in\">CFStringRef</span> runLoopMode = k<span class=\"built_in\">CFRunLoopDefaultMode</span>;</span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopObserverRef</span> observer = <span class=\"built_in\">CFRunLoopObserverCreateWithHandler</span></span><br><span class=\"line\">(k<span class=\"built_in\">CFAllocatorDefault</span>, k<span class=\"built_in\">CFRunLoopBeforeWaiting</span>, <span class=\"literal\">true</span>, <span class=\"number\">0</span>, ^(<span class=\"built_in\">CFRunLoopObserverRef</span> observer, <span class=\"built_in\">CFRunLoopActivity</span> _) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO here</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopAddObserver</span>(runLoop, observer, runLoopMode);</span><br></pre></td></tr></table></figure>\n<p>在其中的 TODO 位置，就可以开始任务的收集和分发了，当然，不能忘记适时的移除这个 observer  </p>\n<h2 id=\"分解成多个RunLoop-Source任务\"><a href=\"#分解成多个RunLoop-Source任务\" class=\"headerlink\" title=\"分解成多个RunLoop Source任务\"></a>分解成多个RunLoop Source任务</h2><p>假设列表有 20 个 cell，加载后展示了前 5 个，那么开启估算后 table view 只计算了这 5 个的高度，此时剩下 15 个就是“预缓存”的任务，而我们并不希望这 15 个计算任务在同一个 RunLoop 迭代中同步执行，这样会卡顿 UI，所以应该把它们<strong>分别分解</strong>到 15 个 RunLoop 迭代中执行，这时就需要手动向 RunLoop 中添加 Source 任务（由应用发起和处理的是 Source 0 任务）<br>Foundation 层没对 RunLoopSource 提供直接构建的 API，但是提供了一个间接的、既熟悉又陌生的 API：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)performSelector:(SEL)aSelector</span><br><span class=\"line\">               onThread:(<span class=\"built_in\">NSThread</span> *)thr</span><br><span class=\"line\">             withObject:(<span class=\"keyword\">id</span>)arg</span><br><span class=\"line\">          waitUntilDone:(<span class=\"built_in\">BOOL</span>)wait</span><br><span class=\"line\">                  modes:(<span class=\"built_in\">NSArray</span> *)array;</span><br></pre></td></tr></table></figure>\n<p>这个方法将创建一个 Source 0 任务，分发到指定线程的 RunLoop 中，在给定的 Mode 下执行，若指定的 RunLoop 处于休眠状态，则唤醒它处理事件，简单来说就是“睡你xx，起来嗨！”<br>于是，我们用一个可变数组装载当前所有需要“预缓存”的 index path，每个 RunLoopObserver 回调时都把第一个任务拿出来分发:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *mutableIndexPathsToBePrecached = <span class=\"keyword\">self</span>.fd_allIndexPathsToBePrecached.mutableCopy;</span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopObserverRef</span> observer = <span class=\"built_in\">CFRunLoopObserverCreateWithHandler</span>(k<span class=\"built_in\">CFAllocatorDefault</span>, k<span class=\"built_in\">CFRunLoopBeforeWaiting</span>, <span class=\"literal\">true</span>, <span class=\"number\">0</span>, ^(<span class=\"built_in\">CFRunLoopObserverRef</span> observer, <span class=\"built_in\">CFRunLoopActivity</span> _) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mutableIndexPathsToBePrecached.count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CFRunLoopRemoveObserver</span>(runLoop, observer, runLoopMode);</span><br><span class=\"line\">        <span class=\"built_in\">CFRelease</span>(observer); <span class=\"comment\">// 注意释放，否则会造成内存泄露</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSIndexPath</span> *indexPath = mutableIndexPathsToBePrecached.firstObject;</span><br><span class=\"line\">    [mutableIndexPathsToBePrecached removeObject:indexPath];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(fd_precacheIndexPathIfNeeded:)</span><br><span class=\"line\">                 onThread:[<span class=\"built_in\">NSThread</span> mainThread]</span><br><span class=\"line\">               withObject:indexPath</span><br><span class=\"line\">            waitUntilDone:<span class=\"literal\">NO</span></span><br><span class=\"line\">                    modes:@[<span class=\"built_in\">NSDefaultRunLoopMode</span>]];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这样，每个任务都被分配到下个“空闲” RunLoop 迭代中执行，其间但凡有滑动事件开始，Mode 切换成 UITrackingRunLoopMode，所有的“预缓存”任务的分发和执行都会自动暂定，最大程度保证滑动流畅。  </p>\n<p>PS: 预缓存功能因为下拉刷新的冲突和不明显的收益已经废弃</p>\n<hr>\n<h1 id=\"开始使用UITableView-FDTemplateLayoutCell\"><a href=\"#开始使用UITableView-FDTemplateLayoutCell\" class=\"headerlink\" title=\"开始使用UITableView+FDTemplateLayoutCell\"></a>开始使用UITableView+FDTemplateLayoutCell</h1><p>如果你觉得这个工具能帮得到你，整合到工程也十分简单。<br>使用 cocoapods：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod search UITableView+FDTemplateLayoutCell</span><br></pre></td></tr></table></figure>\n<p>写这篇文章时的最新版本为 1.2，去除了前一个版本的黑魔法，增加了预缓存功能。<br>欢迎使用和支持这个工具，有 bug 请随时反馈哦~<br>再复习下 github 地址： <a href=\"https://github.com/forkingdog/UITableView-FDTemplateLayoutCell\">https://github.com/forkingdog/UITableView-FDTemplateLayoutCell</a>  </p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/219689/7244961/4209de32-e816-11e4-87bc-b161c442d348.png\" width=\"640\"></p>\n"},{"title":"Objective-C 类依赖注入与组件化架构空想","date":"2016-03-29T08:49:50.000Z","_content":"\n## 我是前言\n\n![](http://ww1.sinaimg.cn/large/51530583jw1f2e305fh99j20gz0bjdh9.jpg)\n\n写这篇博客的时候，正好听了半天万物发展、“递弱代偿”的讲解，借机扯一扯：\n\n1. 从原子电子到元素和分子、再从有机物到高级生命，万物都由简单向复杂发展。\n2. 各司其职的小部件组成细胞，各司其职的细胞组成器官，各司其职的器官组成一个人，各司其职的人们组成这个社会，复杂的事物都由特定功能的组件按一定架构构成。\n3. 低级的细菌给点营养就能活，再看现在的人没网都能半死，越高度演化的东西结构越复杂，但存在性反而越差，只能靠更多的外部依赖才能存活。\n\n细想这些道理，和软件设计似乎也有蛮多共通之处。\n零散的功能代码在过程封装的思想下成了 Function，Function 在面向对象思想下的成了 Class，Class 在设计模式的指导下成了 Module，各个 Module 在组件化架构的指导下构成了一个 App。最近各位老师一直在讨论的组件化架构问题，正是 App 复杂度到了一定程度后，陈旧结构的退化、拆散、重新组合成更复杂结构的过程。但随着系统的庞大、分工的细致，必将带来存在性的减弱，要引入更多外部依赖代为偿还，有时一个依赖库编译失败、人为失误、流程错误、甚至负责打包的机器出了问题，都可能造成整个部门运转的瘫痪。所以一个架构师的挑战不仅仅是想出个组件化实现，更要维持这个大规模代码、人员构成的复杂系统的稳定运转。\n乍一看是不是很高大上，但其实本身也没当过架构师，大多只是空想而已，受最近老师们讨论的启发，产生了自己的一些想法，加上一些对 Objective-C Runtime 机制和小黑魔法的了解，利用依赖注入的思路，简单怼出来了套实现，下面分享一下。\n\n## Objective-C 中依赖的本质\n\n所谓组件化终归到底都是在处理**依赖**问题，将以往的：\n\n``` objc\n#import \"FDLogger/FDLogger.h\"\n```\n\n## 我心目中的组件化架构\n\n1. 自然的调用方式。\n2. 低侵入的接入\n","source":"_posts/class-dependency-injection-and-architecture.md","raw":"---\ntitle: Objective-C 类依赖注入与组件化架构空想\ndate: 2016-03-29 16:49:50\ntags:\n---\n\n## 我是前言\n\n![](http://ww1.sinaimg.cn/large/51530583jw1f2e305fh99j20gz0bjdh9.jpg)\n\n写这篇博客的时候，正好听了半天万物发展、“递弱代偿”的讲解，借机扯一扯：\n\n1. 从原子电子到元素和分子、再从有机物到高级生命，万物都由简单向复杂发展。\n2. 各司其职的小部件组成细胞，各司其职的细胞组成器官，各司其职的器官组成一个人，各司其职的人们组成这个社会，复杂的事物都由特定功能的组件按一定架构构成。\n3. 低级的细菌给点营养就能活，再看现在的人没网都能半死，越高度演化的东西结构越复杂，但存在性反而越差，只能靠更多的外部依赖才能存活。\n\n细想这些道理，和软件设计似乎也有蛮多共通之处。\n零散的功能代码在过程封装的思想下成了 Function，Function 在面向对象思想下的成了 Class，Class 在设计模式的指导下成了 Module，各个 Module 在组件化架构的指导下构成了一个 App。最近各位老师一直在讨论的组件化架构问题，正是 App 复杂度到了一定程度后，陈旧结构的退化、拆散、重新组合成更复杂结构的过程。但随着系统的庞大、分工的细致，必将带来存在性的减弱，要引入更多外部依赖代为偿还，有时一个依赖库编译失败、人为失误、流程错误、甚至负责打包的机器出了问题，都可能造成整个部门运转的瘫痪。所以一个架构师的挑战不仅仅是想出个组件化实现，更要维持这个大规模代码、人员构成的复杂系统的稳定运转。\n乍一看是不是很高大上，但其实本身也没当过架构师，大多只是空想而已，受最近老师们讨论的启发，产生了自己的一些想法，加上一些对 Objective-C Runtime 机制和小黑魔法的了解，利用依赖注入的思路，简单怼出来了套实现，下面分享一下。\n\n## Objective-C 中依赖的本质\n\n所谓组件化终归到底都是在处理**依赖**问题，将以往的：\n\n``` objc\n#import \"FDLogger/FDLogger.h\"\n```\n\n## 我心目中的组件化架构\n\n1. 自然的调用方式。\n2. 低侵入的接入\n","slug":"class-dependency-injection-and-architecture","published":1,"updated":"2016-03-30T05:48:25.000Z","_id":"cimd6pxjp0004ev12flt3x2vc","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h2><p><img src=\"http://ww1.sinaimg.cn/large/51530583jw1f2e305fh99j20gz0bjdh9.jpg\" alt=\"\"></p>\n<p>写这篇博客的时候，正好听了半天万物发展、“递弱代偿”的讲解，借机扯一扯：</p>\n<ol>\n<li>从原子电子到元素和分子、再从有机物到高级生命，万物都由简单向复杂发展。</li>\n<li>各司其职的小部件组成细胞，各司其职的细胞组成器官，各司其职的器官组成一个人，各司其职的人们组成这个社会，复杂的事物都由特定功能的组件按一定架构构成。</li>\n<li>低级的细菌给点营养就能活，再看现在的人没网都能半死，越高度演化的东西结构越复杂，但存在性反而越差，只能靠更多的外部依赖才能存活。</li>\n</ol>\n<p>细想这些道理，和软件设计似乎也有蛮多共通之处。<br>零散的功能代码在过程封装的思想下成了 Function，Function 在面向对象思想下的成了 Class，Class 在设计模式的指导下成了 Module，各个 Module 在组件化架构的指导下构成了一个 App。最近各位老师一直在讨论的组件化架构问题，正是 App 复杂度到了一定程度后，陈旧结构的退化、拆散、重新组合成更复杂结构的过程。但随着系统的庞大、分工的细致，必将带来存在性的减弱，要引入更多外部依赖代为偿还，有时一个依赖库编译失败、人为失误、流程错误、甚至负责打包的机器出了问题，都可能造成整个部门运转的瘫痪。所以一个架构师的挑战不仅仅是想出个组件化实现，更要维持这个大规模代码、人员构成的复杂系统的稳定运转。<br>乍一看是不是很高大上，但其实本身也没当过架构师，大多只是空想而已，受最近老师们讨论的启发，产生了自己的一些想法，加上一些对 Objective-C Runtime 机制和小黑魔法的了解，利用依赖注入的思路，简单怼出来了套实现，下面分享一下。</p>\n<h2 id=\"Objective-C-中依赖的本质\"><a href=\"#Objective-C-中依赖的本质\" class=\"headerlink\" title=\"Objective-C 中依赖的本质\"></a>Objective-C 中依赖的本质</h2><p>所谓组件化终归到底都是在处理<strong>依赖</strong>问题，将以往的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"FDLogger/FDLogger.h\"</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"我心目中的组件化架构\"><a href=\"#我心目中的组件化架构\" class=\"headerlink\" title=\"我心目中的组件化架构\"></a>我心目中的组件化架构</h2><ol>\n<li>自然的调用方式。</li>\n<li>低侵入的接入</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h2><p><img src=\"http://ww1.sinaimg.cn/large/51530583jw1f2e305fh99j20gz0bjdh9.jpg\" alt=\"\"></p>\n<p>写这篇博客的时候，正好听了半天万物发展、“递弱代偿”的讲解，借机扯一扯：</p>\n<ol>\n<li>从原子电子到元素和分子、再从有机物到高级生命，万物都由简单向复杂发展。</li>\n<li>各司其职的小部件组成细胞，各司其职的细胞组成器官，各司其职的器官组成一个人，各司其职的人们组成这个社会，复杂的事物都由特定功能的组件按一定架构构成。</li>\n<li>低级的细菌给点营养就能活，再看现在的人没网都能半死，越高度演化的东西结构越复杂，但存在性反而越差，只能靠更多的外部依赖才能存活。</li>\n</ol>\n<p>细想这些道理，和软件设计似乎也有蛮多共通之处。<br>零散的功能代码在过程封装的思想下成了 Function，Function 在面向对象思想下的成了 Class，Class 在设计模式的指导下成了 Module，各个 Module 在组件化架构的指导下构成了一个 App。最近各位老师一直在讨论的组件化架构问题，正是 App 复杂度到了一定程度后，陈旧结构的退化、拆散、重新组合成更复杂结构的过程。但随着系统的庞大、分工的细致，必将带来存在性的减弱，要引入更多外部依赖代为偿还，有时一个依赖库编译失败、人为失误、流程错误、甚至负责打包的机器出了问题，都可能造成整个部门运转的瘫痪。所以一个架构师的挑战不仅仅是想出个组件化实现，更要维持这个大规模代码、人员构成的复杂系统的稳定运转。<br>乍一看是不是很高大上，但其实本身也没当过架构师，大多只是空想而已，受最近老师们讨论的启发，产生了自己的一些想法，加上一些对 Objective-C Runtime 机制和小黑魔法的了解，利用依赖注入的思路，简单怼出来了套实现，下面分享一下。</p>\n<h2 id=\"Objective-C-中依赖的本质\"><a href=\"#Objective-C-中依赖的本质\" class=\"headerlink\" title=\"Objective-C 中依赖的本质\"></a>Objective-C 中依赖的本质</h2><p>所谓组件化终归到底都是在处理<strong>依赖</strong>问题，将以往的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"FDLogger/FDLogger.h\"</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"我心目中的组件化架构\"><a href=\"#我心目中的组件化架构\" class=\"headerlink\" title=\"我心目中的组件化架构\"></a>我心目中的组件化架构</h2><ol>\n<li>自然的调用方式。</li>\n<li>低侵入的接入</li>\n</ol>\n"},{"title":"从NSArray看类簇","date":"2014-12-18T14:22:22.000Z","_content":"\n# Class Clusters\n\nClass Clusters（类簇）是`抽象工厂`模式在iOS下的一种实现，众多常用类，如`NSString`，`NSArray`，`NSDictionary`，`NSNumber`都运作在这一模式下，它是接口简单性和扩展性的权衡体现，在我们完全不知情的情况下，偷偷隐藏了很多具体的实现类，只暴露出简单的接口。\n\n# NSArray的类簇\n\n虽然[官方文档](https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html)中拿`NSNumber`说事儿，但Foundation并没有像图中描述的那样为每个number都弄一个子类，于是研究下`NSArray`类簇的实现方式。  \n\n## __NSPlacehodlerArray\n\n熟悉这个模式的同学很可能看过下面的测试代码，将原有的`alloc+init`拆开写：  \n\n``` objc\nid obj1 = [NSArray alloc]; // __NSPlacehodlerArray *\nid obj2 = [NSMutableArray alloc];  // __NSPlacehodlerArray *\nid obj3 = [obj1 init];  // __NSArrayI *\nid obj4 = [obj2 init];  // __NSArrayM *\n```\n\n发现`+ alloc`后并非生成了我们期望的类实例，而是一个`__NSPlacehodlerArray`的中间对象，后面的`- init`或`- initWithXXXXX`消息都是发送给这个中间对象，再由它做工厂，生成真的对象。这里的`__NSArrayI`和`__NSArrayM`分别对应Immutable和Mutable（后面的I和M的意思）\n\n于是顺着思路猜实现，`__NSPlacehodlerArray`必定用某种方式存储了**它是由谁alloc出来的**这个信息，才能在`init`的时候知道要创建的是可变数组还是不可变数组\n\n于是乎很开心的去看了下`*obj1`的内存布局：  \n\n<img src=\"http://ww4.sinaimg.cn/large/51530583jw1em3doxs660j20l80j6go3.jpg\" width=\"404\">\n\n下面是32位模拟器中的内存布局（64位太长不好看就临时改32位了- -），第一个箭头是`*obj1`，第二个是`*obj2`\n\n<img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1em3dvmuuanj213006maf2.jpg\" width=\"404\">\n\n我们知道，对象的前4字节（32位下）为isa指针，指向类对象地址，上图所示的`0x0051E768`就是`__NSPlacehodlerArray`类对象地址，可以从lldb下`po`这个地址来验证。\n\n那么问题来了，这个中间对象并没有储存任何信息诶（除了isa外就都是0了），那它init的时候咋知道该创建什么呢？    \n经过研究发现，Foundation用了一个很贱的比较静态实例地址方式来实现，伪代码如下：\n\n``` objc\nstatic __NSPlacehodlerArray *GetPlaceholderForNSArray() {\n    static __NSPlacehodlerArray *instanceForNSArray;\n    if (!instanceForNSArray) {\n        instanceForNSArray = [[__NSPlacehodlerArray alloc] init];\n    }\n    return instanceForNSArray;\n}\n\nstatic __NSPlacehodlerArray *GetPlaceholderForNSMutableArray() {\n    static __NSPlacehodlerArray *instanceForNSMutableArray;\n    if (!instanceForNSMutableArray) {\n        instanceForNSMutableArray = [[__NSPlacehodlerArray alloc] init];\n    }\n    return instanceForNSMutableArray;\n}\n// NSArray实现\n+ (id)alloc {\n    if (self == [NSArray class]) {\n        return GetPlaceholderForNSArray()\n    }\n}\n// NSMutableArray实现\n+ (id)alloc {\n    if (self == [NSMutableArray class]) {\n        return GetPlaceholderForNSMutableArray()\n    }\n}\n// __NSPlacehodlerArray实现\n- (id)init {\n    if (self == GetPlaceholderForNSArray()) {\n        self = [[__NSArrayI alloc] init];\n    }\n    else if (self == GetPlaceholderForNSMutableArray()) {\n        self = [[__NSArrayM alloc] init];\n    }\n    return self;\n}\n```\n\nFoundation不是开源的，所以上面的代码是猜测的，思路大概就是这样，可以这样验证下：\n\n``` objc\nid obj1 = [NSArray alloc];\nid obj2 = [NSArray alloc];\nid obj3 = [NSMutableArray alloc];\nid obj4 = [NSMutableArray alloc];\n// 1和2地址相同，3和4地址相同，无论多少次都相同，且地址相差16位\n```\n\n# 静态不可变空对象\n\n除此之外，Foundation对`不可变`版本的空数组也做了个小优化：  \n\n``` objc\nNSArray *arr1 = [[NSArray alloc] init];\nNSArray *arr2 = [[NSArray alloc] init];\nNSArray *arr3 = @[];\nNSArray *arr4 = @[];\nNSArray *arr5 = @[@1];\n```  \n\n上边1-4号都指向了同一个对象，而arr5指向了另一个对象。  \n若干个不可变的空数组间没有任何特异性，返回一个静态对象也理所应当。  \n不仅是NSArray，Foundation中如`NSString`, `NSDictionary`, `NSSet`等区分可变和不可变版本的类，空实例都是静态对象（NSString的空实例对象是常量区的`@\"\"`）  \n\n所以也给用这些方法来测试对象内存管理的同学提个醒，很容易意料之外的。\n\n# References\n\nhttps://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html\nhttp://iphonedevwiki.net/index.php/Foundation.framework/Inheritance_hierarchy\n","source":"_posts/class-cluster.md","raw":"title: 从NSArray看类簇\ndate: 2014-12-18 22:22:22\ntags: objc刨根问底\n---\n\n# Class Clusters\n\nClass Clusters（类簇）是`抽象工厂`模式在iOS下的一种实现，众多常用类，如`NSString`，`NSArray`，`NSDictionary`，`NSNumber`都运作在这一模式下，它是接口简单性和扩展性的权衡体现，在我们完全不知情的情况下，偷偷隐藏了很多具体的实现类，只暴露出简单的接口。\n\n# NSArray的类簇\n\n虽然[官方文档](https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html)中拿`NSNumber`说事儿，但Foundation并没有像图中描述的那样为每个number都弄一个子类，于是研究下`NSArray`类簇的实现方式。  \n\n## __NSPlacehodlerArray\n\n熟悉这个模式的同学很可能看过下面的测试代码，将原有的`alloc+init`拆开写：  \n\n``` objc\nid obj1 = [NSArray alloc]; // __NSPlacehodlerArray *\nid obj2 = [NSMutableArray alloc];  // __NSPlacehodlerArray *\nid obj3 = [obj1 init];  // __NSArrayI *\nid obj4 = [obj2 init];  // __NSArrayM *\n```\n\n发现`+ alloc`后并非生成了我们期望的类实例，而是一个`__NSPlacehodlerArray`的中间对象，后面的`- init`或`- initWithXXXXX`消息都是发送给这个中间对象，再由它做工厂，生成真的对象。这里的`__NSArrayI`和`__NSArrayM`分别对应Immutable和Mutable（后面的I和M的意思）\n\n于是顺着思路猜实现，`__NSPlacehodlerArray`必定用某种方式存储了**它是由谁alloc出来的**这个信息，才能在`init`的时候知道要创建的是可变数组还是不可变数组\n\n于是乎很开心的去看了下`*obj1`的内存布局：  \n\n<img src=\"http://ww4.sinaimg.cn/large/51530583jw1em3doxs660j20l80j6go3.jpg\" width=\"404\">\n\n下面是32位模拟器中的内存布局（64位太长不好看就临时改32位了- -），第一个箭头是`*obj1`，第二个是`*obj2`\n\n<img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1em3dvmuuanj213006maf2.jpg\" width=\"404\">\n\n我们知道，对象的前4字节（32位下）为isa指针，指向类对象地址，上图所示的`0x0051E768`就是`__NSPlacehodlerArray`类对象地址，可以从lldb下`po`这个地址来验证。\n\n那么问题来了，这个中间对象并没有储存任何信息诶（除了isa外就都是0了），那它init的时候咋知道该创建什么呢？    \n经过研究发现，Foundation用了一个很贱的比较静态实例地址方式来实现，伪代码如下：\n\n``` objc\nstatic __NSPlacehodlerArray *GetPlaceholderForNSArray() {\n    static __NSPlacehodlerArray *instanceForNSArray;\n    if (!instanceForNSArray) {\n        instanceForNSArray = [[__NSPlacehodlerArray alloc] init];\n    }\n    return instanceForNSArray;\n}\n\nstatic __NSPlacehodlerArray *GetPlaceholderForNSMutableArray() {\n    static __NSPlacehodlerArray *instanceForNSMutableArray;\n    if (!instanceForNSMutableArray) {\n        instanceForNSMutableArray = [[__NSPlacehodlerArray alloc] init];\n    }\n    return instanceForNSMutableArray;\n}\n// NSArray实现\n+ (id)alloc {\n    if (self == [NSArray class]) {\n        return GetPlaceholderForNSArray()\n    }\n}\n// NSMutableArray实现\n+ (id)alloc {\n    if (self == [NSMutableArray class]) {\n        return GetPlaceholderForNSMutableArray()\n    }\n}\n// __NSPlacehodlerArray实现\n- (id)init {\n    if (self == GetPlaceholderForNSArray()) {\n        self = [[__NSArrayI alloc] init];\n    }\n    else if (self == GetPlaceholderForNSMutableArray()) {\n        self = [[__NSArrayM alloc] init];\n    }\n    return self;\n}\n```\n\nFoundation不是开源的，所以上面的代码是猜测的，思路大概就是这样，可以这样验证下：\n\n``` objc\nid obj1 = [NSArray alloc];\nid obj2 = [NSArray alloc];\nid obj3 = [NSMutableArray alloc];\nid obj4 = [NSMutableArray alloc];\n// 1和2地址相同，3和4地址相同，无论多少次都相同，且地址相差16位\n```\n\n# 静态不可变空对象\n\n除此之外，Foundation对`不可变`版本的空数组也做了个小优化：  \n\n``` objc\nNSArray *arr1 = [[NSArray alloc] init];\nNSArray *arr2 = [[NSArray alloc] init];\nNSArray *arr3 = @[];\nNSArray *arr4 = @[];\nNSArray *arr5 = @[@1];\n```  \n\n上边1-4号都指向了同一个对象，而arr5指向了另一个对象。  \n若干个不可变的空数组间没有任何特异性，返回一个静态对象也理所应当。  \n不仅是NSArray，Foundation中如`NSString`, `NSDictionary`, `NSSet`等区分可变和不可变版本的类，空实例都是静态对象（NSString的空实例对象是常量区的`@\"\"`）  \n\n所以也给用这些方法来测试对象内存管理的同学提个醒，很容易意料之外的。\n\n# References\n\nhttps://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html\nhttp://iphonedevwiki.net/index.php/Foundation.framework/Inheritance_hierarchy\n","slug":"class-cluster","published":1,"updated":"2016-03-27T07:51:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxjs0006ev12oj9ya2gt","content":"<h1 id=\"Class-Clusters\"><a href=\"#Class-Clusters\" class=\"headerlink\" title=\"Class Clusters\"></a>Class Clusters</h1><p>Class Clusters（类簇）是<code>抽象工厂</code>模式在iOS下的一种实现，众多常用类，如<code>NSString</code>，<code>NSArray</code>，<code>NSDictionary</code>，<code>NSNumber</code>都运作在这一模式下，它是接口简单性和扩展性的权衡体现，在我们完全不知情的情况下，偷偷隐藏了很多具体的实现类，只暴露出简单的接口。</p>\n<h1 id=\"NSArray的类簇\"><a href=\"#NSArray的类簇\" class=\"headerlink\" title=\"NSArray的类簇\"></a>NSArray的类簇</h1><p>虽然<a href=\"https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html\" target=\"_blank\" rel=\"external\">官方文档</a>中拿<code>NSNumber</code>说事儿，但Foundation并没有像图中描述的那样为每个number都弄一个子类，于是研究下<code>NSArray</code>类簇的实现方式。  </p>\n<h2 id=\"NSPlacehodlerArray\"><a href=\"#NSPlacehodlerArray\" class=\"headerlink\" title=\"__NSPlacehodlerArray\"></a>__NSPlacehodlerArray</h2><p>熟悉这个模式的同学很可能看过下面的测试代码，将原有的<code>alloc+init</code>拆开写：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> obj1 = [<span class=\"built_in\">NSArray</span> alloc]; <span class=\"comment\">// __NSPlacehodlerArray *</span></span><br><span class=\"line\"><span class=\"keyword\">id</span> obj2 = [<span class=\"built_in\">NSMutableArray</span> alloc];  <span class=\"comment\">// __NSPlacehodlerArray *</span></span><br><span class=\"line\"><span class=\"keyword\">id</span> obj3 = [obj1 init];  <span class=\"comment\">// __NSArrayI *</span></span><br><span class=\"line\"><span class=\"keyword\">id</span> obj4 = [obj2 init];  <span class=\"comment\">// __NSArrayM *</span></span><br></pre></td></tr></table></figure>\n<p>发现<code>+ alloc</code>后并非生成了我们期望的类实例，而是一个<code>__NSPlacehodlerArray</code>的中间对象，后面的<code>- init</code>或<code>- initWithXXXXX</code>消息都是发送给这个中间对象，再由它做工厂，生成真的对象。这里的<code>__NSArrayI</code>和<code>__NSArrayM</code>分别对应Immutable和Mutable（后面的I和M的意思）</p>\n<p>于是顺着思路猜实现，<code>__NSPlacehodlerArray</code>必定用某种方式存储了<strong>它是由谁alloc出来的</strong>这个信息，才能在<code>init</code>的时候知道要创建的是可变数组还是不可变数组</p>\n<p>于是乎很开心的去看了下<code>*obj1</code>的内存布局：  </p>\n<p><img src=\"http://ww4.sinaimg.cn/large/51530583jw1em3doxs660j20l80j6go3.jpg\" width=\"404\"></p>\n<p>下面是32位模拟器中的内存布局（64位太长不好看就临时改32位了- -），第一个箭头是<code>*obj1</code>，第二个是<code>*obj2</code></p>\n<p><img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1em3dvmuuanj213006maf2.jpg\" width=\"404\"></p>\n<p>我们知道，对象的前4字节（32位下）为isa指针，指向类对象地址，上图所示的<code>0x0051E768</code>就是<code>__NSPlacehodlerArray</code>类对象地址，可以从lldb下<code>po</code>这个地址来验证。</p>\n<p>那么问题来了，这个中间对象并没有储存任何信息诶（除了isa外就都是0了），那它init的时候咋知道该创建什么呢？<br>经过研究发现，Foundation用了一个很贱的比较静态实例地址方式来实现，伪代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> __<span class=\"built_in\">NSPlacehodlerArray</span> *GetPlaceholderFor<span class=\"built_in\">NSArray</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> __<span class=\"built_in\">NSPlacehodlerArray</span> *instanceFor<span class=\"built_in\">NSArray</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instanceFor<span class=\"built_in\">NSArray</span>) &#123;</span><br><span class=\"line\">        instanceFor<span class=\"built_in\">NSArray</span> = [[__<span class=\"built_in\">NSPlacehodlerArray</span> alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instanceFor<span class=\"built_in\">NSArray</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> __<span class=\"built_in\">NSPlacehodlerArray</span> *GetPlaceholderFor<span class=\"built_in\">NSMutableArray</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> __<span class=\"built_in\">NSPlacehodlerArray</span> *instanceFor<span class=\"built_in\">NSMutableArray</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instanceFor<span class=\"built_in\">NSMutableArray</span>) &#123;</span><br><span class=\"line\">        instanceFor<span class=\"built_in\">NSMutableArray</span> = [[__<span class=\"built_in\">NSPlacehodlerArray</span> alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instanceFor<span class=\"built_in\">NSMutableArray</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// NSArray实现</span></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)alloc &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> == [<span class=\"built_in\">NSArray</span> class]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> GetPlaceholderFor<span class=\"built_in\">NSArray</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// NSMutableArray实现</span></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)alloc &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> == [<span class=\"built_in\">NSMutableArray</span> class]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> GetPlaceholderFor<span class=\"built_in\">NSMutableArray</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// __NSPlacehodlerArray实现</span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> == GetPlaceholderFor<span class=\"built_in\">NSArray</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span> = [[__<span class=\"built_in\">NSArrayI</span> alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> == GetPlaceholderFor<span class=\"built_in\">NSMutableArray</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span> = [[__<span class=\"built_in\">NSArrayM</span> alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Foundation不是开源的，所以上面的代码是猜测的，思路大概就是这样，可以这样验证下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> obj1 = [<span class=\"built_in\">NSArray</span> alloc];</span><br><span class=\"line\"><span class=\"keyword\">id</span> obj2 = [<span class=\"built_in\">NSArray</span> alloc];</span><br><span class=\"line\"><span class=\"keyword\">id</span> obj3 = [<span class=\"built_in\">NSMutableArray</span> alloc];</span><br><span class=\"line\"><span class=\"keyword\">id</span> obj4 = [<span class=\"built_in\">NSMutableArray</span> alloc];</span><br><span class=\"line\"><span class=\"comment\">// 1和2地址相同，3和4地址相同，无论多少次都相同，且地址相差16位</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"静态不可变空对象\"><a href=\"#静态不可变空对象\" class=\"headerlink\" title=\"静态不可变空对象\"></a>静态不可变空对象</h1><p>除此之外，Foundation对<code>不可变</code>版本的空数组也做了个小优化：  </p>\n<pre><code class=\"objc\"><span class=\"built_in\">NSArray</span> *arr1 = [[<span class=\"built_in\">NSArray</span> alloc] init];\n<span class=\"built_in\">NSArray</span> *arr2 = [[<span class=\"built_in\">NSArray</span> alloc] init];\n<span class=\"built_in\">NSArray</span> *arr3 = @[];\n<span class=\"built_in\">NSArray</span> *arr4 = @[];\n<span class=\"built_in\">NSArray</span> *arr5 = @[@<span class=\"number\">1</span>];\n</code></pre>\n<p>上边1-4号都指向了同一个对象，而arr5指向了另一个对象。<br>若干个不可变的空数组间没有任何特异性，返回一个静态对象也理所应当。<br>不仅是NSArray，Foundation中如<code>NSString</code>, <code>NSDictionary</code>, <code>NSSet</code>等区分可变和不可变版本的类，空实例都是静态对象（NSString的空实例对象是常量区的<code>@&quot;&quot;</code>）  </p>\n<p>所以也给用这些方法来测试对象内存管理的同学提个醒，很容易意料之外的。</p>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html\" target=\"_blank\" rel=\"external\">https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html</a><br><a href=\"http://iphonedevwiki.net/index.php/Foundation.framework/Inheritance_hierarchy\" target=\"_blank\" rel=\"external\">http://iphonedevwiki.net/index.php/Foundation.framework/Inheritance_hierarchy</a></p>\n","excerpt":"","more":"<h1 id=\"Class-Clusters\"><a href=\"#Class-Clusters\" class=\"headerlink\" title=\"Class Clusters\"></a>Class Clusters</h1><p>Class Clusters（类簇）是<code>抽象工厂</code>模式在iOS下的一种实现，众多常用类，如<code>NSString</code>，<code>NSArray</code>，<code>NSDictionary</code>，<code>NSNumber</code>都运作在这一模式下，它是接口简单性和扩展性的权衡体现，在我们完全不知情的情况下，偷偷隐藏了很多具体的实现类，只暴露出简单的接口。</p>\n<h1 id=\"NSArray的类簇\"><a href=\"#NSArray的类簇\" class=\"headerlink\" title=\"NSArray的类簇\"></a>NSArray的类簇</h1><p>虽然<a href=\"https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html\">官方文档</a>中拿<code>NSNumber</code>说事儿，但Foundation并没有像图中描述的那样为每个number都弄一个子类，于是研究下<code>NSArray</code>类簇的实现方式。  </p>\n<h2 id=\"NSPlacehodlerArray\"><a href=\"#NSPlacehodlerArray\" class=\"headerlink\" title=\"__NSPlacehodlerArray\"></a>__NSPlacehodlerArray</h2><p>熟悉这个模式的同学很可能看过下面的测试代码，将原有的<code>alloc+init</code>拆开写：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> obj1 = [<span class=\"built_in\">NSArray</span> alloc]; <span class=\"comment\">// __NSPlacehodlerArray *</span></span><br><span class=\"line\"><span class=\"keyword\">id</span> obj2 = [<span class=\"built_in\">NSMutableArray</span> alloc];  <span class=\"comment\">// __NSPlacehodlerArray *</span></span><br><span class=\"line\"><span class=\"keyword\">id</span> obj3 = [obj1 init];  <span class=\"comment\">// __NSArrayI *</span></span><br><span class=\"line\"><span class=\"keyword\">id</span> obj4 = [obj2 init];  <span class=\"comment\">// __NSArrayM *</span></span><br></pre></td></tr></table></figure>\n<p>发现<code>+ alloc</code>后并非生成了我们期望的类实例，而是一个<code>__NSPlacehodlerArray</code>的中间对象，后面的<code>- init</code>或<code>- initWithXXXXX</code>消息都是发送给这个中间对象，再由它做工厂，生成真的对象。这里的<code>__NSArrayI</code>和<code>__NSArrayM</code>分别对应Immutable和Mutable（后面的I和M的意思）</p>\n<p>于是顺着思路猜实现，<code>__NSPlacehodlerArray</code>必定用某种方式存储了<strong>它是由谁alloc出来的</strong>这个信息，才能在<code>init</code>的时候知道要创建的是可变数组还是不可变数组</p>\n<p>于是乎很开心的去看了下<code>*obj1</code>的内存布局：  </p>\n<p><img src=\"http://ww4.sinaimg.cn/large/51530583jw1em3doxs660j20l80j6go3.jpg\" width=\"404\"></p>\n<p>下面是32位模拟器中的内存布局（64位太长不好看就临时改32位了- -），第一个箭头是<code>*obj1</code>，第二个是<code>*obj2</code></p>\n<p><img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1em3dvmuuanj213006maf2.jpg\" width=\"404\"></p>\n<p>我们知道，对象的前4字节（32位下）为isa指针，指向类对象地址，上图所示的<code>0x0051E768</code>就是<code>__NSPlacehodlerArray</code>类对象地址，可以从lldb下<code>po</code>这个地址来验证。</p>\n<p>那么问题来了，这个中间对象并没有储存任何信息诶（除了isa外就都是0了），那它init的时候咋知道该创建什么呢？<br>经过研究发现，Foundation用了一个很贱的比较静态实例地址方式来实现，伪代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> __<span class=\"built_in\">NSPlacehodlerArray</span> *GetPlaceholderFor<span class=\"built_in\">NSArray</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> __<span class=\"built_in\">NSPlacehodlerArray</span> *instanceFor<span class=\"built_in\">NSArray</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instanceFor<span class=\"built_in\">NSArray</span>) &#123;</span><br><span class=\"line\">        instanceFor<span class=\"built_in\">NSArray</span> = [[__<span class=\"built_in\">NSPlacehodlerArray</span> alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instanceFor<span class=\"built_in\">NSArray</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> __<span class=\"built_in\">NSPlacehodlerArray</span> *GetPlaceholderFor<span class=\"built_in\">NSMutableArray</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> __<span class=\"built_in\">NSPlacehodlerArray</span> *instanceFor<span class=\"built_in\">NSMutableArray</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instanceFor<span class=\"built_in\">NSMutableArray</span>) &#123;</span><br><span class=\"line\">        instanceFor<span class=\"built_in\">NSMutableArray</span> = [[__<span class=\"built_in\">NSPlacehodlerArray</span> alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instanceFor<span class=\"built_in\">NSMutableArray</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// NSArray实现</span></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)alloc &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> == [<span class=\"built_in\">NSArray</span> class]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> GetPlaceholderFor<span class=\"built_in\">NSArray</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// NSMutableArray实现</span></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)alloc &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> == [<span class=\"built_in\">NSMutableArray</span> class]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> GetPlaceholderFor<span class=\"built_in\">NSMutableArray</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// __NSPlacehodlerArray实现</span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> == GetPlaceholderFor<span class=\"built_in\">NSArray</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span> = [[__<span class=\"built_in\">NSArrayI</span> alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> == GetPlaceholderFor<span class=\"built_in\">NSMutableArray</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span> = [[__<span class=\"built_in\">NSArrayM</span> alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Foundation不是开源的，所以上面的代码是猜测的，思路大概就是这样，可以这样验证下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> obj1 = [<span class=\"built_in\">NSArray</span> alloc];</span><br><span class=\"line\"><span class=\"keyword\">id</span> obj2 = [<span class=\"built_in\">NSArray</span> alloc];</span><br><span class=\"line\"><span class=\"keyword\">id</span> obj3 = [<span class=\"built_in\">NSMutableArray</span> alloc];</span><br><span class=\"line\"><span class=\"keyword\">id</span> obj4 = [<span class=\"built_in\">NSMutableArray</span> alloc];</span><br><span class=\"line\"><span class=\"comment\">// 1和2地址相同，3和4地址相同，无论多少次都相同，且地址相差16位</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"静态不可变空对象\"><a href=\"#静态不可变空对象\" class=\"headerlink\" title=\"静态不可变空对象\"></a>静态不可变空对象</h1><p>除此之外，Foundation对<code>不可变</code>版本的空数组也做了个小优化：  </p>\n<pre><code class=\"objc\"><span class=\"built_in\">NSArray</span> *arr1 = [[<span class=\"built_in\">NSArray</span> alloc] init];\n<span class=\"built_in\">NSArray</span> *arr2 = [[<span class=\"built_in\">NSArray</span> alloc] init];\n<span class=\"built_in\">NSArray</span> *arr3 = @[];\n<span class=\"built_in\">NSArray</span> *arr4 = @[];\n<span class=\"built_in\">NSArray</span> *arr5 = @[@<span class=\"number\">1</span>];\n</code></pre>\n<p>上边1-4号都指向了同一个对象，而arr5指向了另一个对象。<br>若干个不可变的空数组间没有任何特异性，返回一个静态对象也理所应当。<br>不仅是NSArray，Foundation中如<code>NSString</code>, <code>NSDictionary</code>, <code>NSSet</code>等区分可变和不可变版本的类，空实例都是静态对象（NSString的空实例对象是常量区的<code>@&quot;&quot;</code>）  </p>\n<p>所以也给用这些方法来测试对象内存管理的同学提个醒，很容易意料之外的。</p>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html\">https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html</a><br><a href=\"http://iphonedevwiki.net/index.php/Foundation.framework/Inheritance_hierarchy\">http://iphonedevwiki.net/index.php/Foundation.framework/Inheritance_hierarchy</a></p>\n"},{"title":"Objective-C Class Ivar Layout 探索","date":"2015-09-13T11:04:37.000Z","_content":"\n这次探索源于一个朋友问的问题，当我们定义一个类的实例变量的时候，可以指定其修饰符：  \n\n``` objc\n@interface Sark : NSObject {\n    __strong id _gayFriend; // 无修饰符的对象默认会加 __strong\n    __weak id _girlFriend;\n    __unsafe_unretained id _company;\n}\n@end\n```\n\n这使得 ivar (instance variable) 可以像属性一样在 ARC 下进行正确的引用计数管理。  \n\n那么问题来了，假如这个类是动态生成的：  \n\n``` objc\nClass class = objc_allocateClassPair(NSObject.class, \"Sark\", 0);\nclass_addIvar(class, \"_gayFriend\", sizeof(id), log2(sizeof(id)), @encode(id));\nclass_addIvar(class, \"_girlFriend\", sizeof(id), log2(sizeof(id)), @encode(id));\nclass_addIvar(class, \"_company\", sizeof(id), log2(sizeof(id)), @encode(id));\nobjc_registerClassPair(class);\n```\n\n该如何像上面一样来添加 ivar 的属性修饰符呢？  \n\n刨根问底了一下，发现 ivar 的修饰信息存放在了 Class 的 Ivar Layout 中：\n\n``` objc\nstruct class_ro_t {\n    uint32_t flags;\n    uint32_t instanceStart;\n    uint32_t instanceSize;\n#ifdef __LP64__\n    uint32_t reserved;\n#endif\n    const uint8_t * ivarLayout; // <- 记录了哪些是 strong 的 ivar\n\n    const char * name;\n    const method_list_t * baseMethods;\n    const protocol_list_t * baseProtocols;\n    const ivar_list_t * ivars;\n\n    const uint8_t * weakIvarLayout; // <- 记录了哪些是 weak 的 ivar\n    const property_list_t *baseProperties;\n};\n```\n\nivarLayout 和 weakIvarLayout 分别记录了哪些 ivar 是 strong 或是 weak，都未记录的就是基本类型和 __unsafe_unretained 的对象类型。\n\n这两个值可以通过 runtime 提供的几个 API 来访问：\n\n``` objc\nconst uint8_t *class_getIvarLayout(Class cls)\nconst uint8_t *class_getWeakIvarLayout(Class cls)\nvoid class_setIvarLayout(Class cls, const uint8_t *layout)\nvoid class_setWeakIvarLayout(Class cls, const uint8_t *layout)\n```\n\n但我们几乎没可能用到这几个 API，IvarLayout 的值由 runtime 确定，没必要关心它的存在，但为了解决上述问题，我们试着破解了 IvarLayout 的编码方式。\n\n举个例子说明，若类定义为：\n\n``` objc\n@interface Foo : NSObject {\n    __strong id ivar0;\n    __weak id ivar1;\n    __weak id ivar2;\n}\n@end\n```\n\n则储存 strong ivar 的 ivarLayout 的值为 **0x012000**\n\n储存 weak ivar 的 weakIvarLayout 的值为 **0x1200**\n\n一个 uint8_t 在 16 进制下是两位，所以编码的值每两位一对儿，以上面的 ivarLayout 为例：\n\n1. 前两位 **01** 表示有 0 个非 strong 对象和 1 个 strong 对象\n2. 之后两位 **20** 表示有 2 个非 strong 对象和 0 个 strong 对象\n3. 最后两位 **00** 为结束符，就像 cstring 的 **\\0** 一样\n\n同理，上面的 weakIvarLayout：\n\n1. 前两位 **12** 表示有 1 个非 weak 对象和接下来连续 2 个 weak 对象\n2. **00** 结束符\n\n这样，用两个 layout 编码值就可以排查出一个 ivar 是属于 strong 还是 weak 的，若都没有找到，就说明这个对象是 unsafe_unretained.\n\n做个练习，若类定义为：\n\n``` objc\n@interface Bar : NSObject {\n    __weak id ivar0;\n    __strong id ivar1;\n    __unsafe_unretained id ivar2;\n    __weak id ivar3;\n    __strong id ivar4;\n}\n@end\n```\n\n则储存 strong ivar 的 ivarLayout 的值为 **0x012100**\n\n储存 weak ivar 的 weakIvarLayout 的值为 **0x01211000**\n\n于是乎将 class 的创建代码增加了两个 ivarLayout 值的设置：\n\n``` objc\nClass class = objc_allocateClassPair(NSObject.class, \"Sark\", 0);\nclass_addIvar(class, \"_gayFriend\", sizeof(id), log2(sizeof(id)), @encode(id));\nclass_addIvar(class, \"_girlFriend\", sizeof(id), log2(sizeof(id)), @encode(id));\nclass_addIvar(class, \"_company\", sizeof(id), log2(sizeof(id)), @encode(id));\nclass_setIvarLayout(class, (const uint8_t *)\"\\x01\\x12\"); // <--- new\nclass_setWeakIvarLayout(class, (const uint8_t *)\"\\x11\\x10\"); // <--- new\nobjc_registerClassPair(class);\n```\n\n本以为解决了这个问题，但是 runtime 继续打脸，strong 和 weak 的内存管理并没有生效，继续研究发现， class 的 flags 中有一个标记位记录这个类是否 ARC，正常编译的类，且标识了 **-fobjc-arc** flag 时，这个标记位为 1，而动态创建的类并没有设置它。所以只能继续黑魔法，运行时把这个标记位设置上，探索过程不赘述了，实现如下：  \n\n``` objc\nstatic void fixup_class_arc(Class class) {\n    struct {\n        Class isa;\n        Class superclass;\n        struct {\n            void *_buckets;\n            uint32_t _mask;\n            uint32_t _occupied;\n        } cache;\n        uintptr_t bits;\n    } *objcClass = (__bridge typeof(objcClass))class;\n#if !__LP64__\n#define FAST_DATA_MASK 0xfffffffcUL\n#else\n#define FAST_DATA_MASK 0x00007ffffffffff8UL\n#endif\n    struct {\n        uint32_t flags;\n        uint32_t version;\n        struct {\n            uint32_t flags;\n        } *ro;\n    } *objcRWClass = (typeof(objcRWClass))(objcClass->bits & FAST_DATA_MASK);\n#define RO_IS_ARR 1<<7    \n    objcRWClass->ro->flags |= RO_IS_ARR;\n}\n```\n\n把这个 fixup 放在 `objc_registerClassPair(class);` 之后，这个动态的类终于可以像静态编译的类一样操作 ivar 了，可以测试一下：  \n\n``` objc\nid sark = [class new];\nIvar weakIvar = class_getInstanceVariable(class, \"_girlFriend\");\nIvar strongIvar = class_getInstanceVariable(class, \"_gayFriend\");\n{\n    id girl = [NSObject new];\n    id boy = [NSObject new];\n    object_setIvar(sark, weakIvar, girl);\n    object_setIvar(sark, strongIvar, boy);\n} // ARC 在这里会释放大括号内的 girl，boy\n// 输出：weakIvar 为 nil，strongIvar 有值\nNSLog(@\"%@, %@\", object_getIvar(sark, weakIvar), object_getIvar(sark, strongIvar));\n```\n\nDone.\n","source":"_posts/class-ivar-layout.md","raw":"title: Objective-C Class Ivar Layout 探索\ndate: 2015-09-13 19:04:37\ntags: objc刨根问底\n---\n\n这次探索源于一个朋友问的问题，当我们定义一个类的实例变量的时候，可以指定其修饰符：  \n\n``` objc\n@interface Sark : NSObject {\n    __strong id _gayFriend; // 无修饰符的对象默认会加 __strong\n    __weak id _girlFriend;\n    __unsafe_unretained id _company;\n}\n@end\n```\n\n这使得 ivar (instance variable) 可以像属性一样在 ARC 下进行正确的引用计数管理。  \n\n那么问题来了，假如这个类是动态生成的：  \n\n``` objc\nClass class = objc_allocateClassPair(NSObject.class, \"Sark\", 0);\nclass_addIvar(class, \"_gayFriend\", sizeof(id), log2(sizeof(id)), @encode(id));\nclass_addIvar(class, \"_girlFriend\", sizeof(id), log2(sizeof(id)), @encode(id));\nclass_addIvar(class, \"_company\", sizeof(id), log2(sizeof(id)), @encode(id));\nobjc_registerClassPair(class);\n```\n\n该如何像上面一样来添加 ivar 的属性修饰符呢？  \n\n刨根问底了一下，发现 ivar 的修饰信息存放在了 Class 的 Ivar Layout 中：\n\n``` objc\nstruct class_ro_t {\n    uint32_t flags;\n    uint32_t instanceStart;\n    uint32_t instanceSize;\n#ifdef __LP64__\n    uint32_t reserved;\n#endif\n    const uint8_t * ivarLayout; // <- 记录了哪些是 strong 的 ivar\n\n    const char * name;\n    const method_list_t * baseMethods;\n    const protocol_list_t * baseProtocols;\n    const ivar_list_t * ivars;\n\n    const uint8_t * weakIvarLayout; // <- 记录了哪些是 weak 的 ivar\n    const property_list_t *baseProperties;\n};\n```\n\nivarLayout 和 weakIvarLayout 分别记录了哪些 ivar 是 strong 或是 weak，都未记录的就是基本类型和 __unsafe_unretained 的对象类型。\n\n这两个值可以通过 runtime 提供的几个 API 来访问：\n\n``` objc\nconst uint8_t *class_getIvarLayout(Class cls)\nconst uint8_t *class_getWeakIvarLayout(Class cls)\nvoid class_setIvarLayout(Class cls, const uint8_t *layout)\nvoid class_setWeakIvarLayout(Class cls, const uint8_t *layout)\n```\n\n但我们几乎没可能用到这几个 API，IvarLayout 的值由 runtime 确定，没必要关心它的存在，但为了解决上述问题，我们试着破解了 IvarLayout 的编码方式。\n\n举个例子说明，若类定义为：\n\n``` objc\n@interface Foo : NSObject {\n    __strong id ivar0;\n    __weak id ivar1;\n    __weak id ivar2;\n}\n@end\n```\n\n则储存 strong ivar 的 ivarLayout 的值为 **0x012000**\n\n储存 weak ivar 的 weakIvarLayout 的值为 **0x1200**\n\n一个 uint8_t 在 16 进制下是两位，所以编码的值每两位一对儿，以上面的 ivarLayout 为例：\n\n1. 前两位 **01** 表示有 0 个非 strong 对象和 1 个 strong 对象\n2. 之后两位 **20** 表示有 2 个非 strong 对象和 0 个 strong 对象\n3. 最后两位 **00** 为结束符，就像 cstring 的 **\\0** 一样\n\n同理，上面的 weakIvarLayout：\n\n1. 前两位 **12** 表示有 1 个非 weak 对象和接下来连续 2 个 weak 对象\n2. **00** 结束符\n\n这样，用两个 layout 编码值就可以排查出一个 ivar 是属于 strong 还是 weak 的，若都没有找到，就说明这个对象是 unsafe_unretained.\n\n做个练习，若类定义为：\n\n``` objc\n@interface Bar : NSObject {\n    __weak id ivar0;\n    __strong id ivar1;\n    __unsafe_unretained id ivar2;\n    __weak id ivar3;\n    __strong id ivar4;\n}\n@end\n```\n\n则储存 strong ivar 的 ivarLayout 的值为 **0x012100**\n\n储存 weak ivar 的 weakIvarLayout 的值为 **0x01211000**\n\n于是乎将 class 的创建代码增加了两个 ivarLayout 值的设置：\n\n``` objc\nClass class = objc_allocateClassPair(NSObject.class, \"Sark\", 0);\nclass_addIvar(class, \"_gayFriend\", sizeof(id), log2(sizeof(id)), @encode(id));\nclass_addIvar(class, \"_girlFriend\", sizeof(id), log2(sizeof(id)), @encode(id));\nclass_addIvar(class, \"_company\", sizeof(id), log2(sizeof(id)), @encode(id));\nclass_setIvarLayout(class, (const uint8_t *)\"\\x01\\x12\"); // <--- new\nclass_setWeakIvarLayout(class, (const uint8_t *)\"\\x11\\x10\"); // <--- new\nobjc_registerClassPair(class);\n```\n\n本以为解决了这个问题，但是 runtime 继续打脸，strong 和 weak 的内存管理并没有生效，继续研究发现， class 的 flags 中有一个标记位记录这个类是否 ARC，正常编译的类，且标识了 **-fobjc-arc** flag 时，这个标记位为 1，而动态创建的类并没有设置它。所以只能继续黑魔法，运行时把这个标记位设置上，探索过程不赘述了，实现如下：  \n\n``` objc\nstatic void fixup_class_arc(Class class) {\n    struct {\n        Class isa;\n        Class superclass;\n        struct {\n            void *_buckets;\n            uint32_t _mask;\n            uint32_t _occupied;\n        } cache;\n        uintptr_t bits;\n    } *objcClass = (__bridge typeof(objcClass))class;\n#if !__LP64__\n#define FAST_DATA_MASK 0xfffffffcUL\n#else\n#define FAST_DATA_MASK 0x00007ffffffffff8UL\n#endif\n    struct {\n        uint32_t flags;\n        uint32_t version;\n        struct {\n            uint32_t flags;\n        } *ro;\n    } *objcRWClass = (typeof(objcRWClass))(objcClass->bits & FAST_DATA_MASK);\n#define RO_IS_ARR 1<<7    \n    objcRWClass->ro->flags |= RO_IS_ARR;\n}\n```\n\n把这个 fixup 放在 `objc_registerClassPair(class);` 之后，这个动态的类终于可以像静态编译的类一样操作 ivar 了，可以测试一下：  \n\n``` objc\nid sark = [class new];\nIvar weakIvar = class_getInstanceVariable(class, \"_girlFriend\");\nIvar strongIvar = class_getInstanceVariable(class, \"_gayFriend\");\n{\n    id girl = [NSObject new];\n    id boy = [NSObject new];\n    object_setIvar(sark, weakIvar, girl);\n    object_setIvar(sark, strongIvar, boy);\n} // ARC 在这里会释放大括号内的 girl，boy\n// 输出：weakIvar 为 nil，strongIvar 有值\nNSLog(@\"%@, %@\", object_getIvar(sark, weakIvar), object_getIvar(sark, strongIvar));\n```\n\nDone.\n","slug":"class-ivar-layout","published":1,"updated":"2016-03-26T09:21:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxjv0008ev12icf9ywxj","content":"<p>这次探索源于一个朋友问的问题，当我们定义一个类的实例变量的时候，可以指定其修饰符：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"keyword\">id</span> _gayFriend; <span class=\"comment\">// 无修饰符的对象默认会加 __strong</span></span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">id</span> _girlFriend;</span><br><span class=\"line\">    __unsafe_unretained <span class=\"keyword\">id</span> _company;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>这使得 ivar (instance variable) 可以像属性一样在 ARC 下进行正确的引用计数管理。  </p>\n<p>那么问题来了，假如这个类是动态生成的：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class class = objc_allocateClassPair(<span class=\"built_in\">NSObject</span>.class, <span class=\"string\">\"Sark\"</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">class_addIvar(class, <span class=\"string\">\"_gayFriend\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>), log2(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>)), @encode(<span class=\"keyword\">id</span>));</span><br><span class=\"line\">class_addIvar(class, <span class=\"string\">\"_girlFriend\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>), log2(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>)), @encode(<span class=\"keyword\">id</span>));</span><br><span class=\"line\">class_addIvar(class, <span class=\"string\">\"_company\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>), log2(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>)), @encode(<span class=\"keyword\">id</span>));</span><br><span class=\"line\">objc_registerClassPair(class);</span><br></pre></td></tr></table></figure>\n<p>该如何像上面一样来添加 ivar 的属性修饰符呢？  </p>\n<p>刨根问底了一下，发现 ivar 的修饰信息存放在了 Class 的 Ivar Layout 中：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> class_ro_t &#123;</span><br><span class=\"line\">    uint32_t flags;</span><br><span class=\"line\">    uint32_t instanceStart;</span><br><span class=\"line\">    uint32_t instanceSize;</span><br><span class=\"line\"><span class=\"meta\">#ifdef __LP64__</span></span><br><span class=\"line\">    uint32_t reserved;</span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> uint8_t * ivarLayout; <span class=\"comment\">// &lt;- 记录了哪些是 strong 的 ivar</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * name;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> method_list_t * baseMethods;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> protocol_list_t * baseProtocols;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> ivar_list_t * ivars;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> uint8_t * weakIvarLayout; <span class=\"comment\">// &lt;- 记录了哪些是 weak 的 ivar</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> property_list_t *baseProperties;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>ivarLayout 和 weakIvarLayout 分别记录了哪些 ivar 是 strong 或是 weak，都未记录的就是基本类型和 __unsafe_unretained 的对象类型。</p>\n<p>这两个值可以通过 runtime 提供的几个 API 来访问：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> uint8_t *class_getIvarLayout(Class cls)</span><br><span class=\"line\"><span class=\"keyword\">const</span> uint8_t *class_getWeakIvarLayout(Class cls)</span><br><span class=\"line\"><span class=\"keyword\">void</span> class_setIvarLayout(Class cls, <span class=\"keyword\">const</span> uint8_t *layout)</span><br><span class=\"line\"><span class=\"keyword\">void</span> class_setWeakIvarLayout(Class cls, <span class=\"keyword\">const</span> uint8_t *layout)</span><br></pre></td></tr></table></figure>\n<p>但我们几乎没可能用到这几个 API，IvarLayout 的值由 runtime 确定，没必要关心它的存在，但为了解决上述问题，我们试着破解了 IvarLayout 的编码方式。</p>\n<p>举个例子说明，若类定义为：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Foo</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"keyword\">id</span> ivar0;</span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">id</span> ivar1;</span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">id</span> ivar2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>则储存 strong ivar 的 ivarLayout 的值为 <strong>0x012000</strong></p>\n<p>储存 weak ivar 的 weakIvarLayout 的值为 <strong>0x1200</strong></p>\n<p>一个 uint8_t 在 16 进制下是两位，所以编码的值每两位一对儿，以上面的 ivarLayout 为例：</p>\n<ol>\n<li>前两位 <strong>01</strong> 表示有 0 个非 strong 对象和 1 个 strong 对象</li>\n<li>之后两位 <strong>20</strong> 表示有 2 个非 strong 对象和 0 个 strong 对象</li>\n<li>最后两位 <strong>00</strong> 为结束符，就像 cstring 的 <strong>\\0</strong> 一样</li>\n</ol>\n<p>同理，上面的 weakIvarLayout：</p>\n<ol>\n<li>前两位 <strong>12</strong> 表示有 1 个非 weak 对象和接下来连续 2 个 weak 对象</li>\n<li><strong>00</strong> 结束符</li>\n</ol>\n<p>这样，用两个 layout 编码值就可以排查出一个 ivar 是属于 strong 还是 weak 的，若都没有找到，就说明这个对象是 unsafe_unretained.</p>\n<p>做个练习，若类定义为：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Bar</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">id</span> ivar0;</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"keyword\">id</span> ivar1;</span><br><span class=\"line\">    __unsafe_unretained <span class=\"keyword\">id</span> ivar2;</span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">id</span> ivar3;</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"keyword\">id</span> ivar4;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>则储存 strong ivar 的 ivarLayout 的值为 <strong>0x012100</strong></p>\n<p>储存 weak ivar 的 weakIvarLayout 的值为 <strong>0x01211000</strong></p>\n<p>于是乎将 class 的创建代码增加了两个 ivarLayout 值的设置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class class = objc_allocateClassPair(<span class=\"built_in\">NSObject</span>.class, <span class=\"string\">\"Sark\"</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">class_addIvar(class, <span class=\"string\">\"_gayFriend\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>), log2(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>)), @encode(<span class=\"keyword\">id</span>));</span><br><span class=\"line\">class_addIvar(class, <span class=\"string\">\"_girlFriend\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>), log2(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>)), @encode(<span class=\"keyword\">id</span>));</span><br><span class=\"line\">class_addIvar(class, <span class=\"string\">\"_company\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>), log2(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>)), @encode(<span class=\"keyword\">id</span>));</span><br><span class=\"line\">class_setIvarLayout(class, (<span class=\"keyword\">const</span> uint8_t *)<span class=\"string\">\"\\x01\\x12\"</span>); <span class=\"comment\">// &lt;--- new</span></span><br><span class=\"line\">class_setWeakIvarLayout(class, (<span class=\"keyword\">const</span> uint8_t *)<span class=\"string\">\"\\x11\\x10\"</span>); <span class=\"comment\">// &lt;--- new</span></span><br><span class=\"line\">objc_registerClassPair(class);</span><br></pre></td></tr></table></figure>\n<p>本以为解决了这个问题，但是 runtime 继续打脸，strong 和 weak 的内存管理并没有生效，继续研究发现， class 的 flags 中有一个标记位记录这个类是否 ARC，正常编译的类，且标识了 <strong>-fobjc-arc</strong> flag 时，这个标记位为 1，而动态创建的类并没有设置它。所以只能继续黑魔法，运行时把这个标记位设置上，探索过程不赘述了，实现如下：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> fixup_class_arc(Class class) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        Class isa;</span><br><span class=\"line\">        Class superclass;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">void</span> *_buckets;</span><br><span class=\"line\">            uint32_t _mask;</span><br><span class=\"line\">            uint32_t _occupied;</span><br><span class=\"line\">        &#125; cache;</span><br><span class=\"line\">        uintptr_t bits;</span><br><span class=\"line\">    &#125; *objcClass = (__bridge <span class=\"keyword\">typeof</span>(objcClass))class;</span><br><span class=\"line\"><span class=\"meta\">#if !__LP64__</span></span><br><span class=\"line\"><span class=\"meta\">#define FAST_DATA_MASK 0xfffffffcUL</span></span><br><span class=\"line\"><span class=\"meta\">#else</span></span><br><span class=\"line\"><span class=\"meta\">#define FAST_DATA_MASK 0x00007ffffffffff8UL</span></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        uint32_t flags;</span><br><span class=\"line\">        uint32_t version;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">            uint32_t flags;</span><br><span class=\"line\">        &#125; *ro;</span><br><span class=\"line\">    &#125; *objcRWClass = (<span class=\"keyword\">typeof</span>(objcRWClass))(objcClass-&gt;bits &amp; FAST_DATA_MASK);</span><br><span class=\"line\"><span class=\"meta\">#define RO_IS_ARR 1<span class=\"meta-string\">&lt;&lt;7    </span><br><span class=\"line\">    objcRWClass-&gt;</span>ro-&gt;flags |= RO_IS_ARR;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把这个 fixup 放在 <code>objc_registerClassPair(class);</code> 之后，这个动态的类终于可以像静态编译的类一样操作 ivar 了，可以测试一下：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> sark = [class new];</span><br><span class=\"line\">Ivar weakIvar = class_getInstanceVariable(class, <span class=\"string\">\"_girlFriend\"</span>);</span><br><span class=\"line\">Ivar strongIvar = class_getInstanceVariable(class, <span class=\"string\">\"_gayFriend\"</span>);</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">id</span> girl = [<span class=\"built_in\">NSObject</span> new];</span><br><span class=\"line\">    <span class=\"keyword\">id</span> boy = [<span class=\"built_in\">NSObject</span> new];</span><br><span class=\"line\">    object_setIvar(sark, weakIvar, girl);</span><br><span class=\"line\">    object_setIvar(sark, strongIvar, boy);</span><br><span class=\"line\">&#125; <span class=\"comment\">// ARC 在这里会释放大括号内的 girl，boy</span></span><br><span class=\"line\"><span class=\"comment\">// 输出：weakIvar 为 nil，strongIvar 有值</span></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@, %@\"</span>, object_getIvar(sark, weakIvar), object_getIvar(sark, strongIvar));</span><br></pre></td></tr></table></figure>\n<p>Done.</p>\n","excerpt":"","more":"<p>这次探索源于一个朋友问的问题，当我们定义一个类的实例变量的时候，可以指定其修饰符：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"keyword\">id</span> _gayFriend; <span class=\"comment\">// 无修饰符的对象默认会加 __strong</span></span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">id</span> _girlFriend;</span><br><span class=\"line\">    __unsafe_unretained <span class=\"keyword\">id</span> _company;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>这使得 ivar (instance variable) 可以像属性一样在 ARC 下进行正确的引用计数管理。  </p>\n<p>那么问题来了，假如这个类是动态生成的：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class class = objc_allocateClassPair(<span class=\"built_in\">NSObject</span>.class, <span class=\"string\">\"Sark\"</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">class_addIvar(class, <span class=\"string\">\"_gayFriend\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>), log2(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>)), @encode(<span class=\"keyword\">id</span>));</span><br><span class=\"line\">class_addIvar(class, <span class=\"string\">\"_girlFriend\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>), log2(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>)), @encode(<span class=\"keyword\">id</span>));</span><br><span class=\"line\">class_addIvar(class, <span class=\"string\">\"_company\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>), log2(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>)), @encode(<span class=\"keyword\">id</span>));</span><br><span class=\"line\">objc_registerClassPair(class);</span><br></pre></td></tr></table></figure>\n<p>该如何像上面一样来添加 ivar 的属性修饰符呢？  </p>\n<p>刨根问底了一下，发现 ivar 的修饰信息存放在了 Class 的 Ivar Layout 中：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> class_ro_t &#123;</span><br><span class=\"line\">    uint32_t flags;</span><br><span class=\"line\">    uint32_t instanceStart;</span><br><span class=\"line\">    uint32_t instanceSize;</span><br><span class=\"line\"><span class=\"meta\">#ifdef __LP64__</span></span><br><span class=\"line\">    uint32_t reserved;</span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> uint8_t * ivarLayout; <span class=\"comment\">// &lt;- 记录了哪些是 strong 的 ivar</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * name;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> method_list_t * baseMethods;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> protocol_list_t * baseProtocols;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> ivar_list_t * ivars;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> uint8_t * weakIvarLayout; <span class=\"comment\">// &lt;- 记录了哪些是 weak 的 ivar</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> property_list_t *baseProperties;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>ivarLayout 和 weakIvarLayout 分别记录了哪些 ivar 是 strong 或是 weak，都未记录的就是基本类型和 __unsafe_unretained 的对象类型。</p>\n<p>这两个值可以通过 runtime 提供的几个 API 来访问：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> uint8_t *class_getIvarLayout(Class cls)</span><br><span class=\"line\"><span class=\"keyword\">const</span> uint8_t *class_getWeakIvarLayout(Class cls)</span><br><span class=\"line\"><span class=\"keyword\">void</span> class_setIvarLayout(Class cls, <span class=\"keyword\">const</span> uint8_t *layout)</span><br><span class=\"line\"><span class=\"keyword\">void</span> class_setWeakIvarLayout(Class cls, <span class=\"keyword\">const</span> uint8_t *layout)</span><br></pre></td></tr></table></figure>\n<p>但我们几乎没可能用到这几个 API，IvarLayout 的值由 runtime 确定，没必要关心它的存在，但为了解决上述问题，我们试着破解了 IvarLayout 的编码方式。</p>\n<p>举个例子说明，若类定义为：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Foo</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"keyword\">id</span> ivar0;</span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">id</span> ivar1;</span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">id</span> ivar2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>则储存 strong ivar 的 ivarLayout 的值为 <strong>0x012000</strong></p>\n<p>储存 weak ivar 的 weakIvarLayout 的值为 <strong>0x1200</strong></p>\n<p>一个 uint8_t 在 16 进制下是两位，所以编码的值每两位一对儿，以上面的 ivarLayout 为例：</p>\n<ol>\n<li>前两位 <strong>01</strong> 表示有 0 个非 strong 对象和 1 个 strong 对象</li>\n<li>之后两位 <strong>20</strong> 表示有 2 个非 strong 对象和 0 个 strong 对象</li>\n<li>最后两位 <strong>00</strong> 为结束符，就像 cstring 的 <strong>\\0</strong> 一样</li>\n</ol>\n<p>同理，上面的 weakIvarLayout：</p>\n<ol>\n<li>前两位 <strong>12</strong> 表示有 1 个非 weak 对象和接下来连续 2 个 weak 对象</li>\n<li><strong>00</strong> 结束符</li>\n</ol>\n<p>这样，用两个 layout 编码值就可以排查出一个 ivar 是属于 strong 还是 weak 的，若都没有找到，就说明这个对象是 unsafe_unretained.</p>\n<p>做个练习，若类定义为：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Bar</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">id</span> ivar0;</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"keyword\">id</span> ivar1;</span><br><span class=\"line\">    __unsafe_unretained <span class=\"keyword\">id</span> ivar2;</span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">id</span> ivar3;</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"keyword\">id</span> ivar4;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>则储存 strong ivar 的 ivarLayout 的值为 <strong>0x012100</strong></p>\n<p>储存 weak ivar 的 weakIvarLayout 的值为 <strong>0x01211000</strong></p>\n<p>于是乎将 class 的创建代码增加了两个 ivarLayout 值的设置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class class = objc_allocateClassPair(<span class=\"built_in\">NSObject</span>.class, <span class=\"string\">\"Sark\"</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">class_addIvar(class, <span class=\"string\">\"_gayFriend\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>), log2(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>)), @encode(<span class=\"keyword\">id</span>));</span><br><span class=\"line\">class_addIvar(class, <span class=\"string\">\"_girlFriend\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>), log2(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>)), @encode(<span class=\"keyword\">id</span>));</span><br><span class=\"line\">class_addIvar(class, <span class=\"string\">\"_company\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>), log2(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">id</span>)), @encode(<span class=\"keyword\">id</span>));</span><br><span class=\"line\">class_setIvarLayout(class, (<span class=\"keyword\">const</span> uint8_t *)<span class=\"string\">\"\\x01\\x12\"</span>); <span class=\"comment\">// &lt;--- new</span></span><br><span class=\"line\">class_setWeakIvarLayout(class, (<span class=\"keyword\">const</span> uint8_t *)<span class=\"string\">\"\\x11\\x10\"</span>); <span class=\"comment\">// &lt;--- new</span></span><br><span class=\"line\">objc_registerClassPair(class);</span><br></pre></td></tr></table></figure>\n<p>本以为解决了这个问题，但是 runtime 继续打脸，strong 和 weak 的内存管理并没有生效，继续研究发现， class 的 flags 中有一个标记位记录这个类是否 ARC，正常编译的类，且标识了 <strong>-fobjc-arc</strong> flag 时，这个标记位为 1，而动态创建的类并没有设置它。所以只能继续黑魔法，运行时把这个标记位设置上，探索过程不赘述了，实现如下：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> fixup_class_arc(Class class) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        Class isa;</span><br><span class=\"line\">        Class superclass;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">void</span> *_buckets;</span><br><span class=\"line\">            uint32_t _mask;</span><br><span class=\"line\">            uint32_t _occupied;</span><br><span class=\"line\">        &#125; cache;</span><br><span class=\"line\">        uintptr_t bits;</span><br><span class=\"line\">    &#125; *objcClass = (__bridge <span class=\"keyword\">typeof</span>(objcClass))class;</span><br><span class=\"line\"><span class=\"meta\">#if !__LP64__</span></span><br><span class=\"line\"><span class=\"meta\">#define FAST_DATA_MASK 0xfffffffcUL</span></span><br><span class=\"line\"><span class=\"meta\">#else</span></span><br><span class=\"line\"><span class=\"meta\">#define FAST_DATA_MASK 0x00007ffffffffff8UL</span></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        uint32_t flags;</span><br><span class=\"line\">        uint32_t version;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">            uint32_t flags;</span><br><span class=\"line\">        &#125; *ro;</span><br><span class=\"line\">    &#125; *objcRWClass = (<span class=\"keyword\">typeof</span>(objcRWClass))(objcClass-&gt;bits &amp; FAST_DATA_MASK);</span><br><span class=\"line\"><span class=\"meta\">#define RO_IS_ARR 1<span class=\"meta-string\">&lt;&lt;7    </span><br><span class=\"line\">    objcRWClass-&gt;</span>ro-&gt;flags |= RO_IS_ARR;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把这个 fixup 放在 <code>objc_registerClassPair(class);</code> 之后，这个动态的类终于可以像静态编译的类一样操作 ivar 了，可以测试一下：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> sark = [class new];</span><br><span class=\"line\">Ivar weakIvar = class_getInstanceVariable(class, <span class=\"string\">\"_girlFriend\"</span>);</span><br><span class=\"line\">Ivar strongIvar = class_getInstanceVariable(class, <span class=\"string\">\"_gayFriend\"</span>);</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">id</span> girl = [<span class=\"built_in\">NSObject</span> new];</span><br><span class=\"line\">    <span class=\"keyword\">id</span> boy = [<span class=\"built_in\">NSObject</span> new];</span><br><span class=\"line\">    object_setIvar(sark, weakIvar, girl);</span><br><span class=\"line\">    object_setIvar(sark, strongIvar, boy);</span><br><span class=\"line\">&#125; <span class=\"comment\">// ARC 在这里会释放大括号内的 girl，boy</span></span><br><span class=\"line\"><span class=\"comment\">// 输出：weakIvar 为 nil，strongIvar 有值</span></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@, %@\"</span>, object_getIvar(sark, weakIvar), object_getIvar(sark, strongIvar));</span><br></pre></td></tr></table></figure>\n<p>Done.</p>\n"},{"title":"一个丝滑的全屏滑动返回手势","date":"2015-06-07T02:15:04.000Z","_content":"\n# 全屏返回手势\n\n自 iOS7 之后，Apple 增加了**屏幕边缘右划返回**交互的支持，再配合上 UINavigationController 的交互式动画，pop 到上一级页面的操作变的非常顺畅和丝滑，从此，我很少再使用点击左上角导航栏上的返回按钮的方式返回了，因为这对单手操作十分不友好；如果一个 App 居然胆敢不支持滑动返回，那离被卸载就不远了。  \n\n说到**全屏返回手势**，首先我感觉这件事本身可能就有问题，毕竟有点反苹果官方的交互，让用户从任意的地方都能够滑动返回这个交互在国内的 App 中非常普遍，比如我手机中的手Q、微博、网易新闻、大众点评等，当然还有百度知道- -。这里得对微信的产品经理们得点个赞，从整个 App 来看，不论是交互还是 UI 结构和样式都非常的 iOS，没有什么特别奇葩的页面和交互，以至于使用 UIKit 原生的框架可以非常简单的搭建起来，这也符合我个人对 App 的一个愿景：**一个优秀的 App 不论从用户角度看还是从代码角度看都应该是简单且优雅的**，呼吁各家产品经理可以多借鉴下像微信这样很本色的 App 设计。（以后可以分享下如何使用 Storyboard 在一小时内快速搭建起微信 UI）  \n\n# FDFullscreenPopGesture\n\n工作毕竟是工作，于是乎所以就被迫实现了套 pan 手势处理加截图和视差，虽然在运动曲线上、bar 截图处理上下了不少功夫，但距离系统的丝滑效果还是差距挺远。随时间推移，终于能够最低支持 iOS7 后，我们把这个问题再次拿出来讨论和研究，直到在微博上看到了 **J_雨**同学的[这篇文章](http://www.jianshu.com/p/d39f7d22db6c) 后才找到了这个迄今为止最简单的解决方案。于是乎在他的授权下，我们在 forkingdog 上把这个返回手势开源，[github地址](https://github.com/forkingdog/FDFullscreenPopGesture)，并果断应用到了百度知道 App 内，这是 Demo 效果：  \n\n![](https://raw.githubusercontent.com/forkingdog/FDFullscreenPopGesture/master/Snapshots/snapshot0.gif)   \n\n利用了系统自己的边缘返回手势处理函数后，一切动画和曲线都和原生效果一毛一样了。  \n于是乎发布了 `FDFullscreenPopGesture` 1.0 版本，而且提供了一个 AOP 形式的 API，把它添加到工程里面，什么代码都不用写，所有 UINavigationController 就自带这个全屏返回效果了。  \n\n# 丝滑的处理导航栏的显示和隐藏\n\n接下来我们发现利用系统的 UINavigationBar 时，返回手势中若碰到前一个页面有 bar，后一个页面没 bar，或者反过来时，动画就非常难看，举两个反例：  \n\n手Q iOS：  \n\n![](http://ww2.sinaimg.cn/large/51530583jw1esvbwqgawtg208w0fvu0x.gif)\n\n它的个人中心页面上面的 bar 是隐藏状态，然后做了个和其他页面很像的假 bar，但返回手势一开始就露馅了，为了弥补，还做了下后面真 bar 的 alpha 值动画，两个返回按钮还是重叠在了一起。  \n\n新浪微博 iOS：  \n\n![](http://ww4.sinaimg.cn/large/51530583jw1esvbwfphj8g208w0fv4qp.gif)\n\n和手Q一样的实现方式，只不过没做 alpha 动画，所以就非常明显了。  \n\n为啥会这样呢？这可能就是 UINavigationController 在导航栏控制 API 上设计的缺陷了。 一个 UINavigationController 管理了串行的 N 个 UIViewController 栈式的 push 和 pop，而 UINavigationBar 由 UINavigationController 管理，这就导致了 UIViewController 无法控制自己上面的 bar 单独的隐藏或显示。 这非常像 UIApplication 全局的 status bar，牵一发还得动全身，不过 Apple 在 iOS7 之后为 vc 控制自己的 status bar 提供了下面几个方法：  \n\n``` objc\n- (UIStatusBarStyle)preferredStatusBarStyle NS_AVAILABLE_IOS(7_0);\n- (BOOL)prefersStatusBarHidden NS_AVAILABLE_IOS(7_0);\n- (UIStatusBarAnimation)preferredStatusBarUpdateAnimation NS_AVAILABLE_IOS(7_0);\n```\n\n终于让这个**全局变量**变成了**局部变量**，虽然写起来费劲了些。  \n但是对 UINavigationBar 的控制，依然是全局的，可能 Apple 觉得 App 不应该有这种奇怪的页面结构？  \n\n解决这个问题的方法也不难，在滑动返回的后要出现的那个 view controller 中写下面的代码：  \n\n``` objc\n- (void)viewWillAppear:(BOOL)animated {\n    [super viewWillAppear:animated];\n    [self.navigationController setNavigationBarHidden:YES animated:animated];\n}\n```\n\n系统就会把有 bar 和 无 bar 的 transition 动画衔接起来。但是如上面所说，这是个全局变量，还得在所有由这个没有 bar 的特殊页面能 push 和 pop 的页面都进行反向的处理，代码非常的乱乎。于是乎，我们试着解决了这个问题，先看效果：  \n\n![](http://ww2.sinaimg.cn/large/51530583jw1esvbwmjck8g208w0ft7wj.gif)\n\n我特意挑了个从真 bar 到假 bar，再从假 bar 到 真 bar 的页面，还算蛮丝滑的，transition 动画全是系统自己搞定的。  \n就事把 `FDFullscreenPopGesture` 更新到了 1.1 版本，贯彻我们一向的精简 API，你只需要在 bar 要隐藏的 view controller 中写一句话：  \n\n``` objc\n- (void)viewDidLoad\n    [super viewDidLoad];\n    self.navigationController.fd_prefersNavigationBarHidden = YES;\n}\n```\n\n或者喜欢重载的写法也行：  \n\n``` objc\n- (BOOL)fd_prefersNavigationBarHidden {\n    return YES;\n}\n```\n\n刻意的模仿了下系统的命名风格，就这一句话，剩下的就都不用操心了。  \n\n# 关于私有API\n\n大家会质疑说，这用到了 UIKit 的私有属性和私有 API，要是系统升级变了咋办？要是审核被拒了咋办？  \n首先，iOS 系统的 SDK 为了向下兼容，一般只会增加方法或者修改方法实现，不太可能直接删除一个共有方法，而私有方法的行为确实可能有变化，但系统 release 频率毕竟很低，每当新版本发布时 check 下原来的功能是否能 work 就好了，大可不必担心这么远，SDK 是死的人是活的。  \n另一个就是审核问题，FDFullscreenPopGesture 的实现中有主要有两处触碰到了私有 API：  \n\n``` objc\n// 1. 私有变量标志transition动画是否正在进行\n[self.navigationController valueForKey:@\"_isTransitioning\"];\n// 2. 一个内部的selector\nNSSelectorFromString(@\"handleNavigationTransition:\");\n```\n\n不论是 kvc 还是 selector 反射，都是利用 objc runtime 完成的，而到了这一层，真的就没啥公有私有可言了。设想你就是开发 Apple 私有 API 检查工具的工程师，给你一个 ipa 的包，你会如何检查出其中有没有私有 API 呢？  \n\n首先，这个检查一定是个静态检查吧，不可能是运行时检查，因为代码逻辑那么复杂，把程序跑起来看所有 objc_msgSend 中包不包括私有调用这件事太不现实了。  \n对 ipa 文件做静态检查的话肯定是去分析 Mach-O 可执行文件，因为这时很多源代码级别的信息已经丢失，经分析可以采取下面几种手段：  \n\n- 是否 link 了私有 framework 或者公开 framework 中的私有符号，这可以防止开发者把私有 header 都 dump 出来供程序直接调用。  \n- 同上，使用`@selector(_private_sel)`加上`-performSelector:`的方式直接调用私有 API。\n- 扫描所有符号，查看是否有继承自私有类，重载私有方法，方法名是否有重合。\n- 扫描所有**string**，看字符串常量段是否出现和私有 API 对应的。\n\n我觉得前三条被 catch 住的可能性最高，也最容易被检查出来。再来看我们用到用字符串的方法 kvc 和 反射 selector，应该属于最后一条，这时候就很难抉择了，拿 `handleNavigationTransition:` 来说，看上去人畜无害啊，我自己类里面的方法也完全可能命名出这个来，所以单单凭借字符串命中私有 API 判定，苹果很容易误伤一大票开发者。  \n综上，我觉得使用字符串的方式使用私有 API 是相对安全的，我们的 App 马上要提交审核，如果过了几天你还能读到这段文字，说明我的猜想是木有错的，大家可以放心使用。\n\n# 0 代码的 Demo\n\n还有一个有意思的事，我们在 github 上的 [demo工程](https://github.com/forkingdog/FDFullscreenPopGesture) 木有写一行代码，就实现了下面的效果：\n\n![](https://raw.githubusercontent.com/forkingdog/FDFullscreenPopGesture/master/Snapshots/snapshot1.gif)\n\n工程长这个样子，view controller 类也没写，为了体现 `FDFullscreenPopGesture` 的 AOP 性质：  \n\n<img src=\"http://ww3.sinaimg.cn/large/51530583jw1esveprvnvfj20ju0d2tbm.jpg\" width=\"320\">\n\n页面由 Storyboard 构建：  \n\n<img src=\"http://ww3.sinaimg.cn/large/51530583jw1esvepscqomj212m10eq5a.jpg\" width=\"640\">\n\n而控制页面隐藏 bar 的属性也能用 Runtime Attributes 模拟调用：  \n\n<img src=\"http://ww2.sinaimg.cn/large/51530583jw1esvetev633j20ig05ydgl.jpg\" width=\"320\">\n\n这样就完成了一个非常干净的 Demo\n\n# 加入到你的工程中\n\n首先要求最低支持 iOS7，我想在 WWDC 2015 结束，iOS9 发布后，主流的 App 就都会 iOS7 起跳了。  \n依然是熟悉的 cocoapods 安装：\n\n``` objc\npod 'FDFullscreenPopGesture', '~> 1.1'\n```\n\n要是没有搜到就 `pod setup` 下。\n\n# 广告时间  \n\n我这边正在招聘 iOS，坐标北京，希望找到一个代码规范的、爱用 IB 的、懒得写重复代码、不爱加班的同学，相信这里有很大空间供你学习和提升，还可以参与到 forkingdog 开源小组中做点屌屌的东西，欢迎私聊或把简历丢到 sunyuan01@baidu.com   \n\n<img src=\"https://cloud.githubusercontent.com/assets/219689/7244961/4209de32-e816-11e4-87bc-b161c442d348.png\" width=\"640\">\n","source":"_posts/fullscreen-pop-gesture.md","raw":"title: 一个丝滑的全屏滑动返回手势\ndate: 2015-06-07 10:15:04\ntags: ios最佳实践\n---\n\n# 全屏返回手势\n\n自 iOS7 之后，Apple 增加了**屏幕边缘右划返回**交互的支持，再配合上 UINavigationController 的交互式动画，pop 到上一级页面的操作变的非常顺畅和丝滑，从此，我很少再使用点击左上角导航栏上的返回按钮的方式返回了，因为这对单手操作十分不友好；如果一个 App 居然胆敢不支持滑动返回，那离被卸载就不远了。  \n\n说到**全屏返回手势**，首先我感觉这件事本身可能就有问题，毕竟有点反苹果官方的交互，让用户从任意的地方都能够滑动返回这个交互在国内的 App 中非常普遍，比如我手机中的手Q、微博、网易新闻、大众点评等，当然还有百度知道- -。这里得对微信的产品经理们得点个赞，从整个 App 来看，不论是交互还是 UI 结构和样式都非常的 iOS，没有什么特别奇葩的页面和交互，以至于使用 UIKit 原生的框架可以非常简单的搭建起来，这也符合我个人对 App 的一个愿景：**一个优秀的 App 不论从用户角度看还是从代码角度看都应该是简单且优雅的**，呼吁各家产品经理可以多借鉴下像微信这样很本色的 App 设计。（以后可以分享下如何使用 Storyboard 在一小时内快速搭建起微信 UI）  \n\n# FDFullscreenPopGesture\n\n工作毕竟是工作，于是乎所以就被迫实现了套 pan 手势处理加截图和视差，虽然在运动曲线上、bar 截图处理上下了不少功夫，但距离系统的丝滑效果还是差距挺远。随时间推移，终于能够最低支持 iOS7 后，我们把这个问题再次拿出来讨论和研究，直到在微博上看到了 **J_雨**同学的[这篇文章](http://www.jianshu.com/p/d39f7d22db6c) 后才找到了这个迄今为止最简单的解决方案。于是乎在他的授权下，我们在 forkingdog 上把这个返回手势开源，[github地址](https://github.com/forkingdog/FDFullscreenPopGesture)，并果断应用到了百度知道 App 内，这是 Demo 效果：  \n\n![](https://raw.githubusercontent.com/forkingdog/FDFullscreenPopGesture/master/Snapshots/snapshot0.gif)   \n\n利用了系统自己的边缘返回手势处理函数后，一切动画和曲线都和原生效果一毛一样了。  \n于是乎发布了 `FDFullscreenPopGesture` 1.0 版本，而且提供了一个 AOP 形式的 API，把它添加到工程里面，什么代码都不用写，所有 UINavigationController 就自带这个全屏返回效果了。  \n\n# 丝滑的处理导航栏的显示和隐藏\n\n接下来我们发现利用系统的 UINavigationBar 时，返回手势中若碰到前一个页面有 bar，后一个页面没 bar，或者反过来时，动画就非常难看，举两个反例：  \n\n手Q iOS：  \n\n![](http://ww2.sinaimg.cn/large/51530583jw1esvbwqgawtg208w0fvu0x.gif)\n\n它的个人中心页面上面的 bar 是隐藏状态，然后做了个和其他页面很像的假 bar，但返回手势一开始就露馅了，为了弥补，还做了下后面真 bar 的 alpha 值动画，两个返回按钮还是重叠在了一起。  \n\n新浪微博 iOS：  \n\n![](http://ww4.sinaimg.cn/large/51530583jw1esvbwfphj8g208w0fv4qp.gif)\n\n和手Q一样的实现方式，只不过没做 alpha 动画，所以就非常明显了。  \n\n为啥会这样呢？这可能就是 UINavigationController 在导航栏控制 API 上设计的缺陷了。 一个 UINavigationController 管理了串行的 N 个 UIViewController 栈式的 push 和 pop，而 UINavigationBar 由 UINavigationController 管理，这就导致了 UIViewController 无法控制自己上面的 bar 单独的隐藏或显示。 这非常像 UIApplication 全局的 status bar，牵一发还得动全身，不过 Apple 在 iOS7 之后为 vc 控制自己的 status bar 提供了下面几个方法：  \n\n``` objc\n- (UIStatusBarStyle)preferredStatusBarStyle NS_AVAILABLE_IOS(7_0);\n- (BOOL)prefersStatusBarHidden NS_AVAILABLE_IOS(7_0);\n- (UIStatusBarAnimation)preferredStatusBarUpdateAnimation NS_AVAILABLE_IOS(7_0);\n```\n\n终于让这个**全局变量**变成了**局部变量**，虽然写起来费劲了些。  \n但是对 UINavigationBar 的控制，依然是全局的，可能 Apple 觉得 App 不应该有这种奇怪的页面结构？  \n\n解决这个问题的方法也不难，在滑动返回的后要出现的那个 view controller 中写下面的代码：  \n\n``` objc\n- (void)viewWillAppear:(BOOL)animated {\n    [super viewWillAppear:animated];\n    [self.navigationController setNavigationBarHidden:YES animated:animated];\n}\n```\n\n系统就会把有 bar 和 无 bar 的 transition 动画衔接起来。但是如上面所说，这是个全局变量，还得在所有由这个没有 bar 的特殊页面能 push 和 pop 的页面都进行反向的处理，代码非常的乱乎。于是乎，我们试着解决了这个问题，先看效果：  \n\n![](http://ww2.sinaimg.cn/large/51530583jw1esvbwmjck8g208w0ft7wj.gif)\n\n我特意挑了个从真 bar 到假 bar，再从假 bar 到 真 bar 的页面，还算蛮丝滑的，transition 动画全是系统自己搞定的。  \n就事把 `FDFullscreenPopGesture` 更新到了 1.1 版本，贯彻我们一向的精简 API，你只需要在 bar 要隐藏的 view controller 中写一句话：  \n\n``` objc\n- (void)viewDidLoad\n    [super viewDidLoad];\n    self.navigationController.fd_prefersNavigationBarHidden = YES;\n}\n```\n\n或者喜欢重载的写法也行：  \n\n``` objc\n- (BOOL)fd_prefersNavigationBarHidden {\n    return YES;\n}\n```\n\n刻意的模仿了下系统的命名风格，就这一句话，剩下的就都不用操心了。  \n\n# 关于私有API\n\n大家会质疑说，这用到了 UIKit 的私有属性和私有 API，要是系统升级变了咋办？要是审核被拒了咋办？  \n首先，iOS 系统的 SDK 为了向下兼容，一般只会增加方法或者修改方法实现，不太可能直接删除一个共有方法，而私有方法的行为确实可能有变化，但系统 release 频率毕竟很低，每当新版本发布时 check 下原来的功能是否能 work 就好了，大可不必担心这么远，SDK 是死的人是活的。  \n另一个就是审核问题，FDFullscreenPopGesture 的实现中有主要有两处触碰到了私有 API：  \n\n``` objc\n// 1. 私有变量标志transition动画是否正在进行\n[self.navigationController valueForKey:@\"_isTransitioning\"];\n// 2. 一个内部的selector\nNSSelectorFromString(@\"handleNavigationTransition:\");\n```\n\n不论是 kvc 还是 selector 反射，都是利用 objc runtime 完成的，而到了这一层，真的就没啥公有私有可言了。设想你就是开发 Apple 私有 API 检查工具的工程师，给你一个 ipa 的包，你会如何检查出其中有没有私有 API 呢？  \n\n首先，这个检查一定是个静态检查吧，不可能是运行时检查，因为代码逻辑那么复杂，把程序跑起来看所有 objc_msgSend 中包不包括私有调用这件事太不现实了。  \n对 ipa 文件做静态检查的话肯定是去分析 Mach-O 可执行文件，因为这时很多源代码级别的信息已经丢失，经分析可以采取下面几种手段：  \n\n- 是否 link 了私有 framework 或者公开 framework 中的私有符号，这可以防止开发者把私有 header 都 dump 出来供程序直接调用。  \n- 同上，使用`@selector(_private_sel)`加上`-performSelector:`的方式直接调用私有 API。\n- 扫描所有符号，查看是否有继承自私有类，重载私有方法，方法名是否有重合。\n- 扫描所有**string**，看字符串常量段是否出现和私有 API 对应的。\n\n我觉得前三条被 catch 住的可能性最高，也最容易被检查出来。再来看我们用到用字符串的方法 kvc 和 反射 selector，应该属于最后一条，这时候就很难抉择了，拿 `handleNavigationTransition:` 来说，看上去人畜无害啊，我自己类里面的方法也完全可能命名出这个来，所以单单凭借字符串命中私有 API 判定，苹果很容易误伤一大票开发者。  \n综上，我觉得使用字符串的方式使用私有 API 是相对安全的，我们的 App 马上要提交审核，如果过了几天你还能读到这段文字，说明我的猜想是木有错的，大家可以放心使用。\n\n# 0 代码的 Demo\n\n还有一个有意思的事，我们在 github 上的 [demo工程](https://github.com/forkingdog/FDFullscreenPopGesture) 木有写一行代码，就实现了下面的效果：\n\n![](https://raw.githubusercontent.com/forkingdog/FDFullscreenPopGesture/master/Snapshots/snapshot1.gif)\n\n工程长这个样子，view controller 类也没写，为了体现 `FDFullscreenPopGesture` 的 AOP 性质：  \n\n<img src=\"http://ww3.sinaimg.cn/large/51530583jw1esveprvnvfj20ju0d2tbm.jpg\" width=\"320\">\n\n页面由 Storyboard 构建：  \n\n<img src=\"http://ww3.sinaimg.cn/large/51530583jw1esvepscqomj212m10eq5a.jpg\" width=\"640\">\n\n而控制页面隐藏 bar 的属性也能用 Runtime Attributes 模拟调用：  \n\n<img src=\"http://ww2.sinaimg.cn/large/51530583jw1esvetev633j20ig05ydgl.jpg\" width=\"320\">\n\n这样就完成了一个非常干净的 Demo\n\n# 加入到你的工程中\n\n首先要求最低支持 iOS7，我想在 WWDC 2015 结束，iOS9 发布后，主流的 App 就都会 iOS7 起跳了。  \n依然是熟悉的 cocoapods 安装：\n\n``` objc\npod 'FDFullscreenPopGesture', '~> 1.1'\n```\n\n要是没有搜到就 `pod setup` 下。\n\n# 广告时间  \n\n我这边正在招聘 iOS，坐标北京，希望找到一个代码规范的、爱用 IB 的、懒得写重复代码、不爱加班的同学，相信这里有很大空间供你学习和提升，还可以参与到 forkingdog 开源小组中做点屌屌的东西，欢迎私聊或把简历丢到 sunyuan01@baidu.com   \n\n<img src=\"https://cloud.githubusercontent.com/assets/219689/7244961/4209de32-e816-11e4-87bc-b161c442d348.png\" width=\"640\">\n","slug":"fullscreen-pop-gesture","published":1,"updated":"2016-03-26T08:58:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxjx0009ev12ieb16bo1","content":"<h1 id=\"全屏返回手势\"><a href=\"#全屏返回手势\" class=\"headerlink\" title=\"全屏返回手势\"></a>全屏返回手势</h1><p>自 iOS7 之后，Apple 增加了<strong>屏幕边缘右划返回</strong>交互的支持，再配合上 UINavigationController 的交互式动画，pop 到上一级页面的操作变的非常顺畅和丝滑，从此，我很少再使用点击左上角导航栏上的返回按钮的方式返回了，因为这对单手操作十分不友好；如果一个 App 居然胆敢不支持滑动返回，那离被卸载就不远了。  </p>\n<p>说到<strong>全屏返回手势</strong>，首先我感觉这件事本身可能就有问题，毕竟有点反苹果官方的交互，让用户从任意的地方都能够滑动返回这个交互在国内的 App 中非常普遍，比如我手机中的手Q、微博、网易新闻、大众点评等，当然还有百度知道- -。这里得对微信的产品经理们得点个赞，从整个 App 来看，不论是交互还是 UI 结构和样式都非常的 iOS，没有什么特别奇葩的页面和交互，以至于使用 UIKit 原生的框架可以非常简单的搭建起来，这也符合我个人对 App 的一个愿景：<strong>一个优秀的 App 不论从用户角度看还是从代码角度看都应该是简单且优雅的</strong>，呼吁各家产品经理可以多借鉴下像微信这样很本色的 App 设计。（以后可以分享下如何使用 Storyboard 在一小时内快速搭建起微信 UI）  </p>\n<h1 id=\"FDFullscreenPopGesture\"><a href=\"#FDFullscreenPopGesture\" class=\"headerlink\" title=\"FDFullscreenPopGesture\"></a>FDFullscreenPopGesture</h1><p>工作毕竟是工作，于是乎所以就被迫实现了套 pan 手势处理加截图和视差，虽然在运动曲线上、bar 截图处理上下了不少功夫，但距离系统的丝滑效果还是差距挺远。随时间推移，终于能够最低支持 iOS7 后，我们把这个问题再次拿出来讨论和研究，直到在微博上看到了 <strong>J_雨</strong>同学的<a href=\"http://www.jianshu.com/p/d39f7d22db6c\" target=\"_blank\" rel=\"external\">这篇文章</a> 后才找到了这个迄今为止最简单的解决方案。于是乎在他的授权下，我们在 forkingdog 上把这个返回手势开源，<a href=\"https://github.com/forkingdog/FDFullscreenPopGesture\" target=\"_blank\" rel=\"external\">github地址</a>，并果断应用到了百度知道 App 内，这是 Demo 效果：  </p>\n<p><img src=\"https://raw.githubusercontent.com/forkingdog/FDFullscreenPopGesture/master/Snapshots/snapshot0.gif\" alt=\"\">   </p>\n<p>利用了系统自己的边缘返回手势处理函数后，一切动画和曲线都和原生效果一毛一样了。<br>于是乎发布了 <code>FDFullscreenPopGesture</code> 1.0 版本，而且提供了一个 AOP 形式的 API，把它添加到工程里面，什么代码都不用写，所有 UINavigationController 就自带这个全屏返回效果了。  </p>\n<h1 id=\"丝滑的处理导航栏的显示和隐藏\"><a href=\"#丝滑的处理导航栏的显示和隐藏\" class=\"headerlink\" title=\"丝滑的处理导航栏的显示和隐藏\"></a>丝滑的处理导航栏的显示和隐藏</h1><p>接下来我们发现利用系统的 UINavigationBar 时，返回手势中若碰到前一个页面有 bar，后一个页面没 bar，或者反过来时，动画就非常难看，举两个反例：  </p>\n<p>手Q iOS：  </p>\n<p><img src=\"http://ww2.sinaimg.cn/large/51530583jw1esvbwqgawtg208w0fvu0x.gif\" alt=\"\"></p>\n<p>它的个人中心页面上面的 bar 是隐藏状态，然后做了个和其他页面很像的假 bar，但返回手势一开始就露馅了，为了弥补，还做了下后面真 bar 的 alpha 值动画，两个返回按钮还是重叠在了一起。  </p>\n<p>新浪微博 iOS：  </p>\n<p><img src=\"http://ww4.sinaimg.cn/large/51530583jw1esvbwfphj8g208w0fv4qp.gif\" alt=\"\"></p>\n<p>和手Q一样的实现方式，只不过没做 alpha 动画，所以就非常明显了。  </p>\n<p>为啥会这样呢？这可能就是 UINavigationController 在导航栏控制 API 上设计的缺陷了。 一个 UINavigationController 管理了串行的 N 个 UIViewController 栈式的 push 和 pop，而 UINavigationBar 由 UINavigationController 管理，这就导致了 UIViewController 无法控制自己上面的 bar 单独的隐藏或显示。 这非常像 UIApplication 全局的 status bar，牵一发还得动全身，不过 Apple 在 iOS7 之后为 vc 控制自己的 status bar 提供了下面几个方法：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIStatusBarStyle</span>)preferredStatusBarStyle <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">7</span>_0);</span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)prefersStatusBarHidden <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">7</span>_0);</span><br><span class=\"line\">- (<span class=\"built_in\">UIStatusBarAnimation</span>)preferredStatusBarUpdateAnimation <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">7</span>_0);</span><br></pre></td></tr></table></figure>\n<p>终于让这个<strong>全局变量</strong>变成了<strong>局部变量</strong>，虽然写起来费劲了些。<br>但是对 UINavigationBar 的控制，依然是全局的，可能 Apple 觉得 App 不应该有这种奇怪的页面结构？  </p>\n<p>解决这个问题的方法也不难，在滑动返回的后要出现的那个 view controller 中写下面的代码：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewWillAppear:(<span class=\"built_in\">BOOL</span>)animated &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewWillAppear:animated];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.navigationController setNavigationBarHidden:<span class=\"literal\">YES</span> animated:animated];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>系统就会把有 bar 和 无 bar 的 transition 动画衔接起来。但是如上面所说，这是个全局变量，还得在所有由这个没有 bar 的特殊页面能 push 和 pop 的页面都进行反向的处理，代码非常的乱乎。于是乎，我们试着解决了这个问题，先看效果：  </p>\n<p><img src=\"http://ww2.sinaimg.cn/large/51530583jw1esvbwmjck8g208w0ft7wj.gif\" alt=\"\"></p>\n<p>我特意挑了个从真 bar 到假 bar，再从假 bar 到 真 bar 的页面，还算蛮丝滑的，transition 动画全是系统自己搞定的。<br>就事把 <code>FDFullscreenPopGesture</code> 更新到了 1.1 版本，贯彻我们一向的精简 API，你只需要在 bar 要隐藏的 view controller 中写一句话：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.navigationController.fd_prefersNavigationBarHidden = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者喜欢重载的写法也行：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)fd_prefersNavigationBarHidden &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>刻意的模仿了下系统的命名风格，就这一句话，剩下的就都不用操心了。  </p>\n<h1 id=\"关于私有API\"><a href=\"#关于私有API\" class=\"headerlink\" title=\"关于私有API\"></a>关于私有API</h1><p>大家会质疑说，这用到了 UIKit 的私有属性和私有 API，要是系统升级变了咋办？要是审核被拒了咋办？<br>首先，iOS 系统的 SDK 为了向下兼容，一般只会增加方法或者修改方法实现，不太可能直接删除一个共有方法，而私有方法的行为确实可能有变化，但系统 release 频率毕竟很低，每当新版本发布时 check 下原来的功能是否能 work 就好了，大可不必担心这么远，SDK 是死的人是活的。<br>另一个就是审核问题，FDFullscreenPopGesture 的实现中有主要有两处触碰到了私有 API：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 私有变量标志transition动画是否正在进行</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.navigationController valueForKey:<span class=\"string\">@\"_isTransitioning\"</span>];</span><br><span class=\"line\"><span class=\"comment\">// 2. 一个内部的selector</span></span><br><span class=\"line\"><span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"handleNavigationTransition:\"</span>);</span><br></pre></td></tr></table></figure>\n<p>不论是 kvc 还是 selector 反射，都是利用 objc runtime 完成的，而到了这一层，真的就没啥公有私有可言了。设想你就是开发 Apple 私有 API 检查工具的工程师，给你一个 ipa 的包，你会如何检查出其中有没有私有 API 呢？  </p>\n<p>首先，这个检查一定是个静态检查吧，不可能是运行时检查，因为代码逻辑那么复杂，把程序跑起来看所有 objc_msgSend 中包不包括私有调用这件事太不现实了。<br>对 ipa 文件做静态检查的话肯定是去分析 Mach-O 可执行文件，因为这时很多源代码级别的信息已经丢失，经分析可以采取下面几种手段：  </p>\n<ul>\n<li>是否 link 了私有 framework 或者公开 framework 中的私有符号，这可以防止开发者把私有 header 都 dump 出来供程序直接调用。  </li>\n<li>同上，使用<code>@selector(_private_sel)</code>加上<code>-performSelector:</code>的方式直接调用私有 API。</li>\n<li>扫描所有符号，查看是否有继承自私有类，重载私有方法，方法名是否有重合。</li>\n<li>扫描所有<strong>string</strong>，看字符串常量段是否出现和私有 API 对应的。</li>\n</ul>\n<p>我觉得前三条被 catch 住的可能性最高，也最容易被检查出来。再来看我们用到用字符串的方法 kvc 和 反射 selector，应该属于最后一条，这时候就很难抉择了，拿 <code>handleNavigationTransition:</code> 来说，看上去人畜无害啊，我自己类里面的方法也完全可能命名出这个来，所以单单凭借字符串命中私有 API 判定，苹果很容易误伤一大票开发者。<br>综上，我觉得使用字符串的方式使用私有 API 是相对安全的，我们的 App 马上要提交审核，如果过了几天你还能读到这段文字，说明我的猜想是木有错的，大家可以放心使用。</p>\n<h1 id=\"0-代码的-Demo\"><a href=\"#0-代码的-Demo\" class=\"headerlink\" title=\"0 代码的 Demo\"></a>0 代码的 Demo</h1><p>还有一个有意思的事，我们在 github 上的 <a href=\"https://github.com/forkingdog/FDFullscreenPopGesture\" target=\"_blank\" rel=\"external\">demo工程</a> 木有写一行代码，就实现了下面的效果：</p>\n<p><img src=\"https://raw.githubusercontent.com/forkingdog/FDFullscreenPopGesture/master/Snapshots/snapshot1.gif\" alt=\"\"></p>\n<p>工程长这个样子，view controller 类也没写，为了体现 <code>FDFullscreenPopGesture</code> 的 AOP 性质：  </p>\n<p><img src=\"http://ww3.sinaimg.cn/large/51530583jw1esveprvnvfj20ju0d2tbm.jpg\" width=\"320\"></p>\n<p>页面由 Storyboard 构建：  </p>\n<p><img src=\"http://ww3.sinaimg.cn/large/51530583jw1esvepscqomj212m10eq5a.jpg\" width=\"640\"></p>\n<p>而控制页面隐藏 bar 的属性也能用 Runtime Attributes 模拟调用：  </p>\n<p><img src=\"http://ww2.sinaimg.cn/large/51530583jw1esvetev633j20ig05ydgl.jpg\" width=\"320\"></p>\n<p>这样就完成了一个非常干净的 Demo</p>\n<h1 id=\"加入到你的工程中\"><a href=\"#加入到你的工程中\" class=\"headerlink\" title=\"加入到你的工程中\"></a>加入到你的工程中</h1><p>首先要求最低支持 iOS7，我想在 WWDC 2015 结束，iOS9 发布后，主流的 App 就都会 iOS7 起跳了。<br>依然是熟悉的 cocoapods 安装：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod 'FDFullscreenPopGesture', '~&gt; 1.1'</span><br></pre></td></tr></table></figure>\n<p>要是没有搜到就 <code>pod setup</code> 下。</p>\n<h1 id=\"广告时间\"><a href=\"#广告时间\" class=\"headerlink\" title=\"广告时间\"></a>广告时间</h1><p>我这边正在招聘 iOS，坐标北京，希望找到一个代码规范的、爱用 IB 的、懒得写重复代码、不爱加班的同学，相信这里有很大空间供你学习和提升，还可以参与到 forkingdog 开源小组中做点屌屌的东西，欢迎私聊或把简历丢到 sunyuan01@baidu.com   </p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/219689/7244961/4209de32-e816-11e4-87bc-b161c442d348.png\" width=\"640\"></p>\n","excerpt":"","more":"<h1 id=\"全屏返回手势\"><a href=\"#全屏返回手势\" class=\"headerlink\" title=\"全屏返回手势\"></a>全屏返回手势</h1><p>自 iOS7 之后，Apple 增加了<strong>屏幕边缘右划返回</strong>交互的支持，再配合上 UINavigationController 的交互式动画，pop 到上一级页面的操作变的非常顺畅和丝滑，从此，我很少再使用点击左上角导航栏上的返回按钮的方式返回了，因为这对单手操作十分不友好；如果一个 App 居然胆敢不支持滑动返回，那离被卸载就不远了。  </p>\n<p>说到<strong>全屏返回手势</strong>，首先我感觉这件事本身可能就有问题，毕竟有点反苹果官方的交互，让用户从任意的地方都能够滑动返回这个交互在国内的 App 中非常普遍，比如我手机中的手Q、微博、网易新闻、大众点评等，当然还有百度知道- -。这里得对微信的产品经理们得点个赞，从整个 App 来看，不论是交互还是 UI 结构和样式都非常的 iOS，没有什么特别奇葩的页面和交互，以至于使用 UIKit 原生的框架可以非常简单的搭建起来，这也符合我个人对 App 的一个愿景：<strong>一个优秀的 App 不论从用户角度看还是从代码角度看都应该是简单且优雅的</strong>，呼吁各家产品经理可以多借鉴下像微信这样很本色的 App 设计。（以后可以分享下如何使用 Storyboard 在一小时内快速搭建起微信 UI）  </p>\n<h1 id=\"FDFullscreenPopGesture\"><a href=\"#FDFullscreenPopGesture\" class=\"headerlink\" title=\"FDFullscreenPopGesture\"></a>FDFullscreenPopGesture</h1><p>工作毕竟是工作，于是乎所以就被迫实现了套 pan 手势处理加截图和视差，虽然在运动曲线上、bar 截图处理上下了不少功夫，但距离系统的丝滑效果还是差距挺远。随时间推移，终于能够最低支持 iOS7 后，我们把这个问题再次拿出来讨论和研究，直到在微博上看到了 <strong>J_雨</strong>同学的<a href=\"http://www.jianshu.com/p/d39f7d22db6c\">这篇文章</a> 后才找到了这个迄今为止最简单的解决方案。于是乎在他的授权下，我们在 forkingdog 上把这个返回手势开源，<a href=\"https://github.com/forkingdog/FDFullscreenPopGesture\">github地址</a>，并果断应用到了百度知道 App 内，这是 Demo 效果：  </p>\n<p><img src=\"https://raw.githubusercontent.com/forkingdog/FDFullscreenPopGesture/master/Snapshots/snapshot0.gif\" alt=\"\">   </p>\n<p>利用了系统自己的边缘返回手势处理函数后，一切动画和曲线都和原生效果一毛一样了。<br>于是乎发布了 <code>FDFullscreenPopGesture</code> 1.0 版本，而且提供了一个 AOP 形式的 API，把它添加到工程里面，什么代码都不用写，所有 UINavigationController 就自带这个全屏返回效果了。  </p>\n<h1 id=\"丝滑的处理导航栏的显示和隐藏\"><a href=\"#丝滑的处理导航栏的显示和隐藏\" class=\"headerlink\" title=\"丝滑的处理导航栏的显示和隐藏\"></a>丝滑的处理导航栏的显示和隐藏</h1><p>接下来我们发现利用系统的 UINavigationBar 时，返回手势中若碰到前一个页面有 bar，后一个页面没 bar，或者反过来时，动画就非常难看，举两个反例：  </p>\n<p>手Q iOS：  </p>\n<p><img src=\"http://ww2.sinaimg.cn/large/51530583jw1esvbwqgawtg208w0fvu0x.gif\" alt=\"\"></p>\n<p>它的个人中心页面上面的 bar 是隐藏状态，然后做了个和其他页面很像的假 bar，但返回手势一开始就露馅了，为了弥补，还做了下后面真 bar 的 alpha 值动画，两个返回按钮还是重叠在了一起。  </p>\n<p>新浪微博 iOS：  </p>\n<p><img src=\"http://ww4.sinaimg.cn/large/51530583jw1esvbwfphj8g208w0fv4qp.gif\" alt=\"\"></p>\n<p>和手Q一样的实现方式，只不过没做 alpha 动画，所以就非常明显了。  </p>\n<p>为啥会这样呢？这可能就是 UINavigationController 在导航栏控制 API 上设计的缺陷了。 一个 UINavigationController 管理了串行的 N 个 UIViewController 栈式的 push 和 pop，而 UINavigationBar 由 UINavigationController 管理，这就导致了 UIViewController 无法控制自己上面的 bar 单独的隐藏或显示。 这非常像 UIApplication 全局的 status bar，牵一发还得动全身，不过 Apple 在 iOS7 之后为 vc 控制自己的 status bar 提供了下面几个方法：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIStatusBarStyle</span>)preferredStatusBarStyle <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">7</span>_0);</span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)prefersStatusBarHidden <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">7</span>_0);</span><br><span class=\"line\">- (<span class=\"built_in\">UIStatusBarAnimation</span>)preferredStatusBarUpdateAnimation <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">7</span>_0);</span><br></pre></td></tr></table></figure>\n<p>终于让这个<strong>全局变量</strong>变成了<strong>局部变量</strong>，虽然写起来费劲了些。<br>但是对 UINavigationBar 的控制，依然是全局的，可能 Apple 觉得 App 不应该有这种奇怪的页面结构？  </p>\n<p>解决这个问题的方法也不难，在滑动返回的后要出现的那个 view controller 中写下面的代码：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewWillAppear:(<span class=\"built_in\">BOOL</span>)animated &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewWillAppear:animated];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.navigationController setNavigationBarHidden:<span class=\"literal\">YES</span> animated:animated];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>系统就会把有 bar 和 无 bar 的 transition 动画衔接起来。但是如上面所说，这是个全局变量，还得在所有由这个没有 bar 的特殊页面能 push 和 pop 的页面都进行反向的处理，代码非常的乱乎。于是乎，我们试着解决了这个问题，先看效果：  </p>\n<p><img src=\"http://ww2.sinaimg.cn/large/51530583jw1esvbwmjck8g208w0ft7wj.gif\" alt=\"\"></p>\n<p>我特意挑了个从真 bar 到假 bar，再从假 bar 到 真 bar 的页面，还算蛮丝滑的，transition 动画全是系统自己搞定的。<br>就事把 <code>FDFullscreenPopGesture</code> 更新到了 1.1 版本，贯彻我们一向的精简 API，你只需要在 bar 要隐藏的 view controller 中写一句话：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.navigationController.fd_prefersNavigationBarHidden = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者喜欢重载的写法也行：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)fd_prefersNavigationBarHidden &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>刻意的模仿了下系统的命名风格，就这一句话，剩下的就都不用操心了。  </p>\n<h1 id=\"关于私有API\"><a href=\"#关于私有API\" class=\"headerlink\" title=\"关于私有API\"></a>关于私有API</h1><p>大家会质疑说，这用到了 UIKit 的私有属性和私有 API，要是系统升级变了咋办？要是审核被拒了咋办？<br>首先，iOS 系统的 SDK 为了向下兼容，一般只会增加方法或者修改方法实现，不太可能直接删除一个共有方法，而私有方法的行为确实可能有变化，但系统 release 频率毕竟很低，每当新版本发布时 check 下原来的功能是否能 work 就好了，大可不必担心这么远，SDK 是死的人是活的。<br>另一个就是审核问题，FDFullscreenPopGesture 的实现中有主要有两处触碰到了私有 API：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 私有变量标志transition动画是否正在进行</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.navigationController valueForKey:<span class=\"string\">@\"_isTransitioning\"</span>];</span><br><span class=\"line\"><span class=\"comment\">// 2. 一个内部的selector</span></span><br><span class=\"line\"><span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"handleNavigationTransition:\"</span>);</span><br></pre></td></tr></table></figure>\n<p>不论是 kvc 还是 selector 反射，都是利用 objc runtime 完成的，而到了这一层，真的就没啥公有私有可言了。设想你就是开发 Apple 私有 API 检查工具的工程师，给你一个 ipa 的包，你会如何检查出其中有没有私有 API 呢？  </p>\n<p>首先，这个检查一定是个静态检查吧，不可能是运行时检查，因为代码逻辑那么复杂，把程序跑起来看所有 objc_msgSend 中包不包括私有调用这件事太不现实了。<br>对 ipa 文件做静态检查的话肯定是去分析 Mach-O 可执行文件，因为这时很多源代码级别的信息已经丢失，经分析可以采取下面几种手段：  </p>\n<ul>\n<li>是否 link 了私有 framework 或者公开 framework 中的私有符号，这可以防止开发者把私有 header 都 dump 出来供程序直接调用。  </li>\n<li>同上，使用<code>@selector(_private_sel)</code>加上<code>-performSelector:</code>的方式直接调用私有 API。</li>\n<li>扫描所有符号，查看是否有继承自私有类，重载私有方法，方法名是否有重合。</li>\n<li>扫描所有<strong>string</strong>，看字符串常量段是否出现和私有 API 对应的。</li>\n</ul>\n<p>我觉得前三条被 catch 住的可能性最高，也最容易被检查出来。再来看我们用到用字符串的方法 kvc 和 反射 selector，应该属于最后一条，这时候就很难抉择了，拿 <code>handleNavigationTransition:</code> 来说，看上去人畜无害啊，我自己类里面的方法也完全可能命名出这个来，所以单单凭借字符串命中私有 API 判定，苹果很容易误伤一大票开发者。<br>综上，我觉得使用字符串的方式使用私有 API 是相对安全的，我们的 App 马上要提交审核，如果过了几天你还能读到这段文字，说明我的猜想是木有错的，大家可以放心使用。</p>\n<h1 id=\"0-代码的-Demo\"><a href=\"#0-代码的-Demo\" class=\"headerlink\" title=\"0 代码的 Demo\"></a>0 代码的 Demo</h1><p>还有一个有意思的事，我们在 github 上的 <a href=\"https://github.com/forkingdog/FDFullscreenPopGesture\">demo工程</a> 木有写一行代码，就实现了下面的效果：</p>\n<p><img src=\"https://raw.githubusercontent.com/forkingdog/FDFullscreenPopGesture/master/Snapshots/snapshot1.gif\" alt=\"\"></p>\n<p>工程长这个样子，view controller 类也没写，为了体现 <code>FDFullscreenPopGesture</code> 的 AOP 性质：  </p>\n<p><img src=\"http://ww3.sinaimg.cn/large/51530583jw1esveprvnvfj20ju0d2tbm.jpg\" width=\"320\"></p>\n<p>页面由 Storyboard 构建：  </p>\n<p><img src=\"http://ww3.sinaimg.cn/large/51530583jw1esvepscqomj212m10eq5a.jpg\" width=\"640\"></p>\n<p>而控制页面隐藏 bar 的属性也能用 Runtime Attributes 模拟调用：  </p>\n<p><img src=\"http://ww2.sinaimg.cn/large/51530583jw1esvetev633j20ig05ydgl.jpg\" width=\"320\"></p>\n<p>这样就完成了一个非常干净的 Demo</p>\n<h1 id=\"加入到你的工程中\"><a href=\"#加入到你的工程中\" class=\"headerlink\" title=\"加入到你的工程中\"></a>加入到你的工程中</h1><p>首先要求最低支持 iOS7，我想在 WWDC 2015 结束，iOS9 发布后，主流的 App 就都会 iOS7 起跳了。<br>依然是熟悉的 cocoapods 安装：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod 'FDFullscreenPopGesture', '~&gt; 1.1'</span><br></pre></td></tr></table></figure>\n<p>要是没有搜到就 <code>pod setup</code> 下。</p>\n<h1 id=\"广告时间\"><a href=\"#广告时间\" class=\"headerlink\" title=\"广告时间\"></a>广告时间</h1><p>我这边正在招聘 iOS，坐标北京，希望找到一个代码规范的、爱用 IB 的、懒得写重复代码、不爱加班的同学，相信这里有很大空间供你学习和提升，还可以参与到 forkingdog 开源小组中做点屌屌的东西，欢迎私聊或把简历丢到 sunyuan01@baidu.com   </p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/219689/7244961/4209de32-e816-11e4-87bc-b161c442d348.png\" width=\"640\"></p>\n"},{"title":"( ) -> ( )","date":"2014-10-14T11:44:42.000Z","_content":"\n# 我是前言\n\n`() -> ()`不是什么表情符号，而是一种高度抽象的编程范式，它表示了一个函数式的编程思想，即`值`的变化过程。本文将从`swift`语言入手分析，元组，函数，闭包等的设计对它进行解释，并阐释swift语言设计的大局观。随后分享一个`Reactive Cocoa`作者的Talk中的编程思想。\n\n\n# 编程的核心\n\n编程的无非两件事，`数据`和`运算`。  \n放在计算机硬件，是内存和CPU；\n放在C语言，是结构体和函数（基本类型本质上就是一个只有一个字段的结构体）；\n放在面向对象的语言，是类和消息；\n放在函数式语言，就是值和函数了\n\n如果用`()`表示数据，`->`表示运算，也是醉了\n\n# 从Swift说起\n\n\n## ->表示运算过程\n\n熟悉swift的同学肯定能联想到swift中函数的表示方法\n\n``` swift\nfunc foo(number: Int) -> Int {\n    return 1\n}\nlet f = foo // f的类型为 (Int) -> Int\n```\n\n把参数通通去掉之后就成了`() -> ()`\n\n``` swift\nfunc foo () -> () {\n    // ...\n}\n```\n\n像好多吐槽swift语法的人一样，起初我也不理解为什么用这么个奇葩的`->`来表示返回值，其实它并非表示返回值，而是表示`运算过程`，从入参到返回值的过程。按这个思路来看，把返回值写在函数声明前面倒是有点说不通了。\n\n## 元组表示所有的值\n\n再来说说这个`()`，在swift里面表示元组（tuple），值得一提的是，swift里面任何值都是一个tuple，且一共有三种Tuple：\n\n- **0-Tuple**表示空值，也就是`Void` （Void是`()`的别名）\n- **1-Tuple**表示任意一个类型的实例（Int、String、对象、枚举等等），也就是说`Int`其实是一个`(Int)`，`String`是一个`(String)`，以此类推，所以有下面的写法：\n\n\t``` swift\n\t\tvar i: Int = 1\n\t\ti.0.0.0.0.0.0 // 1\n\t\tvar a = [\"A\", \"B\", \"C\"]\n\t\ta.0.0.0.0.0.0 // [\"A\", \"B\", \"C\"]\n\t```\n\n- **N-Tuple**表示两个以上值的组合，如`(2, \"B\")`\n\n## func是一种特殊的block\n\n一开始我认为block是一种特殊的func，后来发现反过来理解更加合理。  \n\n``` swift\nclass Foo {\n    func bar(i: Int) {\n       // ...\n    }\n}\nvar f = Foo.bar\n```\n\n其中f的类型为`Foo -> (Int) -> ()`，用括号结合一下更好理解：`Foo -> (Int -> ())`，外层传入一个Foo的实例，返回值是一个`(Int) -> ()`的函数\n\n知道这一点，上面的方法用一个block也能轻松搞定：\n\n``` swift\nvar bar = {(f: Foo) -> (Int) -> () in\n    return {(i: Int) in\n        // ...\n    }\n}\n```\n\n所以说，一个`func`只是在一个`class`（或struct、enum）作用域中一个特殊的block罢了，隐式的被传入了第一层的`self`参数而已。再多想一步，假如外部有一个全局变量，在`func`中是可以访问，多么像block的捕获外部变量呢。\n\n## swift函数式世界观\n\n讲到这儿，swift中的`数据`+`运算`就可以被抽象成：`() -> ()`了，一切结构、函数、block，各种调用，本质上都可以被归纳成**从一个元组经过运算得到另一个元组的过程**，这不就是`函数式编程`么。\n当然，这个思想也不孤单，`java script`中也用`=>`来表示相同的概念\n\n\n# Reactive Cocoa作者谈未来\n\n说完了swift，再来说`Reactive Cocoa`  \nRAC可以说是对objc语言和runtime机制使用最深刻的开源库之一了，可见作者对水平。他的`《The Future of Reactive Cocoa》`的Talk很有趣，pdf可以从[这个git地址下载](https://github.com/jspahrsummers/the-future-of-reactivecocoa)\n\n他把函数式编程中的Event分成：\n\n- Observer（Push）: `Event -> ()`\n- Obserable（Push）: `(Event -> ()) -> ()`\n- Enumerator（Pull）: `() -> Event`\n- Enumerable（Pull）: `() -> (() -> Event)`\n\n先不说具体含义，这个抽象范式的表示方法就与上面提到一致。熟悉RAC的同学将会对上面精简的概括叫绝。\n拿第二个，Obserable来说，这就是RAC中的`RACSignal`，后面的范式表示这个Event可以串联起来（当返回值的也是一个同样结构的函数时）：\n`(Event1 -> ()) -> (Event2 -> ()) ->...-> (EventN -> ()) -> ()`\n\n## 不寻常意义的Enumerator\n\n这里的Enumerator不是通常意义上的`for-in`语句中使用的枚举器，而是代表了一种`延时计算`的思想：不到最后一刻，这个值一直不被计算出来，向它套用的函数也都将延时到最后才依次计算。其实swift在语言基本库中就实现了它，名为`LazyBidirectionalCollection`，如一个字典：\n\n``` swift\nvar dict = [\"A\": 1, \"B\": 2]\nvar generator = dict.keys.map({$0.lowercaseString}).generate()\ngenerator.next()! // \"b\" （这里进行一次计算）\ngenerator.next()! // \"a\" （这里进行后一次计算）\n```\n\n# 跑题了，往回拉拉\n\n`()`表示任意的值  \n`->`表示运算过程  \n所以`() -> ()`表示一个任意的函数  \n\n函数作为一等公民，可以作为值进行传递，所以上面的范式中的值也可以是函数，于是衍生出  \n`(() -> ()) -> ()`或`() -> (() -> ())`\n\n这就是函数式编程\n\n# Reference\n\nhttps://medium.com/swift-programming/facets-of-swift-part-2-tuples-4bfe58d21abf\nhttps://github.com/jspahrsummers/the-future-of-reactivecocoa\n","source":"_posts/fp-essential.md","raw":"title: ( ) -> ( )\ndate: 2014-10-14 19:44:42\ntags: wtf\n---\n\n# 我是前言\n\n`() -> ()`不是什么表情符号，而是一种高度抽象的编程范式，它表示了一个函数式的编程思想，即`值`的变化过程。本文将从`swift`语言入手分析，元组，函数，闭包等的设计对它进行解释，并阐释swift语言设计的大局观。随后分享一个`Reactive Cocoa`作者的Talk中的编程思想。\n\n\n# 编程的核心\n\n编程的无非两件事，`数据`和`运算`。  \n放在计算机硬件，是内存和CPU；\n放在C语言，是结构体和函数（基本类型本质上就是一个只有一个字段的结构体）；\n放在面向对象的语言，是类和消息；\n放在函数式语言，就是值和函数了\n\n如果用`()`表示数据，`->`表示运算，也是醉了\n\n# 从Swift说起\n\n\n## ->表示运算过程\n\n熟悉swift的同学肯定能联想到swift中函数的表示方法\n\n``` swift\nfunc foo(number: Int) -> Int {\n    return 1\n}\nlet f = foo // f的类型为 (Int) -> Int\n```\n\n把参数通通去掉之后就成了`() -> ()`\n\n``` swift\nfunc foo () -> () {\n    // ...\n}\n```\n\n像好多吐槽swift语法的人一样，起初我也不理解为什么用这么个奇葩的`->`来表示返回值，其实它并非表示返回值，而是表示`运算过程`，从入参到返回值的过程。按这个思路来看，把返回值写在函数声明前面倒是有点说不通了。\n\n## 元组表示所有的值\n\n再来说说这个`()`，在swift里面表示元组（tuple），值得一提的是，swift里面任何值都是一个tuple，且一共有三种Tuple：\n\n- **0-Tuple**表示空值，也就是`Void` （Void是`()`的别名）\n- **1-Tuple**表示任意一个类型的实例（Int、String、对象、枚举等等），也就是说`Int`其实是一个`(Int)`，`String`是一个`(String)`，以此类推，所以有下面的写法：\n\n\t``` swift\n\t\tvar i: Int = 1\n\t\ti.0.0.0.0.0.0 // 1\n\t\tvar a = [\"A\", \"B\", \"C\"]\n\t\ta.0.0.0.0.0.0 // [\"A\", \"B\", \"C\"]\n\t```\n\n- **N-Tuple**表示两个以上值的组合，如`(2, \"B\")`\n\n## func是一种特殊的block\n\n一开始我认为block是一种特殊的func，后来发现反过来理解更加合理。  \n\n``` swift\nclass Foo {\n    func bar(i: Int) {\n       // ...\n    }\n}\nvar f = Foo.bar\n```\n\n其中f的类型为`Foo -> (Int) -> ()`，用括号结合一下更好理解：`Foo -> (Int -> ())`，外层传入一个Foo的实例，返回值是一个`(Int) -> ()`的函数\n\n知道这一点，上面的方法用一个block也能轻松搞定：\n\n``` swift\nvar bar = {(f: Foo) -> (Int) -> () in\n    return {(i: Int) in\n        // ...\n    }\n}\n```\n\n所以说，一个`func`只是在一个`class`（或struct、enum）作用域中一个特殊的block罢了，隐式的被传入了第一层的`self`参数而已。再多想一步，假如外部有一个全局变量，在`func`中是可以访问，多么像block的捕获外部变量呢。\n\n## swift函数式世界观\n\n讲到这儿，swift中的`数据`+`运算`就可以被抽象成：`() -> ()`了，一切结构、函数、block，各种调用，本质上都可以被归纳成**从一个元组经过运算得到另一个元组的过程**，这不就是`函数式编程`么。\n当然，这个思想也不孤单，`java script`中也用`=>`来表示相同的概念\n\n\n# Reactive Cocoa作者谈未来\n\n说完了swift，再来说`Reactive Cocoa`  \nRAC可以说是对objc语言和runtime机制使用最深刻的开源库之一了，可见作者对水平。他的`《The Future of Reactive Cocoa》`的Talk很有趣，pdf可以从[这个git地址下载](https://github.com/jspahrsummers/the-future-of-reactivecocoa)\n\n他把函数式编程中的Event分成：\n\n- Observer（Push）: `Event -> ()`\n- Obserable（Push）: `(Event -> ()) -> ()`\n- Enumerator（Pull）: `() -> Event`\n- Enumerable（Pull）: `() -> (() -> Event)`\n\n先不说具体含义，这个抽象范式的表示方法就与上面提到一致。熟悉RAC的同学将会对上面精简的概括叫绝。\n拿第二个，Obserable来说，这就是RAC中的`RACSignal`，后面的范式表示这个Event可以串联起来（当返回值的也是一个同样结构的函数时）：\n`(Event1 -> ()) -> (Event2 -> ()) ->...-> (EventN -> ()) -> ()`\n\n## 不寻常意义的Enumerator\n\n这里的Enumerator不是通常意义上的`for-in`语句中使用的枚举器，而是代表了一种`延时计算`的思想：不到最后一刻，这个值一直不被计算出来，向它套用的函数也都将延时到最后才依次计算。其实swift在语言基本库中就实现了它，名为`LazyBidirectionalCollection`，如一个字典：\n\n``` swift\nvar dict = [\"A\": 1, \"B\": 2]\nvar generator = dict.keys.map({$0.lowercaseString}).generate()\ngenerator.next()! // \"b\" （这里进行一次计算）\ngenerator.next()! // \"a\" （这里进行后一次计算）\n```\n\n# 跑题了，往回拉拉\n\n`()`表示任意的值  \n`->`表示运算过程  \n所以`() -> ()`表示一个任意的函数  \n\n函数作为一等公民，可以作为值进行传递，所以上面的范式中的值也可以是函数，于是衍生出  \n`(() -> ()) -> ()`或`() -> (() -> ())`\n\n这就是函数式编程\n\n# Reference\n\nhttps://medium.com/swift-programming/facets-of-swift-part-2-tuples-4bfe58d21abf\nhttps://github.com/jspahrsummers/the-future-of-reactivecocoa\n","slug":"fp-essential","published":1,"updated":"2016-03-27T07:54:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxk8000cev12hp35dhft","content":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p><code>() -&gt; ()</code>不是什么表情符号，而是一种高度抽象的编程范式，它表示了一个函数式的编程思想，即<code>值</code>的变化过程。本文将从<code>swift</code>语言入手分析，元组，函数，闭包等的设计对它进行解释，并阐释swift语言设计的大局观。随后分享一个<code>Reactive Cocoa</code>作者的Talk中的编程思想。</p>\n<h1 id=\"编程的核心\"><a href=\"#编程的核心\" class=\"headerlink\" title=\"编程的核心\"></a>编程的核心</h1><p>编程的无非两件事，<code>数据</code>和<code>运算</code>。<br>放在计算机硬件，是内存和CPU；<br>放在C语言，是结构体和函数（基本类型本质上就是一个只有一个字段的结构体）；<br>放在面向对象的语言，是类和消息；<br>放在函数式语言，就是值和函数了</p>\n<p>如果用<code>()</code>表示数据，<code>-&gt;</code>表示运算，也是醉了</p>\n<h1 id=\"从Swift说起\"><a href=\"#从Swift说起\" class=\"headerlink\" title=\"从Swift说起\"></a>从Swift说起</h1><h2 id=\"gt-表示运算过程\"><a href=\"#gt-表示运算过程\" class=\"headerlink\" title=\"-&gt;表示运算过程\"></a>-&gt;表示运算过程</h2><p>熟悉swift的同学肯定能联想到swift中函数的表示方法</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">foo</span><span class=\"params\">(number: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> f = foo <span class=\"comment\">// f的类型为 (Int) -&gt; Int</span></span><br></pre></td></tr></table></figure>\n<p>把参数通通去掉之后就成了<code>() -&gt; ()</code></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">foo</span> <span class=\"params\">()</span></span> -&gt; () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>像好多吐槽swift语法的人一样，起初我也不理解为什么用这么个奇葩的<code>-&gt;</code>来表示返回值，其实它并非表示返回值，而是表示<code>运算过程</code>，从入参到返回值的过程。按这个思路来看，把返回值写在函数声明前面倒是有点说不通了。</p>\n<h2 id=\"元组表示所有的值\"><a href=\"#元组表示所有的值\" class=\"headerlink\" title=\"元组表示所有的值\"></a>元组表示所有的值</h2><p>再来说说这个<code>()</code>，在swift里面表示元组（tuple），值得一提的是，swift里面任何值都是一个tuple，且一共有三种Tuple：</p>\n<ul>\n<li><strong>0-Tuple</strong>表示空值，也就是<code>Void</code> （Void是<code>()</code>的别名）</li>\n<li><p><strong>1-Tuple</strong>表示任意一个类型的实例（Int、String、对象、枚举等等），也就是说<code>Int</code>其实是一个<code>(Int)</code>，<code>String</code>是一个<code>(String)</code>，以此类推，所以有下面的写法：</p>\n  <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i: <span class=\"type\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\">i.<span class=\"number\">0.0</span>.<span class=\"number\">0.0</span>.<span class=\"number\">0.0</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"C\"</span>]</span><br><span class=\"line\">a.<span class=\"number\">0.0</span>.<span class=\"number\">0.0</span>.<span class=\"number\">0.0</span> <span class=\"comment\">// [\"A\", \"B\", \"C\"]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>N-Tuple</strong>表示两个以上值的组合，如<code>(2, &quot;B&quot;)</code></p>\n</li>\n</ul>\n<h2 id=\"func是一种特殊的block\"><a href=\"#func是一种特殊的block\" class=\"headerlink\" title=\"func是一种特殊的block\"></a>func是一种特殊的block</h2><p>一开始我认为block是一种特殊的func，后来发现反过来理解更加合理。  </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">bar</span><span class=\"params\">(i: Int)</span></span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"type\">Foo</span>.bar</span><br></pre></td></tr></table></figure>\n<p>其中f的类型为<code>Foo -&gt; (Int) -&gt; ()</code>，用括号结合一下更好理解：<code>Foo -&gt; (Int -&gt; ())</code>，外层传入一个Foo的实例，返回值是一个<code>(Int) -&gt; ()</code>的函数</p>\n<p>知道这一点，上面的方法用一个block也能轻松搞定：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar = &#123;(f: <span class=\"type\">Foo</span>) -&gt; (<span class=\"type\">Int</span>) -&gt; () <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;(i: <span class=\"type\">Int</span>) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以说，一个<code>func</code>只是在一个<code>class</code>（或struct、enum）作用域中一个特殊的block罢了，隐式的被传入了第一层的<code>self</code>参数而已。再多想一步，假如外部有一个全局变量，在<code>func</code>中是可以访问，多么像block的捕获外部变量呢。</p>\n<h2 id=\"swift函数式世界观\"><a href=\"#swift函数式世界观\" class=\"headerlink\" title=\"swift函数式世界观\"></a>swift函数式世界观</h2><p>讲到这儿，swift中的<code>数据</code>+<code>运算</code>就可以被抽象成：<code>() -&gt; ()</code>了，一切结构、函数、block，各种调用，本质上都可以被归纳成<strong>从一个元组经过运算得到另一个元组的过程</strong>，这不就是<code>函数式编程</code>么。<br>当然，这个思想也不孤单，<code>java script</code>中也用<code>=&gt;</code>来表示相同的概念</p>\n<h1 id=\"Reactive-Cocoa作者谈未来\"><a href=\"#Reactive-Cocoa作者谈未来\" class=\"headerlink\" title=\"Reactive Cocoa作者谈未来\"></a>Reactive Cocoa作者谈未来</h1><p>说完了swift，再来说<code>Reactive Cocoa</code><br>RAC可以说是对objc语言和runtime机制使用最深刻的开源库之一了，可见作者对水平。他的<code>《The Future of Reactive Cocoa》</code>的Talk很有趣，pdf可以从<a href=\"https://github.com/jspahrsummers/the-future-of-reactivecocoa\" target=\"_blank\" rel=\"external\">这个git地址下载</a></p>\n<p>他把函数式编程中的Event分成：</p>\n<ul>\n<li>Observer（Push）: <code>Event -&gt; ()</code></li>\n<li>Obserable（Push）: <code>(Event -&gt; ()) -&gt; ()</code></li>\n<li>Enumerator（Pull）: <code>() -&gt; Event</code></li>\n<li>Enumerable（Pull）: <code>() -&gt; (() -&gt; Event)</code></li>\n</ul>\n<p>先不说具体含义，这个抽象范式的表示方法就与上面提到一致。熟悉RAC的同学将会对上面精简的概括叫绝。<br>拿第二个，Obserable来说，这就是RAC中的<code>RACSignal</code>，后面的范式表示这个Event可以串联起来（当返回值的也是一个同样结构的函数时）：<br><code>(Event1 -&gt; ()) -&gt; (Event2 -&gt; ()) -&gt;...-&gt; (EventN -&gt; ()) -&gt; ()</code></p>\n<h2 id=\"不寻常意义的Enumerator\"><a href=\"#不寻常意义的Enumerator\" class=\"headerlink\" title=\"不寻常意义的Enumerator\"></a>不寻常意义的Enumerator</h2><p>这里的Enumerator不是通常意义上的<code>for-in</code>语句中使用的枚举器，而是代表了一种<code>延时计算</code>的思想：不到最后一刻，这个值一直不被计算出来，向它套用的函数也都将延时到最后才依次计算。其实swift在语言基本库中就实现了它，名为<code>LazyBidirectionalCollection</code>，如一个字典：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> dict = [<span class=\"string\">\"A\"</span>: <span class=\"number\">1</span>, <span class=\"string\">\"B\"</span>: <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> generator = dict.keys.<span class=\"built_in\">map</span>(&#123;$<span class=\"number\">0</span>.lowercaseString&#125;).generate()</span><br><span class=\"line\">generator.next()! <span class=\"comment\">// \"b\" （这里进行一次计算）</span></span><br><span class=\"line\">generator.next()! <span class=\"comment\">// \"a\" （这里进行后一次计算）</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"跑题了，往回拉拉\"><a href=\"#跑题了，往回拉拉\" class=\"headerlink\" title=\"跑题了，往回拉拉\"></a>跑题了，往回拉拉</h1><p><code>()</code>表示任意的值<br><code>-&gt;</code>表示运算过程<br>所以<code>() -&gt; ()</code>表示一个任意的函数  </p>\n<p>函数作为一等公民，可以作为值进行传递，所以上面的范式中的值也可以是函数，于是衍生出<br><code>(() -&gt; ()) -&gt; ()</code>或<code>() -&gt; (() -&gt; ())</code></p>\n<p>这就是函数式编程</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p><a href=\"https://medium.com/swift-programming/facets-of-swift-part-2-tuples-4bfe58d21abf\" target=\"_blank\" rel=\"external\">https://medium.com/swift-programming/facets-of-swift-part-2-tuples-4bfe58d21abf</a><br><a href=\"https://github.com/jspahrsummers/the-future-of-reactivecocoa\" target=\"_blank\" rel=\"external\">https://github.com/jspahrsummers/the-future-of-reactivecocoa</a></p>\n","excerpt":"","more":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p><code>() -&gt; ()</code>不是什么表情符号，而是一种高度抽象的编程范式，它表示了一个函数式的编程思想，即<code>值</code>的变化过程。本文将从<code>swift</code>语言入手分析，元组，函数，闭包等的设计对它进行解释，并阐释swift语言设计的大局观。随后分享一个<code>Reactive Cocoa</code>作者的Talk中的编程思想。</p>\n<h1 id=\"编程的核心\"><a href=\"#编程的核心\" class=\"headerlink\" title=\"编程的核心\"></a>编程的核心</h1><p>编程的无非两件事，<code>数据</code>和<code>运算</code>。<br>放在计算机硬件，是内存和CPU；<br>放在C语言，是结构体和函数（基本类型本质上就是一个只有一个字段的结构体）；<br>放在面向对象的语言，是类和消息；<br>放在函数式语言，就是值和函数了</p>\n<p>如果用<code>()</code>表示数据，<code>-&gt;</code>表示运算，也是醉了</p>\n<h1 id=\"从Swift说起\"><a href=\"#从Swift说起\" class=\"headerlink\" title=\"从Swift说起\"></a>从Swift说起</h1><h2 id=\"gt-表示运算过程\"><a href=\"#gt-表示运算过程\" class=\"headerlink\" title=\"-&gt;表示运算过程\"></a>-&gt;表示运算过程</h2><p>熟悉swift的同学肯定能联想到swift中函数的表示方法</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">foo</span><span class=\"params\">(number: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> f = foo <span class=\"comment\">// f的类型为 (Int) -&gt; Int</span></span><br></pre></td></tr></table></figure>\n<p>把参数通通去掉之后就成了<code>() -&gt; ()</code></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">foo</span> <span class=\"params\">()</span></span> -&gt; () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>像好多吐槽swift语法的人一样，起初我也不理解为什么用这么个奇葩的<code>-&gt;</code>来表示返回值，其实它并非表示返回值，而是表示<code>运算过程</code>，从入参到返回值的过程。按这个思路来看，把返回值写在函数声明前面倒是有点说不通了。</p>\n<h2 id=\"元组表示所有的值\"><a href=\"#元组表示所有的值\" class=\"headerlink\" title=\"元组表示所有的值\"></a>元组表示所有的值</h2><p>再来说说这个<code>()</code>，在swift里面表示元组（tuple），值得一提的是，swift里面任何值都是一个tuple，且一共有三种Tuple：</p>\n<ul>\n<li><strong>0-Tuple</strong>表示空值，也就是<code>Void</code> （Void是<code>()</code>的别名）</li>\n<li><p><strong>1-Tuple</strong>表示任意一个类型的实例（Int、String、对象、枚举等等），也就是说<code>Int</code>其实是一个<code>(Int)</code>，<code>String</code>是一个<code>(String)</code>，以此类推，所以有下面的写法：</p>\n  <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i: <span class=\"type\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\">i.<span class=\"number\">0.0</span>.<span class=\"number\">0.0</span>.<span class=\"number\">0.0</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"C\"</span>]</span><br><span class=\"line\">a.<span class=\"number\">0.0</span>.<span class=\"number\">0.0</span>.<span class=\"number\">0.0</span> <span class=\"comment\">// [\"A\", \"B\", \"C\"]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>N-Tuple</strong>表示两个以上值的组合，如<code>(2, &quot;B&quot;)</code></p>\n</li>\n</ul>\n<h2 id=\"func是一种特殊的block\"><a href=\"#func是一种特殊的block\" class=\"headerlink\" title=\"func是一种特殊的block\"></a>func是一种特殊的block</h2><p>一开始我认为block是一种特殊的func，后来发现反过来理解更加合理。  </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">bar</span><span class=\"params\">(i: Int)</span></span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"type\">Foo</span>.bar</span><br></pre></td></tr></table></figure>\n<p>其中f的类型为<code>Foo -&gt; (Int) -&gt; ()</code>，用括号结合一下更好理解：<code>Foo -&gt; (Int -&gt; ())</code>，外层传入一个Foo的实例，返回值是一个<code>(Int) -&gt; ()</code>的函数</p>\n<p>知道这一点，上面的方法用一个block也能轻松搞定：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar = &#123;(f: <span class=\"type\">Foo</span>) -&gt; (<span class=\"type\">Int</span>) -&gt; () <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;(i: <span class=\"type\">Int</span>) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以说，一个<code>func</code>只是在一个<code>class</code>（或struct、enum）作用域中一个特殊的block罢了，隐式的被传入了第一层的<code>self</code>参数而已。再多想一步，假如外部有一个全局变量，在<code>func</code>中是可以访问，多么像block的捕获外部变量呢。</p>\n<h2 id=\"swift函数式世界观\"><a href=\"#swift函数式世界观\" class=\"headerlink\" title=\"swift函数式世界观\"></a>swift函数式世界观</h2><p>讲到这儿，swift中的<code>数据</code>+<code>运算</code>就可以被抽象成：<code>() -&gt; ()</code>了，一切结构、函数、block，各种调用，本质上都可以被归纳成<strong>从一个元组经过运算得到另一个元组的过程</strong>，这不就是<code>函数式编程</code>么。<br>当然，这个思想也不孤单，<code>java script</code>中也用<code>=&gt;</code>来表示相同的概念</p>\n<h1 id=\"Reactive-Cocoa作者谈未来\"><a href=\"#Reactive-Cocoa作者谈未来\" class=\"headerlink\" title=\"Reactive Cocoa作者谈未来\"></a>Reactive Cocoa作者谈未来</h1><p>说完了swift，再来说<code>Reactive Cocoa</code><br>RAC可以说是对objc语言和runtime机制使用最深刻的开源库之一了，可见作者对水平。他的<code>《The Future of Reactive Cocoa》</code>的Talk很有趣，pdf可以从<a href=\"https://github.com/jspahrsummers/the-future-of-reactivecocoa\">这个git地址下载</a></p>\n<p>他把函数式编程中的Event分成：</p>\n<ul>\n<li>Observer（Push）: <code>Event -&gt; ()</code></li>\n<li>Obserable（Push）: <code>(Event -&gt; ()) -&gt; ()</code></li>\n<li>Enumerator（Pull）: <code>() -&gt; Event</code></li>\n<li>Enumerable（Pull）: <code>() -&gt; (() -&gt; Event)</code></li>\n</ul>\n<p>先不说具体含义，这个抽象范式的表示方法就与上面提到一致。熟悉RAC的同学将会对上面精简的概括叫绝。<br>拿第二个，Obserable来说，这就是RAC中的<code>RACSignal</code>，后面的范式表示这个Event可以串联起来（当返回值的也是一个同样结构的函数时）：<br><code>(Event1 -&gt; ()) -&gt; (Event2 -&gt; ()) -&gt;...-&gt; (EventN -&gt; ()) -&gt; ()</code></p>\n<h2 id=\"不寻常意义的Enumerator\"><a href=\"#不寻常意义的Enumerator\" class=\"headerlink\" title=\"不寻常意义的Enumerator\"></a>不寻常意义的Enumerator</h2><p>这里的Enumerator不是通常意义上的<code>for-in</code>语句中使用的枚举器，而是代表了一种<code>延时计算</code>的思想：不到最后一刻，这个值一直不被计算出来，向它套用的函数也都将延时到最后才依次计算。其实swift在语言基本库中就实现了它，名为<code>LazyBidirectionalCollection</code>，如一个字典：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> dict = [<span class=\"string\">\"A\"</span>: <span class=\"number\">1</span>, <span class=\"string\">\"B\"</span>: <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> generator = dict.keys.<span class=\"built_in\">map</span>(&#123;$<span class=\"number\">0</span>.lowercaseString&#125;).generate()</span><br><span class=\"line\">generator.next()! <span class=\"comment\">// \"b\" （这里进行一次计算）</span></span><br><span class=\"line\">generator.next()! <span class=\"comment\">// \"a\" （这里进行后一次计算）</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"跑题了，往回拉拉\"><a href=\"#跑题了，往回拉拉\" class=\"headerlink\" title=\"跑题了，往回拉拉\"></a>跑题了，往回拉拉</h1><p><code>()</code>表示任意的值<br><code>-&gt;</code>表示运算过程<br>所以<code>() -&gt; ()</code>表示一个任意的函数  </p>\n<p>函数作为一等公民，可以作为值进行传递，所以上面的范式中的值也可以是函数，于是衍生出<br><code>(() -&gt; ()) -&gt; ()</code>或<code>() -&gt; (() -&gt; ())</code></p>\n<p>这就是函数式编程</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p><a href=\"https://medium.com/swift-programming/facets-of-swift-part-2-tuples-4bfe58d21abf\">https://medium.com/swift-programming/facets-of-swift-part-2-tuples-4bfe58d21abf</a><br><a href=\"https://github.com/jspahrsummers/the-future-of-reactivecocoa\">https://github.com/jspahrsummers/the-future-of-reactivecocoa</a></p>\n"},{"title":"hexo的私人订制","date":"2014-03-07T08:26:34.000Z","_content":"\n# 准备工作\n## Fork it!\n从0开始多费劲，先从hexo的主题中选一个看的过去的，从上面加工。\n这次选的是hexo的默认主题`Landscape`，觉得一个大banner挺好看而已。\n主题在github上，https://github.com/hexojs/hexo-theme-landscape  \n废话不说，先fork一份，虽然不会再merge回去了。\nfork完去setting页面改个名字，就叫它`present`了，因为当时看到群里正说`presentViewController`的事- -\n\n![][1]\n * hexo工程的`themes/`目录默认是在`.gitignore`里的，意思是主题和内容是应该分开的\ntheme作为主项目的`submodule`，所以主题更改时也应该单独提交了\n\n## Clone it！\n把刚fork的名为`present`的theme安装到hexo目录：\n\n``` sh\n$ git clone https://github.com/sunnyxx/present themes/present\n```\n\n去`/_config.yml`中找到并设置：\n\n```\n# Extensions\n## Plugins: https://github.com/tommy351/hexo/wiki/Plugins\n## Themes: https://github.com/tommy351/hexo/wiki/Themes\ntheme: present // 修改这儿\n```\n\n运行下`hexo server`就能立刻看到效果了\n\n# 开始定制theme\n先得看看hexo theme里面的结构：\n\n - _config.yml - 主题总体配置\n - /layout/*.ejs - 网页布局\n - /source/css/*.styl - 网页样式\n\n## 定制banner\n![banner][2]\n默认的banner图是个地球星空图，先从它下手，这张图位于`/themes/present/source/css/images/banner.jpg`\n这图分辨率有`1920x1200`之大，显示的部分很少，搞一张喜欢的banner图，PS成大概的尺寸（高度还就得设的很大才行，虽然只显示一小部分，否则会出现显示不出来图片的状况），我这儿PS过的是一张png，名为`banner.png`，文件名修改需找找到位于`/themes/present/source/css/_variables.styl`中，修改为`banner.png`  \n**当然，考虑到github的访问速度，这张大图我最后决定用上传微博图床，使用生成的URL，这样加载就快很多**\n```\n// Header\nlogo-size = 40px\nsubtitle-size = 16px\nbanner-height = 404px // 看看多高合适\nbanner-url = \"images/banner.png\" // 修改这里\n```\n然后就变成这鸟样了：\n![专业多了][3]\n这个标题横在这儿太恶心了，我的banner里面已经有标题了，这就是需要修改布局了，header的布局在`/themes/present/layout/_partial/header.ejs`，打开修改：\n```\n// 把这一段都注释掉好了：\n<div id=\"header-title\" class=\"inner\">\n    <h1 id=\"logo-wrap\">\n        <a href=\"<%- config.root %>\" id=\"logo\"><%= config.title %></a>\n    </h1>\n    <% if (theme.subtitle){ %>\n        <h2 id=\"subtitle-wrap\">\n          <a href=\"<%- config.root %>\" id=\"subtitle\"><%= theme.subtitle %></a>\n        </h2>\n    <% } %>\n</div>\n```\n然后世界变清净了。\n![丑][4]\n默认主题里面banner上下都有个渐变，换了图之后就尤其丑，干掉之。\n这个是样式的修改，所以肯定在`present/source/css/_partial`里面了，再看这位置明显是header嘛，所以`header.styl`就是你了：\n```\n#header\n  height: banner-height\n  position: relative\n  border-bottom: 1px solid color-border\n  &:before, &:after\n    content: \"\"\n    position: absolute\n    left: 0\n    right: 0\n    height: 40px\n  &:before\n    top: 0\n    background: linear-gradient(rgba(0, 0, 0, 0.2), transparent) // 找到你了，注释掉！\n  &:after\n    bottom: 0\n    background: linear-gradient(transparent, rgba(0, 0, 0, 0.2)) // 也找到你了，注释掉！\n```\n瞬间清爽很多，但又发现去掉之后字看不清了：\n![看不清！][5]\n还是在这个文件：\n\n```\n$nav-link\n  float: left\n  color: #000 // 改个深色\n  opacity: 1.0 // 别半透明的\n  text-decoration: none\n  /*text-shadow: 0 1px rgba(0, 0, 0, 0.2)*/ // 改个阴影\n  transition: opacity 0.2s\n  display: block\n  padding: 20px 15px\n  &:hover\n    opacity: 1\n```\nmuch better\n![better][6]\n\n##定制样式\n\n列几个常用的：\n\n在`/themes/present/source/css/_variables.styl`中：\n\n#### 调整主区域布局（很值得修改）\n默认的主题的主区域太窄了，没几个字就得换行，下面的`main-column`控制主区域宽，`sidebar-column`控制sidebar宽，这两个值加一起凑成全部宽度，会居中对齐。\n```\n// Layout\nblock-margin = 20px\narticle-padding = 20px // 文章内缩进\nmobile-nav-width = 280px\nmain-column = 12 // 主文章区域的宽度\nsidebar-column = 3 // 侧边栏区域的宽度\n```\n#### 修改代码字体\n\n```\nfont-mono = Menlo/*Menlo必须提前面啊*/, \"Source Code Pro\", Monaco, Consolas, Consolas, monospace\n```\n#### 修改正文字体和行高\n```\nfont-size = 15px // Menlo字体我看15px的很清楚\nline-height = 1.6em\nline-height-title = 1.3em\n```\n\n\n-----\n位于`/themes/present/source/css/_partial/article.styl`的样式文件负责文章里面的样式\n#### 修改图片格式\n```\n  img, video\n    max-width: 80%\n    height: auto\n    display: block\n    margin: auto\n```\n去除图片的描述的caption的话，去`present/source/js/script.js`中修改：\n```\n// Caption\n  $('.article-entry').each(function(i){\n    $(this).find('img').each(function(){\n      if ($(this).parent().hasClass('fancybox')) return;\n\n      var alt = this.alt;\n\n      // if (alt) $(this).after('<span class=\"caption\">' + alt + '</span>'); 这个去掉\n\n      $(this).wrap('<a href=\"' + this.src + '\" title=\"' + alt + '\" class=\"fancybox\"></a>');\n    });\n\n    $(this).find('.fancybox').each(function(){\n      $(this).attr('rel', 'article' + i);\n    });\n  });\n```\n\n#### 修改blockquote样式\n```\n  blockquote\n    font-family: font-serif\n    font-size: 2.0em // 搞大点\n    margin: line-height 20px\n    text-align: left // 必须应该左对齐啊\n```\n\n-----\n位于`/themes/present/source/css/_extend.styl`的样式文件定义了基本样式\n#### 修改标题样式\n```\n  h1\n    font-size: 2em\n  h2\n    font-size: 1.5em\n  h3\n    font-size: 1.3em\n  h4\n    font-size: 1.2em\n  h5\n    font-size: 1em\n  h6\n    font-size: 1em\n    color: color-grey\n```\n\n#### 修改文章背景\n```\n$block\n  background: #fbfbfb // 白里透着灰\n  /*box-shadow: 1px 2px 3px #eee*/ // 扁平化咋能要阴影\n  border: 1.5px solid #ccc // 边框\n  border-radius: 10px // 圆角矩形走起\n```\n\n## 定制代码样式\n这个必须单拿出来写  \n> We shall show no mercy to those shit colored codes ----- sunnyxx\n\n代码的高亮样式在`present/source/css/_partial/highlight.styl`中\n```\n$code-block\n  background: highlight-background\n  /*margin: 0 article-padding * -1*/\n  margin: auto // 默认的顶边对齐是怎么回事？改个居中\n  padding: 15px article-padding\n  border-style: solid\n  border-color: color-border\n  border-width: 0px 0\n  border-radius: 5px // 加个圆角~\n  overflow: auto\n  color: highlight-foreground\n  line-height: font-size * line-height\n\n$line-numbers\n  color: #666\n  font-size: 0.85em // 行号大小\n\n...\n\n.highlight\n    @extend $code-block\n    pre\n      border: none\n      margin: 0\n      padding: 0\n    table\n      margin: 0\n      width: auto\n      font-size: 14px // 设置代码字体\n      letter-spacing: 1px // 设置字间距，要不太挤了\n\n```\nCode block高亮：`我是小代码块高亮`\n```\n.article-entry\n  pre, code\n    font-family: font-mono\n  code\n    background: #e3e3e3\n    color: #666\n    border-radius: 3px // 也来个圆角\n    border-width 1px\n    border-color: #fff\n    text-shadow: 0 1px #fff\n    padding: 0.1em 0.3em // 控制大小\n```\n\n# 开始定制widget\n\n## 添加多说评论\n在`present/layout/_partial/article.ejs`中最下面，要不用discuss的话先注掉，换成下面的：\n\n```\n<% if (!index && post.comments){ %>\n<section id=\"comments\">\n  <!-- Duoshuo Comment BEGIN -->\n  <div class=\"ds-thread\"></div>\n    <script type=\"text/javascript\">\n      var duoshuoQuery = {short_name:\"sunnyxx\"};\n        (function() {\n          var ds = document.createElement('script');\n          ds.type = 'text/javascript';ds.async = true;\n          ds.src = 'http://static.duoshuo.com/embed.js';\n          ds.charset = 'UTF-8';\n          (document.getElementsByTagName('head')[0]\n          || document.getElementsByTagName('body')[0]).appendChild(ds);\n        })();\n  </script>\n<!-- Duoshuo Comment END -->\n</section>\n<% } %>\n```\n## 添加友情链接\n首先，在`present/layout/_widget/`目录下新建一个文件，随便copy个当前目录下的改名也行，我这儿叫`friends.ejs`\n编辑这个文件：\n```\n<div class=\"widget tag\">\n\t<h3 class=\"title\">友情链接</h3>\n\t<ul class=\"entry\">\n\t<li><a href=\"http://zhouxl.github.io\" title=\"小六\">小六的博客</a></li>\n\t</ul>\n</div>\n```\n里面以上面的格式定义友情链接，css套用了tag定义好的格式，随后修改`present/_config.yml`\n```\n# Sidebar\nsidebar: right\nwidgets:\n- category\n- tag\n- tagcloud\n- archive\n- recent_posts\n- friends // 新加的就是刚才`_widget`目录中新建的文件的文件名\n```\n然后刷新页面，效果就出来了~\n\n  [1]: http://ww3.sinaimg.cn/large/51530583gw1ee7835uauoj20j804mwen.jpg\n  [2]: http://ww4.sinaimg.cn/large/51530583gw1ee78mkdkspj20jp06bq3h.jpg\n  [3]: http://ww2.sinaimg.cn/large/51530583gw1ee790pxkk9j20fv085t9c.jpg\n  [4]: http://ww3.sinaimg.cn/large/51530583gw1ee79b2xop4j201u0bt0sm.jpg\n  [5]: http://ww4.sinaimg.cn/large/51530583gw1ee79ex02pgj206901u0qo.jpg\n  [6]: http://ww3.sinaimg.cn/large/51530583tw1ee79mmlwkaj205401iwe9.jpg\n","source":"_posts/hexo_customize.md","raw":"title: hexo的私人订制\ndate: 2014-03-07 16:26:34\ntags: hexo\n---\n\n# 准备工作\n## Fork it!\n从0开始多费劲，先从hexo的主题中选一个看的过去的，从上面加工。\n这次选的是hexo的默认主题`Landscape`，觉得一个大banner挺好看而已。\n主题在github上，https://github.com/hexojs/hexo-theme-landscape  \n废话不说，先fork一份，虽然不会再merge回去了。\nfork完去setting页面改个名字，就叫它`present`了，因为当时看到群里正说`presentViewController`的事- -\n\n![][1]\n * hexo工程的`themes/`目录默认是在`.gitignore`里的，意思是主题和内容是应该分开的\ntheme作为主项目的`submodule`，所以主题更改时也应该单独提交了\n\n## Clone it！\n把刚fork的名为`present`的theme安装到hexo目录：\n\n``` sh\n$ git clone https://github.com/sunnyxx/present themes/present\n```\n\n去`/_config.yml`中找到并设置：\n\n```\n# Extensions\n## Plugins: https://github.com/tommy351/hexo/wiki/Plugins\n## Themes: https://github.com/tommy351/hexo/wiki/Themes\ntheme: present // 修改这儿\n```\n\n运行下`hexo server`就能立刻看到效果了\n\n# 开始定制theme\n先得看看hexo theme里面的结构：\n\n - _config.yml - 主题总体配置\n - /layout/*.ejs - 网页布局\n - /source/css/*.styl - 网页样式\n\n## 定制banner\n![banner][2]\n默认的banner图是个地球星空图，先从它下手，这张图位于`/themes/present/source/css/images/banner.jpg`\n这图分辨率有`1920x1200`之大，显示的部分很少，搞一张喜欢的banner图，PS成大概的尺寸（高度还就得设的很大才行，虽然只显示一小部分，否则会出现显示不出来图片的状况），我这儿PS过的是一张png，名为`banner.png`，文件名修改需找找到位于`/themes/present/source/css/_variables.styl`中，修改为`banner.png`  \n**当然，考虑到github的访问速度，这张大图我最后决定用上传微博图床，使用生成的URL，这样加载就快很多**\n```\n// Header\nlogo-size = 40px\nsubtitle-size = 16px\nbanner-height = 404px // 看看多高合适\nbanner-url = \"images/banner.png\" // 修改这里\n```\n然后就变成这鸟样了：\n![专业多了][3]\n这个标题横在这儿太恶心了，我的banner里面已经有标题了，这就是需要修改布局了，header的布局在`/themes/present/layout/_partial/header.ejs`，打开修改：\n```\n// 把这一段都注释掉好了：\n<div id=\"header-title\" class=\"inner\">\n    <h1 id=\"logo-wrap\">\n        <a href=\"<%- config.root %>\" id=\"logo\"><%= config.title %></a>\n    </h1>\n    <% if (theme.subtitle){ %>\n        <h2 id=\"subtitle-wrap\">\n          <a href=\"<%- config.root %>\" id=\"subtitle\"><%= theme.subtitle %></a>\n        </h2>\n    <% } %>\n</div>\n```\n然后世界变清净了。\n![丑][4]\n默认主题里面banner上下都有个渐变，换了图之后就尤其丑，干掉之。\n这个是样式的修改，所以肯定在`present/source/css/_partial`里面了，再看这位置明显是header嘛，所以`header.styl`就是你了：\n```\n#header\n  height: banner-height\n  position: relative\n  border-bottom: 1px solid color-border\n  &:before, &:after\n    content: \"\"\n    position: absolute\n    left: 0\n    right: 0\n    height: 40px\n  &:before\n    top: 0\n    background: linear-gradient(rgba(0, 0, 0, 0.2), transparent) // 找到你了，注释掉！\n  &:after\n    bottom: 0\n    background: linear-gradient(transparent, rgba(0, 0, 0, 0.2)) // 也找到你了，注释掉！\n```\n瞬间清爽很多，但又发现去掉之后字看不清了：\n![看不清！][5]\n还是在这个文件：\n\n```\n$nav-link\n  float: left\n  color: #000 // 改个深色\n  opacity: 1.0 // 别半透明的\n  text-decoration: none\n  /*text-shadow: 0 1px rgba(0, 0, 0, 0.2)*/ // 改个阴影\n  transition: opacity 0.2s\n  display: block\n  padding: 20px 15px\n  &:hover\n    opacity: 1\n```\nmuch better\n![better][6]\n\n##定制样式\n\n列几个常用的：\n\n在`/themes/present/source/css/_variables.styl`中：\n\n#### 调整主区域布局（很值得修改）\n默认的主题的主区域太窄了，没几个字就得换行，下面的`main-column`控制主区域宽，`sidebar-column`控制sidebar宽，这两个值加一起凑成全部宽度，会居中对齐。\n```\n// Layout\nblock-margin = 20px\narticle-padding = 20px // 文章内缩进\nmobile-nav-width = 280px\nmain-column = 12 // 主文章区域的宽度\nsidebar-column = 3 // 侧边栏区域的宽度\n```\n#### 修改代码字体\n\n```\nfont-mono = Menlo/*Menlo必须提前面啊*/, \"Source Code Pro\", Monaco, Consolas, Consolas, monospace\n```\n#### 修改正文字体和行高\n```\nfont-size = 15px // Menlo字体我看15px的很清楚\nline-height = 1.6em\nline-height-title = 1.3em\n```\n\n\n-----\n位于`/themes/present/source/css/_partial/article.styl`的样式文件负责文章里面的样式\n#### 修改图片格式\n```\n  img, video\n    max-width: 80%\n    height: auto\n    display: block\n    margin: auto\n```\n去除图片的描述的caption的话，去`present/source/js/script.js`中修改：\n```\n// Caption\n  $('.article-entry').each(function(i){\n    $(this).find('img').each(function(){\n      if ($(this).parent().hasClass('fancybox')) return;\n\n      var alt = this.alt;\n\n      // if (alt) $(this).after('<span class=\"caption\">' + alt + '</span>'); 这个去掉\n\n      $(this).wrap('<a href=\"' + this.src + '\" title=\"' + alt + '\" class=\"fancybox\"></a>');\n    });\n\n    $(this).find('.fancybox').each(function(){\n      $(this).attr('rel', 'article' + i);\n    });\n  });\n```\n\n#### 修改blockquote样式\n```\n  blockquote\n    font-family: font-serif\n    font-size: 2.0em // 搞大点\n    margin: line-height 20px\n    text-align: left // 必须应该左对齐啊\n```\n\n-----\n位于`/themes/present/source/css/_extend.styl`的样式文件定义了基本样式\n#### 修改标题样式\n```\n  h1\n    font-size: 2em\n  h2\n    font-size: 1.5em\n  h3\n    font-size: 1.3em\n  h4\n    font-size: 1.2em\n  h5\n    font-size: 1em\n  h6\n    font-size: 1em\n    color: color-grey\n```\n\n#### 修改文章背景\n```\n$block\n  background: #fbfbfb // 白里透着灰\n  /*box-shadow: 1px 2px 3px #eee*/ // 扁平化咋能要阴影\n  border: 1.5px solid #ccc // 边框\n  border-radius: 10px // 圆角矩形走起\n```\n\n## 定制代码样式\n这个必须单拿出来写  \n> We shall show no mercy to those shit colored codes ----- sunnyxx\n\n代码的高亮样式在`present/source/css/_partial/highlight.styl`中\n```\n$code-block\n  background: highlight-background\n  /*margin: 0 article-padding * -1*/\n  margin: auto // 默认的顶边对齐是怎么回事？改个居中\n  padding: 15px article-padding\n  border-style: solid\n  border-color: color-border\n  border-width: 0px 0\n  border-radius: 5px // 加个圆角~\n  overflow: auto\n  color: highlight-foreground\n  line-height: font-size * line-height\n\n$line-numbers\n  color: #666\n  font-size: 0.85em // 行号大小\n\n...\n\n.highlight\n    @extend $code-block\n    pre\n      border: none\n      margin: 0\n      padding: 0\n    table\n      margin: 0\n      width: auto\n      font-size: 14px // 设置代码字体\n      letter-spacing: 1px // 设置字间距，要不太挤了\n\n```\nCode block高亮：`我是小代码块高亮`\n```\n.article-entry\n  pre, code\n    font-family: font-mono\n  code\n    background: #e3e3e3\n    color: #666\n    border-radius: 3px // 也来个圆角\n    border-width 1px\n    border-color: #fff\n    text-shadow: 0 1px #fff\n    padding: 0.1em 0.3em // 控制大小\n```\n\n# 开始定制widget\n\n## 添加多说评论\n在`present/layout/_partial/article.ejs`中最下面，要不用discuss的话先注掉，换成下面的：\n\n```\n<% if (!index && post.comments){ %>\n<section id=\"comments\">\n  <!-- Duoshuo Comment BEGIN -->\n  <div class=\"ds-thread\"></div>\n    <script type=\"text/javascript\">\n      var duoshuoQuery = {short_name:\"sunnyxx\"};\n        (function() {\n          var ds = document.createElement('script');\n          ds.type = 'text/javascript';ds.async = true;\n          ds.src = 'http://static.duoshuo.com/embed.js';\n          ds.charset = 'UTF-8';\n          (document.getElementsByTagName('head')[0]\n          || document.getElementsByTagName('body')[0]).appendChild(ds);\n        })();\n  </script>\n<!-- Duoshuo Comment END -->\n</section>\n<% } %>\n```\n## 添加友情链接\n首先，在`present/layout/_widget/`目录下新建一个文件，随便copy个当前目录下的改名也行，我这儿叫`friends.ejs`\n编辑这个文件：\n```\n<div class=\"widget tag\">\n\t<h3 class=\"title\">友情链接</h3>\n\t<ul class=\"entry\">\n\t<li><a href=\"http://zhouxl.github.io\" title=\"小六\">小六的博客</a></li>\n\t</ul>\n</div>\n```\n里面以上面的格式定义友情链接，css套用了tag定义好的格式，随后修改`present/_config.yml`\n```\n# Sidebar\nsidebar: right\nwidgets:\n- category\n- tag\n- tagcloud\n- archive\n- recent_posts\n- friends // 新加的就是刚才`_widget`目录中新建的文件的文件名\n```\n然后刷新页面，效果就出来了~\n\n  [1]: http://ww3.sinaimg.cn/large/51530583gw1ee7835uauoj20j804mwen.jpg\n  [2]: http://ww4.sinaimg.cn/large/51530583gw1ee78mkdkspj20jp06bq3h.jpg\n  [3]: http://ww2.sinaimg.cn/large/51530583gw1ee790pxkk9j20fv085t9c.jpg\n  [4]: http://ww3.sinaimg.cn/large/51530583gw1ee79b2xop4j201u0bt0sm.jpg\n  [5]: http://ww4.sinaimg.cn/large/51530583gw1ee79ex02pgj206901u0qo.jpg\n  [6]: http://ww3.sinaimg.cn/large/51530583tw1ee79mmlwkaj205401iwe9.jpg\n","slug":"hexo_customize","published":1,"updated":"2016-03-27T08:39:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxkb000eev12kka9pkqc","content":"<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><h2 id=\"Fork-it\"><a href=\"#Fork-it\" class=\"headerlink\" title=\"Fork it!\"></a>Fork it!</h2><p>从0开始多费劲，先从hexo的主题中选一个看的过去的，从上面加工。<br>这次选的是hexo的默认主题<code>Landscape</code>，觉得一个大banner挺好看而已。<br>主题在github上，<a href=\"https://github.com/hexojs/hexo-theme-landscape\" target=\"_blank\" rel=\"external\">https://github.com/hexojs/hexo-theme-landscape</a><br>废话不说，先fork一份，虽然不会再merge回去了。<br>fork完去setting页面改个名字，就叫它<code>present</code>了，因为当时看到群里正说<code>presentViewController</code>的事- -</p>\n<p><img src=\"http://ww3.sinaimg.cn/large/51530583gw1ee7835uauoj20j804mwen.jpg\" alt=\"\"></p>\n<ul>\n<li>hexo工程的<code>themes/</code>目录默认是在<code>.gitignore</code>里的，意思是主题和内容是应该分开的<br>theme作为主项目的<code>submodule</code>，所以主题更改时也应该单独提交了</li>\n</ul>\n<h2 id=\"Clone-it！\"><a href=\"#Clone-it！\" class=\"headerlink\" title=\"Clone it！\"></a>Clone it！</h2><p>把刚fork的名为<code>present</code>的theme安装到hexo目录：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/sunnyxx/present themes/present</span><br></pre></td></tr></table></figure>\n<p>去<code>/_config.yml</code>中找到并设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Extensions</span><br><span class=\"line\">## Plugins: https://github.com/tommy351/hexo/wiki/Plugins</span><br><span class=\"line\">## Themes: https://github.com/tommy351/hexo/wiki/Themes</span><br><span class=\"line\">theme: present // 修改这儿</span><br></pre></td></tr></table></figure>\n<p>运行下<code>hexo server</code>就能立刻看到效果了</p>\n<h1 id=\"开始定制theme\"><a href=\"#开始定制theme\" class=\"headerlink\" title=\"开始定制theme\"></a>开始定制theme</h1><p>先得看看hexo theme里面的结构：</p>\n<ul>\n<li>_config.yml - 主题总体配置</li>\n<li>/layout/*.ejs - 网页布局</li>\n<li>/source/css/*.styl - 网页样式</li>\n</ul>\n<h2 id=\"定制banner\"><a href=\"#定制banner\" class=\"headerlink\" title=\"定制banner\"></a>定制banner</h2><p><img src=\"http://ww4.sinaimg.cn/large/51530583gw1ee78mkdkspj20jp06bq3h.jpg\" alt=\"banner\"><br>默认的banner图是个地球星空图，先从它下手，这张图位于<code>/themes/present/source/css/images/banner.jpg</code><br>这图分辨率有<code>1920x1200</code>之大，显示的部分很少，搞一张喜欢的banner图，PS成大概的尺寸（高度还就得设的很大才行，虽然只显示一小部分，否则会出现显示不出来图片的状况），我这儿PS过的是一张png，名为<code>banner.png</code>，文件名修改需找找到位于<code>/themes/present/source/css/_variables.styl</code>中，修改为<code>banner.png</code><br><strong>当然，考虑到github的访问速度，这张大图我最后决定用上传微博图床，使用生成的URL，这样加载就快很多</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Header</span><br><span class=\"line\">logo-size = 40px</span><br><span class=\"line\">subtitle-size = 16px</span><br><span class=\"line\">banner-height = 404px // 看看多高合适</span><br><span class=\"line\">banner-url = &quot;images/banner.png&quot; // 修改这里</span><br></pre></td></tr></table></figure></p>\n<p>然后就变成这鸟样了：<br><img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee790pxkk9j20fv085t9c.jpg\" alt=\"专业多了\"><br>这个标题横在这儿太恶心了，我的banner里面已经有标题了，这就是需要修改布局了，header的布局在<code>/themes/present/layout/_partial/header.ejs</code>，打开修改：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 把这一段都注释掉好了：</span><br><span class=\"line\">&lt;div id=&quot;header-title&quot; class=&quot;inner&quot;&gt;</span><br><span class=\"line\">    &lt;h1 id=&quot;logo-wrap&quot;&gt;</span><br><span class=\"line\">        &lt;a href=&quot;&lt;%- config.root %&gt;&quot; id=&quot;logo&quot;&gt;&lt;%= config.title %&gt;&lt;/a&gt;</span><br><span class=\"line\">    &lt;/h1&gt;</span><br><span class=\"line\">    &lt;% if (theme.subtitle)&#123; %&gt;</span><br><span class=\"line\">        &lt;h2 id=&quot;subtitle-wrap&quot;&gt;</span><br><span class=\"line\">          &lt;a href=&quot;&lt;%- config.root %&gt;&quot; id=&quot;subtitle&quot;&gt;&lt;%= theme.subtitle %&gt;&lt;/a&gt;</span><br><span class=\"line\">        &lt;/h2&gt;</span><br><span class=\"line\">    &lt;% &#125; %&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后世界变清净了。<br><img src=\"http://ww3.sinaimg.cn/large/51530583gw1ee79b2xop4j201u0bt0sm.jpg\" alt=\"丑\"><br>默认主题里面banner上下都有个渐变，换了图之后就尤其丑，干掉之。<br>这个是样式的修改，所以肯定在<code>present/source/css/_partial</code>里面了，再看这位置明显是header嘛，所以<code>header.styl</code>就是你了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#header</span><br><span class=\"line\">  height: banner-height</span><br><span class=\"line\">  position: relative</span><br><span class=\"line\">  border-bottom: 1px solid color-border</span><br><span class=\"line\">  &amp;:before, &amp;:after</span><br><span class=\"line\">    content: &quot;&quot;</span><br><span class=\"line\">    position: absolute</span><br><span class=\"line\">    left: 0</span><br><span class=\"line\">    right: 0</span><br><span class=\"line\">    height: 40px</span><br><span class=\"line\">  &amp;:before</span><br><span class=\"line\">    top: 0</span><br><span class=\"line\">    background: linear-gradient(rgba(0, 0, 0, 0.2), transparent) // 找到你了，注释掉！</span><br><span class=\"line\">  &amp;:after</span><br><span class=\"line\">    bottom: 0</span><br><span class=\"line\">    background: linear-gradient(transparent, rgba(0, 0, 0, 0.2)) // 也找到你了，注释掉！</span><br></pre></td></tr></table></figure></p>\n<p>瞬间清爽很多，但又发现去掉之后字看不清了：<br><img src=\"http://ww4.sinaimg.cn/large/51530583gw1ee79ex02pgj206901u0qo.jpg\" alt=\"看不清！\"><br>还是在这个文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$nav-link</span><br><span class=\"line\">  float: left</span><br><span class=\"line\">  color: #000 // 改个深色</span><br><span class=\"line\">  opacity: 1.0 // 别半透明的</span><br><span class=\"line\">  text-decoration: none</span><br><span class=\"line\">  /*text-shadow: 0 1px rgba(0, 0, 0, 0.2)*/ // 改个阴影</span><br><span class=\"line\">  transition: opacity 0.2s</span><br><span class=\"line\">  display: block</span><br><span class=\"line\">  padding: 20px 15px</span><br><span class=\"line\">  &amp;:hover</span><br><span class=\"line\">    opacity: 1</span><br></pre></td></tr></table></figure>\n<p>much better<br><img src=\"http://ww3.sinaimg.cn/large/51530583tw1ee79mmlwkaj205401iwe9.jpg\" alt=\"better\"></p>\n<p>##定制样式</p>\n<p>列几个常用的：</p>\n<p>在<code>/themes/present/source/css/_variables.styl</code>中：</p>\n<h4 id=\"调整主区域布局（很值得修改）\"><a href=\"#调整主区域布局（很值得修改）\" class=\"headerlink\" title=\"调整主区域布局（很值得修改）\"></a>调整主区域布局（很值得修改）</h4><p>默认的主题的主区域太窄了，没几个字就得换行，下面的<code>main-column</code>控制主区域宽，<code>sidebar-column</code>控制sidebar宽，这两个值加一起凑成全部宽度，会居中对齐。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Layout</span><br><span class=\"line\">block-margin = 20px</span><br><span class=\"line\">article-padding = 20px // 文章内缩进</span><br><span class=\"line\">mobile-nav-width = 280px</span><br><span class=\"line\">main-column = 12 // 主文章区域的宽度</span><br><span class=\"line\">sidebar-column = 3 // 侧边栏区域的宽度</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"修改代码字体\"><a href=\"#修改代码字体\" class=\"headerlink\" title=\"修改代码字体\"></a>修改代码字体</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">font-mono = Menlo/*Menlo必须提前面啊*/, &quot;Source Code Pro&quot;, Monaco, Consolas, Consolas, monospace</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改正文字体和行高\"><a href=\"#修改正文字体和行高\" class=\"headerlink\" title=\"修改正文字体和行高\"></a>修改正文字体和行高</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">font-size = 15px // Menlo字体我看15px的很清楚</span><br><span class=\"line\">line-height = 1.6em</span><br><span class=\"line\">line-height-title = 1.3em</span><br></pre></td></tr></table></figure>\n<hr>\n<p>位于<code>/themes/present/source/css/_partial/article.styl</code>的样式文件负责文章里面的样式</p>\n<h4 id=\"修改图片格式\"><a href=\"#修改图片格式\" class=\"headerlink\" title=\"修改图片格式\"></a>修改图片格式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">img, video</span><br><span class=\"line\">  max-width: 80%</span><br><span class=\"line\">  height: auto</span><br><span class=\"line\">  display: block</span><br><span class=\"line\">  margin: auto</span><br></pre></td></tr></table></figure>\n<p>去除图片的描述的caption的话，去<code>present/source/js/script.js</code>中修改：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Caption</span><br><span class=\"line\">  $(&apos;.article-entry&apos;).each(function(i)&#123;</span><br><span class=\"line\">    $(this).find(&apos;img&apos;).each(function()&#123;</span><br><span class=\"line\">      if ($(this).parent().hasClass(&apos;fancybox&apos;)) return;</span><br><span class=\"line\"></span><br><span class=\"line\">      var alt = this.alt;</span><br><span class=\"line\"></span><br><span class=\"line\">      // if (alt) $(this).after(&apos;&lt;span class=&quot;caption&quot;&gt;&apos; + alt + &apos;&lt;/span&gt;&apos;); 这个去掉</span><br><span class=\"line\"></span><br><span class=\"line\">      $(this).wrap(&apos;&lt;a href=&quot;&apos; + this.src + &apos;&quot; title=&quot;&apos; + alt + &apos;&quot; class=&quot;fancybox&quot;&gt;&lt;/a&gt;&apos;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    $(this).find(&apos;.fancybox&apos;).each(function()&#123;</span><br><span class=\"line\">      $(this).attr(&apos;rel&apos;, &apos;article&apos; + i);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"修改blockquote样式\"><a href=\"#修改blockquote样式\" class=\"headerlink\" title=\"修改blockquote样式\"></a>修改blockquote样式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blockquote</span><br><span class=\"line\">  font-family: font-serif</span><br><span class=\"line\">  font-size: 2.0em // 搞大点</span><br><span class=\"line\">  margin: line-height 20px</span><br><span class=\"line\">  text-align: left // 必须应该左对齐啊</span><br></pre></td></tr></table></figure>\n<hr>\n<p>位于<code>/themes/present/source/css/_extend.styl</code>的样式文件定义了基本样式</p>\n<h4 id=\"修改标题样式\"><a href=\"#修改标题样式\" class=\"headerlink\" title=\"修改标题样式\"></a>修改标题样式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h1</span><br><span class=\"line\">  font-size: 2em</span><br><span class=\"line\">h2</span><br><span class=\"line\">  font-size: 1.5em</span><br><span class=\"line\">h3</span><br><span class=\"line\">  font-size: 1.3em</span><br><span class=\"line\">h4</span><br><span class=\"line\">  font-size: 1.2em</span><br><span class=\"line\">h5</span><br><span class=\"line\">  font-size: 1em</span><br><span class=\"line\">h6</span><br><span class=\"line\">  font-size: 1em</span><br><span class=\"line\">  color: color-grey</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改文章背景\"><a href=\"#修改文章背景\" class=\"headerlink\" title=\"修改文章背景\"></a>修改文章背景</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$block</span><br><span class=\"line\">  background: #fbfbfb // 白里透着灰</span><br><span class=\"line\">  /*box-shadow: 1px 2px 3px #eee*/ // 扁平化咋能要阴影</span><br><span class=\"line\">  border: 1.5px solid #ccc // 边框</span><br><span class=\"line\">  border-radius: 10px // 圆角矩形走起</span><br></pre></td></tr></table></figure>\n<h2 id=\"定制代码样式\"><a href=\"#定制代码样式\" class=\"headerlink\" title=\"定制代码样式\"></a>定制代码样式</h2><p>这个必须单拿出来写  </p>\n<blockquote>\n<p>We shall show no mercy to those shit colored codes —– sunnyxx</p>\n</blockquote>\n<p>代码的高亮样式在<code>present/source/css/_partial/highlight.styl</code>中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$code-block</span><br><span class=\"line\">  background: highlight-background</span><br><span class=\"line\">  /*margin: 0 article-padding * -1*/</span><br><span class=\"line\">  margin: auto // 默认的顶边对齐是怎么回事？改个居中</span><br><span class=\"line\">  padding: 15px article-padding</span><br><span class=\"line\">  border-style: solid</span><br><span class=\"line\">  border-color: color-border</span><br><span class=\"line\">  border-width: 0px 0</span><br><span class=\"line\">  border-radius: 5px // 加个圆角~</span><br><span class=\"line\">  overflow: auto</span><br><span class=\"line\">  color: highlight-foreground</span><br><span class=\"line\">  line-height: font-size * line-height</span><br><span class=\"line\"></span><br><span class=\"line\">$line-numbers</span><br><span class=\"line\">  color: #666</span><br><span class=\"line\">  font-size: 0.85em // 行号大小</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">.highlight</span><br><span class=\"line\">    @extend $code-block</span><br><span class=\"line\">    pre</span><br><span class=\"line\">      border: none</span><br><span class=\"line\">      margin: 0</span><br><span class=\"line\">      padding: 0</span><br><span class=\"line\">    table</span><br><span class=\"line\">      margin: 0</span><br><span class=\"line\">      width: auto</span><br><span class=\"line\">      font-size: 14px // 设置代码字体</span><br><span class=\"line\">      letter-spacing: 1px // 设置字间距，要不太挤了</span><br></pre></td></tr></table></figure></p>\n<p>Code block高亮：<code>我是小代码块高亮</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.article-entry</span><br><span class=\"line\">  pre, code</span><br><span class=\"line\">    font-family: font-mono</span><br><span class=\"line\">  code</span><br><span class=\"line\">    background: #e3e3e3</span><br><span class=\"line\">    color: #666</span><br><span class=\"line\">    border-radius: 3px // 也来个圆角</span><br><span class=\"line\">    border-width 1px</span><br><span class=\"line\">    border-color: #fff</span><br><span class=\"line\">    text-shadow: 0 1px #fff</span><br><span class=\"line\">    padding: 0.1em 0.3em // 控制大小</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"开始定制widget\"><a href=\"#开始定制widget\" class=\"headerlink\" title=\"开始定制widget\"></a>开始定制widget</h1><h2 id=\"添加多说评论\"><a href=\"#添加多说评论\" class=\"headerlink\" title=\"添加多说评论\"></a>添加多说评论</h2><p>在<code>present/layout/_partial/article.ejs</code>中最下面，要不用discuss的话先注掉，换成下面的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% if (!index &amp;&amp; post.comments)&#123; %&gt;</span><br><span class=\"line\">&lt;section id=&quot;comments&quot;&gt;</span><br><span class=\"line\">  &lt;!-- Duoshuo Comment BEGIN --&gt;</span><br><span class=\"line\">  &lt;div class=&quot;ds-thread&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">      var duoshuoQuery = &#123;short_name:&quot;sunnyxx&quot;&#125;;</span><br><span class=\"line\">        (function() &#123;</span><br><span class=\"line\">          var ds = document.createElement(&apos;script&apos;);</span><br><span class=\"line\">          ds.type = &apos;text/javascript&apos;;ds.async = true;</span><br><span class=\"line\">          ds.src = &apos;http://static.duoshuo.com/embed.js&apos;;</span><br><span class=\"line\">          ds.charset = &apos;UTF-8&apos;;</span><br><span class=\"line\">          (document.getElementsByTagName(&apos;head&apos;)[0]</span><br><span class=\"line\">          || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds);</span><br><span class=\"line\">        &#125;)();</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;!-- Duoshuo Comment END --&gt;</span><br><span class=\"line\">&lt;/section&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加友情链接\"><a href=\"#添加友情链接\" class=\"headerlink\" title=\"添加友情链接\"></a>添加友情链接</h2><p>首先，在<code>present/layout/_widget/</code>目录下新建一个文件，随便copy个当前目录下的改名也行，我这儿叫<code>friends.ejs</code><br>编辑这个文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;widget tag&quot;&gt;</span><br><span class=\"line\">\t&lt;h3 class=&quot;title&quot;&gt;友情链接&lt;/h3&gt;</span><br><span class=\"line\">\t&lt;ul class=&quot;entry&quot;&gt;</span><br><span class=\"line\">\t&lt;li&gt;&lt;a href=&quot;http://zhouxl.github.io&quot; title=&quot;小六&quot;&gt;小六的博客&lt;/a&gt;&lt;/li&gt;</span><br><span class=\"line\">\t&lt;/ul&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>里面以上面的格式定义友情链接，css套用了tag定义好的格式，随后修改<code>present/_config.yml</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Sidebar</span><br><span class=\"line\">sidebar: right</span><br><span class=\"line\">widgets:</span><br><span class=\"line\">- category</span><br><span class=\"line\">- tag</span><br><span class=\"line\">- tagcloud</span><br><span class=\"line\">- archive</span><br><span class=\"line\">- recent_posts</span><br><span class=\"line\">- friends // 新加的就是刚才`_widget`目录中新建的文件的文件名</span><br></pre></td></tr></table></figure></p>\n<p>然后刷新页面，效果就出来了~</p>\n","excerpt":"","more":"<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><h2 id=\"Fork-it\"><a href=\"#Fork-it\" class=\"headerlink\" title=\"Fork it!\"></a>Fork it!</h2><p>从0开始多费劲，先从hexo的主题中选一个看的过去的，从上面加工。<br>这次选的是hexo的默认主题<code>Landscape</code>，觉得一个大banner挺好看而已。<br>主题在github上，<a href=\"https://github.com/hexojs/hexo-theme-landscape\">https://github.com/hexojs/hexo-theme-landscape</a><br>废话不说，先fork一份，虽然不会再merge回去了。<br>fork完去setting页面改个名字，就叫它<code>present</code>了，因为当时看到群里正说<code>presentViewController</code>的事- -</p>\n<p><img src=\"http://ww3.sinaimg.cn/large/51530583gw1ee7835uauoj20j804mwen.jpg\" alt=\"\"></p>\n<ul>\n<li>hexo工程的<code>themes/</code>目录默认是在<code>.gitignore</code>里的，意思是主题和内容是应该分开的<br>theme作为主项目的<code>submodule</code>，所以主题更改时也应该单独提交了</li>\n</ul>\n<h2 id=\"Clone-it！\"><a href=\"#Clone-it！\" class=\"headerlink\" title=\"Clone it！\"></a>Clone it！</h2><p>把刚fork的名为<code>present</code>的theme安装到hexo目录：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/sunnyxx/present themes/present</span><br></pre></td></tr></table></figure>\n<p>去<code>/_config.yml</code>中找到并设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Extensions</span><br><span class=\"line\">## Plugins: https://github.com/tommy351/hexo/wiki/Plugins</span><br><span class=\"line\">## Themes: https://github.com/tommy351/hexo/wiki/Themes</span><br><span class=\"line\">theme: present // 修改这儿</span><br></pre></td></tr></table></figure>\n<p>运行下<code>hexo server</code>就能立刻看到效果了</p>\n<h1 id=\"开始定制theme\"><a href=\"#开始定制theme\" class=\"headerlink\" title=\"开始定制theme\"></a>开始定制theme</h1><p>先得看看hexo theme里面的结构：</p>\n<ul>\n<li>_config.yml - 主题总体配置</li>\n<li>/layout/*.ejs - 网页布局</li>\n<li>/source/css/*.styl - 网页样式</li>\n</ul>\n<h2 id=\"定制banner\"><a href=\"#定制banner\" class=\"headerlink\" title=\"定制banner\"></a>定制banner</h2><p><img src=\"http://ww4.sinaimg.cn/large/51530583gw1ee78mkdkspj20jp06bq3h.jpg\" alt=\"banner\"><br>默认的banner图是个地球星空图，先从它下手，这张图位于<code>/themes/present/source/css/images/banner.jpg</code><br>这图分辨率有<code>1920x1200</code>之大，显示的部分很少，搞一张喜欢的banner图，PS成大概的尺寸（高度还就得设的很大才行，虽然只显示一小部分，否则会出现显示不出来图片的状况），我这儿PS过的是一张png，名为<code>banner.png</code>，文件名修改需找找到位于<code>/themes/present/source/css/_variables.styl</code>中，修改为<code>banner.png</code><br><strong>当然，考虑到github的访问速度，这张大图我最后决定用上传微博图床，使用生成的URL，这样加载就快很多</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Header</span><br><span class=\"line\">logo-size = 40px</span><br><span class=\"line\">subtitle-size = 16px</span><br><span class=\"line\">banner-height = 404px // 看看多高合适</span><br><span class=\"line\">banner-url = &quot;images/banner.png&quot; // 修改这里</span><br></pre></td></tr></table></figure></p>\n<p>然后就变成这鸟样了：<br><img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee790pxkk9j20fv085t9c.jpg\" alt=\"专业多了\"><br>这个标题横在这儿太恶心了，我的banner里面已经有标题了，这就是需要修改布局了，header的布局在<code>/themes/present/layout/_partial/header.ejs</code>，打开修改：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 把这一段都注释掉好了：</span><br><span class=\"line\">&lt;div id=&quot;header-title&quot; class=&quot;inner&quot;&gt;</span><br><span class=\"line\">    &lt;h1 id=&quot;logo-wrap&quot;&gt;</span><br><span class=\"line\">        &lt;a href=&quot;&lt;%- config.root %&gt;&quot; id=&quot;logo&quot;&gt;&lt;%= config.title %&gt;&lt;/a&gt;</span><br><span class=\"line\">    &lt;/h1&gt;</span><br><span class=\"line\">    &lt;% if (theme.subtitle)&#123; %&gt;</span><br><span class=\"line\">        &lt;h2 id=&quot;subtitle-wrap&quot;&gt;</span><br><span class=\"line\">          &lt;a href=&quot;&lt;%- config.root %&gt;&quot; id=&quot;subtitle&quot;&gt;&lt;%= theme.subtitle %&gt;&lt;/a&gt;</span><br><span class=\"line\">        &lt;/h2&gt;</span><br><span class=\"line\">    &lt;% &#125; %&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后世界变清净了。<br><img src=\"http://ww3.sinaimg.cn/large/51530583gw1ee79b2xop4j201u0bt0sm.jpg\" alt=\"丑\"><br>默认主题里面banner上下都有个渐变，换了图之后就尤其丑，干掉之。<br>这个是样式的修改，所以肯定在<code>present/source/css/_partial</code>里面了，再看这位置明显是header嘛，所以<code>header.styl</code>就是你了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#header</span><br><span class=\"line\">  height: banner-height</span><br><span class=\"line\">  position: relative</span><br><span class=\"line\">  border-bottom: 1px solid color-border</span><br><span class=\"line\">  &amp;:before, &amp;:after</span><br><span class=\"line\">    content: &quot;&quot;</span><br><span class=\"line\">    position: absolute</span><br><span class=\"line\">    left: 0</span><br><span class=\"line\">    right: 0</span><br><span class=\"line\">    height: 40px</span><br><span class=\"line\">  &amp;:before</span><br><span class=\"line\">    top: 0</span><br><span class=\"line\">    background: linear-gradient(rgba(0, 0, 0, 0.2), transparent) // 找到你了，注释掉！</span><br><span class=\"line\">  &amp;:after</span><br><span class=\"line\">    bottom: 0</span><br><span class=\"line\">    background: linear-gradient(transparent, rgba(0, 0, 0, 0.2)) // 也找到你了，注释掉！</span><br></pre></td></tr></table></figure></p>\n<p>瞬间清爽很多，但又发现去掉之后字看不清了：<br><img src=\"http://ww4.sinaimg.cn/large/51530583gw1ee79ex02pgj206901u0qo.jpg\" alt=\"看不清！\"><br>还是在这个文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$nav-link</span><br><span class=\"line\">  float: left</span><br><span class=\"line\">  color: #000 // 改个深色</span><br><span class=\"line\">  opacity: 1.0 // 别半透明的</span><br><span class=\"line\">  text-decoration: none</span><br><span class=\"line\">  /*text-shadow: 0 1px rgba(0, 0, 0, 0.2)*/ // 改个阴影</span><br><span class=\"line\">  transition: opacity 0.2s</span><br><span class=\"line\">  display: block</span><br><span class=\"line\">  padding: 20px 15px</span><br><span class=\"line\">  &amp;:hover</span><br><span class=\"line\">    opacity: 1</span><br></pre></td></tr></table></figure>\n<p>much better<br><img src=\"http://ww3.sinaimg.cn/large/51530583tw1ee79mmlwkaj205401iwe9.jpg\" alt=\"better\"></p>\n<p>##定制样式</p>\n<p>列几个常用的：</p>\n<p>在<code>/themes/present/source/css/_variables.styl</code>中：</p>\n<h4 id=\"调整主区域布局（很值得修改）\"><a href=\"#调整主区域布局（很值得修改）\" class=\"headerlink\" title=\"调整主区域布局（很值得修改）\"></a>调整主区域布局（很值得修改）</h4><p>默认的主题的主区域太窄了，没几个字就得换行，下面的<code>main-column</code>控制主区域宽，<code>sidebar-column</code>控制sidebar宽，这两个值加一起凑成全部宽度，会居中对齐。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Layout</span><br><span class=\"line\">block-margin = 20px</span><br><span class=\"line\">article-padding = 20px // 文章内缩进</span><br><span class=\"line\">mobile-nav-width = 280px</span><br><span class=\"line\">main-column = 12 // 主文章区域的宽度</span><br><span class=\"line\">sidebar-column = 3 // 侧边栏区域的宽度</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"修改代码字体\"><a href=\"#修改代码字体\" class=\"headerlink\" title=\"修改代码字体\"></a>修改代码字体</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">font-mono = Menlo/*Menlo必须提前面啊*/, &quot;Source Code Pro&quot;, Monaco, Consolas, Consolas, monospace</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改正文字体和行高\"><a href=\"#修改正文字体和行高\" class=\"headerlink\" title=\"修改正文字体和行高\"></a>修改正文字体和行高</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">font-size = 15px // Menlo字体我看15px的很清楚</span><br><span class=\"line\">line-height = 1.6em</span><br><span class=\"line\">line-height-title = 1.3em</span><br></pre></td></tr></table></figure>\n<hr>\n<p>位于<code>/themes/present/source/css/_partial/article.styl</code>的样式文件负责文章里面的样式</p>\n<h4 id=\"修改图片格式\"><a href=\"#修改图片格式\" class=\"headerlink\" title=\"修改图片格式\"></a>修改图片格式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">img, video</span><br><span class=\"line\">  max-width: 80%</span><br><span class=\"line\">  height: auto</span><br><span class=\"line\">  display: block</span><br><span class=\"line\">  margin: auto</span><br></pre></td></tr></table></figure>\n<p>去除图片的描述的caption的话，去<code>present/source/js/script.js</code>中修改：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Caption</span><br><span class=\"line\">  $(&apos;.article-entry&apos;).each(function(i)&#123;</span><br><span class=\"line\">    $(this).find(&apos;img&apos;).each(function()&#123;</span><br><span class=\"line\">      if ($(this).parent().hasClass(&apos;fancybox&apos;)) return;</span><br><span class=\"line\"></span><br><span class=\"line\">      var alt = this.alt;</span><br><span class=\"line\"></span><br><span class=\"line\">      // if (alt) $(this).after(&apos;&lt;span class=&quot;caption&quot;&gt;&apos; + alt + &apos;&lt;/span&gt;&apos;); 这个去掉</span><br><span class=\"line\"></span><br><span class=\"line\">      $(this).wrap(&apos;&lt;a href=&quot;&apos; + this.src + &apos;&quot; title=&quot;&apos; + alt + &apos;&quot; class=&quot;fancybox&quot;&gt;&lt;/a&gt;&apos;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    $(this).find(&apos;.fancybox&apos;).each(function()&#123;</span><br><span class=\"line\">      $(this).attr(&apos;rel&apos;, &apos;article&apos; + i);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"修改blockquote样式\"><a href=\"#修改blockquote样式\" class=\"headerlink\" title=\"修改blockquote样式\"></a>修改blockquote样式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blockquote</span><br><span class=\"line\">  font-family: font-serif</span><br><span class=\"line\">  font-size: 2.0em // 搞大点</span><br><span class=\"line\">  margin: line-height 20px</span><br><span class=\"line\">  text-align: left // 必须应该左对齐啊</span><br></pre></td></tr></table></figure>\n<hr>\n<p>位于<code>/themes/present/source/css/_extend.styl</code>的样式文件定义了基本样式</p>\n<h4 id=\"修改标题样式\"><a href=\"#修改标题样式\" class=\"headerlink\" title=\"修改标题样式\"></a>修改标题样式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h1</span><br><span class=\"line\">  font-size: 2em</span><br><span class=\"line\">h2</span><br><span class=\"line\">  font-size: 1.5em</span><br><span class=\"line\">h3</span><br><span class=\"line\">  font-size: 1.3em</span><br><span class=\"line\">h4</span><br><span class=\"line\">  font-size: 1.2em</span><br><span class=\"line\">h5</span><br><span class=\"line\">  font-size: 1em</span><br><span class=\"line\">h6</span><br><span class=\"line\">  font-size: 1em</span><br><span class=\"line\">  color: color-grey</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改文章背景\"><a href=\"#修改文章背景\" class=\"headerlink\" title=\"修改文章背景\"></a>修改文章背景</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$block</span><br><span class=\"line\">  background: #fbfbfb // 白里透着灰</span><br><span class=\"line\">  /*box-shadow: 1px 2px 3px #eee*/ // 扁平化咋能要阴影</span><br><span class=\"line\">  border: 1.5px solid #ccc // 边框</span><br><span class=\"line\">  border-radius: 10px // 圆角矩形走起</span><br></pre></td></tr></table></figure>\n<h2 id=\"定制代码样式\"><a href=\"#定制代码样式\" class=\"headerlink\" title=\"定制代码样式\"></a>定制代码样式</h2><p>这个必须单拿出来写  </p>\n<blockquote>\n<p>We shall show no mercy to those shit colored codes —– sunnyxx</p>\n</blockquote>\n<p>代码的高亮样式在<code>present/source/css/_partial/highlight.styl</code>中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$code-block</span><br><span class=\"line\">  background: highlight-background</span><br><span class=\"line\">  /*margin: 0 article-padding * -1*/</span><br><span class=\"line\">  margin: auto // 默认的顶边对齐是怎么回事？改个居中</span><br><span class=\"line\">  padding: 15px article-padding</span><br><span class=\"line\">  border-style: solid</span><br><span class=\"line\">  border-color: color-border</span><br><span class=\"line\">  border-width: 0px 0</span><br><span class=\"line\">  border-radius: 5px // 加个圆角~</span><br><span class=\"line\">  overflow: auto</span><br><span class=\"line\">  color: highlight-foreground</span><br><span class=\"line\">  line-height: font-size * line-height</span><br><span class=\"line\"></span><br><span class=\"line\">$line-numbers</span><br><span class=\"line\">  color: #666</span><br><span class=\"line\">  font-size: 0.85em // 行号大小</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">.highlight</span><br><span class=\"line\">    @extend $code-block</span><br><span class=\"line\">    pre</span><br><span class=\"line\">      border: none</span><br><span class=\"line\">      margin: 0</span><br><span class=\"line\">      padding: 0</span><br><span class=\"line\">    table</span><br><span class=\"line\">      margin: 0</span><br><span class=\"line\">      width: auto</span><br><span class=\"line\">      font-size: 14px // 设置代码字体</span><br><span class=\"line\">      letter-spacing: 1px // 设置字间距，要不太挤了</span><br></pre></td></tr></table></figure></p>\n<p>Code block高亮：<code>我是小代码块高亮</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.article-entry</span><br><span class=\"line\">  pre, code</span><br><span class=\"line\">    font-family: font-mono</span><br><span class=\"line\">  code</span><br><span class=\"line\">    background: #e3e3e3</span><br><span class=\"line\">    color: #666</span><br><span class=\"line\">    border-radius: 3px // 也来个圆角</span><br><span class=\"line\">    border-width 1px</span><br><span class=\"line\">    border-color: #fff</span><br><span class=\"line\">    text-shadow: 0 1px #fff</span><br><span class=\"line\">    padding: 0.1em 0.3em // 控制大小</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"开始定制widget\"><a href=\"#开始定制widget\" class=\"headerlink\" title=\"开始定制widget\"></a>开始定制widget</h1><h2 id=\"添加多说评论\"><a href=\"#添加多说评论\" class=\"headerlink\" title=\"添加多说评论\"></a>添加多说评论</h2><p>在<code>present/layout/_partial/article.ejs</code>中最下面，要不用discuss的话先注掉，换成下面的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% if (!index &amp;&amp; post.comments)&#123; %&gt;</span><br><span class=\"line\">&lt;section id=&quot;comments&quot;&gt;</span><br><span class=\"line\">  &lt;!-- Duoshuo Comment BEGIN --&gt;</span><br><span class=\"line\">  &lt;div class=&quot;ds-thread&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">      var duoshuoQuery = &#123;short_name:&quot;sunnyxx&quot;&#125;;</span><br><span class=\"line\">        (function() &#123;</span><br><span class=\"line\">          var ds = document.createElement(&apos;script&apos;);</span><br><span class=\"line\">          ds.type = &apos;text/javascript&apos;;ds.async = true;</span><br><span class=\"line\">          ds.src = &apos;http://static.duoshuo.com/embed.js&apos;;</span><br><span class=\"line\">          ds.charset = &apos;UTF-8&apos;;</span><br><span class=\"line\">          (document.getElementsByTagName(&apos;head&apos;)[0]</span><br><span class=\"line\">          || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds);</span><br><span class=\"line\">        &#125;)();</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;!-- Duoshuo Comment END --&gt;</span><br><span class=\"line\">&lt;/section&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加友情链接\"><a href=\"#添加友情链接\" class=\"headerlink\" title=\"添加友情链接\"></a>添加友情链接</h2><p>首先，在<code>present/layout/_widget/</code>目录下新建一个文件，随便copy个当前目录下的改名也行，我这儿叫<code>friends.ejs</code><br>编辑这个文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;widget tag&quot;&gt;</span><br><span class=\"line\">\t&lt;h3 class=&quot;title&quot;&gt;友情链接&lt;/h3&gt;</span><br><span class=\"line\">\t&lt;ul class=&quot;entry&quot;&gt;</span><br><span class=\"line\">\t&lt;li&gt;&lt;a href=&quot;http://zhouxl.github.io&quot; title=&quot;小六&quot;&gt;小六的博客&lt;/a&gt;&lt;/li&gt;</span><br><span class=\"line\">\t&lt;/ul&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>里面以上面的格式定义友情链接，css套用了tag定义好的格式，随后修改<code>present/_config.yml</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Sidebar</span><br><span class=\"line\">sidebar: right</span><br><span class=\"line\">widgets:</span><br><span class=\"line\">- category</span><br><span class=\"line\">- tag</span><br><span class=\"line\">- tagcloud</span><br><span class=\"line\">- archive</span><br><span class=\"line\">- recent_posts</span><br><span class=\"line\">- friends // 新加的就是刚才`_widget`目录中新建的文件的文件名</span><br></pre></td></tr></table></figure></p>\n<p>然后刷新页面，效果就出来了~</p>\n"},{"title":"hexo边搭边记","date":"2014-02-27T06:56:47.000Z","_content":"\n# Install\n**安装nvm（Node Version Manager）**，Terminal中运行\n\n    $ curl https://raw.githubusercontent.com/creationix/nvm/v0.7.0/install.sh | sh\n会提示：\n\n    => Close and reopen your terminal to start using NVM\n退出Terminal重启后nvm命令才能生效。\n假如update失败，可能没有profile文件，touch一下：\n\n``` shell\n$ touch ~/.bash_profile\n$ touch ~/.profile\n```\n  使用nvm安装node.js：\n\n``` shell\n$ nvm install 0.10\n```\n下完后安装hexo，这一步时间比较长：\n\n    $ npm install -g hexo\n\n然后找个文件初始化blog：\n\n    $ cd ~/git/blog  \n    $ hexo init .\n    $ ls\n\n[update]更新hexo2.6版本后安装还需要执行：\n\n``` shell\n$ npm install hexo-renderer-ejs --save\n$ npm install hexo-renderer-stylus --save\n$ npm install hexo-renderer-marked --save\n```\n\n生成出的目录结构：\n\n    .\n    ├── _config.yml\n    ├── package.json\n    ├── scaffolds\n    ├── scripts\n    ├── source\n    |   ├── _drafts\n    |   └── _posts\n    └── themes\n\n新建一篇文章：\n\n    $ hexo new mac下使用hexo搭建blog\n$ open source/_posts/mac下使用hexo搭建blog.md\n编辑md后生成html：\n\n    $ hexo generate\n本地预览：\n\n    $ hexo server\n    => [info] Hexo is running at localhost:4000/. Press Ctrl+C to stop.\nTheme，去官方提供的[主题列表][1]中选个现成的，按照里面的方法pull下来，如light主题\n\n\n    $ git clone git://github.com/tommy351/hexo-theme-light.git themes/light\n\n_config.yml配置文件中设置：\n\n    theme: light\n重新generate和server预览，就看到变化了。\n\n## deploy\n\ngithub上建个respository，设置里设一下\n在`_config.yml`中：\n``` yml\ndeploy:\ntype: github\nrepository: https://github.com/sunnyxx/blog-hexo.git\n```\n然后执行：\n\n    $ hexo deploy\n就行了，github会多一个branch，比octopress简单\n\n## 绑定域名\n去万网买了这个域名`sunnyxx.com`，以`blog.sunnyxx.com`作为博客的域名，\n看万网是阿里的才从那儿买的，后来发现`DNSPod`貌似比较好，万网的后台做的那叫一个*，但愿解析速度上别再不行就行。\n托管在github上，首先建一个CNAME文件，里面写`最终指向`的域名：\n``` bash\n$ blog.sunnyxx.com > public/CNAME\n```\n然后去域名后台配置下，由于github表示说我托管的页面的域名是：`sunnyxx.github.io`\n所以建一个CNAME记录，将`blog.sunnyxx.com`解析到`sunnyxx.github.io`\nDNS域名解析最常用的是**A记录**和**CNAME记录**，A记录把域名解析到服务器IP，CNAME相当于把一个域名指向另一个域名，因此我这个用的是CNAME，要是托管的服务器也是自己搭的那就用A记录了。\n完事之后得等一段时间（DNSPod说几秒内就同步完，要是这样真心是它好）\n使用下面的命令测一下域名的解析\n``` bash\n$ dig blog.sunnyxx.com +nostats +nocomments +nocmd\n\n=> output:\n;; global options: +cmd\n;blog.sunnyxx.com.      IN  A\nblog.sunnyxx.com.   1778    IN  CNAME   sunnyxx.github.io.\nsunnyxx.github.io.  1778    IN  CNAME   github.map.fastly.net.\ngithub.map.fastly.net.  30  IN  A   103.245.222.133\n```\n这说明是成功了，发现解析过程是`blog.sunnyxx.com`->`sunnyxx.github.io`->`github.map.fastly.net`->`103.245.222.133` 最终指向了github的web server\n由于国内GreatWall，解析速度明显不稳定，有时候都连不上，以后再看怎么办吧\n\n## 添加sitemap\n同样的，我们使用hexo提供的插件，方法与添加RSS类似。\n安装sitemap到本地：\n```\nnpm install hexo-generator-sitemap\n```\n开启sitemap功能：编辑hexo/_config.yml，添加如下代码：\n```\nplugins:\n- hexo-generator-sitemap\n```\n访问zipperary/sitemap.xml即可看到站点地图。不过，sitemap的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到google和百度等搜索引擎提交sitemap.xml。\n\n## 文章中插入图片\n\n原来用octopress写的时候在目录下面建个`images`目录来保存图片，引用时使用了相对路径就行了，但这是让我最蛋疼的事，想发个图片还得命个名，然后`mv`过去，再引进来，特别墨迹。hexo中当然也可以用这种方法，但是发现使用个`图床`来搞定图片真是一劳永逸了。\n\n\n**微博图床**，地址http://weibotuchuang.sinaapp.com/，我是chrome用户，所以下了个他的插件，装完了点开发现直接把图片拖进去就行了：\n![enter image description here][3]\n生成的地址直接用就行了\n有时候需要使用QQ截屏，只要随便截到某个人的聊天窗口里面，不用发送，然后直接拖拽到这个小窗口里面就OK了。\n> Life saver.\n\nPS：gif也没问题\n![1231231][2]\n\n## StackEdit - 超赞的Markdown在线编辑器  \n\n<img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee1a7efwa0j20hk03kwen.jpg\" width=\"500px\" />\n\n界面干净，所见即所得，支持同步到`Dropbox`和`github`，这个特别好，比如在公司写了点东西就可以一键同步，保留犯罪现场，回来之后继续写剩下的。\n\n遇到的问题\n-----\n第二次用的时候发现安装的hexo命令找不到了，重新use一下：\n```\n$ nvm use 0.10\n```\n\n**使用StackEdit时改变图片大小**\n\n```\n<img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee1a7efwa0j20hk03kwen.jpg\" width=\"200px align=\"center\" />\n```\n效果：\n  <img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee1a7efwa0j20hk03kwen.jpg\" width=\"200px\" />\n\n## 添加友情链接\n\n`themes/xxxxxx/layout/_widget/blogroll.ejs`\n```\n<div class=\"widget tag\">\n<h3 class=\"title\">友情链接</h3>\n<ul class=\"entry\">\n<li><a href=\"http://zhouxl.github.io\" title=\"小六\">小六的博客</a></li>\n</ul>\n</div>\n```\n\n  [1]: https://github.com/tommy351/hexo/wiki/Themes\n  [2]: http://ww2.sinaimg.cn/large/51530583gw1ee17y3p11zg207804lnhh.gif\n  [3]: http://ww2.sinaimg.cn/large/51530583gw1ee18d6ak6yj208c08ydg6.jpg\n  [4]: https://stackedit.io/res-min/img/logo-promo-128.png\n","source":"_posts/hexo_startup.md","raw":"title: hexo边搭边记\ndate: 2014-02-27 14:56:47\ntags: hexo\n---\n\n# Install\n**安装nvm（Node Version Manager）**，Terminal中运行\n\n    $ curl https://raw.githubusercontent.com/creationix/nvm/v0.7.0/install.sh | sh\n会提示：\n\n    => Close and reopen your terminal to start using NVM\n退出Terminal重启后nvm命令才能生效。\n假如update失败，可能没有profile文件，touch一下：\n\n``` shell\n$ touch ~/.bash_profile\n$ touch ~/.profile\n```\n  使用nvm安装node.js：\n\n``` shell\n$ nvm install 0.10\n```\n下完后安装hexo，这一步时间比较长：\n\n    $ npm install -g hexo\n\n然后找个文件初始化blog：\n\n    $ cd ~/git/blog  \n    $ hexo init .\n    $ ls\n\n[update]更新hexo2.6版本后安装还需要执行：\n\n``` shell\n$ npm install hexo-renderer-ejs --save\n$ npm install hexo-renderer-stylus --save\n$ npm install hexo-renderer-marked --save\n```\n\n生成出的目录结构：\n\n    .\n    ├── _config.yml\n    ├── package.json\n    ├── scaffolds\n    ├── scripts\n    ├── source\n    |   ├── _drafts\n    |   └── _posts\n    └── themes\n\n新建一篇文章：\n\n    $ hexo new mac下使用hexo搭建blog\n$ open source/_posts/mac下使用hexo搭建blog.md\n编辑md后生成html：\n\n    $ hexo generate\n本地预览：\n\n    $ hexo server\n    => [info] Hexo is running at localhost:4000/. Press Ctrl+C to stop.\nTheme，去官方提供的[主题列表][1]中选个现成的，按照里面的方法pull下来，如light主题\n\n\n    $ git clone git://github.com/tommy351/hexo-theme-light.git themes/light\n\n_config.yml配置文件中设置：\n\n    theme: light\n重新generate和server预览，就看到变化了。\n\n## deploy\n\ngithub上建个respository，设置里设一下\n在`_config.yml`中：\n``` yml\ndeploy:\ntype: github\nrepository: https://github.com/sunnyxx/blog-hexo.git\n```\n然后执行：\n\n    $ hexo deploy\n就行了，github会多一个branch，比octopress简单\n\n## 绑定域名\n去万网买了这个域名`sunnyxx.com`，以`blog.sunnyxx.com`作为博客的域名，\n看万网是阿里的才从那儿买的，后来发现`DNSPod`貌似比较好，万网的后台做的那叫一个*，但愿解析速度上别再不行就行。\n托管在github上，首先建一个CNAME文件，里面写`最终指向`的域名：\n``` bash\n$ blog.sunnyxx.com > public/CNAME\n```\n然后去域名后台配置下，由于github表示说我托管的页面的域名是：`sunnyxx.github.io`\n所以建一个CNAME记录，将`blog.sunnyxx.com`解析到`sunnyxx.github.io`\nDNS域名解析最常用的是**A记录**和**CNAME记录**，A记录把域名解析到服务器IP，CNAME相当于把一个域名指向另一个域名，因此我这个用的是CNAME，要是托管的服务器也是自己搭的那就用A记录了。\n完事之后得等一段时间（DNSPod说几秒内就同步完，要是这样真心是它好）\n使用下面的命令测一下域名的解析\n``` bash\n$ dig blog.sunnyxx.com +nostats +nocomments +nocmd\n\n=> output:\n;; global options: +cmd\n;blog.sunnyxx.com.      IN  A\nblog.sunnyxx.com.   1778    IN  CNAME   sunnyxx.github.io.\nsunnyxx.github.io.  1778    IN  CNAME   github.map.fastly.net.\ngithub.map.fastly.net.  30  IN  A   103.245.222.133\n```\n这说明是成功了，发现解析过程是`blog.sunnyxx.com`->`sunnyxx.github.io`->`github.map.fastly.net`->`103.245.222.133` 最终指向了github的web server\n由于国内GreatWall，解析速度明显不稳定，有时候都连不上，以后再看怎么办吧\n\n## 添加sitemap\n同样的，我们使用hexo提供的插件，方法与添加RSS类似。\n安装sitemap到本地：\n```\nnpm install hexo-generator-sitemap\n```\n开启sitemap功能：编辑hexo/_config.yml，添加如下代码：\n```\nplugins:\n- hexo-generator-sitemap\n```\n访问zipperary/sitemap.xml即可看到站点地图。不过，sitemap的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到google和百度等搜索引擎提交sitemap.xml。\n\n## 文章中插入图片\n\n原来用octopress写的时候在目录下面建个`images`目录来保存图片，引用时使用了相对路径就行了，但这是让我最蛋疼的事，想发个图片还得命个名，然后`mv`过去，再引进来，特别墨迹。hexo中当然也可以用这种方法，但是发现使用个`图床`来搞定图片真是一劳永逸了。\n\n\n**微博图床**，地址http://weibotuchuang.sinaapp.com/，我是chrome用户，所以下了个他的插件，装完了点开发现直接把图片拖进去就行了：\n![enter image description here][3]\n生成的地址直接用就行了\n有时候需要使用QQ截屏，只要随便截到某个人的聊天窗口里面，不用发送，然后直接拖拽到这个小窗口里面就OK了。\n> Life saver.\n\nPS：gif也没问题\n![1231231][2]\n\n## StackEdit - 超赞的Markdown在线编辑器  \n\n<img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee1a7efwa0j20hk03kwen.jpg\" width=\"500px\" />\n\n界面干净，所见即所得，支持同步到`Dropbox`和`github`，这个特别好，比如在公司写了点东西就可以一键同步，保留犯罪现场，回来之后继续写剩下的。\n\n遇到的问题\n-----\n第二次用的时候发现安装的hexo命令找不到了，重新use一下：\n```\n$ nvm use 0.10\n```\n\n**使用StackEdit时改变图片大小**\n\n```\n<img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee1a7efwa0j20hk03kwen.jpg\" width=\"200px align=\"center\" />\n```\n效果：\n  <img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee1a7efwa0j20hk03kwen.jpg\" width=\"200px\" />\n\n## 添加友情链接\n\n`themes/xxxxxx/layout/_widget/blogroll.ejs`\n```\n<div class=\"widget tag\">\n<h3 class=\"title\">友情链接</h3>\n<ul class=\"entry\">\n<li><a href=\"http://zhouxl.github.io\" title=\"小六\">小六的博客</a></li>\n</ul>\n</div>\n```\n\n  [1]: https://github.com/tommy351/hexo/wiki/Themes\n  [2]: http://ww2.sinaimg.cn/large/51530583gw1ee17y3p11zg207804lnhh.gif\n  [3]: http://ww2.sinaimg.cn/large/51530583gw1ee18d6ak6yj208c08ydg6.jpg\n  [4]: https://stackedit.io/res-min/img/logo-promo-128.png\n","slug":"hexo_startup","published":1,"updated":"2016-03-27T09:22:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxkf000hev12uyx2twh9","content":"<h1 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h1><p><strong>安装nvm（Node Version Manager）</strong>，Terminal中运行</p>\n<pre><code>$ curl https://raw.githubusercontent.com/creationix/nvm/v0.7.0/install.sh | sh\n</code></pre><p>会提示：</p>\n<pre><code>=&gt; Close and reopen your terminal to start using NVM\n</code></pre><p>退出Terminal重启后nvm命令才能生效。<br>假如update失败，可能没有profile文件，touch一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ touch ~/.bash_profile</span><br><span class=\"line\">$ touch ~/.profile</span><br></pre></td></tr></table></figure>\n<p>  使用nvm安装node.js：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ nvm install 0.10</span><br></pre></td></tr></table></figure>\n<p>下完后安装hexo，这一步时间比较长：</p>\n<pre><code>$ npm install -g hexo\n</code></pre><p>然后找个文件初始化blog：</p>\n<pre><code>$ cd ~/git/blog  \n$ hexo init .\n$ ls\n</code></pre><p>[update]更新hexo2.6版本后安装还需要执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-renderer-ejs --save</span><br><span class=\"line\">$ npm install hexo-renderer-stylus --save</span><br><span class=\"line\">$ npm install hexo-renderer-marked --save</span><br></pre></td></tr></table></figure>\n<p>生成出的目录结构：</p>\n<pre><code>.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── scripts\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n</code></pre><p>新建一篇文章：</p>\n<pre><code>$ hexo new mac下使用hexo搭建blog\n</code></pre><p>$ open source/_posts/mac下使用hexo搭建blog.md<br>编辑md后生成html：</p>\n<pre><code>$ hexo generate\n</code></pre><p>本地预览：</p>\n<pre><code>$ hexo server\n=&gt; [info] Hexo is running at localhost:4000/. Press Ctrl+C to stop.\n</code></pre><p>Theme，去官方提供的<a href=\"https://github.com/tommy351/hexo/wiki/Themes\" target=\"_blank\" rel=\"external\">主题列表</a>中选个现成的，按照里面的方法pull下来，如light主题</p>\n<pre><code>$ git clone git://github.com/tommy351/hexo-theme-light.git themes/light\n</code></pre><p>_config.yml配置文件中设置：</p>\n<pre><code>theme: light\n</code></pre><p>重新generate和server预览，就看到变化了。</p>\n<h2 id=\"deploy\"><a href=\"#deploy\" class=\"headerlink\" title=\"deploy\"></a>deploy</h2><p>github上建个respository，设置里设一下<br>在<code>_config.yml</code>中：<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">type:</span> github</span><br><span class=\"line\"><span class=\"attr\">repository:</span> https://github.com/sunnyxx/blog-hexo.git</span><br></pre></td></tr></table></figure></p>\n<p>然后执行：</p>\n<pre><code>$ hexo deploy\n</code></pre><p>就行了，github会多一个branch，比octopress简单</p>\n<h2 id=\"绑定域名\"><a href=\"#绑定域名\" class=\"headerlink\" title=\"绑定域名\"></a>绑定域名</h2><p>去万网买了这个域名<code>sunnyxx.com</code>，以<code>blog.sunnyxx.com</code>作为博客的域名，<br>看万网是阿里的才从那儿买的，后来发现<code>DNSPod</code>貌似比较好，万网的后台做的那叫一个*，但愿解析速度上别再不行就行。<br>托管在github上，首先建一个CNAME文件，里面写<code>最终指向</code>的域名：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ blog.sunnyxx.com &gt; public/CNAME</span><br></pre></td></tr></table></figure></p>\n<p>然后去域名后台配置下，由于github表示说我托管的页面的域名是：<code>sunnyxx.github.io</code><br>所以建一个CNAME记录，将<code>blog.sunnyxx.com</code>解析到<code>sunnyxx.github.io</code><br>DNS域名解析最常用的是<strong>A记录</strong>和<strong>CNAME记录</strong>，A记录把域名解析到服务器IP，CNAME相当于把一个域名指向另一个域名，因此我这个用的是CNAME，要是托管的服务器也是自己搭的那就用A记录了。<br>完事之后得等一段时间（DNSPod说几秒内就同步完，要是这样真心是它好）<br>使用下面的命令测一下域名的解析<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dig blog.sunnyxx.com +nostats +nocomments +nocmd</span><br><span class=\"line\"></span><br><span class=\"line\">=&gt; output:</span><br><span class=\"line\">;; global options: +cmd</span><br><span class=\"line\">;blog.sunnyxx.com.      IN  A</span><br><span class=\"line\">blog.sunnyxx.com.   1778    IN  CNAME   sunnyxx.github.io.</span><br><span class=\"line\">sunnyxx.github.io.  1778    IN  CNAME   github.map.fastly.net.</span><br><span class=\"line\">github.map.fastly.net.  30  IN  A   103.245.222.133</span><br></pre></td></tr></table></figure></p>\n<p>这说明是成功了，发现解析过程是<code>blog.sunnyxx.com</code>-&gt;<code>sunnyxx.github.io</code>-&gt;<code>github.map.fastly.net</code>-&gt;<code>103.245.222.133</code> 最终指向了github的web server<br>由于国内GreatWall，解析速度明显不稳定，有时候都连不上，以后再看怎么办吧</p>\n<h2 id=\"添加sitemap\"><a href=\"#添加sitemap\" class=\"headerlink\" title=\"添加sitemap\"></a>添加sitemap</h2><p>同样的，我们使用hexo提供的插件，方法与添加RSS类似。<br>安装sitemap到本地：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-sitemap</span><br></pre></td></tr></table></figure></p>\n<p>开启sitemap功能：编辑hexo/_config.yml，添加如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins:</span><br><span class=\"line\">- hexo-generator-sitemap</span><br></pre></td></tr></table></figure></p>\n<p>访问zipperary/sitemap.xml即可看到站点地图。不过，sitemap的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到google和百度等搜索引擎提交sitemap.xml。</p>\n<h2 id=\"文章中插入图片\"><a href=\"#文章中插入图片\" class=\"headerlink\" title=\"文章中插入图片\"></a>文章中插入图片</h2><p>原来用octopress写的时候在目录下面建个<code>images</code>目录来保存图片，引用时使用了相对路径就行了，但这是让我最蛋疼的事，想发个图片还得命个名，然后<code>mv</code>过去，再引进来，特别墨迹。hexo中当然也可以用这种方法，但是发现使用个<code>图床</code>来搞定图片真是一劳永逸了。</p>\n<p><strong>微博图床</strong>，地址<a href=\"http://weibotuchuang.sinaapp.com/，我是chrome用户，所以下了个他的插件，装完了点开发现直接把图片拖进去就行了：\" target=\"_blank\" rel=\"external\">http://weibotuchuang.sinaapp.com/，我是chrome用户，所以下了个他的插件，装完了点开发现直接把图片拖进去就行了：</a><br><img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee18d6ak6yj208c08ydg6.jpg\" alt=\"enter image description here\"><br>生成的地址直接用就行了<br>有时候需要使用QQ截屏，只要随便截到某个人的聊天窗口里面，不用发送，然后直接拖拽到这个小窗口里面就OK了。</p>\n<blockquote>\n<p>Life saver.</p>\n</blockquote>\n<p>PS：gif也没问题<br><img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee17y3p11zg207804lnhh.gif\" alt=\"1231231\"></p>\n<h2 id=\"StackEdit-超赞的Markdown在线编辑器\"><a href=\"#StackEdit-超赞的Markdown在线编辑器\" class=\"headerlink\" title=\"StackEdit - 超赞的Markdown在线编辑器\"></a>StackEdit - 超赞的Markdown在线编辑器</h2><p><img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee1a7efwa0j20hk03kwen.jpg\" width=\"500px\"></p>\n<p>界面干净，所见即所得，支持同步到<code>Dropbox</code>和<code>github</code>，这个特别好，比如在公司写了点东西就可以一键同步，保留犯罪现场，回来之后继续写剩下的。</p>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><p>第二次用的时候发现安装的hexo命令找不到了，重新use一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ nvm use 0.10</span><br></pre></td></tr></table></figure></p>\n<p><strong>使用StackEdit时改变图片大小</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img src=&quot;http://ww2.sinaimg.cn/large/51530583gw1ee1a7efwa0j20hk03kwen.jpg&quot; width=&quot;200px align=&quot;center&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>效果：<br>  <img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee1a7efwa0j20hk03kwen.jpg\" width=\"200px\"></p>\n<h2 id=\"添加友情链接\"><a href=\"#添加友情链接\" class=\"headerlink\" title=\"添加友情链接\"></a>添加友情链接</h2><p><code>themes/xxxxxx/layout/_widget/blogroll.ejs</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;widget tag&quot;&gt;</span><br><span class=\"line\">&lt;h3 class=&quot;title&quot;&gt;友情链接&lt;/h3&gt;</span><br><span class=\"line\">&lt;ul class=&quot;entry&quot;&gt;</span><br><span class=\"line\">&lt;li&gt;&lt;a href=&quot;http://zhouxl.github.io&quot; title=&quot;小六&quot;&gt;小六的博客&lt;/a&gt;&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<h1 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h1><p><strong>安装nvm（Node Version Manager）</strong>，Terminal中运行</p>\n<pre><code>$ curl https://raw.githubusercontent.com/creationix/nvm/v0.7.0/install.sh | sh\n</code></pre><p>会提示：</p>\n<pre><code>=&gt; Close and reopen your terminal to start using NVM\n</code></pre><p>退出Terminal重启后nvm命令才能生效。<br>假如update失败，可能没有profile文件，touch一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ touch ~/.bash_profile</span><br><span class=\"line\">$ touch ~/.profile</span><br></pre></td></tr></table></figure>\n<p>  使用nvm安装node.js：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ nvm install 0.10</span><br></pre></td></tr></table></figure>\n<p>下完后安装hexo，这一步时间比较长：</p>\n<pre><code>$ npm install -g hexo\n</code></pre><p>然后找个文件初始化blog：</p>\n<pre><code>$ cd ~/git/blog  \n$ hexo init .\n$ ls\n</code></pre><p>[update]更新hexo2.6版本后安装还需要执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-renderer-ejs --save</span><br><span class=\"line\">$ npm install hexo-renderer-stylus --save</span><br><span class=\"line\">$ npm install hexo-renderer-marked --save</span><br></pre></td></tr></table></figure>\n<p>生成出的目录结构：</p>\n<pre><code>.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── scripts\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n</code></pre><p>新建一篇文章：</p>\n<pre><code>$ hexo new mac下使用hexo搭建blog\n</code></pre><p>$ open source/_posts/mac下使用hexo搭建blog.md<br>编辑md后生成html：</p>\n<pre><code>$ hexo generate\n</code></pre><p>本地预览：</p>\n<pre><code>$ hexo server\n=&gt; [info] Hexo is running at localhost:4000/. Press Ctrl+C to stop.\n</code></pre><p>Theme，去官方提供的<a href=\"https://github.com/tommy351/hexo/wiki/Themes\">主题列表</a>中选个现成的，按照里面的方法pull下来，如light主题</p>\n<pre><code>$ git clone git://github.com/tommy351/hexo-theme-light.git themes/light\n</code></pre><p>_config.yml配置文件中设置：</p>\n<pre><code>theme: light\n</code></pre><p>重新generate和server预览，就看到变化了。</p>\n<h2 id=\"deploy\"><a href=\"#deploy\" class=\"headerlink\" title=\"deploy\"></a>deploy</h2><p>github上建个respository，设置里设一下<br>在<code>_config.yml</code>中：<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">type:</span> github</span><br><span class=\"line\"><span class=\"attr\">repository:</span> https://github.com/sunnyxx/blog-hexo.git</span><br></pre></td></tr></table></figure></p>\n<p>然后执行：</p>\n<pre><code>$ hexo deploy\n</code></pre><p>就行了，github会多一个branch，比octopress简单</p>\n<h2 id=\"绑定域名\"><a href=\"#绑定域名\" class=\"headerlink\" title=\"绑定域名\"></a>绑定域名</h2><p>去万网买了这个域名<code>sunnyxx.com</code>，以<code>blog.sunnyxx.com</code>作为博客的域名，<br>看万网是阿里的才从那儿买的，后来发现<code>DNSPod</code>貌似比较好，万网的后台做的那叫一个*，但愿解析速度上别再不行就行。<br>托管在github上，首先建一个CNAME文件，里面写<code>最终指向</code>的域名：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ blog.sunnyxx.com &gt; public/CNAME</span><br></pre></td></tr></table></figure></p>\n<p>然后去域名后台配置下，由于github表示说我托管的页面的域名是：<code>sunnyxx.github.io</code><br>所以建一个CNAME记录，将<code>blog.sunnyxx.com</code>解析到<code>sunnyxx.github.io</code><br>DNS域名解析最常用的是<strong>A记录</strong>和<strong>CNAME记录</strong>，A记录把域名解析到服务器IP，CNAME相当于把一个域名指向另一个域名，因此我这个用的是CNAME，要是托管的服务器也是自己搭的那就用A记录了。<br>完事之后得等一段时间（DNSPod说几秒内就同步完，要是这样真心是它好）<br>使用下面的命令测一下域名的解析<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dig blog.sunnyxx.com +nostats +nocomments +nocmd</span><br><span class=\"line\"></span><br><span class=\"line\">=&gt; output:</span><br><span class=\"line\">;; global options: +cmd</span><br><span class=\"line\">;blog.sunnyxx.com.      IN  A</span><br><span class=\"line\">blog.sunnyxx.com.   1778    IN  CNAME   sunnyxx.github.io.</span><br><span class=\"line\">sunnyxx.github.io.  1778    IN  CNAME   github.map.fastly.net.</span><br><span class=\"line\">github.map.fastly.net.  30  IN  A   103.245.222.133</span><br></pre></td></tr></table></figure></p>\n<p>这说明是成功了，发现解析过程是<code>blog.sunnyxx.com</code>-&gt;<code>sunnyxx.github.io</code>-&gt;<code>github.map.fastly.net</code>-&gt;<code>103.245.222.133</code> 最终指向了github的web server<br>由于国内GreatWall，解析速度明显不稳定，有时候都连不上，以后再看怎么办吧</p>\n<h2 id=\"添加sitemap\"><a href=\"#添加sitemap\" class=\"headerlink\" title=\"添加sitemap\"></a>添加sitemap</h2><p>同样的，我们使用hexo提供的插件，方法与添加RSS类似。<br>安装sitemap到本地：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-sitemap</span><br></pre></td></tr></table></figure></p>\n<p>开启sitemap功能：编辑hexo/_config.yml，添加如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins:</span><br><span class=\"line\">- hexo-generator-sitemap</span><br></pre></td></tr></table></figure></p>\n<p>访问zipperary/sitemap.xml即可看到站点地图。不过，sitemap的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到google和百度等搜索引擎提交sitemap.xml。</p>\n<h2 id=\"文章中插入图片\"><a href=\"#文章中插入图片\" class=\"headerlink\" title=\"文章中插入图片\"></a>文章中插入图片</h2><p>原来用octopress写的时候在目录下面建个<code>images</code>目录来保存图片，引用时使用了相对路径就行了，但这是让我最蛋疼的事，想发个图片还得命个名，然后<code>mv</code>过去，再引进来，特别墨迹。hexo中当然也可以用这种方法，但是发现使用个<code>图床</code>来搞定图片真是一劳永逸了。</p>\n<p><strong>微博图床</strong>，地址<a href=\"http://weibotuchuang.sinaapp.com/，我是chrome用户，所以下了个他的插件，装完了点开发现直接把图片拖进去就行了：\">http://weibotuchuang.sinaapp.com/，我是chrome用户，所以下了个他的插件，装完了点开发现直接把图片拖进去就行了：</a><br><img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee18d6ak6yj208c08ydg6.jpg\" alt=\"enter image description here\"><br>生成的地址直接用就行了<br>有时候需要使用QQ截屏，只要随便截到某个人的聊天窗口里面，不用发送，然后直接拖拽到这个小窗口里面就OK了。</p>\n<blockquote>\n<p>Life saver.</p>\n</blockquote>\n<p>PS：gif也没问题<br><img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee17y3p11zg207804lnhh.gif\" alt=\"1231231\"></p>\n<h2 id=\"StackEdit-超赞的Markdown在线编辑器\"><a href=\"#StackEdit-超赞的Markdown在线编辑器\" class=\"headerlink\" title=\"StackEdit - 超赞的Markdown在线编辑器\"></a>StackEdit - 超赞的Markdown在线编辑器</h2><p><img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee1a7efwa0j20hk03kwen.jpg\" width=\"500px\" /></p>\n<p>界面干净，所见即所得，支持同步到<code>Dropbox</code>和<code>github</code>，这个特别好，比如在公司写了点东西就可以一键同步，保留犯罪现场，回来之后继续写剩下的。</p>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><p>第二次用的时候发现安装的hexo命令找不到了，重新use一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ nvm use 0.10</span><br></pre></td></tr></table></figure></p>\n<p><strong>使用StackEdit时改变图片大小</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img src=&quot;http://ww2.sinaimg.cn/large/51530583gw1ee1a7efwa0j20hk03kwen.jpg&quot; width=&quot;200px align=&quot;center&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>效果：<br>  <img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee1a7efwa0j20hk03kwen.jpg\" width=\"200px\" /></p>\n<h2 id=\"添加友情链接\"><a href=\"#添加友情链接\" class=\"headerlink\" title=\"添加友情链接\"></a>添加友情链接</h2><p><code>themes/xxxxxx/layout/_widget/blogroll.ejs</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;widget tag&quot;&gt;</span><br><span class=\"line\">&lt;h3 class=&quot;title&quot;&gt;友情链接&lt;/h3&gt;</span><br><span class=\"line\">&lt;ul class=&quot;entry&quot;&gt;</span><br><span class=\"line\">&lt;li&gt;&lt;a href=&quot;http://zhouxl.github.io&quot; title=&quot;小六&quot;&gt;小六的博客&lt;/a&gt;&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"0代码隐藏GroupedTableView上边多余的间隔","date":"2015-04-15T10:50:10.000Z","_content":"\n实现诸如支付宝的 “探索” 页面时，最简单的方案是在 Storyboard 中来一个静态 Grouped UITableViewController，把各个 Cell 中的元素摆好就行了\n\n<img src=\"http://ww1.sinaimg.cn/mw690/51530583jw1er6hby1sp0j20nq0tk768.jpg\" width=320>\n\n不过会有下面的问题，第一个 Section 距离屏幕顶端有间隔\n\n<img src=\"http://ww1.sinaimg.cn/mw690/51530583jw1er6hbxkv2xj20k80oota0.jpg\" width=320>\n\n### 一行代码搞定\n\n研究发现，这里其实是一个被 UITableView 默认填充的 HeaderView。而且，当试图将它的高度设置为 0 时，完全不起效果。但我们用下面的代码创建一个高度特别小的 HeaderView 时，上面的边距就不见了：  \n\n<img src=\"http://ww2.sinaimg.cn/large/51530583jw1er6jpgw0ndj20u40600ud.jpg\" width=400>\n\n\n`CGFLOAT_MIN` 这个宏表示 CGFloat 能代表的最接近 0 的浮点数，64 位下大概是 0.00(300左右个)0225 这个样子  \n这样写单纯的为了避免一个魔法数字，这里用 `0.1` 效果是一样的，后面再讲。 \n\n### 在 Storyboard 中 0 代码搞定\n\n没用 Storyboard 的同学使用上面的代码就 OK 了； 而在 Storyboard 中可以 0 代码搞定这个事：  \n\n首先，在第一个 Section 的上面拖进来一个空 UIView \n\n<img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1er6jd7na5uj20aw07cwfi.jpg\" width=320>\n\n然后选中这个 UIView 的 Runtime Attributes 栏，添加一个 `frame` 的 KeyPath \n\n<img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1er6jd7wt02j20f6064wf8.jpg\" width=320>\n\n这样头部的间隔就乖乖的不见了：   \n\n<img src=\"http://ww2.sinaimg.cn/mw690/51530583jw1er6jj5n61fj20ju0lidgi.jpg\n\" width=320>\n\n\n### 刨根问底 UITableViewHeader 的猫腻\n\n为什么刚才说 0.1 和 CGFLOAT_MIN 是等效的呢？经过研究，这个高度值的影响大概是这样的：\n\n1. 若传入的 height == 0，则 height 被设置成默认值\n2. 若 height 小于屏幕半像素对应的高度，这个 header 不在另一个像素渲染\n\n半像素也就是 `1.0 / scale / 2.0`，如在 @2x 屏上是 0.25\n直观的感受下，假如这个 height 被设置成 0.5 的样子：\n<img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1er6kdmuz21j20ju0de0u4.jpg\n\" width=320>\n\n身患强迫症的我是绝对不能容忍导航栏下面的阴影线看上去宽了 0.5 像素的，Done。\n\n","source":"_posts/ios-hide-grouped-tableview-header.md","raw":"title: 0代码隐藏GroupedTableView上边多余的间隔\ndate: 2015-04-15 18:50:10\ntags: ios最佳实践\n---\n\n实现诸如支付宝的 “探索” 页面时，最简单的方案是在 Storyboard 中来一个静态 Grouped UITableViewController，把各个 Cell 中的元素摆好就行了\n\n<img src=\"http://ww1.sinaimg.cn/mw690/51530583jw1er6hby1sp0j20nq0tk768.jpg\" width=320>\n\n不过会有下面的问题，第一个 Section 距离屏幕顶端有间隔\n\n<img src=\"http://ww1.sinaimg.cn/mw690/51530583jw1er6hbxkv2xj20k80oota0.jpg\" width=320>\n\n### 一行代码搞定\n\n研究发现，这里其实是一个被 UITableView 默认填充的 HeaderView。而且，当试图将它的高度设置为 0 时，完全不起效果。但我们用下面的代码创建一个高度特别小的 HeaderView 时，上面的边距就不见了：  \n\n<img src=\"http://ww2.sinaimg.cn/large/51530583jw1er6jpgw0ndj20u40600ud.jpg\" width=400>\n\n\n`CGFLOAT_MIN` 这个宏表示 CGFloat 能代表的最接近 0 的浮点数，64 位下大概是 0.00(300左右个)0225 这个样子  \n这样写单纯的为了避免一个魔法数字，这里用 `0.1` 效果是一样的，后面再讲。 \n\n### 在 Storyboard 中 0 代码搞定\n\n没用 Storyboard 的同学使用上面的代码就 OK 了； 而在 Storyboard 中可以 0 代码搞定这个事：  \n\n首先，在第一个 Section 的上面拖进来一个空 UIView \n\n<img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1er6jd7na5uj20aw07cwfi.jpg\" width=320>\n\n然后选中这个 UIView 的 Runtime Attributes 栏，添加一个 `frame` 的 KeyPath \n\n<img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1er6jd7wt02j20f6064wf8.jpg\" width=320>\n\n这样头部的间隔就乖乖的不见了：   \n\n<img src=\"http://ww2.sinaimg.cn/mw690/51530583jw1er6jj5n61fj20ju0lidgi.jpg\n\" width=320>\n\n\n### 刨根问底 UITableViewHeader 的猫腻\n\n为什么刚才说 0.1 和 CGFLOAT_MIN 是等效的呢？经过研究，这个高度值的影响大概是这样的：\n\n1. 若传入的 height == 0，则 height 被设置成默认值\n2. 若 height 小于屏幕半像素对应的高度，这个 header 不在另一个像素渲染\n\n半像素也就是 `1.0 / scale / 2.0`，如在 @2x 屏上是 0.25\n直观的感受下，假如这个 height 被设置成 0.5 的样子：\n<img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1er6kdmuz21j20ju0de0u4.jpg\n\" width=320>\n\n身患强迫症的我是绝对不能容忍导航栏下面的阴影线看上去宽了 0.5 像素的，Done。\n\n","slug":"ios-hide-grouped-tableview-header","published":1,"updated":"2016-03-23T13:53:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxkh000jev12evi2wo22","content":"<p>实现诸如支付宝的 “探索” 页面时，最简单的方案是在 Storyboard 中来一个静态 Grouped UITableViewController，把各个 Cell 中的元素摆好就行了</p>\n<p><img src=\"http://ww1.sinaimg.cn/mw690/51530583jw1er6hby1sp0j20nq0tk768.jpg\" width=\"320\"></p>\n<p>不过会有下面的问题，第一个 Section 距离屏幕顶端有间隔</p>\n<p><img src=\"http://ww1.sinaimg.cn/mw690/51530583jw1er6hbxkv2xj20k80oota0.jpg\" width=\"320\"></p>\n<h3 id=\"一行代码搞定\"><a href=\"#一行代码搞定\" class=\"headerlink\" title=\"一行代码搞定\"></a>一行代码搞定</h3><p>研究发现，这里其实是一个被 UITableView 默认填充的 HeaderView。而且，当试图将它的高度设置为 0 时，完全不起效果。但我们用下面的代码创建一个高度特别小的 HeaderView 时，上面的边距就不见了：  </p>\n<p><img src=\"http://ww2.sinaimg.cn/large/51530583jw1er6jpgw0ndj20u40600ud.jpg\" width=\"400\"></p>\n<p><code>CGFLOAT_MIN</code> 这个宏表示 CGFloat 能代表的最接近 0 的浮点数，64 位下大概是 0.00(300左右个)0225 这个样子<br>这样写单纯的为了避免一个魔法数字，这里用 <code>0.1</code> 效果是一样的，后面再讲。 </p>\n<h3 id=\"在-Storyboard-中-0-代码搞定\"><a href=\"#在-Storyboard-中-0-代码搞定\" class=\"headerlink\" title=\"在 Storyboard 中 0 代码搞定\"></a>在 Storyboard 中 0 代码搞定</h3><p>没用 Storyboard 的同学使用上面的代码就 OK 了； 而在 Storyboard 中可以 0 代码搞定这个事：  </p>\n<p>首先，在第一个 Section 的上面拖进来一个空 UIView </p>\n<p><img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1er6jd7na5uj20aw07cwfi.jpg\" width=\"320\"></p>\n<p>然后选中这个 UIView 的 Runtime Attributes 栏，添加一个 <code>frame</code> 的 KeyPath </p>\n<p><img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1er6jd7wt02j20f6064wf8.jpg\" width=\"320\"></p>\n<p>这样头部的间隔就乖乖的不见了：   </p>\n<p><img src=\"http://ww2.sinaimg.cn/mw690/51530583jw1er6jj5n61fj20ju0lidgi.jpg\n\" width=\"320\"></p>\n<h3 id=\"刨根问底-UITableViewHeader-的猫腻\"><a href=\"#刨根问底-UITableViewHeader-的猫腻\" class=\"headerlink\" title=\"刨根问底 UITableViewHeader 的猫腻\"></a>刨根问底 UITableViewHeader 的猫腻</h3><p>为什么刚才说 0.1 和 CGFLOAT_MIN 是等效的呢？经过研究，这个高度值的影响大概是这样的：</p>\n<ol>\n<li>若传入的 height == 0，则 height 被设置成默认值</li>\n<li>若 height 小于屏幕半像素对应的高度，这个 header 不在另一个像素渲染</li>\n</ol>\n<p>半像素也就是 <code>1.0 / scale / 2.0</code>，如在 @2x 屏上是 0.25<br>直观的感受下，假如这个 height 被设置成 0.5 的样子：<br><img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1er6kdmuz21j20ju0de0u4.jpg\n\" width=\"320\"></p>\n<p>身患强迫症的我是绝对不能容忍导航栏下面的阴影线看上去宽了 0.5 像素的，Done。</p>\n","excerpt":"","more":"<p>实现诸如支付宝的 “探索” 页面时，最简单的方案是在 Storyboard 中来一个静态 Grouped UITableViewController，把各个 Cell 中的元素摆好就行了</p>\n<p><img src=\"http://ww1.sinaimg.cn/mw690/51530583jw1er6hby1sp0j20nq0tk768.jpg\" width=320></p>\n<p>不过会有下面的问题，第一个 Section 距离屏幕顶端有间隔</p>\n<p><img src=\"http://ww1.sinaimg.cn/mw690/51530583jw1er6hbxkv2xj20k80oota0.jpg\" width=320></p>\n<h3 id=\"一行代码搞定\"><a href=\"#一行代码搞定\" class=\"headerlink\" title=\"一行代码搞定\"></a>一行代码搞定</h3><p>研究发现，这里其实是一个被 UITableView 默认填充的 HeaderView。而且，当试图将它的高度设置为 0 时，完全不起效果。但我们用下面的代码创建一个高度特别小的 HeaderView 时，上面的边距就不见了：  </p>\n<p><img src=\"http://ww2.sinaimg.cn/large/51530583jw1er6jpgw0ndj20u40600ud.jpg\" width=400></p>\n<p><code>CGFLOAT_MIN</code> 这个宏表示 CGFloat 能代表的最接近 0 的浮点数，64 位下大概是 0.00(300左右个)0225 这个样子<br>这样写单纯的为了避免一个魔法数字，这里用 <code>0.1</code> 效果是一样的，后面再讲。 </p>\n<h3 id=\"在-Storyboard-中-0-代码搞定\"><a href=\"#在-Storyboard-中-0-代码搞定\" class=\"headerlink\" title=\"在 Storyboard 中 0 代码搞定\"></a>在 Storyboard 中 0 代码搞定</h3><p>没用 Storyboard 的同学使用上面的代码就 OK 了； 而在 Storyboard 中可以 0 代码搞定这个事：  </p>\n<p>首先，在第一个 Section 的上面拖进来一个空 UIView </p>\n<p><img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1er6jd7na5uj20aw07cwfi.jpg\" width=320></p>\n<p>然后选中这个 UIView 的 Runtime Attributes 栏，添加一个 <code>frame</code> 的 KeyPath </p>\n<p><img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1er6jd7wt02j20f6064wf8.jpg\" width=320></p>\n<p>这样头部的间隔就乖乖的不见了：   </p>\n<p><img src=\"http://ww2.sinaimg.cn/mw690/51530583jw1er6jj5n61fj20ju0lidgi.jpg\n\" width=320></p>\n<h3 id=\"刨根问底-UITableViewHeader-的猫腻\"><a href=\"#刨根问底-UITableViewHeader-的猫腻\" class=\"headerlink\" title=\"刨根问底 UITableViewHeader 的猫腻\"></a>刨根问底 UITableViewHeader 的猫腻</h3><p>为什么刚才说 0.1 和 CGFLOAT_MIN 是等效的呢？经过研究，这个高度值的影响大概是这样的：</p>\n<ol>\n<li>若传入的 height == 0，则 height 被设置成默认值</li>\n<li>若 height 小于屏幕半像素对应的高度，这个 header 不在另一个像素渲染</li>\n</ol>\n<p>半像素也就是 <code>1.0 / scale / 2.0</code>，如在 @2x 屏上是 0.25<br>直观的感受下，假如这个 height 被设置成 0.5 的样子：<br><img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1er6kdmuz21j20ju0de0u4.jpg\n\" width=320></p>\n<p>身患强迫症的我是绝对不能容忍导航栏下面的阴影线看上去宽了 0.5 像素的，Done。</p>\n"},{"title":"招聘一个靠谱的 iOS","date":"2015-07-04T00:34:01.000Z","_content":"\n近一年内陆续面试了不少人了，从面试者到面试官的转变让我对 iOS 招聘有了更多的感受。经过了前段时间的一大波面试，我们终于找到了志同道合的小伙伴，面试也暂时告一段落了。总结下面试人过程中的感受，你也可以读到我们对简历、算法、性格、iOS 基础、底层知识的看法和一些常问的面试题。\n\n## 一个靠谱的简历\n\n简历非常能反映一个人的性格和水平，相比于你在学校获得多少奖项，工作经历、项目经历、熟悉的技术等更加关键，如果还有博客和一些 Github 上的项目，好感度++，但记得在去面试前收拾下，我们真的会挨个文件 review 你的开源代码的。我们还喜欢关注一些细节，比如简历里关键字的拼写，看似无关紧要但很能反映出对自己的要求，经常见一个简历中 **iOS** 这三个字母的拼写就出现 IOS、iOS、ios 三种的，非常不能忍，再列举几个常见问题：  \n\niPhone -> IPHONE IPhone  \nXcode -> XCode xcode\nObjective-C -> Object-C\nJSON -> Json\nHTTP -> Http\n\n还有，注意中英文间用一个半角空格隔开，排版会漂亮很多，简历承载的不仅是内容，还有细节和态度，上面这些点往往都反映着面试者的代码风格、做事的认真程度。当然，简历写的很漂亮但面聊之后发现啥都不会的也有，甚至见过来面试上来就跟我说简历是假的，就想求个面试机会这种 - -\n\n## 面试\n\n别迟到，别迟到，别迟到，重要的事说三遍。有变动提前通知 HR，碰到过临时有事没来，和谁都不说一声，打电话过去还要求改个时间的，这种直接拜拜。  \n面试时最好准备纸、笔、简历，可能用不上，但很能体现认真程度。有条件的话带着 Mac 和源码，手机中装好所有在简历中出现的 App。\n\n### 关于算法\n\n我们是实用主义，iOS 开发中很少需要自己写复杂的算法，所以不在面试考核标准中。\n\n### 代码规范\n\n这是一个重点考察项，曾经在微博上发过一个风格纠错题：  \n\n<img src=\"http://ww4.sinaimg.cn/large/51530583jw1eqo0v3zgr8j20qc0f2dja.jpg\" width=\"640\">\n\n也曾在面试时让人当场改过，槽点不少，能够有 10 处以上修改的就基本达到标准了（处女座的人在这方面表现都很优秀\n\n## 一个区分度很大的面试题\n\n考察一个面试者基础咋样，基本上问一个 @property 就够了：  \n\n- @property 后面可以有哪些修饰符？\n- 什么情况使用 weak 关键字，相比 assign 有什么不同？\n- 怎么用 copy 关键字？\n- 这个写法会出什么问题： `@property (copy) NSMutableArray *array;`\n- 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？\n\n这一套问题区分度比较大，如果上面的问题都能回答正确，可以延伸问更深入点的：  \n\n- @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的\n- @protocol 和 category 中如何使用 @property\n- runtime 如何实现 weak 属性\n\n每个人擅长的领域不一样，我们一般会从简历上找自己写擅长的技术聊，假如自己并不是很熟，最好别写出来或扯出来，万一面试官刚好非常精通这里就露馅了。  \n\n---\n\n## Checklist\n\n总结过些面试题，没坚持下去，后来把这些当 checklist，面试的时候实在没话聊的时候做个提醒，语言、框架、运行机制性质的：\n\n[※]@property中有哪些属性关键字？  \n[※]weak属性需要在dealloc中置nil么？  \n[※※]@synthesize和@dynamic分别有什么作用？  \n[※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？  \n[※※※]用@property声明的`NSString`（或`NSArray`，`NSDictionary`）经常使用`copy`关键字，为什么？如果改用`strong`关键字，可能造成什么问题？   \n[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？  \n[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？  \n\n[※※]objc中向一个nil对象发送消息将会发生什么？  \n[※※※]objc中向一个对象发送消息`[obj foo]`和`objc_msgSend()`函数之间有什么关系？  \n[※※※]什么时候会报`unrecognized selector`的异常？  \n[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）  \n[※※※※]一个objc对象的`isa`的指针指向什么？有什么作用？  \n[※※※※]下面的代码输出什么？    \n\n``` objc\n@implementation Son : Father\n- (id)init\n{\n    self = [super init];\n    if (self) {\n        NSLog(@\"%@\", NSStringFromClass([self class]));\n        NSLog(@\"%@\", NSStringFromClass([super class]));\n    }\n    return self;\n}\n@end\n```\n\n[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）  \n[※※※※]使用`runtime Associate`方法关联的对象，需要在主对象dealloc的时候释放么？  \n[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？     \n[※※※※※]`_objc_msgForward`函数是做什么的，直接调用它将会发生什么？    \n[※※※※※]runtime如何实现weak变量的自动置nil？  \n[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？  \n\n[※※※]runloop和线程有什么关系？  \n[※※※]runloop的mode作用是什么？  \n[※※※※]以`+ scheduledTimerWithTimeInterval...`的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？  \n[※※※※※]猜想runloop内部是如何实现的？  \n\n[※]objc使用什么机制管理对象内存？  \n[※※※※]ARC通过什么方式帮助开发者管理内存？\n[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）  \n[※※※※]BAD_ACCESS在什么情况下出现？  \n[※※※※※]苹果是如何实现autoreleasepool的？   \n\n[※※]使用block时什么情况会发生引用循环，如何解决？   \n[※※]在block内如何修改block外部变量？   \n[※※※]使用系统的某些block api（如`UIView`的block版本写动画时），是否也考虑引用循环问题？   \n\n[※※]GCD的队列（dispatch_queue_t）分哪两种类型？   \n[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）   \n[※※※※]dispatch_barrier_async的作用是什么？   \n[※※※※※]苹果为什么要废弃dispatch_get_current_queue？   \n[※※※※※]以下代码运行结果如何？   \n\n``` objc\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    NSLog(@\"1\");\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@\"2\");\n    });\n    NSLog(@\"3\");\n}\n```\n\n[※※]`addObserver:forKeyPath:options:context:`各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？  \n[※※※]如何手动触发一个value的KVO   \n[※※※]若一个类有实例变量`NSString *_foo`，调用`setValue:forKey:`时，可以以`foo`还是`_foo`作为key？\n[※※※※]KVC的`keyPath`中的集合运算符如何使用？\n[※※※※]KVC和KVO的`keyPath`一定是属性么？\n[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？   \n[※※※※※]apple用什么方式实现对一个对象的KVO？    \n\n[※※]IBOutlet连出来的视图属性为什么可以被设置成`weak`?   \n[※※※※※]IB中`User Defined Runtime Attributes`如何使用？   \n\n[※※※]如何调试BAD_ACCESS错误  \n[※※※]lldb（gdb）常用的调试命令？\n\n这些小题可以做为讨论的入口，根据面试者的回答再继续聊下去。其中一些题比较底层，是留给屌屌的面试者或者试探评级用的，一般情况并不是重点的考察内容。\n\n## 业务能力\n\n毕竟平常的工作内容不是 runtime、runloop，不怎么会用到底层的黑魔法，80% 的时间都是和搭建页面、写业务逻辑、网络请求打交道。  \n要求面试者能够熟练构建 UI，我会找一个面试者做过的页面让他分析下页面结构、约束或者 frame 布局的连法和计算方法；有时也会让面试者说说 UITableView 常用的几个 delegate 和 data source 代理方法，动态 Cell 高度计算什么的；接下来，在手机里随便找一个 App 的页面，让面试者当场说说如果是他写应该用哪些 UI 组件和布局方式等。问几个问题后就能大概了解业务能力了，我们这边重度使用 IB 和 AutoLayout，假如面试者依然使用代码码 UI 也到没关系，有“从良”意愿就很好~  \n\n程序架构和一些设计模式如果面试者自己觉得还不错的话也会聊聊，但跪求别说 Singleton 了，用的越多对水平就越表示怀疑。对设计模式自信的我一般问一个问题，抽象工厂模式在 Cocoa SDK 中哪些类中体现？  \n架构上 MVC 还是 MVVM 还是 MVP 神马的到是可以聊聊各自的见解，反正也没有正确答案，只要别搞的太离谱就行，比如有的人说网络请求和数据库的操作最好放到 UIView 的子类里面干。\n\n网络请求、数据库等各家都有成熟的封装，基本知道咋用就行。除此之外，我们还会顺带的问下除了 iOS 开发外，还会什么其他编程语言、或者熟悉哪种脚本语言和 Terminal 操作等，甚至还问问是如何翻墙- -，相信这些技能都是很重要的。  \n\n## 性格\n\n大家都是写程序的，没啥必要用奇怪的、很难的问题难为对方，更关键的还是性格，和 Team 的风格是不是和的来。一个心态良好的面试者需要有个平常心，不傲娇也不跪舔，表达要正常，经常遇到问一个问题后一两分钟一直处于沉思状态，一句话不说，交流像挤牙膏一样，很是憋屈；还有非常屌屌的，明明不懂仍然强行据理力争，镇得住面试官也罢，撞枪口上就别怪不客气了- - 。决定要不要一个人基本上聊 5 分钟就可以确定了，喜欢水到渠成的感觉，看对眼了挡都挡不住。\n\n招聘告一段落，后面将会有更精彩的事情发生。最后，再次感谢大家的支持和对我的信任。\n\n![](http://ww4.sinaimg.cn/large/51530583jw1ets0j4fy8aj20cf0afjsp.jpg)\n","source":"_posts/ios-interview.md","raw":"title: 招聘一个靠谱的 iOS\ndate: 2015-07-04 08:34:01\ntags: wtf\n---\n\n近一年内陆续面试了不少人了，从面试者到面试官的转变让我对 iOS 招聘有了更多的感受。经过了前段时间的一大波面试，我们终于找到了志同道合的小伙伴，面试也暂时告一段落了。总结下面试人过程中的感受，你也可以读到我们对简历、算法、性格、iOS 基础、底层知识的看法和一些常问的面试题。\n\n## 一个靠谱的简历\n\n简历非常能反映一个人的性格和水平，相比于你在学校获得多少奖项，工作经历、项目经历、熟悉的技术等更加关键，如果还有博客和一些 Github 上的项目，好感度++，但记得在去面试前收拾下，我们真的会挨个文件 review 你的开源代码的。我们还喜欢关注一些细节，比如简历里关键字的拼写，看似无关紧要但很能反映出对自己的要求，经常见一个简历中 **iOS** 这三个字母的拼写就出现 IOS、iOS、ios 三种的，非常不能忍，再列举几个常见问题：  \n\niPhone -> IPHONE IPhone  \nXcode -> XCode xcode\nObjective-C -> Object-C\nJSON -> Json\nHTTP -> Http\n\n还有，注意中英文间用一个半角空格隔开，排版会漂亮很多，简历承载的不仅是内容，还有细节和态度，上面这些点往往都反映着面试者的代码风格、做事的认真程度。当然，简历写的很漂亮但面聊之后发现啥都不会的也有，甚至见过来面试上来就跟我说简历是假的，就想求个面试机会这种 - -\n\n## 面试\n\n别迟到，别迟到，别迟到，重要的事说三遍。有变动提前通知 HR，碰到过临时有事没来，和谁都不说一声，打电话过去还要求改个时间的，这种直接拜拜。  \n面试时最好准备纸、笔、简历，可能用不上，但很能体现认真程度。有条件的话带着 Mac 和源码，手机中装好所有在简历中出现的 App。\n\n### 关于算法\n\n我们是实用主义，iOS 开发中很少需要自己写复杂的算法，所以不在面试考核标准中。\n\n### 代码规范\n\n这是一个重点考察项，曾经在微博上发过一个风格纠错题：  \n\n<img src=\"http://ww4.sinaimg.cn/large/51530583jw1eqo0v3zgr8j20qc0f2dja.jpg\" width=\"640\">\n\n也曾在面试时让人当场改过，槽点不少，能够有 10 处以上修改的就基本达到标准了（处女座的人在这方面表现都很优秀\n\n## 一个区分度很大的面试题\n\n考察一个面试者基础咋样，基本上问一个 @property 就够了：  \n\n- @property 后面可以有哪些修饰符？\n- 什么情况使用 weak 关键字，相比 assign 有什么不同？\n- 怎么用 copy 关键字？\n- 这个写法会出什么问题： `@property (copy) NSMutableArray *array;`\n- 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？\n\n这一套问题区分度比较大，如果上面的问题都能回答正确，可以延伸问更深入点的：  \n\n- @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的\n- @protocol 和 category 中如何使用 @property\n- runtime 如何实现 weak 属性\n\n每个人擅长的领域不一样，我们一般会从简历上找自己写擅长的技术聊，假如自己并不是很熟，最好别写出来或扯出来，万一面试官刚好非常精通这里就露馅了。  \n\n---\n\n## Checklist\n\n总结过些面试题，没坚持下去，后来把这些当 checklist，面试的时候实在没话聊的时候做个提醒，语言、框架、运行机制性质的：\n\n[※]@property中有哪些属性关键字？  \n[※]weak属性需要在dealloc中置nil么？  \n[※※]@synthesize和@dynamic分别有什么作用？  \n[※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？  \n[※※※]用@property声明的`NSString`（或`NSArray`，`NSDictionary`）经常使用`copy`关键字，为什么？如果改用`strong`关键字，可能造成什么问题？   \n[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？  \n[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？  \n\n[※※]objc中向一个nil对象发送消息将会发生什么？  \n[※※※]objc中向一个对象发送消息`[obj foo]`和`objc_msgSend()`函数之间有什么关系？  \n[※※※]什么时候会报`unrecognized selector`的异常？  \n[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）  \n[※※※※]一个objc对象的`isa`的指针指向什么？有什么作用？  \n[※※※※]下面的代码输出什么？    \n\n``` objc\n@implementation Son : Father\n- (id)init\n{\n    self = [super init];\n    if (self) {\n        NSLog(@\"%@\", NSStringFromClass([self class]));\n        NSLog(@\"%@\", NSStringFromClass([super class]));\n    }\n    return self;\n}\n@end\n```\n\n[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）  \n[※※※※]使用`runtime Associate`方法关联的对象，需要在主对象dealloc的时候释放么？  \n[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？     \n[※※※※※]`_objc_msgForward`函数是做什么的，直接调用它将会发生什么？    \n[※※※※※]runtime如何实现weak变量的自动置nil？  \n[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？  \n\n[※※※]runloop和线程有什么关系？  \n[※※※]runloop的mode作用是什么？  \n[※※※※]以`+ scheduledTimerWithTimeInterval...`的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？  \n[※※※※※]猜想runloop内部是如何实现的？  \n\n[※]objc使用什么机制管理对象内存？  \n[※※※※]ARC通过什么方式帮助开发者管理内存？\n[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）  \n[※※※※]BAD_ACCESS在什么情况下出现？  \n[※※※※※]苹果是如何实现autoreleasepool的？   \n\n[※※]使用block时什么情况会发生引用循环，如何解决？   \n[※※]在block内如何修改block外部变量？   \n[※※※]使用系统的某些block api（如`UIView`的block版本写动画时），是否也考虑引用循环问题？   \n\n[※※]GCD的队列（dispatch_queue_t）分哪两种类型？   \n[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）   \n[※※※※]dispatch_barrier_async的作用是什么？   \n[※※※※※]苹果为什么要废弃dispatch_get_current_queue？   \n[※※※※※]以下代码运行结果如何？   \n\n``` objc\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    NSLog(@\"1\");\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@\"2\");\n    });\n    NSLog(@\"3\");\n}\n```\n\n[※※]`addObserver:forKeyPath:options:context:`各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？  \n[※※※]如何手动触发一个value的KVO   \n[※※※]若一个类有实例变量`NSString *_foo`，调用`setValue:forKey:`时，可以以`foo`还是`_foo`作为key？\n[※※※※]KVC的`keyPath`中的集合运算符如何使用？\n[※※※※]KVC和KVO的`keyPath`一定是属性么？\n[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？   \n[※※※※※]apple用什么方式实现对一个对象的KVO？    \n\n[※※]IBOutlet连出来的视图属性为什么可以被设置成`weak`?   \n[※※※※※]IB中`User Defined Runtime Attributes`如何使用？   \n\n[※※※]如何调试BAD_ACCESS错误  \n[※※※]lldb（gdb）常用的调试命令？\n\n这些小题可以做为讨论的入口，根据面试者的回答再继续聊下去。其中一些题比较底层，是留给屌屌的面试者或者试探评级用的，一般情况并不是重点的考察内容。\n\n## 业务能力\n\n毕竟平常的工作内容不是 runtime、runloop，不怎么会用到底层的黑魔法，80% 的时间都是和搭建页面、写业务逻辑、网络请求打交道。  \n要求面试者能够熟练构建 UI，我会找一个面试者做过的页面让他分析下页面结构、约束或者 frame 布局的连法和计算方法；有时也会让面试者说说 UITableView 常用的几个 delegate 和 data source 代理方法，动态 Cell 高度计算什么的；接下来，在手机里随便找一个 App 的页面，让面试者当场说说如果是他写应该用哪些 UI 组件和布局方式等。问几个问题后就能大概了解业务能力了，我们这边重度使用 IB 和 AutoLayout，假如面试者依然使用代码码 UI 也到没关系，有“从良”意愿就很好~  \n\n程序架构和一些设计模式如果面试者自己觉得还不错的话也会聊聊，但跪求别说 Singleton 了，用的越多对水平就越表示怀疑。对设计模式自信的我一般问一个问题，抽象工厂模式在 Cocoa SDK 中哪些类中体现？  \n架构上 MVC 还是 MVVM 还是 MVP 神马的到是可以聊聊各自的见解，反正也没有正确答案，只要别搞的太离谱就行，比如有的人说网络请求和数据库的操作最好放到 UIView 的子类里面干。\n\n网络请求、数据库等各家都有成熟的封装，基本知道咋用就行。除此之外，我们还会顺带的问下除了 iOS 开发外，还会什么其他编程语言、或者熟悉哪种脚本语言和 Terminal 操作等，甚至还问问是如何翻墙- -，相信这些技能都是很重要的。  \n\n## 性格\n\n大家都是写程序的，没啥必要用奇怪的、很难的问题难为对方，更关键的还是性格，和 Team 的风格是不是和的来。一个心态良好的面试者需要有个平常心，不傲娇也不跪舔，表达要正常，经常遇到问一个问题后一两分钟一直处于沉思状态，一句话不说，交流像挤牙膏一样，很是憋屈；还有非常屌屌的，明明不懂仍然强行据理力争，镇得住面试官也罢，撞枪口上就别怪不客气了- - 。决定要不要一个人基本上聊 5 分钟就可以确定了，喜欢水到渠成的感觉，看对眼了挡都挡不住。\n\n招聘告一段落，后面将会有更精彩的事情发生。最后，再次感谢大家的支持和对我的信任。\n\n![](http://ww4.sinaimg.cn/large/51530583jw1ets0j4fy8aj20cf0afjsp.jpg)\n","slug":"ios-interview","published":1,"updated":"2016-03-26T08:51:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxkj000mev12w4stctbm","content":"<p>近一年内陆续面试了不少人了，从面试者到面试官的转变让我对 iOS 招聘有了更多的感受。经过了前段时间的一大波面试，我们终于找到了志同道合的小伙伴，面试也暂时告一段落了。总结下面试人过程中的感受，你也可以读到我们对简历、算法、性格、iOS 基础、底层知识的看法和一些常问的面试题。</p>\n<h2 id=\"一个靠谱的简历\"><a href=\"#一个靠谱的简历\" class=\"headerlink\" title=\"一个靠谱的简历\"></a>一个靠谱的简历</h2><p>简历非常能反映一个人的性格和水平，相比于你在学校获得多少奖项，工作经历、项目经历、熟悉的技术等更加关键，如果还有博客和一些 Github 上的项目，好感度++，但记得在去面试前收拾下，我们真的会挨个文件 review 你的开源代码的。我们还喜欢关注一些细节，比如简历里关键字的拼写，看似无关紧要但很能反映出对自己的要求，经常见一个简历中 <strong>iOS</strong> 这三个字母的拼写就出现 IOS、iOS、ios 三种的，非常不能忍，再列举几个常见问题：  </p>\n<p>iPhone -&gt; IPHONE IPhone<br>Xcode -&gt; XCode xcode<br>Objective-C -&gt; Object-C<br>JSON -&gt; Json<br>HTTP -&gt; Http</p>\n<p>还有，注意中英文间用一个半角空格隔开，排版会漂亮很多，简历承载的不仅是内容，还有细节和态度，上面这些点往往都反映着面试者的代码风格、做事的认真程度。当然，简历写的很漂亮但面聊之后发现啥都不会的也有，甚至见过来面试上来就跟我说简历是假的，就想求个面试机会这种 - -</p>\n<h2 id=\"面试\"><a href=\"#面试\" class=\"headerlink\" title=\"面试\"></a>面试</h2><p>别迟到，别迟到，别迟到，重要的事说三遍。有变动提前通知 HR，碰到过临时有事没来，和谁都不说一声，打电话过去还要求改个时间的，这种直接拜拜。<br>面试时最好准备纸、笔、简历，可能用不上，但很能体现认真程度。有条件的话带着 Mac 和源码，手机中装好所有在简历中出现的 App。</p>\n<h3 id=\"关于算法\"><a href=\"#关于算法\" class=\"headerlink\" title=\"关于算法\"></a>关于算法</h3><p>我们是实用主义，iOS 开发中很少需要自己写复杂的算法，所以不在面试考核标准中。</p>\n<h3 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h3><p>这是一个重点考察项，曾经在微博上发过一个风格纠错题：  </p>\n<p><img src=\"http://ww4.sinaimg.cn/large/51530583jw1eqo0v3zgr8j20qc0f2dja.jpg\" width=\"640\"></p>\n<p>也曾在面试时让人当场改过，槽点不少，能够有 10 处以上修改的就基本达到标准了（处女座的人在这方面表现都很优秀</p>\n<h2 id=\"一个区分度很大的面试题\"><a href=\"#一个区分度很大的面试题\" class=\"headerlink\" title=\"一个区分度很大的面试题\"></a>一个区分度很大的面试题</h2><p>考察一个面试者基础咋样，基本上问一个 @property 就够了：  </p>\n<ul>\n<li>@property 后面可以有哪些修饰符？</li>\n<li>什么情况使用 weak 关键字，相比 assign 有什么不同？</li>\n<li>怎么用 copy 关键字？</li>\n<li>这个写法会出什么问题： <code>@property (copy) NSMutableArray *array;</code></li>\n<li>如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</li>\n</ul>\n<p>这一套问题区分度比较大，如果上面的问题都能回答正确，可以延伸问更深入点的：  </p>\n<ul>\n<li>@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</li>\n<li>@protocol 和 category 中如何使用 @property</li>\n<li>runtime 如何实现 weak 属性</li>\n</ul>\n<p>每个人擅长的领域不一样，我们一般会从简历上找自己写擅长的技术聊，假如自己并不是很熟，最好别写出来或扯出来，万一面试官刚好非常精通这里就露馅了。  </p>\n<hr>\n<h2 id=\"Checklist\"><a href=\"#Checklist\" class=\"headerlink\" title=\"Checklist\"></a>Checklist</h2><p>总结过些面试题，没坚持下去，后来把这些当 checklist，面试的时候实在没话聊的时候做个提醒，语言、框架、运行机制性质的：</p>\n<p>[※]@property中有哪些属性关键字？<br>[※]weak属性需要在dealloc中置nil么？<br>[※※]@synthesize和@dynamic分别有什么作用？<br>[※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？<br>[※※※]用@property声明的<code>NSString</code>（或<code>NSArray</code>，<code>NSDictionary</code>）经常使用<code>copy</code>关键字，为什么？如果改用<code>strong</code>关键字，可能造成什么问题？<br>[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？<br>[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？  </p>\n<p>[※※]objc中向一个nil对象发送消息将会发生什么？<br>[※※※]objc中向一个对象发送消息<code>[obj foo]</code>和<code>objc_msgSend()</code>函数之间有什么关系？<br>[※※※]什么时候会报<code>unrecognized selector</code>的异常？<br>[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）<br>[※※※※]一个objc对象的<code>isa</code>的指针指向什么？有什么作用？<br>[※※※※]下面的代码输出什么？    </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Son</span> : <span class=\"title\">Father</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">self</span> class]));</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">super</span> class]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）<br>[※※※※]使用<code>runtime Associate</code>方法关联的对象，需要在主对象dealloc的时候释放么？<br>[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？<br>[※※※※※]<code>_objc_msgForward</code>函数是做什么的，直接调用它将会发生什么？<br>[※※※※※]runtime如何实现weak变量的自动置nil？<br>[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？  </p>\n<p>[※※※]runloop和线程有什么关系？<br>[※※※]runloop的mode作用是什么？<br>[※※※※]以<code>+ scheduledTimerWithTimeInterval...</code>的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？<br>[※※※※※]猜想runloop内部是如何实现的？  </p>\n<p>[※]objc使用什么机制管理对象内存？<br>[※※※※]ARC通过什么方式帮助开发者管理内存？<br>[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）<br>[※※※※]BAD_ACCESS在什么情况下出现？<br>[※※※※※]苹果是如何实现autoreleasepool的？   </p>\n<p>[※※]使用block时什么情况会发生引用循环，如何解决？<br>[※※]在block内如何修改block外部变量？<br>[※※※]使用系统的某些block api（如<code>UIView</code>的block版本写动画时），是否也考虑引用循环问题？   </p>\n<p>[※※]GCD的队列（dispatch_queue_t）分哪两种类型？<br>[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）<br>[※※※※]dispatch_barrier_async的作用是什么？<br>[※※※※※]苹果为什么要废弃dispatch_get_current_queue？<br>[※※※※※]以下代码运行结果如何？   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>[※※]<code>addObserver:forKeyPath:options:context:</code>各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？<br>[※※※]如何手动触发一个value的KVO<br>[※※※]若一个类有实例变量<code>NSString *_foo</code>，调用<code>setValue:forKey:</code>时，可以以<code>foo</code>还是<code>_foo</code>作为key？<br>[※※※※]KVC的<code>keyPath</code>中的集合运算符如何使用？<br>[※※※※]KVC和KVO的<code>keyPath</code>一定是属性么？<br>[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？<br>[※※※※※]apple用什么方式实现对一个对象的KVO？    </p>\n<p>[※※]IBOutlet连出来的视图属性为什么可以被设置成<code>weak</code>?<br>[※※※※※]IB中<code>User Defined Runtime Attributes</code>如何使用？   </p>\n<p>[※※※]如何调试BAD_ACCESS错误<br>[※※※]lldb（gdb）常用的调试命令？</p>\n<p>这些小题可以做为讨论的入口，根据面试者的回答再继续聊下去。其中一些题比较底层，是留给屌屌的面试者或者试探评级用的，一般情况并不是重点的考察内容。</p>\n<h2 id=\"业务能力\"><a href=\"#业务能力\" class=\"headerlink\" title=\"业务能力\"></a>业务能力</h2><p>毕竟平常的工作内容不是 runtime、runloop，不怎么会用到底层的黑魔法，80% 的时间都是和搭建页面、写业务逻辑、网络请求打交道。<br>要求面试者能够熟练构建 UI，我会找一个面试者做过的页面让他分析下页面结构、约束或者 frame 布局的连法和计算方法；有时也会让面试者说说 UITableView 常用的几个 delegate 和 data source 代理方法，动态 Cell 高度计算什么的；接下来，在手机里随便找一个 App 的页面，让面试者当场说说如果是他写应该用哪些 UI 组件和布局方式等。问几个问题后就能大概了解业务能力了，我们这边重度使用 IB 和 AutoLayout，假如面试者依然使用代码码 UI 也到没关系，有“从良”意愿就很好~  </p>\n<p>程序架构和一些设计模式如果面试者自己觉得还不错的话也会聊聊，但跪求别说 Singleton 了，用的越多对水平就越表示怀疑。对设计模式自信的我一般问一个问题，抽象工厂模式在 Cocoa SDK 中哪些类中体现？<br>架构上 MVC 还是 MVVM 还是 MVP 神马的到是可以聊聊各自的见解，反正也没有正确答案，只要别搞的太离谱就行，比如有的人说网络请求和数据库的操作最好放到 UIView 的子类里面干。</p>\n<p>网络请求、数据库等各家都有成熟的封装，基本知道咋用就行。除此之外，我们还会顺带的问下除了 iOS 开发外，还会什么其他编程语言、或者熟悉哪种脚本语言和 Terminal 操作等，甚至还问问是如何翻墙- -，相信这些技能都是很重要的。  </p>\n<h2 id=\"性格\"><a href=\"#性格\" class=\"headerlink\" title=\"性格\"></a>性格</h2><p>大家都是写程序的，没啥必要用奇怪的、很难的问题难为对方，更关键的还是性格，和 Team 的风格是不是和的来。一个心态良好的面试者需要有个平常心，不傲娇也不跪舔，表达要正常，经常遇到问一个问题后一两分钟一直处于沉思状态，一句话不说，交流像挤牙膏一样，很是憋屈；还有非常屌屌的，明明不懂仍然强行据理力争，镇得住面试官也罢，撞枪口上就别怪不客气了- - 。决定要不要一个人基本上聊 5 分钟就可以确定了，喜欢水到渠成的感觉，看对眼了挡都挡不住。</p>\n<p>招聘告一段落，后面将会有更精彩的事情发生。最后，再次感谢大家的支持和对我的信任。</p>\n<p><img src=\"http://ww4.sinaimg.cn/large/51530583jw1ets0j4fy8aj20cf0afjsp.jpg\" alt=\"\"></p>\n","excerpt":"","more":"<p>近一年内陆续面试了不少人了，从面试者到面试官的转变让我对 iOS 招聘有了更多的感受。经过了前段时间的一大波面试，我们终于找到了志同道合的小伙伴，面试也暂时告一段落了。总结下面试人过程中的感受，你也可以读到我们对简历、算法、性格、iOS 基础、底层知识的看法和一些常问的面试题。</p>\n<h2 id=\"一个靠谱的简历\"><a href=\"#一个靠谱的简历\" class=\"headerlink\" title=\"一个靠谱的简历\"></a>一个靠谱的简历</h2><p>简历非常能反映一个人的性格和水平，相比于你在学校获得多少奖项，工作经历、项目经历、熟悉的技术等更加关键，如果还有博客和一些 Github 上的项目，好感度++，但记得在去面试前收拾下，我们真的会挨个文件 review 你的开源代码的。我们还喜欢关注一些细节，比如简历里关键字的拼写，看似无关紧要但很能反映出对自己的要求，经常见一个简历中 <strong>iOS</strong> 这三个字母的拼写就出现 IOS、iOS、ios 三种的，非常不能忍，再列举几个常见问题：  </p>\n<p>iPhone -&gt; IPHONE IPhone<br>Xcode -&gt; XCode xcode<br>Objective-C -&gt; Object-C<br>JSON -&gt; Json<br>HTTP -&gt; Http</p>\n<p>还有，注意中英文间用一个半角空格隔开，排版会漂亮很多，简历承载的不仅是内容，还有细节和态度，上面这些点往往都反映着面试者的代码风格、做事的认真程度。当然，简历写的很漂亮但面聊之后发现啥都不会的也有，甚至见过来面试上来就跟我说简历是假的，就想求个面试机会这种 - -</p>\n<h2 id=\"面试\"><a href=\"#面试\" class=\"headerlink\" title=\"面试\"></a>面试</h2><p>别迟到，别迟到，别迟到，重要的事说三遍。有变动提前通知 HR，碰到过临时有事没来，和谁都不说一声，打电话过去还要求改个时间的，这种直接拜拜。<br>面试时最好准备纸、笔、简历，可能用不上，但很能体现认真程度。有条件的话带着 Mac 和源码，手机中装好所有在简历中出现的 App。</p>\n<h3 id=\"关于算法\"><a href=\"#关于算法\" class=\"headerlink\" title=\"关于算法\"></a>关于算法</h3><p>我们是实用主义，iOS 开发中很少需要自己写复杂的算法，所以不在面试考核标准中。</p>\n<h3 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h3><p>这是一个重点考察项，曾经在微博上发过一个风格纠错题：  </p>\n<p><img src=\"http://ww4.sinaimg.cn/large/51530583jw1eqo0v3zgr8j20qc0f2dja.jpg\" width=\"640\"></p>\n<p>也曾在面试时让人当场改过，槽点不少，能够有 10 处以上修改的就基本达到标准了（处女座的人在这方面表现都很优秀</p>\n<h2 id=\"一个区分度很大的面试题\"><a href=\"#一个区分度很大的面试题\" class=\"headerlink\" title=\"一个区分度很大的面试题\"></a>一个区分度很大的面试题</h2><p>考察一个面试者基础咋样，基本上问一个 @property 就够了：  </p>\n<ul>\n<li>@property 后面可以有哪些修饰符？</li>\n<li>什么情况使用 weak 关键字，相比 assign 有什么不同？</li>\n<li>怎么用 copy 关键字？</li>\n<li>这个写法会出什么问题： <code>@property (copy) NSMutableArray *array;</code></li>\n<li>如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</li>\n</ul>\n<p>这一套问题区分度比较大，如果上面的问题都能回答正确，可以延伸问更深入点的：  </p>\n<ul>\n<li>@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</li>\n<li>@protocol 和 category 中如何使用 @property</li>\n<li>runtime 如何实现 weak 属性</li>\n</ul>\n<p>每个人擅长的领域不一样，我们一般会从简历上找自己写擅长的技术聊，假如自己并不是很熟，最好别写出来或扯出来，万一面试官刚好非常精通这里就露馅了。  </p>\n<hr>\n<h2 id=\"Checklist\"><a href=\"#Checklist\" class=\"headerlink\" title=\"Checklist\"></a>Checklist</h2><p>总结过些面试题，没坚持下去，后来把这些当 checklist，面试的时候实在没话聊的时候做个提醒，语言、框架、运行机制性质的：</p>\n<p>[※]@property中有哪些属性关键字？<br>[※]weak属性需要在dealloc中置nil么？<br>[※※]@synthesize和@dynamic分别有什么作用？<br>[※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？<br>[※※※]用@property声明的<code>NSString</code>（或<code>NSArray</code>，<code>NSDictionary</code>）经常使用<code>copy</code>关键字，为什么？如果改用<code>strong</code>关键字，可能造成什么问题？<br>[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？<br>[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？  </p>\n<p>[※※]objc中向一个nil对象发送消息将会发生什么？<br>[※※※]objc中向一个对象发送消息<code>[obj foo]</code>和<code>objc_msgSend()</code>函数之间有什么关系？<br>[※※※]什么时候会报<code>unrecognized selector</code>的异常？<br>[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）<br>[※※※※]一个objc对象的<code>isa</code>的指针指向什么？有什么作用？<br>[※※※※]下面的代码输出什么？    </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Son</span> : <span class=\"title\">Father</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">self</span> class]));</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">super</span> class]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）<br>[※※※※]使用<code>runtime Associate</code>方法关联的对象，需要在主对象dealloc的时候释放么？<br>[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？<br>[※※※※※]<code>_objc_msgForward</code>函数是做什么的，直接调用它将会发生什么？<br>[※※※※※]runtime如何实现weak变量的自动置nil？<br>[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？  </p>\n<p>[※※※]runloop和线程有什么关系？<br>[※※※]runloop的mode作用是什么？<br>[※※※※]以<code>+ scheduledTimerWithTimeInterval...</code>的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？<br>[※※※※※]猜想runloop内部是如何实现的？  </p>\n<p>[※]objc使用什么机制管理对象内存？<br>[※※※※]ARC通过什么方式帮助开发者管理内存？<br>[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）<br>[※※※※]BAD_ACCESS在什么情况下出现？<br>[※※※※※]苹果是如何实现autoreleasepool的？   </p>\n<p>[※※]使用block时什么情况会发生引用循环，如何解决？<br>[※※]在block内如何修改block外部变量？<br>[※※※]使用系统的某些block api（如<code>UIView</code>的block版本写动画时），是否也考虑引用循环问题？   </p>\n<p>[※※]GCD的队列（dispatch_queue_t）分哪两种类型？<br>[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）<br>[※※※※]dispatch_barrier_async的作用是什么？<br>[※※※※※]苹果为什么要废弃dispatch_get_current_queue？<br>[※※※※※]以下代码运行结果如何？   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>[※※]<code>addObserver:forKeyPath:options:context:</code>各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？<br>[※※※]如何手动触发一个value的KVO<br>[※※※]若一个类有实例变量<code>NSString *_foo</code>，调用<code>setValue:forKey:</code>时，可以以<code>foo</code>还是<code>_foo</code>作为key？<br>[※※※※]KVC的<code>keyPath</code>中的集合运算符如何使用？<br>[※※※※]KVC和KVO的<code>keyPath</code>一定是属性么？<br>[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？<br>[※※※※※]apple用什么方式实现对一个对象的KVO？    </p>\n<p>[※※]IBOutlet连出来的视图属性为什么可以被设置成<code>weak</code>?<br>[※※※※※]IB中<code>User Defined Runtime Attributes</code>如何使用？   </p>\n<p>[※※※]如何调试BAD_ACCESS错误<br>[※※※]lldb（gdb）常用的调试命令？</p>\n<p>这些小题可以做为讨论的入口，根据面试者的回答再继续聊下去。其中一些题比较底层，是留给屌屌的面试者或者试探评级用的，一般情况并不是重点的考察内容。</p>\n<h2 id=\"业务能力\"><a href=\"#业务能力\" class=\"headerlink\" title=\"业务能力\"></a>业务能力</h2><p>毕竟平常的工作内容不是 runtime、runloop，不怎么会用到底层的黑魔法，80% 的时间都是和搭建页面、写业务逻辑、网络请求打交道。<br>要求面试者能够熟练构建 UI，我会找一个面试者做过的页面让他分析下页面结构、约束或者 frame 布局的连法和计算方法；有时也会让面试者说说 UITableView 常用的几个 delegate 和 data source 代理方法，动态 Cell 高度计算什么的；接下来，在手机里随便找一个 App 的页面，让面试者当场说说如果是他写应该用哪些 UI 组件和布局方式等。问几个问题后就能大概了解业务能力了，我们这边重度使用 IB 和 AutoLayout，假如面试者依然使用代码码 UI 也到没关系，有“从良”意愿就很好~  </p>\n<p>程序架构和一些设计模式如果面试者自己觉得还不错的话也会聊聊，但跪求别说 Singleton 了，用的越多对水平就越表示怀疑。对设计模式自信的我一般问一个问题，抽象工厂模式在 Cocoa SDK 中哪些类中体现？<br>架构上 MVC 还是 MVVM 还是 MVP 神马的到是可以聊聊各自的见解，反正也没有正确答案，只要别搞的太离谱就行，比如有的人说网络请求和数据库的操作最好放到 UIView 的子类里面干。</p>\n<p>网络请求、数据库等各家都有成熟的封装，基本知道咋用就行。除此之外，我们还会顺带的问下除了 iOS 开发外，还会什么其他编程语言、或者熟悉哪种脚本语言和 Terminal 操作等，甚至还问问是如何翻墙- -，相信这些技能都是很重要的。  </p>\n<h2 id=\"性格\"><a href=\"#性格\" class=\"headerlink\" title=\"性格\"></a>性格</h2><p>大家都是写程序的，没啥必要用奇怪的、很难的问题难为对方，更关键的还是性格，和 Team 的风格是不是和的来。一个心态良好的面试者需要有个平常心，不傲娇也不跪舔，表达要正常，经常遇到问一个问题后一两分钟一直处于沉思状态，一句话不说，交流像挤牙膏一样，很是憋屈；还有非常屌屌的，明明不懂仍然强行据理力争，镇得住面试官也罢，撞枪口上就别怪不客气了- - 。决定要不要一个人基本上聊 5 分钟就可以确定了，喜欢水到渠成的感觉，看对眼了挡都挡不住。</p>\n<p>招聘告一段落，后面将会有更精彩的事情发生。最后，再次感谢大家的支持和对我的信任。</p>\n<p><img src=\"http://ww4.sinaimg.cn/large/51530583jw1ets0j4fy8aj20cf0afjsp.jpg\" alt=\"\"></p>\n"},{"title":"0代码ViewController","date":"2014-07-17T02:27:54.000Z","_content":"\n# 我是前言\n\n看了`objc.io`中的[《Behaviors in iOS Apps》](http://www.objc.io/issue-13/behaviors.html)（objccn上也有[中文翻译版](http://objccn.io/issue-13-3/)）后，终于**如梦初醒**了IB中的这个低调的`Object`存在的意义：  \n\n<img src=\"http://ww1.sinaimg.cn/large/51530583gw1eifvg6elgrj20jk060js7.jpg\" width=\"400\"/>\n\n再加上同样被轻视的Runtime Attributes:  \n\n<img src=\"http://ww4.sinaimg.cn/large/51530583gw1eifvtsgrgpj20dq05w0sv.jpg\" width=\"300\"/>\n\n有了这些，IB才算完整和强大。  \n最近看了一些文章，加上工程中也遇到的坑，矛头都指向了**MVC(Massive View Controller)**：臃肿的ViewController所引发的不爽，`objc.io`也是以一个[《Lighter View Controllers》](http://www.objc.io/issue-1/)开篇。从把DataSource和Delegte从VC中分离，到把Model逻辑整个分离的`MVVM`，VC一步步瘦身，再到这篇Behavior模式巧妙的组件式的分离了功能。但有没有想过，为啥往一个页面写点啥东西就一定要子类化一个VC呢，使用上面两个IB的功能，我们可以激进地实验一次`0代码ViewController`\n\n---\n\n# Top Level Objects\n\n首先必须说明Top Level Objects这个概念，根据apple文档：\n\n> The top-level objects are the subset of these objects that do not have a parent object. The top-level objects typically include only the windows, menubars, and custom controller objects that you add to the nib file. (Objects such as File’s Owner, First Responder, and Application are placeholder objects and not considered top-level objects.)\n\n所以，IB里面的`Object`控件其实就是向Controller中添加`Custom Top Level Object`，在storyboard中被摆在下面的位置：\n\n<img src=\"http://ww4.sinaimg.cn/large/51530583gw1eifwvsnandj20es08kaaw.jpg\" width=\"400\"/>\n\n事实上任何Object都可以添加，这里出现了一个LoginViewModel对象、一个菊花、一个Tap手势。\n\n### Nib对象的创建顺序   \n1. 自定义的Top Level Objects收到`- init`消息\n2. ViewController收到`- initWithCoder:`消息\n3. 自定义的Top Level Objects 收到`- awakeFromNib`消息\n4. ViewController收到`- awakeFromNib`消息\n5. 子View分别收到`- initWithCoder:`消息\n6. 子View分别收到`- awakeFromNib`消息\n\n可见自定义的Object的创建时间是早于VC的，至于为什么`- awakeFromNib`收到的晚于VC的创建，是因为**创建出来的Object需要被VC强引用**\n\n### VC对自定义Objects的强引用  \n\n创建出来的Object必须保证不被释放，这个强引用由VC实现，虽说没有显示的API，但从`UIViewController.h`中可以看到马脚：\n\n``` objc\n@interface UIViewController : UIResponder {\n    @package\n    // ...\n    NSDictionary  *_externalObjectsTableForViewLoading;\n    NSArray       *_topLevelObjectsToKeepAliveFromStoryboard;\n    // ...   \n}\n```\n\n通过KVC可以很轻松的取出来：\n\n``` objc\nNSArray *objs = [vc valueForKey:@\"_topLevelObjectsToKeepAliveFromStoryboard\"];\nNSDictionary *dict = [vc valueForKey:@\"_externalObjectsTableForViewLoading\"];\n```\n\n这些objects就是被这个数组强引用的，感兴趣的可以打印下看看结果。   \n_注：只在storyboard下生效，在xib下，被创建的Object因为没有被强引用而随后被释放。_\n\n---\n\n# 构建0代码VC的简单登录场景   \n\n**storyboard中拉出个VC，随便摆摆：**\n<img src=\"http://ww3.sinaimg.cn/large/51530583gw1eig0usoroej209k076t8p.jpg\" width=\"350\"/>\n\n**创建一个ViewModel类（也就是Behavior类），里面写需要的IBOutlet和IBAction**  \n\n\n``` objc\n@interface XXLoginViewModel : NSObject\n@property (nonatomic, weak) IBOutlet UIViewController *ownerViewController;\n@property (nonatomic, weak) IBOutlet UITextField *usernameTextField;\n@property (nonatomic, weak) IBOutlet UITextField *passwordTextField;\n@property (nonatomic, weak) IBOutlet UIActivityIndicatorView *spinner;\n- (IBAction)loginAction:(id)sender;\n@end\n```\n\n**storyboard中拖出来一个Object到左边，设置类为这个`XXLoginViewModel`, 将所有IBOutlet和IBAction连接好**\n\n<img src=\"http://ww2.sinaimg.cn/large/51530583gw1eig0zjf4gpj20wi0ecdid.jpg\" width=\"550\"/>\n\n**这样，就可以在自定义Object中为所欲为了，需要什么就从storyboard里面Outlet出来就好了，比如点击之后的跳转：**  \n\n\n``` objc\n- (IBAction)loginAction:(id)sender {\n    [self.ownerViewController performSegueWithIdentifier:@\"LoginSegue\" sender:nil];\n}\n```\n\n具体的代码不show了，Demo的效果如下：\n\n![](http://ww1.sinaimg.cn/large/51530583gw1eig8tuzciig208r0d5n18.gif)\n\n当然，TableView的delegate和data source也都是可以托管到自定义Object中，同时，Object之间也可以有Outlet关系哦，剩下的就纯靠想象力了。   \n\n**这个简单的demo从[->这里下载<-](https://github.com/sunnyxx/XXZeroCodeViewControllerDemo)**\n\n---\n\n# What's more\n\n- 首先，这次实验并非表明我们应该写0代码的VC，UIViewController本身被设计作为一个`模板类`，继承+重载无可非议（但像UITableView这种被设计成`配置类`的类，我们更应该去配置它，而非继承它，更别说NSArray，NSString这种类簇的工具类了）\n- 组合模式以十分灵活的方式划分功能，Demo中只用了一个ViewModel，其实完全可以组合一个Animation类实现动画，组合一个HTTP类来发请求？，组合一个处理旋转屏幕的类等等，而且**完成这些子功能的代码集中在一个类中，而不是分散在VC的各个角落，两个功能的小模块间可以说没有耦合**\n- VC没有代码，但storyboard已经干了VC该干的事，如创建和布局子View、设置Autolayout、设置action，定义跳转等。我想，Apple祭出storyboard的目的就在于将纯视图和纯代码逻辑分离，VC本该Control它的View，而不是自己就是那个View\n\n---\n\n# References\n\nhttps://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html\nhttp://www.objc.io/issue-13/behaviors.html\n","source":"_posts/ios_0code_vc.md","raw":"title: 0代码ViewController\ndate: 2014-07-17 10:27:54\ntags: ios最佳实践\n---\n\n# 我是前言\n\n看了`objc.io`中的[《Behaviors in iOS Apps》](http://www.objc.io/issue-13/behaviors.html)（objccn上也有[中文翻译版](http://objccn.io/issue-13-3/)）后，终于**如梦初醒**了IB中的这个低调的`Object`存在的意义：  \n\n<img src=\"http://ww1.sinaimg.cn/large/51530583gw1eifvg6elgrj20jk060js7.jpg\" width=\"400\"/>\n\n再加上同样被轻视的Runtime Attributes:  \n\n<img src=\"http://ww4.sinaimg.cn/large/51530583gw1eifvtsgrgpj20dq05w0sv.jpg\" width=\"300\"/>\n\n有了这些，IB才算完整和强大。  \n最近看了一些文章，加上工程中也遇到的坑，矛头都指向了**MVC(Massive View Controller)**：臃肿的ViewController所引发的不爽，`objc.io`也是以一个[《Lighter View Controllers》](http://www.objc.io/issue-1/)开篇。从把DataSource和Delegte从VC中分离，到把Model逻辑整个分离的`MVVM`，VC一步步瘦身，再到这篇Behavior模式巧妙的组件式的分离了功能。但有没有想过，为啥往一个页面写点啥东西就一定要子类化一个VC呢，使用上面两个IB的功能，我们可以激进地实验一次`0代码ViewController`\n\n---\n\n# Top Level Objects\n\n首先必须说明Top Level Objects这个概念，根据apple文档：\n\n> The top-level objects are the subset of these objects that do not have a parent object. The top-level objects typically include only the windows, menubars, and custom controller objects that you add to the nib file. (Objects such as File’s Owner, First Responder, and Application are placeholder objects and not considered top-level objects.)\n\n所以，IB里面的`Object`控件其实就是向Controller中添加`Custom Top Level Object`，在storyboard中被摆在下面的位置：\n\n<img src=\"http://ww4.sinaimg.cn/large/51530583gw1eifwvsnandj20es08kaaw.jpg\" width=\"400\"/>\n\n事实上任何Object都可以添加，这里出现了一个LoginViewModel对象、一个菊花、一个Tap手势。\n\n### Nib对象的创建顺序   \n1. 自定义的Top Level Objects收到`- init`消息\n2. ViewController收到`- initWithCoder:`消息\n3. 自定义的Top Level Objects 收到`- awakeFromNib`消息\n4. ViewController收到`- awakeFromNib`消息\n5. 子View分别收到`- initWithCoder:`消息\n6. 子View分别收到`- awakeFromNib`消息\n\n可见自定义的Object的创建时间是早于VC的，至于为什么`- awakeFromNib`收到的晚于VC的创建，是因为**创建出来的Object需要被VC强引用**\n\n### VC对自定义Objects的强引用  \n\n创建出来的Object必须保证不被释放，这个强引用由VC实现，虽说没有显示的API，但从`UIViewController.h`中可以看到马脚：\n\n``` objc\n@interface UIViewController : UIResponder {\n    @package\n    // ...\n    NSDictionary  *_externalObjectsTableForViewLoading;\n    NSArray       *_topLevelObjectsToKeepAliveFromStoryboard;\n    // ...   \n}\n```\n\n通过KVC可以很轻松的取出来：\n\n``` objc\nNSArray *objs = [vc valueForKey:@\"_topLevelObjectsToKeepAliveFromStoryboard\"];\nNSDictionary *dict = [vc valueForKey:@\"_externalObjectsTableForViewLoading\"];\n```\n\n这些objects就是被这个数组强引用的，感兴趣的可以打印下看看结果。   \n_注：只在storyboard下生效，在xib下，被创建的Object因为没有被强引用而随后被释放。_\n\n---\n\n# 构建0代码VC的简单登录场景   \n\n**storyboard中拉出个VC，随便摆摆：**\n<img src=\"http://ww3.sinaimg.cn/large/51530583gw1eig0usoroej209k076t8p.jpg\" width=\"350\"/>\n\n**创建一个ViewModel类（也就是Behavior类），里面写需要的IBOutlet和IBAction**  \n\n\n``` objc\n@interface XXLoginViewModel : NSObject\n@property (nonatomic, weak) IBOutlet UIViewController *ownerViewController;\n@property (nonatomic, weak) IBOutlet UITextField *usernameTextField;\n@property (nonatomic, weak) IBOutlet UITextField *passwordTextField;\n@property (nonatomic, weak) IBOutlet UIActivityIndicatorView *spinner;\n- (IBAction)loginAction:(id)sender;\n@end\n```\n\n**storyboard中拖出来一个Object到左边，设置类为这个`XXLoginViewModel`, 将所有IBOutlet和IBAction连接好**\n\n<img src=\"http://ww2.sinaimg.cn/large/51530583gw1eig0zjf4gpj20wi0ecdid.jpg\" width=\"550\"/>\n\n**这样，就可以在自定义Object中为所欲为了，需要什么就从storyboard里面Outlet出来就好了，比如点击之后的跳转：**  \n\n\n``` objc\n- (IBAction)loginAction:(id)sender {\n    [self.ownerViewController performSegueWithIdentifier:@\"LoginSegue\" sender:nil];\n}\n```\n\n具体的代码不show了，Demo的效果如下：\n\n![](http://ww1.sinaimg.cn/large/51530583gw1eig8tuzciig208r0d5n18.gif)\n\n当然，TableView的delegate和data source也都是可以托管到自定义Object中，同时，Object之间也可以有Outlet关系哦，剩下的就纯靠想象力了。   \n\n**这个简单的demo从[->这里下载<-](https://github.com/sunnyxx/XXZeroCodeViewControllerDemo)**\n\n---\n\n# What's more\n\n- 首先，这次实验并非表明我们应该写0代码的VC，UIViewController本身被设计作为一个`模板类`，继承+重载无可非议（但像UITableView这种被设计成`配置类`的类，我们更应该去配置它，而非继承它，更别说NSArray，NSString这种类簇的工具类了）\n- 组合模式以十分灵活的方式划分功能，Demo中只用了一个ViewModel，其实完全可以组合一个Animation类实现动画，组合一个HTTP类来发请求？，组合一个处理旋转屏幕的类等等，而且**完成这些子功能的代码集中在一个类中，而不是分散在VC的各个角落，两个功能的小模块间可以说没有耦合**\n- VC没有代码，但storyboard已经干了VC该干的事，如创建和布局子View、设置Autolayout、设置action，定义跳转等。我想，Apple祭出storyboard的目的就在于将纯视图和纯代码逻辑分离，VC本该Control它的View，而不是自己就是那个View\n\n---\n\n# References\n\nhttps://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html\nhttp://www.objc.io/issue-13/behaviors.html\n","slug":"ios_0code_vc","published":1,"updated":"2016-03-27T08:15:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxkk000oev12civ6jex8","content":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>看了<code>objc.io</code>中的<a href=\"http://www.objc.io/issue-13/behaviors.html\" target=\"_blank\" rel=\"external\">《Behaviors in iOS Apps》</a>（objccn上也有<a href=\"http://objccn.io/issue-13-3/\" target=\"_blank\" rel=\"external\">中文翻译版</a>）后，终于<strong>如梦初醒</strong>了IB中的这个低调的<code>Object</code>存在的意义：  </p>\n<p><img src=\"http://ww1.sinaimg.cn/large/51530583gw1eifvg6elgrj20jk060js7.jpg\" width=\"400\"></p>\n<p>再加上同样被轻视的Runtime Attributes:  </p>\n<p><img src=\"http://ww4.sinaimg.cn/large/51530583gw1eifvtsgrgpj20dq05w0sv.jpg\" width=\"300\"></p>\n<p>有了这些，IB才算完整和强大。<br>最近看了一些文章，加上工程中也遇到的坑，矛头都指向了<strong>MVC(Massive View Controller)</strong>：臃肿的ViewController所引发的不爽，<code>objc.io</code>也是以一个<a href=\"http://www.objc.io/issue-1/\" target=\"_blank\" rel=\"external\">《Lighter View Controllers》</a>开篇。从把DataSource和Delegte从VC中分离，到把Model逻辑整个分离的<code>MVVM</code>，VC一步步瘦身，再到这篇Behavior模式巧妙的组件式的分离了功能。但有没有想过，为啥往一个页面写点啥东西就一定要子类化一个VC呢，使用上面两个IB的功能，我们可以激进地实验一次<code>0代码ViewController</code></p>\n<hr>\n<h1 id=\"Top-Level-Objects\"><a href=\"#Top-Level-Objects\" class=\"headerlink\" title=\"Top Level Objects\"></a>Top Level Objects</h1><p>首先必须说明Top Level Objects这个概念，根据apple文档：</p>\n<blockquote>\n<p>The top-level objects are the subset of these objects that do not have a parent object. The top-level objects typically include only the windows, menubars, and custom controller objects that you add to the nib file. (Objects such as File’s Owner, First Responder, and Application are placeholder objects and not considered top-level objects.)</p>\n</blockquote>\n<p>所以，IB里面的<code>Object</code>控件其实就是向Controller中添加<code>Custom Top Level Object</code>，在storyboard中被摆在下面的位置：</p>\n<p><img src=\"http://ww4.sinaimg.cn/large/51530583gw1eifwvsnandj20es08kaaw.jpg\" width=\"400\"></p>\n<p>事实上任何Object都可以添加，这里出现了一个LoginViewModel对象、一个菊花、一个Tap手势。</p>\n<h3 id=\"Nib对象的创建顺序\"><a href=\"#Nib对象的创建顺序\" class=\"headerlink\" title=\"Nib对象的创建顺序\"></a>Nib对象的创建顺序</h3><ol>\n<li>自定义的Top Level Objects收到<code>- init</code>消息</li>\n<li>ViewController收到<code>- initWithCoder:</code>消息</li>\n<li>自定义的Top Level Objects 收到<code>- awakeFromNib</code>消息</li>\n<li>ViewController收到<code>- awakeFromNib</code>消息</li>\n<li>子View分别收到<code>- initWithCoder:</code>消息</li>\n<li>子View分别收到<code>- awakeFromNib</code>消息</li>\n</ol>\n<p>可见自定义的Object的创建时间是早于VC的，至于为什么<code>- awakeFromNib</code>收到的晚于VC的创建，是因为<strong>创建出来的Object需要被VC强引用</strong></p>\n<h3 id=\"VC对自定义Objects的强引用\"><a href=\"#VC对自定义Objects的强引用\" class=\"headerlink\" title=\"VC对自定义Objects的强引用\"></a>VC对自定义Objects的强引用</h3><p>创建出来的Object必须保证不被释放，这个强引用由VC实现，虽说没有显示的API，但从<code>UIViewController.h</code>中可以看到马脚：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIViewController</span> : <span class=\"title\">UIResponder</span> </span>&#123;</span><br><span class=\"line\">    @package</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>  *_externalObjectsTableForViewLoading;</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span>       *_topLevelObjectsToKeepAliveFromStoryboard;</span><br><span class=\"line\">    <span class=\"comment\">// ...   </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过KVC可以很轻松的取出来：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *objs = [vc valueForKey:<span class=\"string\">@\"_topLevelObjectsToKeepAliveFromStoryboard\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *dict = [vc valueForKey:<span class=\"string\">@\"_externalObjectsTableForViewLoading\"</span>];</span><br></pre></td></tr></table></figure>\n<p>这些objects就是被这个数组强引用的，感兴趣的可以打印下看看结果。<br><em>注：只在storyboard下生效，在xib下，被创建的Object因为没有被强引用而随后被释放。</em></p>\n<hr>\n<h1 id=\"构建0代码VC的简单登录场景\"><a href=\"#构建0代码VC的简单登录场景\" class=\"headerlink\" title=\"构建0代码VC的简单登录场景\"></a>构建0代码VC的简单登录场景</h1><p><strong>storyboard中拉出个VC，随便摆摆：</strong><br><img src=\"http://ww3.sinaimg.cn/large/51530583gw1eig0usoroej209k076t8p.jpg\" width=\"350\"></p>\n<p><strong>创建一个ViewModel类（也就是Behavior类），里面写需要的IBOutlet和IBAction</strong>  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">XXLoginViewModel</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIViewController</span> *ownerViewController;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UITextField</span> *usernameTextField;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UITextField</span> *passwordTextField;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIActivityIndicatorView</span> *spinner;</span><br><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)loginAction:(<span class=\"keyword\">id</span>)sender;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p><strong>storyboard中拖出来一个Object到左边，设置类为这个<code>XXLoginViewModel</code>, 将所有IBOutlet和IBAction连接好</strong></p>\n<p><img src=\"http://ww2.sinaimg.cn/large/51530583gw1eig0zjf4gpj20wi0ecdid.jpg\" width=\"550\"></p>\n<p><strong>这样，就可以在自定义Object中为所欲为了，需要什么就从storyboard里面Outlet出来就好了，比如点击之后的跳转：</strong>  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)loginAction:(<span class=\"keyword\">id</span>)sender &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.ownerViewController performSegueWithIdentifier:<span class=\"string\">@\"LoginSegue\"</span> sender:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体的代码不show了，Demo的效果如下：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/51530583gw1eig8tuzciig208r0d5n18.gif\" alt=\"\"></p>\n<p>当然，TableView的delegate和data source也都是可以托管到自定义Object中，同时，Object之间也可以有Outlet关系哦，剩下的就纯靠想象力了。   </p>\n<p><strong>这个简单的demo从<a href=\"https://github.com/sunnyxx/XXZeroCodeViewControllerDemo\" target=\"_blank\" rel=\"external\">-&gt;这里下载&lt;-</a></strong></p>\n<hr>\n<h1 id=\"What’s-more\"><a href=\"#What’s-more\" class=\"headerlink\" title=\"What’s more\"></a>What’s more</h1><ul>\n<li>首先，这次实验并非表明我们应该写0代码的VC，UIViewController本身被设计作为一个<code>模板类</code>，继承+重载无可非议（但像UITableView这种被设计成<code>配置类</code>的类，我们更应该去配置它，而非继承它，更别说NSArray，NSString这种类簇的工具类了）</li>\n<li>组合模式以十分灵活的方式划分功能，Demo中只用了一个ViewModel，其实完全可以组合一个Animation类实现动画，组合一个HTTP类来发请求？，组合一个处理旋转屏幕的类等等，而且<strong>完成这些子功能的代码集中在一个类中，而不是分散在VC的各个角落，两个功能的小模块间可以说没有耦合</strong></li>\n<li>VC没有代码，但storyboard已经干了VC该干的事，如创建和布局子View、设置Autolayout、设置action，定义跳转等。我想，Apple祭出storyboard的目的就在于将纯视图和纯代码逻辑分离，VC本该Control它的View，而不是自己就是那个View</li>\n</ul>\n<hr>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html\" target=\"_blank\" rel=\"external\">https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html</a><br><a href=\"http://www.objc.io/issue-13/behaviors.html\" target=\"_blank\" rel=\"external\">http://www.objc.io/issue-13/behaviors.html</a></p>\n","excerpt":"","more":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>看了<code>objc.io</code>中的<a href=\"http://www.objc.io/issue-13/behaviors.html\">《Behaviors in iOS Apps》</a>（objccn上也有<a href=\"http://objccn.io/issue-13-3/\">中文翻译版</a>）后，终于<strong>如梦初醒</strong>了IB中的这个低调的<code>Object</code>存在的意义：  </p>\n<p><img src=\"http://ww1.sinaimg.cn/large/51530583gw1eifvg6elgrj20jk060js7.jpg\" width=\"400\"/></p>\n<p>再加上同样被轻视的Runtime Attributes:  </p>\n<p><img src=\"http://ww4.sinaimg.cn/large/51530583gw1eifvtsgrgpj20dq05w0sv.jpg\" width=\"300\"/></p>\n<p>有了这些，IB才算完整和强大。<br>最近看了一些文章，加上工程中也遇到的坑，矛头都指向了<strong>MVC(Massive View Controller)</strong>：臃肿的ViewController所引发的不爽，<code>objc.io</code>也是以一个<a href=\"http://www.objc.io/issue-1/\">《Lighter View Controllers》</a>开篇。从把DataSource和Delegte从VC中分离，到把Model逻辑整个分离的<code>MVVM</code>，VC一步步瘦身，再到这篇Behavior模式巧妙的组件式的分离了功能。但有没有想过，为啥往一个页面写点啥东西就一定要子类化一个VC呢，使用上面两个IB的功能，我们可以激进地实验一次<code>0代码ViewController</code></p>\n<hr>\n<h1 id=\"Top-Level-Objects\"><a href=\"#Top-Level-Objects\" class=\"headerlink\" title=\"Top Level Objects\"></a>Top Level Objects</h1><p>首先必须说明Top Level Objects这个概念，根据apple文档：</p>\n<blockquote>\n<p>The top-level objects are the subset of these objects that do not have a parent object. The top-level objects typically include only the windows, menubars, and custom controller objects that you add to the nib file. (Objects such as File’s Owner, First Responder, and Application are placeholder objects and not considered top-level objects.)</p>\n</blockquote>\n<p>所以，IB里面的<code>Object</code>控件其实就是向Controller中添加<code>Custom Top Level Object</code>，在storyboard中被摆在下面的位置：</p>\n<p><img src=\"http://ww4.sinaimg.cn/large/51530583gw1eifwvsnandj20es08kaaw.jpg\" width=\"400\"/></p>\n<p>事实上任何Object都可以添加，这里出现了一个LoginViewModel对象、一个菊花、一个Tap手势。</p>\n<h3 id=\"Nib对象的创建顺序\"><a href=\"#Nib对象的创建顺序\" class=\"headerlink\" title=\"Nib对象的创建顺序\"></a>Nib对象的创建顺序</h3><ol>\n<li>自定义的Top Level Objects收到<code>- init</code>消息</li>\n<li>ViewController收到<code>- initWithCoder:</code>消息</li>\n<li>自定义的Top Level Objects 收到<code>- awakeFromNib</code>消息</li>\n<li>ViewController收到<code>- awakeFromNib</code>消息</li>\n<li>子View分别收到<code>- initWithCoder:</code>消息</li>\n<li>子View分别收到<code>- awakeFromNib</code>消息</li>\n</ol>\n<p>可见自定义的Object的创建时间是早于VC的，至于为什么<code>- awakeFromNib</code>收到的晚于VC的创建，是因为<strong>创建出来的Object需要被VC强引用</strong></p>\n<h3 id=\"VC对自定义Objects的强引用\"><a href=\"#VC对自定义Objects的强引用\" class=\"headerlink\" title=\"VC对自定义Objects的强引用\"></a>VC对自定义Objects的强引用</h3><p>创建出来的Object必须保证不被释放，这个强引用由VC实现，虽说没有显示的API，但从<code>UIViewController.h</code>中可以看到马脚：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIViewController</span> : <span class=\"title\">UIResponder</span> </span>&#123;</span><br><span class=\"line\">    @package</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>  *_externalObjectsTableForViewLoading;</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span>       *_topLevelObjectsToKeepAliveFromStoryboard;</span><br><span class=\"line\">    <span class=\"comment\">// ...   </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过KVC可以很轻松的取出来：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *objs = [vc valueForKey:<span class=\"string\">@\"_topLevelObjectsToKeepAliveFromStoryboard\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *dict = [vc valueForKey:<span class=\"string\">@\"_externalObjectsTableForViewLoading\"</span>];</span><br></pre></td></tr></table></figure>\n<p>这些objects就是被这个数组强引用的，感兴趣的可以打印下看看结果。<br><em>注：只在storyboard下生效，在xib下，被创建的Object因为没有被强引用而随后被释放。</em></p>\n<hr>\n<h1 id=\"构建0代码VC的简单登录场景\"><a href=\"#构建0代码VC的简单登录场景\" class=\"headerlink\" title=\"构建0代码VC的简单登录场景\"></a>构建0代码VC的简单登录场景</h1><p><strong>storyboard中拉出个VC，随便摆摆：</strong><br><img src=\"http://ww3.sinaimg.cn/large/51530583gw1eig0usoroej209k076t8p.jpg\" width=\"350\"/></p>\n<p><strong>创建一个ViewModel类（也就是Behavior类），里面写需要的IBOutlet和IBAction</strong>  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">XXLoginViewModel</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIViewController</span> *ownerViewController;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UITextField</span> *usernameTextField;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UITextField</span> *passwordTextField;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIActivityIndicatorView</span> *spinner;</span><br><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)loginAction:(<span class=\"keyword\">id</span>)sender;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p><strong>storyboard中拖出来一个Object到左边，设置类为这个<code>XXLoginViewModel</code>, 将所有IBOutlet和IBAction连接好</strong></p>\n<p><img src=\"http://ww2.sinaimg.cn/large/51530583gw1eig0zjf4gpj20wi0ecdid.jpg\" width=\"550\"/></p>\n<p><strong>这样，就可以在自定义Object中为所欲为了，需要什么就从storyboard里面Outlet出来就好了，比如点击之后的跳转：</strong>  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)loginAction:(<span class=\"keyword\">id</span>)sender &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.ownerViewController performSegueWithIdentifier:<span class=\"string\">@\"LoginSegue\"</span> sender:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体的代码不show了，Demo的效果如下：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/51530583gw1eig8tuzciig208r0d5n18.gif\" alt=\"\"></p>\n<p>当然，TableView的delegate和data source也都是可以托管到自定义Object中，同时，Object之间也可以有Outlet关系哦，剩下的就纯靠想象力了。   </p>\n<p><strong>这个简单的demo从<a href=\"https://github.com/sunnyxx/XXZeroCodeViewControllerDemo\">-&gt;这里下载&lt;-</a></strong></p>\n<hr>\n<h1 id=\"What’s-more\"><a href=\"#What’s-more\" class=\"headerlink\" title=\"What’s more\"></a>What’s more</h1><ul>\n<li>首先，这次实验并非表明我们应该写0代码的VC，UIViewController本身被设计作为一个<code>模板类</code>，继承+重载无可非议（但像UITableView这种被设计成<code>配置类</code>的类，我们更应该去配置它，而非继承它，更别说NSArray，NSString这种类簇的工具类了）</li>\n<li>组合模式以十分灵活的方式划分功能，Demo中只用了一个ViewModel，其实完全可以组合一个Animation类实现动画，组合一个HTTP类来发请求？，组合一个处理旋转屏幕的类等等，而且<strong>完成这些子功能的代码集中在一个类中，而不是分散在VC的各个角落，两个功能的小模块间可以说没有耦合</strong></li>\n<li>VC没有代码，但storyboard已经干了VC该干的事，如创建和布局子View、设置Autolayout、设置action，定义跳转等。我想，Apple祭出storyboard的目的就在于将纯视图和纯代码逻辑分离，VC本该Control它的View，而不是自己就是那个View</li>\n</ul>\n<hr>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html\">https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html</a><br><a href=\"http://www.objc.io/issue-13/behaviors.html\">http://www.objc.io/issue-13/behaviors.html</a></p>\n"},{"title":"iOS8 Size Classes初探","date":"2014-09-09T09:18:41.000Z","_content":"\niOS8新特性，`Size Classes`，是对老式UI思路的全新抽象：把各个设备屏幕（iphone4,5,6, ipad,iwatch?）以及它们的屏幕旋转状态都抽象成屏幕Size的变化，将这些Size归纳成几个类别（Class）\n\n<img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmaz9sIa0ZszJu53F4dekibfkPLhq7lmF6UOLcC2pAHnGF5PyZ1MaRJHAlA/0\" width=\"320\">\n\n宽（正常，任意， 紧凑），高（正常，任意， 紧凑）\n\n3x3共9种Size，每种Size都可以设置特定的一套布局，如果不特殊指定，默认是在（宽任意，高任意）模式下设置，且其他8种布局继承它。\n\n听过有人说，我们不用学autolayout了，直接学Size Class就一步到位了。这个说法是不对的，因为Size Class在将屏幕分类后，执行布局的还是Autolayout。\n\n--- \n\n# Size Classes与Interface Builder\n\n当然不出所料的是，Xcode6中Interface Builder对Size Class有了很强大的支持：\n\n<img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmazWvtHou58grUl8IyOq2sYgb9iacUTL0oeYE7eWulrWF35G4D3GWQich3w/0\" width=\"320\">\n\n启用Size Class后，IB中就会出现Size Class切换的菜单\n\n<img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmazQ3DeTLO8z0QyicMicRkr1qSJbrpX5aO5jsKydyolqibWg7tAGDynpI5Jw/0\" width=\"320\">\n我们可以切换到`wAny,hAny`模式去编辑通用的控件和布局，也可以切换到某个特定Class，立刻可以预览到变化，于是有个问题：\n\n假如iPad和iPhone的布局有差异，老式写法是分成ipad.storyboard和iphone.storyboard来分别写，这本身就是个bug，因为大部分控件其实并没差别，新Size Class解决这个问题了木？\n\n答案是肯定的，Size Class的方案比老式的好了几条街：\nIB中某个View的出现与否，**约束的出现与否以及约束的值都是可以根据Size Class单独设置的**，也就是说现在一个storyboard是`9合1`的。\n比如下面有个Label，我只希望它出现在长宽紧缩的屏幕上时（脑补iwatch），这么勾选下就可以（出现或不出现被命名为\"Installed\"，这个选项可以从9个Size Class中多选）\n<img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmaz8fvJEaFDD7V313hKoYeyPHfnkvJA3akacdkg2r7hQLknceicpaL8kiaQ/0\" width=\"480\">\n\n--- \n\n# Size Classes的xml文件改动\n\n说到9合1的时候肯定会有疑问，这样的storyboard文件会不会很大？源文件会不会很乱导致多人开发经常冲突？\n\n答案是不会的，源于apple对Size Class在xml中的描述方法是针对变化配置的，什么意思呢？对比下storyboard的xml源文件就知道了：\nwAny,hAny模式下刚才只有一个Label的页面：\n<img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmazSsj5BiaLrzLsOcowFj3zB49NTRS86NTVG5dqe0ACU8DnXov4iaWKllZg/0\" width=\"480\">\n\n假如在wC,hC紧缩模式下设置不出现这个label时，在label的父view层级出现了下面的配置：\n<img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmazaYtgIVwxibLf16xJXhicdWjfuBONNebKfgU2ICQsOEwAMjkibz6BJCTAQ/0\" width=\"480\">\n所以说ib中以附加的描述字段来表示哪些元素是被哪些Size Class包含或排除的，也正因为这样的描述方式，使得新的xml格式**可以被低版本兼容**（低版本不解析这个字段，但其他字段正常解析）\n\n--- \n\n# Size Classes与xcassets\n\n既然storyboard变成了9合1，配套的`xcassets`必须也有所表示才行，xcode6后向`xcassets`中添加图片时增加了选择对应Size Classes的菜单，展开后会像下面一样：\n\n<img src=\"http://ww1.sinaimg.cn/mw690/51530583gw1ek7k01ldj9j20j40k4aat.jpg\" width=\"480\">\n\n通过符号表示确实不错 `-`对应紧缩，`*`对应Any，`+`对应宽松  \n（@3x是iphone6 plus）\n\n--- \n\n\n# 总结\n\n总的来说，iOS对UI这块的改动是跨时代性的，Autolayout的出现使得布局的复杂度减少到了View与View的关系上，再由根View（也就是屏幕）指定frame，随后所有子View相对布局，把frame的概念归一化到根View的frame上；但有了Size Class后，根视图的frame概念也被移除了，这下整个app的UI和frame这个单词已然脱离关系，这也正是apple想要达到的目的。\n\nFarewell，frame和那些还奋战在手写UI的iOS coder们...","source":"_posts/ios8-size-classes.md","raw":"title: iOS8 Size Classes初探\ndate: 2014-09-09 17:18:41\ntags: iOS8\n---\n\niOS8新特性，`Size Classes`，是对老式UI思路的全新抽象：把各个设备屏幕（iphone4,5,6, ipad,iwatch?）以及它们的屏幕旋转状态都抽象成屏幕Size的变化，将这些Size归纳成几个类别（Class）\n\n<img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmaz9sIa0ZszJu53F4dekibfkPLhq7lmF6UOLcC2pAHnGF5PyZ1MaRJHAlA/0\" width=\"320\">\n\n宽（正常，任意， 紧凑），高（正常，任意， 紧凑）\n\n3x3共9种Size，每种Size都可以设置特定的一套布局，如果不特殊指定，默认是在（宽任意，高任意）模式下设置，且其他8种布局继承它。\n\n听过有人说，我们不用学autolayout了，直接学Size Class就一步到位了。这个说法是不对的，因为Size Class在将屏幕分类后，执行布局的还是Autolayout。\n\n--- \n\n# Size Classes与Interface Builder\n\n当然不出所料的是，Xcode6中Interface Builder对Size Class有了很强大的支持：\n\n<img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmazWvtHou58grUl8IyOq2sYgb9iacUTL0oeYE7eWulrWF35G4D3GWQich3w/0\" width=\"320\">\n\n启用Size Class后，IB中就会出现Size Class切换的菜单\n\n<img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmazQ3DeTLO8z0QyicMicRkr1qSJbrpX5aO5jsKydyolqibWg7tAGDynpI5Jw/0\" width=\"320\">\n我们可以切换到`wAny,hAny`模式去编辑通用的控件和布局，也可以切换到某个特定Class，立刻可以预览到变化，于是有个问题：\n\n假如iPad和iPhone的布局有差异，老式写法是分成ipad.storyboard和iphone.storyboard来分别写，这本身就是个bug，因为大部分控件其实并没差别，新Size Class解决这个问题了木？\n\n答案是肯定的，Size Class的方案比老式的好了几条街：\nIB中某个View的出现与否，**约束的出现与否以及约束的值都是可以根据Size Class单独设置的**，也就是说现在一个storyboard是`9合1`的。\n比如下面有个Label，我只希望它出现在长宽紧缩的屏幕上时（脑补iwatch），这么勾选下就可以（出现或不出现被命名为\"Installed\"，这个选项可以从9个Size Class中多选）\n<img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmaz8fvJEaFDD7V313hKoYeyPHfnkvJA3akacdkg2r7hQLknceicpaL8kiaQ/0\" width=\"480\">\n\n--- \n\n# Size Classes的xml文件改动\n\n说到9合1的时候肯定会有疑问，这样的storyboard文件会不会很大？源文件会不会很乱导致多人开发经常冲突？\n\n答案是不会的，源于apple对Size Class在xml中的描述方法是针对变化配置的，什么意思呢？对比下storyboard的xml源文件就知道了：\nwAny,hAny模式下刚才只有一个Label的页面：\n<img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmazSsj5BiaLrzLsOcowFj3zB49NTRS86NTVG5dqe0ACU8DnXov4iaWKllZg/0\" width=\"480\">\n\n假如在wC,hC紧缩模式下设置不出现这个label时，在label的父view层级出现了下面的配置：\n<img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmazaYtgIVwxibLf16xJXhicdWjfuBONNebKfgU2ICQsOEwAMjkibz6BJCTAQ/0\" width=\"480\">\n所以说ib中以附加的描述字段来表示哪些元素是被哪些Size Class包含或排除的，也正因为这样的描述方式，使得新的xml格式**可以被低版本兼容**（低版本不解析这个字段，但其他字段正常解析）\n\n--- \n\n# Size Classes与xcassets\n\n既然storyboard变成了9合1，配套的`xcassets`必须也有所表示才行，xcode6后向`xcassets`中添加图片时增加了选择对应Size Classes的菜单，展开后会像下面一样：\n\n<img src=\"http://ww1.sinaimg.cn/mw690/51530583gw1ek7k01ldj9j20j40k4aat.jpg\" width=\"480\">\n\n通过符号表示确实不错 `-`对应紧缩，`*`对应Any，`+`对应宽松  \n（@3x是iphone6 plus）\n\n--- \n\n\n# 总结\n\n总的来说，iOS对UI这块的改动是跨时代性的，Autolayout的出现使得布局的复杂度减少到了View与View的关系上，再由根View（也就是屏幕）指定frame，随后所有子View相对布局，把frame的概念归一化到根View的frame上；但有了Size Class后，根视图的frame概念也被移除了，这下整个app的UI和frame这个单词已然脱离关系，这也正是apple想要达到的目的。\n\nFarewell，frame和那些还奋战在手写UI的iOS coder们...","slug":"ios8-size-classes","published":1,"updated":"2016-03-23T13:53:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxkn000rev121wxmuhoy","content":"<p>iOS8新特性，<code>Size Classes</code>，是对老式UI思路的全新抽象：把各个设备屏幕（iphone4,5,6, ipad,iwatch?）以及它们的屏幕旋转状态都抽象成屏幕Size的变化，将这些Size归纳成几个类别（Class）</p>\n<p><img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmaz9sIa0ZszJu53F4dekibfkPLhq7lmF6UOLcC2pAHnGF5PyZ1MaRJHAlA/0\" width=\"320\"></p>\n<p>宽（正常，任意， 紧凑），高（正常，任意， 紧凑）</p>\n<p>3x3共9种Size，每种Size都可以设置特定的一套布局，如果不特殊指定，默认是在（宽任意，高任意）模式下设置，且其他8种布局继承它。</p>\n<p>听过有人说，我们不用学autolayout了，直接学Size Class就一步到位了。这个说法是不对的，因为Size Class在将屏幕分类后，执行布局的还是Autolayout。</p>\n<hr>\n<h1 id=\"Size-Classes与Interface-Builder\"><a href=\"#Size-Classes与Interface-Builder\" class=\"headerlink\" title=\"Size Classes与Interface Builder\"></a>Size Classes与Interface Builder</h1><p>当然不出所料的是，Xcode6中Interface Builder对Size Class有了很强大的支持：</p>\n<p><img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmazWvtHou58grUl8IyOq2sYgb9iacUTL0oeYE7eWulrWF35G4D3GWQich3w/0\" width=\"320\"></p>\n<p>启用Size Class后，IB中就会出现Size Class切换的菜单</p>\n<p><img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmazQ3DeTLO8z0QyicMicRkr1qSJbrpX5aO5jsKydyolqibWg7tAGDynpI5Jw/0\" width=\"320\"><br>我们可以切换到<code>wAny,hAny</code>模式去编辑通用的控件和布局，也可以切换到某个特定Class，立刻可以预览到变化，于是有个问题：</p>\n<p>假如iPad和iPhone的布局有差异，老式写法是分成ipad.storyboard和iphone.storyboard来分别写，这本身就是个bug，因为大部分控件其实并没差别，新Size Class解决这个问题了木？</p>\n<p>答案是肯定的，Size Class的方案比老式的好了几条街：<br>IB中某个View的出现与否，<strong>约束的出现与否以及约束的值都是可以根据Size Class单独设置的</strong>，也就是说现在一个storyboard是<code>9合1</code>的。<br>比如下面有个Label，我只希望它出现在长宽紧缩的屏幕上时（脑补iwatch），这么勾选下就可以（出现或不出现被命名为”Installed”，这个选项可以从9个Size Class中多选）<br><img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmaz8fvJEaFDD7V313hKoYeyPHfnkvJA3akacdkg2r7hQLknceicpaL8kiaQ/0\" width=\"480\"></p>\n<hr>\n<h1 id=\"Size-Classes的xml文件改动\"><a href=\"#Size-Classes的xml文件改动\" class=\"headerlink\" title=\"Size Classes的xml文件改动\"></a>Size Classes的xml文件改动</h1><p>说到9合1的时候肯定会有疑问，这样的storyboard文件会不会很大？源文件会不会很乱导致多人开发经常冲突？</p>\n<p>答案是不会的，源于apple对Size Class在xml中的描述方法是针对变化配置的，什么意思呢？对比下storyboard的xml源文件就知道了：<br>wAny,hAny模式下刚才只有一个Label的页面：<br><img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmazSsj5BiaLrzLsOcowFj3zB49NTRS86NTVG5dqe0ACU8DnXov4iaWKllZg/0\" width=\"480\"></p>\n<p>假如在wC,hC紧缩模式下设置不出现这个label时，在label的父view层级出现了下面的配置：<br><img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmazaYtgIVwxibLf16xJXhicdWjfuBONNebKfgU2ICQsOEwAMjkibz6BJCTAQ/0\" width=\"480\"><br>所以说ib中以附加的描述字段来表示哪些元素是被哪些Size Class包含或排除的，也正因为这样的描述方式，使得新的xml格式<strong>可以被低版本兼容</strong>（低版本不解析这个字段，但其他字段正常解析）</p>\n<hr>\n<h1 id=\"Size-Classes与xcassets\"><a href=\"#Size-Classes与xcassets\" class=\"headerlink\" title=\"Size Classes与xcassets\"></a>Size Classes与xcassets</h1><p>既然storyboard变成了9合1，配套的<code>xcassets</code>必须也有所表示才行，xcode6后向<code>xcassets</code>中添加图片时增加了选择对应Size Classes的菜单，展开后会像下面一样：</p>\n<p><img src=\"http://ww1.sinaimg.cn/mw690/51530583gw1ek7k01ldj9j20j40k4aat.jpg\" width=\"480\"></p>\n<p>通过符号表示确实不错 <code>-</code>对应紧缩，<code>*</code>对应Any，<code>+</code>对应宽松<br>（@3x是iphone6 plus）</p>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>总的来说，iOS对UI这块的改动是跨时代性的，Autolayout的出现使得布局的复杂度减少到了View与View的关系上，再由根View（也就是屏幕）指定frame，随后所有子View相对布局，把frame的概念归一化到根View的frame上；但有了Size Class后，根视图的frame概念也被移除了，这下整个app的UI和frame这个单词已然脱离关系，这也正是apple想要达到的目的。</p>\n<p>Farewell，frame和那些还奋战在手写UI的iOS coder们…</p>\n","excerpt":"","more":"<p>iOS8新特性，<code>Size Classes</code>，是对老式UI思路的全新抽象：把各个设备屏幕（iphone4,5,6, ipad,iwatch?）以及它们的屏幕旋转状态都抽象成屏幕Size的变化，将这些Size归纳成几个类别（Class）</p>\n<p><img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmaz9sIa0ZszJu53F4dekibfkPLhq7lmF6UOLcC2pAHnGF5PyZ1MaRJHAlA/0\" width=\"320\"></p>\n<p>宽（正常，任意， 紧凑），高（正常，任意， 紧凑）</p>\n<p>3x3共9种Size，每种Size都可以设置特定的一套布局，如果不特殊指定，默认是在（宽任意，高任意）模式下设置，且其他8种布局继承它。</p>\n<p>听过有人说，我们不用学autolayout了，直接学Size Class就一步到位了。这个说法是不对的，因为Size Class在将屏幕分类后，执行布局的还是Autolayout。</p>\n<hr>\n<h1 id=\"Size-Classes与Interface-Builder\"><a href=\"#Size-Classes与Interface-Builder\" class=\"headerlink\" title=\"Size Classes与Interface Builder\"></a>Size Classes与Interface Builder</h1><p>当然不出所料的是，Xcode6中Interface Builder对Size Class有了很强大的支持：</p>\n<p><img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmazWvtHou58grUl8IyOq2sYgb9iacUTL0oeYE7eWulrWF35G4D3GWQich3w/0\" width=\"320\"></p>\n<p>启用Size Class后，IB中就会出现Size Class切换的菜单</p>\n<p><img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmazQ3DeTLO8z0QyicMicRkr1qSJbrpX5aO5jsKydyolqibWg7tAGDynpI5Jw/0\" width=\"320\"><br>我们可以切换到<code>wAny,hAny</code>模式去编辑通用的控件和布局，也可以切换到某个特定Class，立刻可以预览到变化，于是有个问题：</p>\n<p>假如iPad和iPhone的布局有差异，老式写法是分成ipad.storyboard和iphone.storyboard来分别写，这本身就是个bug，因为大部分控件其实并没差别，新Size Class解决这个问题了木？</p>\n<p>答案是肯定的，Size Class的方案比老式的好了几条街：<br>IB中某个View的出现与否，<strong>约束的出现与否以及约束的值都是可以根据Size Class单独设置的</strong>，也就是说现在一个storyboard是<code>9合1</code>的。<br>比如下面有个Label，我只希望它出现在长宽紧缩的屏幕上时（脑补iwatch），这么勾选下就可以（出现或不出现被命名为”Installed”，这个选项可以从9个Size Class中多选）<br><img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmaz8fvJEaFDD7V313hKoYeyPHfnkvJA3akacdkg2r7hQLknceicpaL8kiaQ/0\" width=\"480\"></p>\n<hr>\n<h1 id=\"Size-Classes的xml文件改动\"><a href=\"#Size-Classes的xml文件改动\" class=\"headerlink\" title=\"Size Classes的xml文件改动\"></a>Size Classes的xml文件改动</h1><p>说到9合1的时候肯定会有疑问，这样的storyboard文件会不会很大？源文件会不会很乱导致多人开发经常冲突？</p>\n<p>答案是不会的，源于apple对Size Class在xml中的描述方法是针对变化配置的，什么意思呢？对比下storyboard的xml源文件就知道了：<br>wAny,hAny模式下刚才只有一个Label的页面：<br><img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmazSsj5BiaLrzLsOcowFj3zB49NTRS86NTVG5dqe0ACU8DnXov4iaWKllZg/0\" width=\"480\"></p>\n<p>假如在wC,hC紧缩模式下设置不出现这个label时，在label的父view层级出现了下面的配置：<br><img src=\"https://mmbiz.qlogo.cn/mmbiz/5EEx1Jwk8kKN4lAicL1VN2y32W4ejmmazaYtgIVwxibLf16xJXhicdWjfuBONNebKfgU2ICQsOEwAMjkibz6BJCTAQ/0\" width=\"480\"><br>所以说ib中以附加的描述字段来表示哪些元素是被哪些Size Class包含或排除的，也正因为这样的描述方式，使得新的xml格式<strong>可以被低版本兼容</strong>（低版本不解析这个字段，但其他字段正常解析）</p>\n<hr>\n<h1 id=\"Size-Classes与xcassets\"><a href=\"#Size-Classes与xcassets\" class=\"headerlink\" title=\"Size Classes与xcassets\"></a>Size Classes与xcassets</h1><p>既然storyboard变成了9合1，配套的<code>xcassets</code>必须也有所表示才行，xcode6后向<code>xcassets</code>中添加图片时增加了选择对应Size Classes的菜单，展开后会像下面一样：</p>\n<p><img src=\"http://ww1.sinaimg.cn/mw690/51530583gw1ek7k01ldj9j20j40k4aat.jpg\" width=\"480\"></p>\n<p>通过符号表示确实不错 <code>-</code>对应紧缩，<code>*</code>对应Any，<code>+</code>对应宽松<br>（@3x是iphone6 plus）</p>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>总的来说，iOS对UI这块的改动是跨时代性的，Autolayout的出现使得布局的复杂度减少到了View与View的关系上，再由根View（也就是屏幕）指定frame，随后所有子View相对布局，把frame的概念归一化到根View的frame上；但有了Size Class后，根视图的frame概念也被移除了，这下整个app的UI和frame这个单词已然脱离关系，这也正是apple想要达到的目的。</p>\n<p>Farewell，frame和那些还奋战在手写UI的iOS coder们…</p>\n"},{"title":"ios程序员6级考试","date":"2014-03-06T15:10:58.000Z","_content":"## 前言\n\niOS 面试题看过来\n题目多来源于项目中遇到的错误和平时的误区，要是都能了如指掌，恭喜你，6级过了- -。  \n考点大概是对 iOS 框架、objc 语言基础的理解，以看代码为主（那种“谈谈xxxx的理解的题就算了吧”）  \n\n不断总结中...\n\n > It's examing time...  \n\n------\n\n## 1. 下面的代码分别输出什么？  \n\n\n``` objc\n@implementation Son : Father\n- (id)init {\n    self = [super init];\n    if (self) {\n        NSLog(@\"%@\", NSStringFromClass([self class]));\n        NSLog(@\"%@\", NSStringFromClass([super class]));\n    }\n    return self;\n}\n@end\n```\n\n## 2. 下面的代码报错？警告？还是正常输出什么？\n\n``` objc\nFather *father = [Father new];\nBOOL b1 = [father responseToSelector:@selector(responseToSelector:)];\nBOOL b2 = [Father responseToSelector:@selector(responseToSelector:)];\nNSLog(@\"%d, %d\", b1, b2);\n```\n\n## 3. 请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？\n\n``` objc\n...\n// 当前在主线程\n\n[request startAsync]; // 后台线程异步调用，完成后会在主线程调用completionBlock\nsleep(100); // sleep主线程，使得下面的代码在后台线程完成后才能执行\n[request setCompletionBlock:^{\n    NSLog(@\"Can I be printed?\");\n}];\n...\n```\n\n## 4. 不使用IB时，下面这样做有问题么？\n\n``` objc\n- (void)viewDidLoad {\n  [super viewDidLoad];\n  CGRect frame = CGRectMake(0, 0, self.view.bounds.size.width * 0.5, self.bounds.size.height * 0.5);\n  UIView *view = [[UIView alloc] initWithFrame:frame];\n  [self.view addSubview:view];\n}\n```\n\n## 5. 下面代码输出什么？\n\n``` objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    NSLog(@\"1\");\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@\"2\");\n    });\n    NSLog(@\"3\");\n}\n```\n\n-----\n# 答案和解答  \n\n[请戳我，我是传送门](http://blog.sunnyxx.com/2014/03/06/ios_exam_0_key/)\n-----\n原创文章，转载请注明源地址，[blog.sunnyxx.com](http://blog.sunnyxx.com)\n","source":"_posts/ios_exam_0.md","raw":"title: ios程序员6级考试\ndate: 2014-03-06 23:10:58\ntags: ios6级考试\n---\n## 前言\n\niOS 面试题看过来\n题目多来源于项目中遇到的错误和平时的误区，要是都能了如指掌，恭喜你，6级过了- -。  \n考点大概是对 iOS 框架、objc 语言基础的理解，以看代码为主（那种“谈谈xxxx的理解的题就算了吧”）  \n\n不断总结中...\n\n > It's examing time...  \n\n------\n\n## 1. 下面的代码分别输出什么？  \n\n\n``` objc\n@implementation Son : Father\n- (id)init {\n    self = [super init];\n    if (self) {\n        NSLog(@\"%@\", NSStringFromClass([self class]));\n        NSLog(@\"%@\", NSStringFromClass([super class]));\n    }\n    return self;\n}\n@end\n```\n\n## 2. 下面的代码报错？警告？还是正常输出什么？\n\n``` objc\nFather *father = [Father new];\nBOOL b1 = [father responseToSelector:@selector(responseToSelector:)];\nBOOL b2 = [Father responseToSelector:@selector(responseToSelector:)];\nNSLog(@\"%d, %d\", b1, b2);\n```\n\n## 3. 请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？\n\n``` objc\n...\n// 当前在主线程\n\n[request startAsync]; // 后台线程异步调用，完成后会在主线程调用completionBlock\nsleep(100); // sleep主线程，使得下面的代码在后台线程完成后才能执行\n[request setCompletionBlock:^{\n    NSLog(@\"Can I be printed?\");\n}];\n...\n```\n\n## 4. 不使用IB时，下面这样做有问题么？\n\n``` objc\n- (void)viewDidLoad {\n  [super viewDidLoad];\n  CGRect frame = CGRectMake(0, 0, self.view.bounds.size.width * 0.5, self.bounds.size.height * 0.5);\n  UIView *view = [[UIView alloc] initWithFrame:frame];\n  [self.view addSubview:view];\n}\n```\n\n## 5. 下面代码输出什么？\n\n``` objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    NSLog(@\"1\");\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@\"2\");\n    });\n    NSLog(@\"3\");\n}\n```\n\n-----\n# 答案和解答  \n\n[请戳我，我是传送门](http://blog.sunnyxx.com/2014/03/06/ios_exam_0_key/)\n-----\n原创文章，转载请注明源地址，[blog.sunnyxx.com](http://blog.sunnyxx.com)\n","slug":"ios_exam_0","published":1,"updated":"2016-03-27T08:43:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxkp000tev12doifvsht","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>iOS 面试题看过来<br>题目多来源于项目中遇到的错误和平时的误区，要是都能了如指掌，恭喜你，6级过了- -。<br>考点大概是对 iOS 框架、objc 语言基础的理解，以看代码为主（那种“谈谈xxxx的理解的题就算了吧”）  </p>\n<p>不断总结中…</p>\n<blockquote>\n<p>It’s examing time…  </p>\n</blockquote>\n<hr>\n<h2 id=\"1-下面的代码分别输出什么？\"><a href=\"#1-下面的代码分别输出什么？\" class=\"headerlink\" title=\"1. 下面的代码分别输出什么？\"></a>1. 下面的代码分别输出什么？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Son</span> : <span class=\"title\">Father</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">self</span> class]));</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">super</span> class]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-下面的代码报错？警告？还是正常输出什么？\"><a href=\"#2-下面的代码报错？警告？还是正常输出什么？\" class=\"headerlink\" title=\"2. 下面的代码报错？警告？还是正常输出什么？\"></a>2. 下面的代码报错？警告？还是正常输出什么？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Father *father = [Father new];</span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> b1 = [father responseToSelector:<span class=\"keyword\">@selector</span>(responseToSelector:)];</span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> b2 = [Father responseToSelector:<span class=\"keyword\">@selector</span>(responseToSelector:)];</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d, %d\"</span>, b1, b2);</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？\"><a href=\"#3-请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？\" class=\"headerlink\" title=\"3. 请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？\"></a>3. 请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// 当前在主线程</span></span><br><span class=\"line\"></span><br><span class=\"line\">[request startAsync]; <span class=\"comment\">// 后台线程异步调用，完成后会在主线程调用completionBlock</span></span><br><span class=\"line\">sleep(<span class=\"number\">100</span>); <span class=\"comment\">// sleep主线程，使得下面的代码在后台线程完成后才能执行</span></span><br><span class=\"line\">[request setCompletionBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Can I be printed?\"</span>);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-不使用IB时，下面这样做有问题么？\"><a href=\"#4-不使用IB时，下面这样做有问题么？\" class=\"headerlink\" title=\"4. 不使用IB时，下面这样做有问题么？\"></a>4. 不使用IB时，下面这样做有问题么？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">  [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">  <span class=\"built_in\">CGRect</span> frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"keyword\">self</span>.view.bounds.size.width * <span class=\"number\">0.5</span>, <span class=\"keyword\">self</span>.bounds.size.height * <span class=\"number\">0.5</span>);</span><br><span class=\"line\">  <span class=\"built_in\">UIView</span> *view = [[<span class=\"built_in\">UIView</span> alloc] initWithFrame:frame];</span><br><span class=\"line\">  [<span class=\"keyword\">self</span>.view addSubview:view];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-下面代码输出什么？\"><a href=\"#5-下面代码输出什么？\" class=\"headerlink\" title=\"5. 下面代码输出什么？\"></a>5. 下面代码输出什么？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"答案和解答\"><a href=\"#答案和解答\" class=\"headerlink\" title=\"答案和解答\"></a>答案和解答</h1><h2 id=\"请戳我，我是传送门\"><a href=\"#请戳我，我是传送门\" class=\"headerlink\" title=\"请戳我，我是传送门\"></a><a href=\"http://blog.sunnyxx.com/2014/03/06/ios_exam_0_key/\">请戳我，我是传送门</a></h2><p>原创文章，转载请注明源地址，<a href=\"http://blog.sunnyxx.com\">blog.sunnyxx.com</a></p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>iOS 面试题看过来<br>题目多来源于项目中遇到的错误和平时的误区，要是都能了如指掌，恭喜你，6级过了- -。<br>考点大概是对 iOS 框架、objc 语言基础的理解，以看代码为主（那种“谈谈xxxx的理解的题就算了吧”）  </p>\n<p>不断总结中…</p>\n<blockquote>\n<p>It’s examing time…  </p>\n</blockquote>\n<hr>\n<h2 id=\"1-下面的代码分别输出什么？\"><a href=\"#1-下面的代码分别输出什么？\" class=\"headerlink\" title=\"1. 下面的代码分别输出什么？\"></a>1. 下面的代码分别输出什么？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Son</span> : <span class=\"title\">Father</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">self</span> class]));</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">super</span> class]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-下面的代码报错？警告？还是正常输出什么？\"><a href=\"#2-下面的代码报错？警告？还是正常输出什么？\" class=\"headerlink\" title=\"2. 下面的代码报错？警告？还是正常输出什么？\"></a>2. 下面的代码报错？警告？还是正常输出什么？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Father *father = [Father new];</span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> b1 = [father responseToSelector:<span class=\"keyword\">@selector</span>(responseToSelector:)];</span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> b2 = [Father responseToSelector:<span class=\"keyword\">@selector</span>(responseToSelector:)];</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d, %d\"</span>, b1, b2);</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？\"><a href=\"#3-请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？\" class=\"headerlink\" title=\"3. 请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？\"></a>3. 请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// 当前在主线程</span></span><br><span class=\"line\"></span><br><span class=\"line\">[request startAsync]; <span class=\"comment\">// 后台线程异步调用，完成后会在主线程调用completionBlock</span></span><br><span class=\"line\">sleep(<span class=\"number\">100</span>); <span class=\"comment\">// sleep主线程，使得下面的代码在后台线程完成后才能执行</span></span><br><span class=\"line\">[request setCompletionBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Can I be printed?\"</span>);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-不使用IB时，下面这样做有问题么？\"><a href=\"#4-不使用IB时，下面这样做有问题么？\" class=\"headerlink\" title=\"4. 不使用IB时，下面这样做有问题么？\"></a>4. 不使用IB时，下面这样做有问题么？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">  [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">  <span class=\"built_in\">CGRect</span> frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"keyword\">self</span>.view.bounds.size.width * <span class=\"number\">0.5</span>, <span class=\"keyword\">self</span>.bounds.size.height * <span class=\"number\">0.5</span>);</span><br><span class=\"line\">  <span class=\"built_in\">UIView</span> *view = [[<span class=\"built_in\">UIView</span> alloc] initWithFrame:frame];</span><br><span class=\"line\">  [<span class=\"keyword\">self</span>.view addSubview:view];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-下面代码输出什么？\"><a href=\"#5-下面代码输出什么？\" class=\"headerlink\" title=\"5. 下面代码输出什么？\"></a>5. 下面代码输出什么？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"答案和解答\"><a href=\"#答案和解答\" class=\"headerlink\" title=\"答案和解答\"></a>答案和解答</h1><h2 id=\"请戳我，我是传送门\"><a href=\"#请戳我，我是传送门\" class=\"headerlink\" title=\"请戳我，我是传送门\"></a><a href=\"http://blog.sunnyxx.com/2014/03/06/ios_exam_0_key/\">请戳我，我是传送门</a></h2><p>原创文章，转载请注明源地址，<a href=\"http://blog.sunnyxx.com\">blog.sunnyxx.com</a></p>\n"},{"title":"iOS程序员6级考试（答案和解释）","date":"2014-03-06T15:10:58.000Z","_content":"# 我是前言\n上次发了个[ios程序员6级考试题](http://blog.sunnyxx.com/2014/03/06/ios_exam_0/) ，还在不断补充中，开个帖子配套写答案和解释。\n\n------\n\n## 1. 下面的代码分别输出什么？  \n\n``` objc\n@implementation Son : Father\n- (id)init {\n    self = [super init];\n    if (self) {\n        NSLog(@\"%@\", NSStringFromClass([self class]));\n        NSLog(@\"%@\", NSStringFromClass([super class]));\n    }\n    return self;\n}\n@end\n```\n\n答案：都输出\"Son\"  \n解释：objc中`super`是编译器标示符，并不像`self`一样是一个对象，遇到向`super`发的方法时会转译成`objc_msgSendSuper(...)`，而参数中的对象还是`self`，于是从父类开始沿继承链寻找`- class`这个方法，最后在`NSObject`中找到（若无override），此时，`[self class]`和[super class]已经等价了。\n\n## 2. 下面的代码报错？警告？还是正常输出什么？\n\n``` objc\nFather *father = [Father new];\nBOOL b1 = [father responseToSelector:@selector(responseToSelector:)];\nBOOL b2 = [Father responseToSelector:@selector(responseToSelector:)];\nNSLog(@\"%d, %d\", b1, b2);\n```\n\n答案：都输出\"1\"(YES)  \n解释：objc中：  \n- 不论是实例对象还是Class，都是id类型的对象（Class同样是对象）\n- 实例对象的isa指向它的Class（储存所有减号方法）,Class对象的isa指向元类（储存所有加号方法）\n- 向一个对象（id类型）发送消息时，都是从这个对象的`isa`指针指向的Class中寻找方法\n\n回到题目，当像`Father`类发送一个实例方法（`- responseToSelector`）消息时：\n1. 会从它的`isa`，也就是Father元类对象中寻找，由于元类中的方法都是类方法，所以自然找不到\n2. 于是沿继承链去父类NSObject元类中寻找，依然没有\n3. 由于objc对这块的设计是，NSObject的元类的父类是NSObject类（也就是我们熟悉的NSObject类），其中有所有的实例方法，因此找到了`- responseToSelector`\n\n补充：NSObject类中的所有实例方法`很可能`都对应实现了一个类方法（至少从开源的代码中可以看出来），如`+ resonseToSelector`，但并非公开的API，如果真的是这样，上面到第2步就可以找到这个方法。  \n再补充： 非NSObject的selector这样做无效。\n\n## 3. 请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？\n\n``` objc\n...\n// 当前在主线程\n[request startAsync]; // 后台线程异步调用，完成后会在主线程调用completionBlock\nsleep(100); // sleep主线程，使得下面的代码在后台线程完成后才能执行\n[request setCompletionBlock:^{\n    NSLog(@\"Can I be printed?\");\n}];\n...\n```\n\n答案：可以（有条件）  \n解释：为了方便解释，我们将其考虑成`gcd`的两个线性`queue`：main queue 和 back queue  \n\n当代码执行到`sleep(100)`时，这两个queue要执行的顺序看起来是这样的：  \n- main: *--- sleep -------------------------> | ---setCompletionBlock--->\n- back: *--- network ---->\n\n于是网络请求很快回来，回调函数一般要执行如：\n```\n// 回到主线程执行回调\ndispatch_async(dispatch_get_main_queue(), ^{\n  if (self.completionBlock) self.completionBlock();\n});\n```\n于是成了这样：  \n\n- main: *----sleep----> | ---setCompletionBlock---> | ---invoke completionBlock---->\n- back: *\n\n所以，当sleep结束后，主线程保持了调用顺序：  \n- main: *---setCompletionBlock---> | ---invoke completionBlock---->  \n\n此时，`completionBlock`的执行是在`setCompletionBlock`，之后的，所以可以正常回调。  \n\n注：这个解释有一个有限制条件，如果用下面的方法回调，则情况就会不同了：  \n\n``` objc\n// 回到主线程执行回调\nif (self.completionBlock) {\n  dispatch_async(dispatch_get_main_queue(), ^{\n    self.completionBlock();\n});\n```\n\n## 4. 不使用IB时，下面这样做有问题么？\n\n``` objc\n- (void)viewDidLoad {\n  [super viewDidLoad];\n  CGRect frame = CGRectMake(0, 0, self.view.bounds.size.width * 0.5, self.bounds.size.height * 0.5);\n  UIView *view = [[UIView alloc] initWithFrame:frame];\n  [self.view addSubview:view];\n}\n```\n\n解释：不使用IB手动创建ViewController时，在`viewDidLoad`中并未进行位置的初始化，原来遇到过不少次这个小坑，当外部创建这个vc时：  \n\n``` objc\nTestViewController *vc = [[TestViewController alloc] init];\nvc.view.frame = CGRectMake(0, 0, 100, 100);\n//...\n```\n\n我们知道，`ViewController`的view初始化大概流程是：  \n\n``` objc\n- (UIView *)view {\n  if (!_view) {\n    [self loadView];\n    [self viewDidLoad]; // Edit: 这句话移动到括号内，感谢@change2hao的提醒\n  }\n}\n```\n\n所以在外部执行到`vc.view.frame = CGRectMake(0, 0, 100, 100);`这句话时，在赋值操作执行前，`viewDidLoad`就已经被调用，因而在`viewDidLoad`中对view frame的取值都是默认值（window的大小），而非设定值。  \n\n注： 使用IB加载时如上情况也会发生，只是一般在IB就已经有一个预设值了。  \n\n## 5. 下面代码输出什么？\n\n``` objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    NSLog(@\"1\");\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@\"2\");\n    });\n    NSLog(@\"3\");\n}\n\n```\n\n答案：输出1之后程序死锁\n解释：`dispatch_sync`文档中提到：\n> Calls to dispatch_sync() targeting the current queue will result in dead-lock. Use of dispatch_sync() is also subject to the same multi-party dead-lock problems that may result from the use of a mutex. Use of dispatch_async() is preferred.\n\nsync到当前线程的block将会引起死锁，所以只会Log出1来后主线程就进入死锁状态，不会继续执行。  \n究其原因，还要看dispatch_sync做的事，它将一个block插入到queue中，这点和async没有区别，区别在于sync会等待到这个block执行完成后才回到调用点继续执行，而这个block的执行还依仗着viewDidLoad中dispatch_sync调用的结束，所以造成了循环等待，导致死锁。\n\n-----\n\n# 后续题目继续补充中\n\n-----\n\n原创文章，转载请注明源地址，[blog.sunnyxx.com](blog.sunnyxx.com)\n","source":"_posts/ios_exam_0_key.md","raw":"title: iOS程序员6级考试（答案和解释）\ndate: 2014-03-06 23:10:58\ntags: ios6级考试\n---\n# 我是前言\n上次发了个[ios程序员6级考试题](http://blog.sunnyxx.com/2014/03/06/ios_exam_0/) ，还在不断补充中，开个帖子配套写答案和解释。\n\n------\n\n## 1. 下面的代码分别输出什么？  \n\n``` objc\n@implementation Son : Father\n- (id)init {\n    self = [super init];\n    if (self) {\n        NSLog(@\"%@\", NSStringFromClass([self class]));\n        NSLog(@\"%@\", NSStringFromClass([super class]));\n    }\n    return self;\n}\n@end\n```\n\n答案：都输出\"Son\"  \n解释：objc中`super`是编译器标示符，并不像`self`一样是一个对象，遇到向`super`发的方法时会转译成`objc_msgSendSuper(...)`，而参数中的对象还是`self`，于是从父类开始沿继承链寻找`- class`这个方法，最后在`NSObject`中找到（若无override），此时，`[self class]`和[super class]已经等价了。\n\n## 2. 下面的代码报错？警告？还是正常输出什么？\n\n``` objc\nFather *father = [Father new];\nBOOL b1 = [father responseToSelector:@selector(responseToSelector:)];\nBOOL b2 = [Father responseToSelector:@selector(responseToSelector:)];\nNSLog(@\"%d, %d\", b1, b2);\n```\n\n答案：都输出\"1\"(YES)  \n解释：objc中：  \n- 不论是实例对象还是Class，都是id类型的对象（Class同样是对象）\n- 实例对象的isa指向它的Class（储存所有减号方法）,Class对象的isa指向元类（储存所有加号方法）\n- 向一个对象（id类型）发送消息时，都是从这个对象的`isa`指针指向的Class中寻找方法\n\n回到题目，当像`Father`类发送一个实例方法（`- responseToSelector`）消息时：\n1. 会从它的`isa`，也就是Father元类对象中寻找，由于元类中的方法都是类方法，所以自然找不到\n2. 于是沿继承链去父类NSObject元类中寻找，依然没有\n3. 由于objc对这块的设计是，NSObject的元类的父类是NSObject类（也就是我们熟悉的NSObject类），其中有所有的实例方法，因此找到了`- responseToSelector`\n\n补充：NSObject类中的所有实例方法`很可能`都对应实现了一个类方法（至少从开源的代码中可以看出来），如`+ resonseToSelector`，但并非公开的API，如果真的是这样，上面到第2步就可以找到这个方法。  \n再补充： 非NSObject的selector这样做无效。\n\n## 3. 请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？\n\n``` objc\n...\n// 当前在主线程\n[request startAsync]; // 后台线程异步调用，完成后会在主线程调用completionBlock\nsleep(100); // sleep主线程，使得下面的代码在后台线程完成后才能执行\n[request setCompletionBlock:^{\n    NSLog(@\"Can I be printed?\");\n}];\n...\n```\n\n答案：可以（有条件）  \n解释：为了方便解释，我们将其考虑成`gcd`的两个线性`queue`：main queue 和 back queue  \n\n当代码执行到`sleep(100)`时，这两个queue要执行的顺序看起来是这样的：  \n- main: *--- sleep -------------------------> | ---setCompletionBlock--->\n- back: *--- network ---->\n\n于是网络请求很快回来，回调函数一般要执行如：\n```\n// 回到主线程执行回调\ndispatch_async(dispatch_get_main_queue(), ^{\n  if (self.completionBlock) self.completionBlock();\n});\n```\n于是成了这样：  \n\n- main: *----sleep----> | ---setCompletionBlock---> | ---invoke completionBlock---->\n- back: *\n\n所以，当sleep结束后，主线程保持了调用顺序：  \n- main: *---setCompletionBlock---> | ---invoke completionBlock---->  \n\n此时，`completionBlock`的执行是在`setCompletionBlock`，之后的，所以可以正常回调。  \n\n注：这个解释有一个有限制条件，如果用下面的方法回调，则情况就会不同了：  \n\n``` objc\n// 回到主线程执行回调\nif (self.completionBlock) {\n  dispatch_async(dispatch_get_main_queue(), ^{\n    self.completionBlock();\n});\n```\n\n## 4. 不使用IB时，下面这样做有问题么？\n\n``` objc\n- (void)viewDidLoad {\n  [super viewDidLoad];\n  CGRect frame = CGRectMake(0, 0, self.view.bounds.size.width * 0.5, self.bounds.size.height * 0.5);\n  UIView *view = [[UIView alloc] initWithFrame:frame];\n  [self.view addSubview:view];\n}\n```\n\n解释：不使用IB手动创建ViewController时，在`viewDidLoad`中并未进行位置的初始化，原来遇到过不少次这个小坑，当外部创建这个vc时：  \n\n``` objc\nTestViewController *vc = [[TestViewController alloc] init];\nvc.view.frame = CGRectMake(0, 0, 100, 100);\n//...\n```\n\n我们知道，`ViewController`的view初始化大概流程是：  \n\n``` objc\n- (UIView *)view {\n  if (!_view) {\n    [self loadView];\n    [self viewDidLoad]; // Edit: 这句话移动到括号内，感谢@change2hao的提醒\n  }\n}\n```\n\n所以在外部执行到`vc.view.frame = CGRectMake(0, 0, 100, 100);`这句话时，在赋值操作执行前，`viewDidLoad`就已经被调用，因而在`viewDidLoad`中对view frame的取值都是默认值（window的大小），而非设定值。  \n\n注： 使用IB加载时如上情况也会发生，只是一般在IB就已经有一个预设值了。  \n\n## 5. 下面代码输出什么？\n\n``` objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    NSLog(@\"1\");\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@\"2\");\n    });\n    NSLog(@\"3\");\n}\n\n```\n\n答案：输出1之后程序死锁\n解释：`dispatch_sync`文档中提到：\n> Calls to dispatch_sync() targeting the current queue will result in dead-lock. Use of dispatch_sync() is also subject to the same multi-party dead-lock problems that may result from the use of a mutex. Use of dispatch_async() is preferred.\n\nsync到当前线程的block将会引起死锁，所以只会Log出1来后主线程就进入死锁状态，不会继续执行。  \n究其原因，还要看dispatch_sync做的事，它将一个block插入到queue中，这点和async没有区别，区别在于sync会等待到这个block执行完成后才回到调用点继续执行，而这个block的执行还依仗着viewDidLoad中dispatch_sync调用的结束，所以造成了循环等待，导致死锁。\n\n-----\n\n# 后续题目继续补充中\n\n-----\n\n原创文章，转载请注明源地址，[blog.sunnyxx.com](blog.sunnyxx.com)\n","slug":"ios_exam_0_key","published":1,"updated":"2016-03-27T08:41:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxks000wev12eajgfp5w","content":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>上次发了个<a href=\"http://blog.sunnyxx.com/2014/03/06/ios_exam_0/\">ios程序员6级考试题</a> ，还在不断补充中，开个帖子配套写答案和解释。</p>\n<hr>\n<h2 id=\"1-下面的代码分别输出什么？\"><a href=\"#1-下面的代码分别输出什么？\" class=\"headerlink\" title=\"1. 下面的代码分别输出什么？\"></a>1. 下面的代码分别输出什么？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Son</span> : <span class=\"title\">Father</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">self</span> class]));</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">super</span> class]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>答案：都输出”Son”<br>解释：objc中<code>super</code>是编译器标示符，并不像<code>self</code>一样是一个对象，遇到向<code>super</code>发的方法时会转译成<code>objc_msgSendSuper(...)</code>，而参数中的对象还是<code>self</code>，于是从父类开始沿继承链寻找<code>- class</code>这个方法，最后在<code>NSObject</code>中找到（若无override），此时，<code>[self class]</code>和[super class]已经等价了。</p>\n<h2 id=\"2-下面的代码报错？警告？还是正常输出什么？\"><a href=\"#2-下面的代码报错？警告？还是正常输出什么？\" class=\"headerlink\" title=\"2. 下面的代码报错？警告？还是正常输出什么？\"></a>2. 下面的代码报错？警告？还是正常输出什么？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Father *father = [Father new];</span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> b1 = [father responseToSelector:<span class=\"keyword\">@selector</span>(responseToSelector:)];</span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> b2 = [Father responseToSelector:<span class=\"keyword\">@selector</span>(responseToSelector:)];</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d, %d\"</span>, b1, b2);</span><br></pre></td></tr></table></figure>\n<p>答案：都输出”1”(YES)<br>解释：objc中：  </p>\n<ul>\n<li>不论是实例对象还是Class，都是id类型的对象（Class同样是对象）</li>\n<li>实例对象的isa指向它的Class（储存所有减号方法）,Class对象的isa指向元类（储存所有加号方法）</li>\n<li>向一个对象（id类型）发送消息时，都是从这个对象的<code>isa</code>指针指向的Class中寻找方法</li>\n</ul>\n<p>回到题目，当像<code>Father</code>类发送一个实例方法（<code>- responseToSelector</code>）消息时：</p>\n<ol>\n<li>会从它的<code>isa</code>，也就是Father元类对象中寻找，由于元类中的方法都是类方法，所以自然找不到</li>\n<li>于是沿继承链去父类NSObject元类中寻找，依然没有</li>\n<li>由于objc对这块的设计是，NSObject的元类的父类是NSObject类（也就是我们熟悉的NSObject类），其中有所有的实例方法，因此找到了<code>- responseToSelector</code></li>\n</ol>\n<p>补充：NSObject类中的所有实例方法<code>很可能</code>都对应实现了一个类方法（至少从开源的代码中可以看出来），如<code>+ resonseToSelector</code>，但并非公开的API，如果真的是这样，上面到第2步就可以找到这个方法。<br>再补充： 非NSObject的selector这样做无效。</p>\n<h2 id=\"3-请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？\"><a href=\"#3-请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？\" class=\"headerlink\" title=\"3. 请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？\"></a>3. 请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// 当前在主线程</span></span><br><span class=\"line\">[request startAsync]; <span class=\"comment\">// 后台线程异步调用，完成后会在主线程调用completionBlock</span></span><br><span class=\"line\">sleep(<span class=\"number\">100</span>); <span class=\"comment\">// sleep主线程，使得下面的代码在后台线程完成后才能执行</span></span><br><span class=\"line\">[request setCompletionBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Can I be printed?\"</span>);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>答案：可以（有条件）<br>解释：为了方便解释，我们将其考虑成<code>gcd</code>的两个线性<code>queue</code>：main queue 和 back queue  </p>\n<p>当代码执行到<code>sleep(100)</code>时，这两个queue要执行的顺序看起来是这样的：  </p>\n<ul>\n<li>main: *— sleep ————————-&gt; | —setCompletionBlock—&gt;</li>\n<li>back: *— network —-&gt;</li>\n</ul>\n<p>于是网络请求很快回来，回调函数一般要执行如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 回到主线程执行回调</span><br><span class=\"line\">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">  if (self.completionBlock) self.completionBlock();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>于是成了这样：  </p>\n<ul>\n<li>main: *—-sleep—-&gt; | —setCompletionBlock—&gt; | —invoke completionBlock—-&gt;</li>\n<li>back: *</li>\n</ul>\n<p>所以，当sleep结束后，主线程保持了调用顺序：  </p>\n<ul>\n<li>main: *—setCompletionBlock—&gt; | —invoke completionBlock—-&gt;  </li>\n</ul>\n<p>此时，<code>completionBlock</code>的执行是在<code>setCompletionBlock</code>，之后的，所以可以正常回调。  </p>\n<p>注：这个解释有一个有限制条件，如果用下面的方法回调，则情况就会不同了：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 回到主线程执行回调</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.completionBlock) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.completionBlock();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-不使用IB时，下面这样做有问题么？\"><a href=\"#4-不使用IB时，下面这样做有问题么？\" class=\"headerlink\" title=\"4. 不使用IB时，下面这样做有问题么？\"></a>4. 不使用IB时，下面这样做有问题么？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">  [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">  <span class=\"built_in\">CGRect</span> frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"keyword\">self</span>.view.bounds.size.width * <span class=\"number\">0.5</span>, <span class=\"keyword\">self</span>.bounds.size.height * <span class=\"number\">0.5</span>);</span><br><span class=\"line\">  <span class=\"built_in\">UIView</span> *view = [[<span class=\"built_in\">UIView</span> alloc] initWithFrame:frame];</span><br><span class=\"line\">  [<span class=\"keyword\">self</span>.view addSubview:view];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释：不使用IB手动创建ViewController时，在<code>viewDidLoad</code>中并未进行位置的初始化，原来遇到过不少次这个小坑，当外部创建这个vc时：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestViewController *vc = [[TestViewController alloc] init];</span><br><span class=\"line\">vc.view.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure>\n<p>我们知道，<code>ViewController</code>的view初始化大概流程是：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIView</span> *)view &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!_view) &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> loadView];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> viewDidLoad]; <span class=\"comment\">// Edit: 这句话移动到括号内，感谢@change2hao的提醒</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以在外部执行到<code>vc.view.frame = CGRectMake(0, 0, 100, 100);</code>这句话时，在赋值操作执行前，<code>viewDidLoad</code>就已经被调用，因而在<code>viewDidLoad</code>中对view frame的取值都是默认值（window的大小），而非设定值。  </p>\n<p>注： 使用IB加载时如上情况也会发生，只是一般在IB就已经有一个预设值了。  </p>\n<h2 id=\"5-下面代码输出什么？\"><a href=\"#5-下面代码输出什么？\" class=\"headerlink\" title=\"5. 下面代码输出什么？\"></a>5. 下面代码输出什么？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案：输出1之后程序死锁<br>解释：<code>dispatch_sync</code>文档中提到：</p>\n<blockquote>\n<p>Calls to dispatch_sync() targeting the current queue will result in dead-lock. Use of dispatch_sync() is also subject to the same multi-party dead-lock problems that may result from the use of a mutex. Use of dispatch_async() is preferred.</p>\n</blockquote>\n<p>sync到当前线程的block将会引起死锁，所以只会Log出1来后主线程就进入死锁状态，不会继续执行。<br>究其原因，还要看dispatch_sync做的事，它将一个block插入到queue中，这点和async没有区别，区别在于sync会等待到这个block执行完成后才回到调用点继续执行，而这个block的执行还依仗着viewDidLoad中dispatch_sync调用的结束，所以造成了循环等待，导致死锁。</p>\n<hr>\n<h1 id=\"后续题目继续补充中\"><a href=\"#后续题目继续补充中\" class=\"headerlink\" title=\"后续题目继续补充中\"></a>后续题目继续补充中</h1><hr>\n<p>原创文章，转载请注明源地址，<a href=\"blog.sunnyxx.com\">blog.sunnyxx.com</a></p>\n","excerpt":"","more":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>上次发了个<a href=\"http://blog.sunnyxx.com/2014/03/06/ios_exam_0/\">ios程序员6级考试题</a> ，还在不断补充中，开个帖子配套写答案和解释。</p>\n<hr>\n<h2 id=\"1-下面的代码分别输出什么？\"><a href=\"#1-下面的代码分别输出什么？\" class=\"headerlink\" title=\"1. 下面的代码分别输出什么？\"></a>1. 下面的代码分别输出什么？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Son</span> : <span class=\"title\">Father</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">self</span> class]));</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">super</span> class]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>答案：都输出”Son”<br>解释：objc中<code>super</code>是编译器标示符，并不像<code>self</code>一样是一个对象，遇到向<code>super</code>发的方法时会转译成<code>objc_msgSendSuper(...)</code>，而参数中的对象还是<code>self</code>，于是从父类开始沿继承链寻找<code>- class</code>这个方法，最后在<code>NSObject</code>中找到（若无override），此时，<code>[self class]</code>和[super class]已经等价了。</p>\n<h2 id=\"2-下面的代码报错？警告？还是正常输出什么？\"><a href=\"#2-下面的代码报错？警告？还是正常输出什么？\" class=\"headerlink\" title=\"2. 下面的代码报错？警告？还是正常输出什么？\"></a>2. 下面的代码报错？警告？还是正常输出什么？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Father *father = [Father new];</span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> b1 = [father responseToSelector:<span class=\"keyword\">@selector</span>(responseToSelector:)];</span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> b2 = [Father responseToSelector:<span class=\"keyword\">@selector</span>(responseToSelector:)];</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d, %d\"</span>, b1, b2);</span><br></pre></td></tr></table></figure>\n<p>答案：都输出”1”(YES)<br>解释：objc中：  </p>\n<ul>\n<li>不论是实例对象还是Class，都是id类型的对象（Class同样是对象）</li>\n<li>实例对象的isa指向它的Class（储存所有减号方法）,Class对象的isa指向元类（储存所有加号方法）</li>\n<li>向一个对象（id类型）发送消息时，都是从这个对象的<code>isa</code>指针指向的Class中寻找方法</li>\n</ul>\n<p>回到题目，当像<code>Father</code>类发送一个实例方法（<code>- responseToSelector</code>）消息时：</p>\n<ol>\n<li>会从它的<code>isa</code>，也就是Father元类对象中寻找，由于元类中的方法都是类方法，所以自然找不到</li>\n<li>于是沿继承链去父类NSObject元类中寻找，依然没有</li>\n<li>由于objc对这块的设计是，NSObject的元类的父类是NSObject类（也就是我们熟悉的NSObject类），其中有所有的实例方法，因此找到了<code>- responseToSelector</code></li>\n</ol>\n<p>补充：NSObject类中的所有实例方法<code>很可能</code>都对应实现了一个类方法（至少从开源的代码中可以看出来），如<code>+ resonseToSelector</code>，但并非公开的API，如果真的是这样，上面到第2步就可以找到这个方法。<br>再补充： 非NSObject的selector这样做无效。</p>\n<h2 id=\"3-请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？\"><a href=\"#3-请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？\" class=\"headerlink\" title=\"3. 请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？\"></a>3. 请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// 当前在主线程</span></span><br><span class=\"line\">[request startAsync]; <span class=\"comment\">// 后台线程异步调用，完成后会在主线程调用completionBlock</span></span><br><span class=\"line\">sleep(<span class=\"number\">100</span>); <span class=\"comment\">// sleep主线程，使得下面的代码在后台线程完成后才能执行</span></span><br><span class=\"line\">[request setCompletionBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Can I be printed?\"</span>);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>答案：可以（有条件）<br>解释：为了方便解释，我们将其考虑成<code>gcd</code>的两个线性<code>queue</code>：main queue 和 back queue  </p>\n<p>当代码执行到<code>sleep(100)</code>时，这两个queue要执行的顺序看起来是这样的：  </p>\n<ul>\n<li>main: *— sleep ————————-&gt; | —setCompletionBlock—&gt;</li>\n<li>back: *— network —-&gt;</li>\n</ul>\n<p>于是网络请求很快回来，回调函数一般要执行如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 回到主线程执行回调</span><br><span class=\"line\">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">  if (self.completionBlock) self.completionBlock();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>于是成了这样：  </p>\n<ul>\n<li>main: *—-sleep—-&gt; | —setCompletionBlock—&gt; | —invoke completionBlock—-&gt;</li>\n<li>back: *</li>\n</ul>\n<p>所以，当sleep结束后，主线程保持了调用顺序：  </p>\n<ul>\n<li>main: *—setCompletionBlock—&gt; | —invoke completionBlock—-&gt;  </li>\n</ul>\n<p>此时，<code>completionBlock</code>的执行是在<code>setCompletionBlock</code>，之后的，所以可以正常回调。  </p>\n<p>注：这个解释有一个有限制条件，如果用下面的方法回调，则情况就会不同了：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 回到主线程执行回调</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.completionBlock) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.completionBlock();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-不使用IB时，下面这样做有问题么？\"><a href=\"#4-不使用IB时，下面这样做有问题么？\" class=\"headerlink\" title=\"4. 不使用IB时，下面这样做有问题么？\"></a>4. 不使用IB时，下面这样做有问题么？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">  [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">  <span class=\"built_in\">CGRect</span> frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"keyword\">self</span>.view.bounds.size.width * <span class=\"number\">0.5</span>, <span class=\"keyword\">self</span>.bounds.size.height * <span class=\"number\">0.5</span>);</span><br><span class=\"line\">  <span class=\"built_in\">UIView</span> *view = [[<span class=\"built_in\">UIView</span> alloc] initWithFrame:frame];</span><br><span class=\"line\">  [<span class=\"keyword\">self</span>.view addSubview:view];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释：不使用IB手动创建ViewController时，在<code>viewDidLoad</code>中并未进行位置的初始化，原来遇到过不少次这个小坑，当外部创建这个vc时：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestViewController *vc = [[TestViewController alloc] init];</span><br><span class=\"line\">vc.view.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure>\n<p>我们知道，<code>ViewController</code>的view初始化大概流程是：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIView</span> *)view &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!_view) &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> loadView];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> viewDidLoad]; <span class=\"comment\">// Edit: 这句话移动到括号内，感谢@change2hao的提醒</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以在外部执行到<code>vc.view.frame = CGRectMake(0, 0, 100, 100);</code>这句话时，在赋值操作执行前，<code>viewDidLoad</code>就已经被调用，因而在<code>viewDidLoad</code>中对view frame的取值都是默认值（window的大小），而非设定值。  </p>\n<p>注： 使用IB加载时如上情况也会发生，只是一般在IB就已经有一个预设值了。  </p>\n<h2 id=\"5-下面代码输出什么？\"><a href=\"#5-下面代码输出什么？\" class=\"headerlink\" title=\"5. 下面代码输出什么？\"></a>5. 下面代码输出什么？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案：输出1之后程序死锁<br>解释：<code>dispatch_sync</code>文档中提到：</p>\n<blockquote>\n<p>Calls to dispatch_sync() targeting the current queue will result in dead-lock. Use of dispatch_sync() is also subject to the same multi-party dead-lock problems that may result from the use of a mutex. Use of dispatch_async() is preferred.</p>\n</blockquote>\n<p>sync到当前线程的block将会引起死锁，所以只会Log出1来后主线程就进入死锁状态，不会继续执行。<br>究其原因，还要看dispatch_sync做的事，它将一个block插入到queue中，这点和async没有区别，区别在于sync会等待到这个block执行完成后才回到调用点继续执行，而这个block的执行还依仗着viewDidLoad中dispatch_sync调用的结束，所以造成了循环等待，导致死锁。</p>\n<hr>\n<h1 id=\"后续题目继续补充中\"><a href=\"#后续题目继续补充中\" class=\"headerlink\" title=\"后续题目继续补充中\"></a>后续题目继续补充中</h1><hr>\n<p>原创文章，转载请注明源地址，<a href=\"blog.sunnyxx.com\">blog.sunnyxx.com</a></p>\n"},{"title":"xib的动态桥接","date":"2014-07-01T10:14:14.000Z","_content":"\n# 我是前言\n个人很主张使用`Interface Builder`(以下都简称`IB`)来构建程序UI，包括`storyboard`和`xib`，相比代码更可视和易于修改，尤其在使用AutoLayout的时候，一目了然。  \n但用了这么久IB之后发现一个很大的槽点，就是IB间很难`嵌套混用`，比如一个xib中的view是另一个xib的子view，或者一个storyboard中两个vc都用到了一个xib构建的view等。解决方法一般是代码手动拼接，这就造成了比较混乱的情况。  \n\n**本文将尝试解决这个问题，实现xib的`动态桥接`，并提供一个支持`cocoapods`的开源工具类供方便使用。**\n\n## 一张图顶十句话：\n\n<img src=\"http://ww2.sinaimg.cn/large/51530583gw1ehzgklik42j20m80go0ua.jpg\" width=\"500\" align=\"middle\">  \n\n## 实现效果：\n\n<img src=\"http://ww3.sinaimg.cn/large/51530583gw1ehzgoiqfkfj20hs0qo75u.jpg\" width=\"300\" align=\"middle\">\n\n-----\n\n# 黑魔法方法\n实现这个功能的关键在于：在ib加载的某个时刻将`placeholder`的view动态替换成从xib加载的view，下面的方法就可以做到：\n\n``` objc\n- (id)awakeAfterUsingCoder:(NSCoder *)aDecoder NS_REPLACES_RECEIVER;\n```\n\n这个方法很少用到，在`NSObject (NSCoderMethods)`中定义，由`NSCoder`在decode过程中调用（于`-initWithCoder:`之后），所以说就算从文件里decode出来的对象也会走这个方法。\n方法后面有`NS_REPLACES_RECEIVER`这个宏：\n\n``` objc\n #define NS_REPLACES_RECEIVER __attribute__((ns_consumes_self)) NS_RETURNS_RETAINED\n```\n在clang的文档中可以找到对这个[编译器属性的介绍](http://clang-analyzer.llvm.org/annotations.html#attr_ns_consumes_self)  \n\n> One use of this attribute is declare your own init-like methods that do not follow the standard Cocoa naming conventions.\n\n所以这个宏主要为了给编译器标识出这个方法可以像`self = [super init]`一样使用，并作出合理的内存管理。\nSo，这个方法提供了一个机会，**可以将decode出来的对象替换成另一个对象**\n\n\n**动态桥接流程**\n\n``` objc\n- (id)awakeAfterUsingCoder:(NSCoder *)aDecoder {\n    self = [super awakeAfterUsingCoder:aDecoder];\n\n    // 0. 判断是否要进行替换\n    // 1. 根据self.class从xib创建真正的view\n    // 2. 将placeholder的属性、autolayout等替换到真正的view上\n    // 3. return 真正的view\n}\n```\n\n流程不难理解，就是有2个小难点：\n - 步骤1从xib创建真正的view时也会调用这个方法，会造成`递归`，如何判断\n - 迁移`AutoLayoutConstrains`\n\n### 解决递归问题\n\n这个topic全网可能就[《这篇文章》](http://blog.yangmeyer.de/blog/2012/07/09/an-update-on-nested-nib-loading)有写，本文也是从它发起的，但是发现它的方法并不能解决所有问题（尤其是用storyboard加载xib时），所以换了个思路，采取了设置标志位的方式避免递归调用：   \n\n``` objc\n- (id)awakeAfterUsingCoder:(NSCoder *)aDecoder {\n    self = [super awakeAfterUsingCoder:aDecoder];\n    if (这个类的Loading标志位 -> NO)\n    {\n        Loading标志位 -> YES\n        从xib加载真实的View (这里会递归调用这个函数)\n        return 真实View\n    }\n    Loading标志位 -> NO\n    return self\n}\n\n```\n\n方法有点土，但是有效了，源代码文章后面会给地址。\n\n\n### 迁移AutoLayoutConstrains\n\n由于IB在加载AutoLayoutConstrains时的顺序是**先加载子View内部的约束，后加载父View上的约束**，而我们替换placeholder的时机是：\n  1. placehodler view被创建（只带width，height的自身约束）\n  2. 真正的view被从xib动态加载（带其子view的所有约束）\n  3. **_placeholder被替换成真的view_**\n  4. placeholder view在其父View（一直到父父父...View）的约束被创建\n\n\n所以说，迁移AutoLayout时，`只需要把placeholder view的自身约束copy到真实View上就好了`（停顿10s感受下）  \n代码如下：  \n\n``` objc\n- (void)replaceAutolayoutConstrainsFromView:(UIView *)placeholderView toView:(UIView *)realView\n{\n    for (NSLayoutConstraint *constraint in placeholderView.constraints) {\n        NSLayoutConstraint* newConstraint  = [NSLayoutConstraint constraintWithItem:realView\n                                                     attribute:constraint.firstAttribute\n                                                     relatedBy:constraint.relation\n                                                        toItem:nil // Only first item\n                                                     attribute:constraint.secondAttribute\n                                                    multiplier:constraint.multiplier\n                                                      constant:constraint.constant];\n        newConstraint.shouldBeArchived = constraint.shouldBeArchived;\n        newConstraint.priority = constraint.priority;\n        [realView addConstraint:newConstraint];\n    }\n}\n```\n\nOne more thing，保证AutoLayout生效还要加上下面这句话：\n\n``` objc\nrealView.translatesAutoresizingMaskIntoConstraints = NO;\n```\n\n-----\n\n# 开源项目XXNibBridge\n\n光说方案不给源码还是不地道的，demo放到了[我的github上面的XXNibBridge项目](https://github.com/sunnyxx/XXNibBridge)，回顾一下上面的关系图：\n\n<img src=\"http://ww2.sinaimg.cn/large/51530583gw1ehzgklik42j20m80go0ua.jpg\" width=\"400\">  \n\n不得不提到`IB命名约定`的最佳实践方案：\n\n**将类名作为Cell或者VC的Reusable Identifier**\n设`ReuseIdentifier`一直比较蛋疼，我一般将Cell的`类名`作为`ReuseIdentifier`（当然，大多数情况我们都会子类化Cell的），写法如：  \n\n``` objc\n[self.tableView registerClass:[XXSarkCell class] forCellReuseIdentifier:NSStringFromClass([XXSarkCell class])];\n```\n\n在`dequeueCell`的时候同理，这样的好处在于省去了起名的恶心、通过ReuseId可以直接找到Cell类、同时重构Cell类名时ReuseId也不用去再改。\n\n**View的xib与View的类名同名** 同理   \n\n实现了桥接Xib的功能的同时，也简单实现了这个命名约定：\n\n``` objc\n// XXNibBridge.h\n+ (NSString *)xx_nibID; // 类名\n+ (UINib *)xx_nib; // 返回类名对应nib\n+ (id)xx_loadFromNib; // 对应nib的类对象\n+ (id/*UIViewController*/)xx_loadFromStoryboardNamed:(NSString *)name; // 返回类名对应的vc\n```\n\n所以之后的代码可以这么写:  \n\n``` objc\n[tableView registerNib:[XXSarkView xx_nib] forCellReuseIdentifier:[XXSarkView xx_nibID]];\n```\n\n# XXNibBridge的使用\n\n**Cocoapods安装**\n\n``` objc\npod 'XXNibBridge', :git => 'https://github.com/sunnyxx/XXNibBridge.git'\n```\n\n对于要支持Bridge的类，重载下面的方法：\n\n``` objc\n#import \"XXNibBridge.h\"\n@implementation XXDogeView\n+ (BOOL)xx_shouldApplyNibBridging\n{\n    return YES;\n}\n@end\n```\n\n在父的Xib或Storyboard中拖个UIView进来作为Placeholder，设置为真实Nib的类\n\n<img src=\"http://ww1.sinaimg.cn/large/51530583gw1ei03b0vuzmj20z40a6q4e.jpg\" width=\"500\">  \n\n保证真实Nib的类名和Nib名相同，记得在Nib中设好Class\n<img src=\"http://ww3.sinaimg.cn/large/51530583gw1ei03dn8rq8j206g036q2z.jpg\" width=\"200\">\n\n**Done.**\n<img src=\"http://ww4.sinaimg.cn/large/51530583gw1ei03g01mmej20ga07sjrt.jpg\" width=\"400\">\n\n-----\n\n# References\n\nhttp://blog.yangmeyer.de/blog/2012/07/09/an-update-on-nested-nib-loading\nhttp://stackoverflow.com/questions/19816703/replacing-nsview-while-keeping-autolayout-constraints\nhttp://clang-analyzer.llvm.org/annotations.html#attr_ns_consumes_self\n","source":"_posts/ios_ib_bridge.md","raw":"title: xib的动态桥接   \ndate: 2014-07-01 18:14:14\ntags: ios最佳实践\n---\n\n# 我是前言\n个人很主张使用`Interface Builder`(以下都简称`IB`)来构建程序UI，包括`storyboard`和`xib`，相比代码更可视和易于修改，尤其在使用AutoLayout的时候，一目了然。  \n但用了这么久IB之后发现一个很大的槽点，就是IB间很难`嵌套混用`，比如一个xib中的view是另一个xib的子view，或者一个storyboard中两个vc都用到了一个xib构建的view等。解决方法一般是代码手动拼接，这就造成了比较混乱的情况。  \n\n**本文将尝试解决这个问题，实现xib的`动态桥接`，并提供一个支持`cocoapods`的开源工具类供方便使用。**\n\n## 一张图顶十句话：\n\n<img src=\"http://ww2.sinaimg.cn/large/51530583gw1ehzgklik42j20m80go0ua.jpg\" width=\"500\" align=\"middle\">  \n\n## 实现效果：\n\n<img src=\"http://ww3.sinaimg.cn/large/51530583gw1ehzgoiqfkfj20hs0qo75u.jpg\" width=\"300\" align=\"middle\">\n\n-----\n\n# 黑魔法方法\n实现这个功能的关键在于：在ib加载的某个时刻将`placeholder`的view动态替换成从xib加载的view，下面的方法就可以做到：\n\n``` objc\n- (id)awakeAfterUsingCoder:(NSCoder *)aDecoder NS_REPLACES_RECEIVER;\n```\n\n这个方法很少用到，在`NSObject (NSCoderMethods)`中定义，由`NSCoder`在decode过程中调用（于`-initWithCoder:`之后），所以说就算从文件里decode出来的对象也会走这个方法。\n方法后面有`NS_REPLACES_RECEIVER`这个宏：\n\n``` objc\n #define NS_REPLACES_RECEIVER __attribute__((ns_consumes_self)) NS_RETURNS_RETAINED\n```\n在clang的文档中可以找到对这个[编译器属性的介绍](http://clang-analyzer.llvm.org/annotations.html#attr_ns_consumes_self)  \n\n> One use of this attribute is declare your own init-like methods that do not follow the standard Cocoa naming conventions.\n\n所以这个宏主要为了给编译器标识出这个方法可以像`self = [super init]`一样使用，并作出合理的内存管理。\nSo，这个方法提供了一个机会，**可以将decode出来的对象替换成另一个对象**\n\n\n**动态桥接流程**\n\n``` objc\n- (id)awakeAfterUsingCoder:(NSCoder *)aDecoder {\n    self = [super awakeAfterUsingCoder:aDecoder];\n\n    // 0. 判断是否要进行替换\n    // 1. 根据self.class从xib创建真正的view\n    // 2. 将placeholder的属性、autolayout等替换到真正的view上\n    // 3. return 真正的view\n}\n```\n\n流程不难理解，就是有2个小难点：\n - 步骤1从xib创建真正的view时也会调用这个方法，会造成`递归`，如何判断\n - 迁移`AutoLayoutConstrains`\n\n### 解决递归问题\n\n这个topic全网可能就[《这篇文章》](http://blog.yangmeyer.de/blog/2012/07/09/an-update-on-nested-nib-loading)有写，本文也是从它发起的，但是发现它的方法并不能解决所有问题（尤其是用storyboard加载xib时），所以换了个思路，采取了设置标志位的方式避免递归调用：   \n\n``` objc\n- (id)awakeAfterUsingCoder:(NSCoder *)aDecoder {\n    self = [super awakeAfterUsingCoder:aDecoder];\n    if (这个类的Loading标志位 -> NO)\n    {\n        Loading标志位 -> YES\n        从xib加载真实的View (这里会递归调用这个函数)\n        return 真实View\n    }\n    Loading标志位 -> NO\n    return self\n}\n\n```\n\n方法有点土，但是有效了，源代码文章后面会给地址。\n\n\n### 迁移AutoLayoutConstrains\n\n由于IB在加载AutoLayoutConstrains时的顺序是**先加载子View内部的约束，后加载父View上的约束**，而我们替换placeholder的时机是：\n  1. placehodler view被创建（只带width，height的自身约束）\n  2. 真正的view被从xib动态加载（带其子view的所有约束）\n  3. **_placeholder被替换成真的view_**\n  4. placeholder view在其父View（一直到父父父...View）的约束被创建\n\n\n所以说，迁移AutoLayout时，`只需要把placeholder view的自身约束copy到真实View上就好了`（停顿10s感受下）  \n代码如下：  \n\n``` objc\n- (void)replaceAutolayoutConstrainsFromView:(UIView *)placeholderView toView:(UIView *)realView\n{\n    for (NSLayoutConstraint *constraint in placeholderView.constraints) {\n        NSLayoutConstraint* newConstraint  = [NSLayoutConstraint constraintWithItem:realView\n                                                     attribute:constraint.firstAttribute\n                                                     relatedBy:constraint.relation\n                                                        toItem:nil // Only first item\n                                                     attribute:constraint.secondAttribute\n                                                    multiplier:constraint.multiplier\n                                                      constant:constraint.constant];\n        newConstraint.shouldBeArchived = constraint.shouldBeArchived;\n        newConstraint.priority = constraint.priority;\n        [realView addConstraint:newConstraint];\n    }\n}\n```\n\nOne more thing，保证AutoLayout生效还要加上下面这句话：\n\n``` objc\nrealView.translatesAutoresizingMaskIntoConstraints = NO;\n```\n\n-----\n\n# 开源项目XXNibBridge\n\n光说方案不给源码还是不地道的，demo放到了[我的github上面的XXNibBridge项目](https://github.com/sunnyxx/XXNibBridge)，回顾一下上面的关系图：\n\n<img src=\"http://ww2.sinaimg.cn/large/51530583gw1ehzgklik42j20m80go0ua.jpg\" width=\"400\">  \n\n不得不提到`IB命名约定`的最佳实践方案：\n\n**将类名作为Cell或者VC的Reusable Identifier**\n设`ReuseIdentifier`一直比较蛋疼，我一般将Cell的`类名`作为`ReuseIdentifier`（当然，大多数情况我们都会子类化Cell的），写法如：  \n\n``` objc\n[self.tableView registerClass:[XXSarkCell class] forCellReuseIdentifier:NSStringFromClass([XXSarkCell class])];\n```\n\n在`dequeueCell`的时候同理，这样的好处在于省去了起名的恶心、通过ReuseId可以直接找到Cell类、同时重构Cell类名时ReuseId也不用去再改。\n\n**View的xib与View的类名同名** 同理   \n\n实现了桥接Xib的功能的同时，也简单实现了这个命名约定：\n\n``` objc\n// XXNibBridge.h\n+ (NSString *)xx_nibID; // 类名\n+ (UINib *)xx_nib; // 返回类名对应nib\n+ (id)xx_loadFromNib; // 对应nib的类对象\n+ (id/*UIViewController*/)xx_loadFromStoryboardNamed:(NSString *)name; // 返回类名对应的vc\n```\n\n所以之后的代码可以这么写:  \n\n``` objc\n[tableView registerNib:[XXSarkView xx_nib] forCellReuseIdentifier:[XXSarkView xx_nibID]];\n```\n\n# XXNibBridge的使用\n\n**Cocoapods安装**\n\n``` objc\npod 'XXNibBridge', :git => 'https://github.com/sunnyxx/XXNibBridge.git'\n```\n\n对于要支持Bridge的类，重载下面的方法：\n\n``` objc\n#import \"XXNibBridge.h\"\n@implementation XXDogeView\n+ (BOOL)xx_shouldApplyNibBridging\n{\n    return YES;\n}\n@end\n```\n\n在父的Xib或Storyboard中拖个UIView进来作为Placeholder，设置为真实Nib的类\n\n<img src=\"http://ww1.sinaimg.cn/large/51530583gw1ei03b0vuzmj20z40a6q4e.jpg\" width=\"500\">  \n\n保证真实Nib的类名和Nib名相同，记得在Nib中设好Class\n<img src=\"http://ww3.sinaimg.cn/large/51530583gw1ei03dn8rq8j206g036q2z.jpg\" width=\"200\">\n\n**Done.**\n<img src=\"http://ww4.sinaimg.cn/large/51530583gw1ei03g01mmej20ga07sjrt.jpg\" width=\"400\">\n\n-----\n\n# References\n\nhttp://blog.yangmeyer.de/blog/2012/07/09/an-update-on-nested-nib-loading\nhttp://stackoverflow.com/questions/19816703/replacing-nsview-while-keeping-autolayout-constraints\nhttp://clang-analyzer.llvm.org/annotations.html#attr_ns_consumes_self\n","slug":"ios_ib_bridge","published":1,"updated":"2016-03-27T08:17:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxkw000yev128f3utq3x","content":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>个人很主张使用<code>Interface Builder</code>(以下都简称<code>IB</code>)来构建程序UI，包括<code>storyboard</code>和<code>xib</code>，相比代码更可视和易于修改，尤其在使用AutoLayout的时候，一目了然。<br>但用了这么久IB之后发现一个很大的槽点，就是IB间很难<code>嵌套混用</code>，比如一个xib中的view是另一个xib的子view，或者一个storyboard中两个vc都用到了一个xib构建的view等。解决方法一般是代码手动拼接，这就造成了比较混乱的情况。  </p>\n<p><strong>本文将尝试解决这个问题，实现xib的<code>动态桥接</code>，并提供一个支持<code>cocoapods</code>的开源工具类供方便使用。</strong></p>\n<h2 id=\"一张图顶十句话：\"><a href=\"#一张图顶十句话：\" class=\"headerlink\" title=\"一张图顶十句话：\"></a>一张图顶十句话：</h2><p><img src=\"http://ww2.sinaimg.cn/large/51530583gw1ehzgklik42j20m80go0ua.jpg\" width=\"500\" align=\"middle\">  </p>\n<h2 id=\"实现效果：\"><a href=\"#实现效果：\" class=\"headerlink\" title=\"实现效果：\"></a>实现效果：</h2><p><img src=\"http://ww3.sinaimg.cn/large/51530583gw1ehzgoiqfkfj20hs0qo75u.jpg\" width=\"300\" align=\"middle\"></p>\n<hr>\n<h1 id=\"黑魔法方法\"><a href=\"#黑魔法方法\" class=\"headerlink\" title=\"黑魔法方法\"></a>黑魔法方法</h1><p>实现这个功能的关键在于：在ib加载的某个时刻将<code>placeholder</code>的view动态替换成从xib加载的view，下面的方法就可以做到：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)awakeAfterUsingCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder <span class=\"built_in\">NS_REPLACES_RECEIVER</span>;</span><br></pre></td></tr></table></figure>\n<p>这个方法很少用到，在<code>NSObject (NSCoderMethods)</code>中定义，由<code>NSCoder</code>在decode过程中调用（于<code>-initWithCoder:</code>之后），所以说就算从文件里decode出来的对象也会走这个方法。<br>方法后面有<code>NS_REPLACES_RECEIVER</code>这个宏：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define NS_REPLACES_RECEIVER __attribute__((ns_consumes_self)) NS_RETURNS_RETAINED</span></span><br></pre></td></tr></table></figure>\n<p>在clang的文档中可以找到对这个<a href=\"http://clang-analyzer.llvm.org/annotations.html#attr_ns_consumes_self\" target=\"_blank\" rel=\"external\">编译器属性的介绍</a>  </p>\n<blockquote>\n<p>One use of this attribute is declare your own init-like methods that do not follow the standard Cocoa naming conventions.</p>\n</blockquote>\n<p>所以这个宏主要为了给编译器标识出这个方法可以像<code>self = [super init]</code>一样使用，并作出合理的内存管理。<br>So，这个方法提供了一个机会，<strong>可以将decode出来的对象替换成另一个对象</strong></p>\n<p><strong>动态桥接流程</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)awakeAfterUsingCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> awakeAfterUsingCoder:aDecoder];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 0. 判断是否要进行替换</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 根据self.class从xib创建真正的view</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 将placeholder的属性、autolayout等替换到真正的view上</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. return 真正的view</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>流程不难理解，就是有2个小难点：</p>\n<ul>\n<li>步骤1从xib创建真正的view时也会调用这个方法，会造成<code>递归</code>，如何判断</li>\n<li>迁移<code>AutoLayoutConstrains</code></li>\n</ul>\n<h3 id=\"解决递归问题\"><a href=\"#解决递归问题\" class=\"headerlink\" title=\"解决递归问题\"></a>解决递归问题</h3><p>这个topic全网可能就<a href=\"http://blog.yangmeyer.de/blog/2012/07/09/an-update-on-nested-nib-loading\" target=\"_blank\" rel=\"external\">《这篇文章》</a>有写，本文也是从它发起的，但是发现它的方法并不能解决所有问题（尤其是用storyboard加载xib时），所以换了个思路，采取了设置标志位的方式避免递归调用：   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)awakeAfterUsingCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> awakeAfterUsingCoder:aDecoder];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (这个类的Loading标志位 -&gt; <span class=\"literal\">NO</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Loading标志位 -&gt; <span class=\"literal\">YES</span></span><br><span class=\"line\">        从xib加载真实的View (这里会递归调用这个函数)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> 真实View</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Loading标志位 -&gt; <span class=\"literal\">NO</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法有点土，但是有效了，源代码文章后面会给地址。</p>\n<h3 id=\"迁移AutoLayoutConstrains\"><a href=\"#迁移AutoLayoutConstrains\" class=\"headerlink\" title=\"迁移AutoLayoutConstrains\"></a>迁移AutoLayoutConstrains</h3><p>由于IB在加载AutoLayoutConstrains时的顺序是<strong>先加载子View内部的约束，后加载父View上的约束</strong>，而我们替换placeholder的时机是：</p>\n<ol>\n<li>placehodler view被创建（只带width，height的自身约束）</li>\n<li>真正的view被从xib动态加载（带其子view的所有约束）</li>\n<li><strong><em>placeholder被替换成真的view</em></strong></li>\n<li>placeholder view在其父View（一直到父父父…View）的约束被创建</li>\n</ol>\n<p>所以说，迁移AutoLayout时，<code>只需要把placeholder view的自身约束copy到真实View上就好了</code>（停顿10s感受下）<br>代码如下：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)replaceAutolayoutConstrainsFromView:(<span class=\"built_in\">UIView</span> *)placeholderView toView:(<span class=\"built_in\">UIView</span> *)realView</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSLayoutConstraint</span> *constraint <span class=\"keyword\">in</span> placeholderView.constraints) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLayoutConstraint</span>* newConstraint  = [<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:realView</span><br><span class=\"line\">                                                     attribute:constraint.firstAttribute</span><br><span class=\"line\">                                                     relatedBy:constraint.relation</span><br><span class=\"line\">                                                        toItem:<span class=\"literal\">nil</span> <span class=\"comment\">// Only first item</span></span><br><span class=\"line\">                                                     attribute:constraint.secondAttribute</span><br><span class=\"line\">                                                    multiplier:constraint.multiplier</span><br><span class=\"line\">                                                      constant:constraint.constant];</span><br><span class=\"line\">        newConstraint.shouldBeArchived = constraint.shouldBeArchived;</span><br><span class=\"line\">        newConstraint.priority = constraint.priority;</span><br><span class=\"line\">        [realView addConstraint:newConstraint];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>One more thing，保证AutoLayout生效还要加上下面这句话：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">realView.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"开源项目XXNibBridge\"><a href=\"#开源项目XXNibBridge\" class=\"headerlink\" title=\"开源项目XXNibBridge\"></a>开源项目XXNibBridge</h1><p>光说方案不给源码还是不地道的，demo放到了<a href=\"https://github.com/sunnyxx/XXNibBridge\" target=\"_blank\" rel=\"external\">我的github上面的XXNibBridge项目</a>，回顾一下上面的关系图：</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/51530583gw1ehzgklik42j20m80go0ua.jpg\" width=\"400\">  </p>\n<p>不得不提到<code>IB命名约定</code>的最佳实践方案：</p>\n<p><strong>将类名作为Cell或者VC的Reusable Identifier</strong><br>设<code>ReuseIdentifier</code>一直比较蛋疼，我一般将Cell的<code>类名</code>作为<code>ReuseIdentifier</code>（当然，大多数情况我们都会子类化Cell的），写法如：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span>.tableView registerClass:[XXSarkCell class] forCellReuseIdentifier:<span class=\"built_in\">NSStringFromClass</span>([XXSarkCell class])];</span><br></pre></td></tr></table></figure>\n<p>在<code>dequeueCell</code>的时候同理，这样的好处在于省去了起名的恶心、通过ReuseId可以直接找到Cell类、同时重构Cell类名时ReuseId也不用去再改。</p>\n<p><strong>View的xib与View的类名同名</strong> 同理   </p>\n<p>实现了桥接Xib的功能的同时，也简单实现了这个命名约定：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// XXNibBridge.h</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSString</span> *)xx_nibID; <span class=\"comment\">// 类名</span></span><br><span class=\"line\">+ (<span class=\"built_in\">UINib</span> *)xx_nib; <span class=\"comment\">// 返回类名对应nib</span></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)xx_loadFromNib; <span class=\"comment\">// 对应nib的类对象</span></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span><span class=\"comment\">/*UIViewController*/</span>)xx_loadFromStoryboardNamed:(<span class=\"built_in\">NSString</span> *)name; <span class=\"comment\">// 返回类名对应的vc</span></span><br></pre></td></tr></table></figure>\n<p>所以之后的代码可以这么写:  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[tableView registerNib:[XXSarkView xx_nib] forCellReuseIdentifier:[XXSarkView xx_nibID]];</span><br></pre></td></tr></table></figure>\n<h1 id=\"XXNibBridge的使用\"><a href=\"#XXNibBridge的使用\" class=\"headerlink\" title=\"XXNibBridge的使用\"></a>XXNibBridge的使用</h1><p><strong>Cocoapods安装</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod 'XXNibBridge', :git =&gt; 'https://github.com/sunnyxx/XXNibBridge.git'</span><br></pre></td></tr></table></figure>\n<p>对于要支持Bridge的类，重载下面的方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"XXNibBridge.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">XXDogeView</span></span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)xx_shouldApplyNibBridging</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>在父的Xib或Storyboard中拖个UIView进来作为Placeholder，设置为真实Nib的类</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/51530583gw1ei03b0vuzmj20z40a6q4e.jpg\" width=\"500\">  </p>\n<p>保证真实Nib的类名和Nib名相同，记得在Nib中设好Class<br><img src=\"http://ww3.sinaimg.cn/large/51530583gw1ei03dn8rq8j206g036q2z.jpg\" width=\"200\"></p>\n<p><strong>Done.</strong><br><img src=\"http://ww4.sinaimg.cn/large/51530583gw1ei03g01mmej20ga07sjrt.jpg\" width=\"400\"></p>\n<hr>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"http://blog.yangmeyer.de/blog/2012/07/09/an-update-on-nested-nib-loading\" target=\"_blank\" rel=\"external\">http://blog.yangmeyer.de/blog/2012/07/09/an-update-on-nested-nib-loading</a><br><a href=\"http://stackoverflow.com/questions/19816703/replacing-nsview-while-keeping-autolayout-constraints\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/19816703/replacing-nsview-while-keeping-autolayout-constraints</a><br><a href=\"http://clang-analyzer.llvm.org/annotations.html#attr_ns_consumes_self\" target=\"_blank\" rel=\"external\">http://clang-analyzer.llvm.org/annotations.html#attr_ns_consumes_self</a></p>\n","excerpt":"","more":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>个人很主张使用<code>Interface Builder</code>(以下都简称<code>IB</code>)来构建程序UI，包括<code>storyboard</code>和<code>xib</code>，相比代码更可视和易于修改，尤其在使用AutoLayout的时候，一目了然。<br>但用了这么久IB之后发现一个很大的槽点，就是IB间很难<code>嵌套混用</code>，比如一个xib中的view是另一个xib的子view，或者一个storyboard中两个vc都用到了一个xib构建的view等。解决方法一般是代码手动拼接，这就造成了比较混乱的情况。  </p>\n<p><strong>本文将尝试解决这个问题，实现xib的<code>动态桥接</code>，并提供一个支持<code>cocoapods</code>的开源工具类供方便使用。</strong></p>\n<h2 id=\"一张图顶十句话：\"><a href=\"#一张图顶十句话：\" class=\"headerlink\" title=\"一张图顶十句话：\"></a>一张图顶十句话：</h2><p><img src=\"http://ww2.sinaimg.cn/large/51530583gw1ehzgklik42j20m80go0ua.jpg\" width=\"500\" align=\"middle\">  </p>\n<h2 id=\"实现效果：\"><a href=\"#实现效果：\" class=\"headerlink\" title=\"实现效果：\"></a>实现效果：</h2><p><img src=\"http://ww3.sinaimg.cn/large/51530583gw1ehzgoiqfkfj20hs0qo75u.jpg\" width=\"300\" align=\"middle\"></p>\n<hr>\n<h1 id=\"黑魔法方法\"><a href=\"#黑魔法方法\" class=\"headerlink\" title=\"黑魔法方法\"></a>黑魔法方法</h1><p>实现这个功能的关键在于：在ib加载的某个时刻将<code>placeholder</code>的view动态替换成从xib加载的view，下面的方法就可以做到：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)awakeAfterUsingCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder <span class=\"built_in\">NS_REPLACES_RECEIVER</span>;</span><br></pre></td></tr></table></figure>\n<p>这个方法很少用到，在<code>NSObject (NSCoderMethods)</code>中定义，由<code>NSCoder</code>在decode过程中调用（于<code>-initWithCoder:</code>之后），所以说就算从文件里decode出来的对象也会走这个方法。<br>方法后面有<code>NS_REPLACES_RECEIVER</code>这个宏：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define NS_REPLACES_RECEIVER __attribute__((ns_consumes_self)) NS_RETURNS_RETAINED</span></span><br></pre></td></tr></table></figure>\n<p>在clang的文档中可以找到对这个<a href=\"http://clang-analyzer.llvm.org/annotations.html#attr_ns_consumes_self\">编译器属性的介绍</a>  </p>\n<blockquote>\n<p>One use of this attribute is declare your own init-like methods that do not follow the standard Cocoa naming conventions.</p>\n</blockquote>\n<p>所以这个宏主要为了给编译器标识出这个方法可以像<code>self = [super init]</code>一样使用，并作出合理的内存管理。<br>So，这个方法提供了一个机会，<strong>可以将decode出来的对象替换成另一个对象</strong></p>\n<p><strong>动态桥接流程</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)awakeAfterUsingCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> awakeAfterUsingCoder:aDecoder];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 0. 判断是否要进行替换</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 根据self.class从xib创建真正的view</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 将placeholder的属性、autolayout等替换到真正的view上</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. return 真正的view</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>流程不难理解，就是有2个小难点：</p>\n<ul>\n<li>步骤1从xib创建真正的view时也会调用这个方法，会造成<code>递归</code>，如何判断</li>\n<li>迁移<code>AutoLayoutConstrains</code></li>\n</ul>\n<h3 id=\"解决递归问题\"><a href=\"#解决递归问题\" class=\"headerlink\" title=\"解决递归问题\"></a>解决递归问题</h3><p>这个topic全网可能就<a href=\"http://blog.yangmeyer.de/blog/2012/07/09/an-update-on-nested-nib-loading\">《这篇文章》</a>有写，本文也是从它发起的，但是发现它的方法并不能解决所有问题（尤其是用storyboard加载xib时），所以换了个思路，采取了设置标志位的方式避免递归调用：   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)awakeAfterUsingCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> awakeAfterUsingCoder:aDecoder];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (这个类的Loading标志位 -&gt; <span class=\"literal\">NO</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Loading标志位 -&gt; <span class=\"literal\">YES</span></span><br><span class=\"line\">        从xib加载真实的View (这里会递归调用这个函数)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> 真实View</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Loading标志位 -&gt; <span class=\"literal\">NO</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法有点土，但是有效了，源代码文章后面会给地址。</p>\n<h3 id=\"迁移AutoLayoutConstrains\"><a href=\"#迁移AutoLayoutConstrains\" class=\"headerlink\" title=\"迁移AutoLayoutConstrains\"></a>迁移AutoLayoutConstrains</h3><p>由于IB在加载AutoLayoutConstrains时的顺序是<strong>先加载子View内部的约束，后加载父View上的约束</strong>，而我们替换placeholder的时机是：</p>\n<ol>\n<li>placehodler view被创建（只带width，height的自身约束）</li>\n<li>真正的view被从xib动态加载（带其子view的所有约束）</li>\n<li><strong><em>placeholder被替换成真的view</em></strong></li>\n<li>placeholder view在其父View（一直到父父父…View）的约束被创建</li>\n</ol>\n<p>所以说，迁移AutoLayout时，<code>只需要把placeholder view的自身约束copy到真实View上就好了</code>（停顿10s感受下）<br>代码如下：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)replaceAutolayoutConstrainsFromView:(<span class=\"built_in\">UIView</span> *)placeholderView toView:(<span class=\"built_in\">UIView</span> *)realView</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSLayoutConstraint</span> *constraint <span class=\"keyword\">in</span> placeholderView.constraints) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLayoutConstraint</span>* newConstraint  = [<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:realView</span><br><span class=\"line\">                                                     attribute:constraint.firstAttribute</span><br><span class=\"line\">                                                     relatedBy:constraint.relation</span><br><span class=\"line\">                                                        toItem:<span class=\"literal\">nil</span> <span class=\"comment\">// Only first item</span></span><br><span class=\"line\">                                                     attribute:constraint.secondAttribute</span><br><span class=\"line\">                                                    multiplier:constraint.multiplier</span><br><span class=\"line\">                                                      constant:constraint.constant];</span><br><span class=\"line\">        newConstraint.shouldBeArchived = constraint.shouldBeArchived;</span><br><span class=\"line\">        newConstraint.priority = constraint.priority;</span><br><span class=\"line\">        [realView addConstraint:newConstraint];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>One more thing，保证AutoLayout生效还要加上下面这句话：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">realView.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"开源项目XXNibBridge\"><a href=\"#开源项目XXNibBridge\" class=\"headerlink\" title=\"开源项目XXNibBridge\"></a>开源项目XXNibBridge</h1><p>光说方案不给源码还是不地道的，demo放到了<a href=\"https://github.com/sunnyxx/XXNibBridge\">我的github上面的XXNibBridge项目</a>，回顾一下上面的关系图：</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/51530583gw1ehzgklik42j20m80go0ua.jpg\" width=\"400\">  </p>\n<p>不得不提到<code>IB命名约定</code>的最佳实践方案：</p>\n<p><strong>将类名作为Cell或者VC的Reusable Identifier</strong><br>设<code>ReuseIdentifier</code>一直比较蛋疼，我一般将Cell的<code>类名</code>作为<code>ReuseIdentifier</code>（当然，大多数情况我们都会子类化Cell的），写法如：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span>.tableView registerClass:[XXSarkCell class] forCellReuseIdentifier:<span class=\"built_in\">NSStringFromClass</span>([XXSarkCell class])];</span><br></pre></td></tr></table></figure>\n<p>在<code>dequeueCell</code>的时候同理，这样的好处在于省去了起名的恶心、通过ReuseId可以直接找到Cell类、同时重构Cell类名时ReuseId也不用去再改。</p>\n<p><strong>View的xib与View的类名同名</strong> 同理   </p>\n<p>实现了桥接Xib的功能的同时，也简单实现了这个命名约定：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// XXNibBridge.h</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSString</span> *)xx_nibID; <span class=\"comment\">// 类名</span></span><br><span class=\"line\">+ (<span class=\"built_in\">UINib</span> *)xx_nib; <span class=\"comment\">// 返回类名对应nib</span></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)xx_loadFromNib; <span class=\"comment\">// 对应nib的类对象</span></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span><span class=\"comment\">/*UIViewController*/</span>)xx_loadFromStoryboardNamed:(<span class=\"built_in\">NSString</span> *)name; <span class=\"comment\">// 返回类名对应的vc</span></span><br></pre></td></tr></table></figure>\n<p>所以之后的代码可以这么写:  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[tableView registerNib:[XXSarkView xx_nib] forCellReuseIdentifier:[XXSarkView xx_nibID]];</span><br></pre></td></tr></table></figure>\n<h1 id=\"XXNibBridge的使用\"><a href=\"#XXNibBridge的使用\" class=\"headerlink\" title=\"XXNibBridge的使用\"></a>XXNibBridge的使用</h1><p><strong>Cocoapods安装</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod 'XXNibBridge', :git =&gt; 'https://github.com/sunnyxx/XXNibBridge.git'</span><br></pre></td></tr></table></figure>\n<p>对于要支持Bridge的类，重载下面的方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"XXNibBridge.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">XXDogeView</span></span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)xx_shouldApplyNibBridging</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>在父的Xib或Storyboard中拖个UIView进来作为Placeholder，设置为真实Nib的类</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/51530583gw1ei03b0vuzmj20z40a6q4e.jpg\" width=\"500\">  </p>\n<p>保证真实Nib的类名和Nib名相同，记得在Nib中设好Class<br><img src=\"http://ww3.sinaimg.cn/large/51530583gw1ei03dn8rq8j206g036q2z.jpg\" width=\"200\"></p>\n<p><strong>Done.</strong><br><img src=\"http://ww4.sinaimg.cn/large/51530583gw1ei03g01mmej20ga07sjrt.jpg\" width=\"400\"></p>\n<hr>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"http://blog.yangmeyer.de/blog/2012/07/09/an-update-on-nested-nib-loading\">http://blog.yangmeyer.de/blog/2012/07/09/an-update-on-nested-nib-loading</a><br><a href=\"http://stackoverflow.com/questions/19816703/replacing-nsview-while-keeping-autolayout-constraints\">http://stackoverflow.com/questions/19816703/replacing-nsview-while-keeping-autolayout-constraints</a><br><a href=\"http://clang-analyzer.llvm.org/annotations.html#attr_ns_consumes_self\">http://clang-analyzer.llvm.org/annotations.html#attr_ns_consumes_self</a></p>\n"},{"title":"ios中集合遍历方法的比较和技巧","date":"2014-04-30T02:02:29.000Z","_content":"\n# 我是前言\n\n集合的遍历操作是开发中最常见的操作之一，从C语言经典的for循环到利用多核cpu的优势进行遍历，开发中ios有若干集合遍历方法，本文通过研究和测试比较了各个操作方法的效率和优略势，并总结几个使用集合遍历时的小技巧。\n\n------\n\n# ios中常用的遍历运算方法\n\n遍历的目的是获取集合中的某个对象或执行某个操作，所以能满足这个条件的方法都可以作为备选：  \n\n- 经典for循环\n- for in (NSFastEnumeration)，若不熟悉可以参考[《nshipster介绍NSFastEnumeration的文章》](http://nshipster.com/enumerators/)\n- makeObjectsPerformSelector\n- kvc集合运算符\n- enumerateObjectsUsingBlock\n- enumerateObjectsWithOptions(NSEnumerationConcurrent)\n- dispatch_apply\n\n------\n\n# 实验\n\n## 实验条件\n\n测试类如下：  \n\n``` objc\n@interface Sark : NSObject\n@property (nonatomic) NSInteger number;\n- (void)doSomethingSlow; // sleep(0.01)\n@end\n```\n\n实验从两个方面来评价：  \n\n1. 分别使用有 100 个对象和 1000000 个对象的 NSArray，只取对象，不执行操作，测试遍历速度  \n2. 使用有 100 个对象的 NSArray 遍历执行`doSomethingSlow`方法，测试遍历中多任务运行速度\n\n实验使用`CFAbsoluteTimeGetCurrent()`记录时间戳来计算运行时间，单位秒。  \n运行在 iPhone5 真机（双核cpu）  \n\n## 实验数据\n\n100对象遍历操作：  \n\n``` objc\n经典for循环 - 0.001355\nfor in (NSFastEnumeration) - 0.002308\nmakeObjectsPerformSelector - 0.001120\nkvc集合运算符(@sum.number) - 0.004272\nenumerateObjectsUsingBlock - 0.001145\nenumerateObjectsWithOptions(NSEnumerationConcurrent) - 0.001605\ndispatch_apply(Concurrent) - 0.001380\n```\n\n1000000对象遍历操作：  \n\n``` objc\n经典for循环 - 1.246721\nfor in (NSFastEnumeration) - 0.025955\nmakeObjectsPerformSelector - 0.068234\nkvc集合运算符(@sum.number) - 21.677246\nenumerateObjectsUsingBlock - 0.586034\nenumerateObjectsWithOptions(NSEnumerationConcurrent) - 0.722548\ndispatch_apply(Concurrent) - 0.607100\n```\n\n100对象遍历执行一个很费时的操作：  \n\n``` objc\n经典for循环 - 1.106567\nfor in (NSFastEnumeration) - 1.102643\nmakeObjectsPerformSelector - 1.103965\nkvc集合运算符(@sum.number) - N/A\nenumerateObjectsUsingBlock - 1.104888\nenumerateObjectsWithOptions(NSEnumerationConcurrent) - 0.554670\ndispatch_apply(Concurrent) - 0.554858\n```\n\n-----\n\n## 值得注意的\n\n- 对于集合中对象数很多的情况下，`for in (NSFastEnumeration)`的遍历速度非常之快，但小规模的遍历并不明显（还没普通for循环快）\n- 使用`kvc集合运算符`运算很大规模的集合时，效率明显下降（100万的数组离谱的21秒多），同时占用了大量内存和cpu\n- `enumerateObjectsWithOptions(NSEnumerationConcurrent)`和`dispatch_apply(Concurrent)`的遍历执行可以利用到多核cpu的优势（实验中在双核cpu上效率基本上x2）\n\n------\n\n\n# 遍历实践Tips\n## 倒序遍历\n`NSArray`和`NSOrderedSet`都支持使用`reverseObjectEnumerator`倒序遍历，如：  \n\n``` objc\nNSArray *strings = @[@\"1\", @\"2\", @\"3\"];\nfor (NSString *string in [strings reverseObjectEnumerator]) {\n    NSLog(@\"%@\", string);\n}\n```\n\n这个方法只在循环第一次被调用，所以也不必担心循环每次计算的问题。  \n\n同时，使用`enumerateObjectsWithOptions:NSEnumerationReverse`也可以实现倒序遍历：   \n\n``` objc\n[array enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(Sark *sark, NSUInteger idx, BOOL *stop) {\n    [sark doSomething];\n}];\n```\n\n## 使用block同时遍历字典key，value\n\nblock版本的字典遍历可以同时取key和value（forin只能取key再手动取value），如：  \n\n``` objc\nNSDictionary *dict = @{@\"a\": @\"1\", @\"b\": @\"2\"};\n[dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {\n    NSLog(@\"key: %@, value: %@\", key, obj);\n}];\n```\n\n## 对于耗时且顺序无关的遍历，使用并发版本\n\n``` objc\n[array enumerateObjectsWithOptions:NSEnumerationConcurrent usingBlock:^(Sark *sark, NSUInteger idx, BOOL *stop) {\n    [sark doSomethingSlow];\n}];\n```\n\n遍历执行block会分配在多核cpu上执行（底层很可能就是gcd的并发queue），对于耗时的任务来说是很值得这么做的，而且在以后cpu升级成更多核心后不用改代码也可以享受带来的好处。同时，对于遍历的外部是保持同步的（遍历都完成后才继续执行下一行），猜想内部大概是gcd的dispatch_group或者信号量控制。\n\n## 代码可读性和效率的权衡\n\n虽然说上面的测试结果表明，在集合内元素不多时，经典for循环的效率要比forin要高，但是从代码可读性上来看，就远不如forin看着更顺畅；同样的还有kvc的集合运算符，一些内置的操作以`keypath`的方式声明，相比自己用for循环实现，一行代码就能搞定，清楚明了，还省去了重复工作；在framework中增加了集合遍历的block支持后，对于需要index的遍历再也不需要经典for循环的写法了。\n\n------\n\n\n# References\nhttp://nshipster.com/enumerators/   \nhttp://iosdevelopertips.com/objective-c/fast-enumeration-on-the-iphone.html   \n\n-----\n\n原创文章，转载请注明源地址，[blog.sunnyxx.com](http://blog.sunnyxx.com)\n","source":"_posts/ios_iterator.md","raw":"title: ios中集合遍历方法的比较和技巧   \ndate: 2014-04-30 10:02:29\ntags: ios最佳实践\n---\n\n# 我是前言\n\n集合的遍历操作是开发中最常见的操作之一，从C语言经典的for循环到利用多核cpu的优势进行遍历，开发中ios有若干集合遍历方法，本文通过研究和测试比较了各个操作方法的效率和优略势，并总结几个使用集合遍历时的小技巧。\n\n------\n\n# ios中常用的遍历运算方法\n\n遍历的目的是获取集合中的某个对象或执行某个操作，所以能满足这个条件的方法都可以作为备选：  \n\n- 经典for循环\n- for in (NSFastEnumeration)，若不熟悉可以参考[《nshipster介绍NSFastEnumeration的文章》](http://nshipster.com/enumerators/)\n- makeObjectsPerformSelector\n- kvc集合运算符\n- enumerateObjectsUsingBlock\n- enumerateObjectsWithOptions(NSEnumerationConcurrent)\n- dispatch_apply\n\n------\n\n# 实验\n\n## 实验条件\n\n测试类如下：  \n\n``` objc\n@interface Sark : NSObject\n@property (nonatomic) NSInteger number;\n- (void)doSomethingSlow; // sleep(0.01)\n@end\n```\n\n实验从两个方面来评价：  \n\n1. 分别使用有 100 个对象和 1000000 个对象的 NSArray，只取对象，不执行操作，测试遍历速度  \n2. 使用有 100 个对象的 NSArray 遍历执行`doSomethingSlow`方法，测试遍历中多任务运行速度\n\n实验使用`CFAbsoluteTimeGetCurrent()`记录时间戳来计算运行时间，单位秒。  \n运行在 iPhone5 真机（双核cpu）  \n\n## 实验数据\n\n100对象遍历操作：  \n\n``` objc\n经典for循环 - 0.001355\nfor in (NSFastEnumeration) - 0.002308\nmakeObjectsPerformSelector - 0.001120\nkvc集合运算符(@sum.number) - 0.004272\nenumerateObjectsUsingBlock - 0.001145\nenumerateObjectsWithOptions(NSEnumerationConcurrent) - 0.001605\ndispatch_apply(Concurrent) - 0.001380\n```\n\n1000000对象遍历操作：  \n\n``` objc\n经典for循环 - 1.246721\nfor in (NSFastEnumeration) - 0.025955\nmakeObjectsPerformSelector - 0.068234\nkvc集合运算符(@sum.number) - 21.677246\nenumerateObjectsUsingBlock - 0.586034\nenumerateObjectsWithOptions(NSEnumerationConcurrent) - 0.722548\ndispatch_apply(Concurrent) - 0.607100\n```\n\n100对象遍历执行一个很费时的操作：  \n\n``` objc\n经典for循环 - 1.106567\nfor in (NSFastEnumeration) - 1.102643\nmakeObjectsPerformSelector - 1.103965\nkvc集合运算符(@sum.number) - N/A\nenumerateObjectsUsingBlock - 1.104888\nenumerateObjectsWithOptions(NSEnumerationConcurrent) - 0.554670\ndispatch_apply(Concurrent) - 0.554858\n```\n\n-----\n\n## 值得注意的\n\n- 对于集合中对象数很多的情况下，`for in (NSFastEnumeration)`的遍历速度非常之快，但小规模的遍历并不明显（还没普通for循环快）\n- 使用`kvc集合运算符`运算很大规模的集合时，效率明显下降（100万的数组离谱的21秒多），同时占用了大量内存和cpu\n- `enumerateObjectsWithOptions(NSEnumerationConcurrent)`和`dispatch_apply(Concurrent)`的遍历执行可以利用到多核cpu的优势（实验中在双核cpu上效率基本上x2）\n\n------\n\n\n# 遍历实践Tips\n## 倒序遍历\n`NSArray`和`NSOrderedSet`都支持使用`reverseObjectEnumerator`倒序遍历，如：  \n\n``` objc\nNSArray *strings = @[@\"1\", @\"2\", @\"3\"];\nfor (NSString *string in [strings reverseObjectEnumerator]) {\n    NSLog(@\"%@\", string);\n}\n```\n\n这个方法只在循环第一次被调用，所以也不必担心循环每次计算的问题。  \n\n同时，使用`enumerateObjectsWithOptions:NSEnumerationReverse`也可以实现倒序遍历：   \n\n``` objc\n[array enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(Sark *sark, NSUInteger idx, BOOL *stop) {\n    [sark doSomething];\n}];\n```\n\n## 使用block同时遍历字典key，value\n\nblock版本的字典遍历可以同时取key和value（forin只能取key再手动取value），如：  \n\n``` objc\nNSDictionary *dict = @{@\"a\": @\"1\", @\"b\": @\"2\"};\n[dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {\n    NSLog(@\"key: %@, value: %@\", key, obj);\n}];\n```\n\n## 对于耗时且顺序无关的遍历，使用并发版本\n\n``` objc\n[array enumerateObjectsWithOptions:NSEnumerationConcurrent usingBlock:^(Sark *sark, NSUInteger idx, BOOL *stop) {\n    [sark doSomethingSlow];\n}];\n```\n\n遍历执行block会分配在多核cpu上执行（底层很可能就是gcd的并发queue），对于耗时的任务来说是很值得这么做的，而且在以后cpu升级成更多核心后不用改代码也可以享受带来的好处。同时，对于遍历的外部是保持同步的（遍历都完成后才继续执行下一行），猜想内部大概是gcd的dispatch_group或者信号量控制。\n\n## 代码可读性和效率的权衡\n\n虽然说上面的测试结果表明，在集合内元素不多时，经典for循环的效率要比forin要高，但是从代码可读性上来看，就远不如forin看着更顺畅；同样的还有kvc的集合运算符，一些内置的操作以`keypath`的方式声明，相比自己用for循环实现，一行代码就能搞定，清楚明了，还省去了重复工作；在framework中增加了集合遍历的block支持后，对于需要index的遍历再也不需要经典for循环的写法了。\n\n------\n\n\n# References\nhttp://nshipster.com/enumerators/   \nhttp://iosdevelopertips.com/objective-c/fast-enumeration-on-the-iphone.html   \n\n-----\n\n原创文章，转载请注明源地址，[blog.sunnyxx.com](http://blog.sunnyxx.com)\n","slug":"ios_iterator","published":1,"updated":"2016-03-27T08:31:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxl10010ev12viag5x5n","content":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>集合的遍历操作是开发中最常见的操作之一，从C语言经典的for循环到利用多核cpu的优势进行遍历，开发中ios有若干集合遍历方法，本文通过研究和测试比较了各个操作方法的效率和优略势，并总结几个使用集合遍历时的小技巧。</p>\n<hr>\n<h1 id=\"ios中常用的遍历运算方法\"><a href=\"#ios中常用的遍历运算方法\" class=\"headerlink\" title=\"ios中常用的遍历运算方法\"></a>ios中常用的遍历运算方法</h1><p>遍历的目的是获取集合中的某个对象或执行某个操作，所以能满足这个条件的方法都可以作为备选：  </p>\n<ul>\n<li>经典for循环</li>\n<li>for in (NSFastEnumeration)，若不熟悉可以参考<a href=\"http://nshipster.com/enumerators/\" target=\"_blank\" rel=\"external\">《nshipster介绍NSFastEnumeration的文章》</a></li>\n<li>makeObjectsPerformSelector</li>\n<li>kvc集合运算符</li>\n<li>enumerateObjectsUsingBlock</li>\n<li>enumerateObjectsWithOptions(NSEnumerationConcurrent)</li>\n<li>dispatch_apply</li>\n</ul>\n<hr>\n<h1 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h1><h2 id=\"实验条件\"><a href=\"#实验条件\" class=\"headerlink\" title=\"实验条件\"></a>实验条件</h2><p>测试类如下：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSInteger</span> number;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomethingSlow; <span class=\"comment\">// sleep(0.01)</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>实验从两个方面来评价：  </p>\n<ol>\n<li>分别使用有 100 个对象和 1000000 个对象的 NSArray，只取对象，不执行操作，测试遍历速度  </li>\n<li>使用有 100 个对象的 NSArray 遍历执行<code>doSomethingSlow</code>方法，测试遍历中多任务运行速度</li>\n</ol>\n<p>实验使用<code>CFAbsoluteTimeGetCurrent()</code>记录时间戳来计算运行时间，单位秒。<br>运行在 iPhone5 真机（双核cpu）  </p>\n<h2 id=\"实验数据\"><a href=\"#实验数据\" class=\"headerlink\" title=\"实验数据\"></a>实验数据</h2><p>100对象遍历操作：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">经典<span class=\"keyword\">for</span>循环 - <span class=\"number\">0.001355</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">in</span> (<span class=\"built_in\">NSFastEnumeration</span>) - <span class=\"number\">0.002308</span></span><br><span class=\"line\">makeObjectsPerformSelector - <span class=\"number\">0.001120</span></span><br><span class=\"line\">kvc集合运算符(@sum.number) - <span class=\"number\">0.004272</span></span><br><span class=\"line\">enumerateObjectsUsingBlock - <span class=\"number\">0.001145</span></span><br><span class=\"line\">enumerateObjectsWithOptions(<span class=\"built_in\">NSEnumerationConcurrent</span>) - <span class=\"number\">0.001605</span></span><br><span class=\"line\">dispatch_apply(Concurrent) - <span class=\"number\">0.001380</span></span><br></pre></td></tr></table></figure>\n<p>1000000对象遍历操作：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">经典<span class=\"keyword\">for</span>循环 - <span class=\"number\">1.246721</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">in</span> (<span class=\"built_in\">NSFastEnumeration</span>) - <span class=\"number\">0.025955</span></span><br><span class=\"line\">makeObjectsPerformSelector - <span class=\"number\">0.068234</span></span><br><span class=\"line\">kvc集合运算符(@sum.number) - <span class=\"number\">21.677246</span></span><br><span class=\"line\">enumerateObjectsUsingBlock - <span class=\"number\">0.586034</span></span><br><span class=\"line\">enumerateObjectsWithOptions(<span class=\"built_in\">NSEnumerationConcurrent</span>) - <span class=\"number\">0.722548</span></span><br><span class=\"line\">dispatch_apply(Concurrent) - <span class=\"number\">0.607100</span></span><br></pre></td></tr></table></figure>\n<p>100对象遍历执行一个很费时的操作：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">经典<span class=\"keyword\">for</span>循环 - <span class=\"number\">1.106567</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">in</span> (<span class=\"built_in\">NSFastEnumeration</span>) - <span class=\"number\">1.102643</span></span><br><span class=\"line\">makeObjectsPerformSelector - <span class=\"number\">1.103965</span></span><br><span class=\"line\">kvc集合运算符(@sum.number) - N/A</span><br><span class=\"line\">enumerateObjectsUsingBlock - <span class=\"number\">1.104888</span></span><br><span class=\"line\">enumerateObjectsWithOptions(<span class=\"built_in\">NSEnumerationConcurrent</span>) - <span class=\"number\">0.554670</span></span><br><span class=\"line\">dispatch_apply(Concurrent) - <span class=\"number\">0.554858</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"值得注意的\"><a href=\"#值得注意的\" class=\"headerlink\" title=\"值得注意的\"></a>值得注意的</h2><ul>\n<li>对于集合中对象数很多的情况下，<code>for in (NSFastEnumeration)</code>的遍历速度非常之快，但小规模的遍历并不明显（还没普通for循环快）</li>\n<li>使用<code>kvc集合运算符</code>运算很大规模的集合时，效率明显下降（100万的数组离谱的21秒多），同时占用了大量内存和cpu</li>\n<li><code>enumerateObjectsWithOptions(NSEnumerationConcurrent)</code>和<code>dispatch_apply(Concurrent)</code>的遍历执行可以利用到多核cpu的优势（实验中在双核cpu上效率基本上x2）</li>\n</ul>\n<hr>\n<h1 id=\"遍历实践Tips\"><a href=\"#遍历实践Tips\" class=\"headerlink\" title=\"遍历实践Tips\"></a>遍历实践Tips</h1><h2 id=\"倒序遍历\"><a href=\"#倒序遍历\" class=\"headerlink\" title=\"倒序遍历\"></a>倒序遍历</h2><p><code>NSArray</code>和<code>NSOrderedSet</code>都支持使用<code>reverseObjectEnumerator</code>倒序遍历，如：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *strings = @[<span class=\"string\">@\"1\"</span>, <span class=\"string\">@\"2\"</span>, <span class=\"string\">@\"3\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *string <span class=\"keyword\">in</span> [strings reverseObjectEnumerator]) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, string);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法只在循环第一次被调用，所以也不必担心循环每次计算的问题。  </p>\n<p>同时，使用<code>enumerateObjectsWithOptions:NSEnumerationReverse</code>也可以实现倒序遍历：   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[array enumerateObjectsWithOptions:<span class=\"built_in\">NSEnumerationReverse</span> usingBlock:^(Sark *sark, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> *stop) &#123;</span><br><span class=\"line\">    [sark doSomething];</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用block同时遍历字典key，value\"><a href=\"#使用block同时遍历字典key，value\" class=\"headerlink\" title=\"使用block同时遍历字典key，value\"></a>使用block同时遍历字典key，value</h2><p>block版本的字典遍历可以同时取key和value（forin只能取key再手动取value），如：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *dict = @&#123;<span class=\"string\">@\"a\"</span>: <span class=\"string\">@\"1\"</span>, <span class=\"string\">@\"b\"</span>: <span class=\"string\">@\"2\"</span>&#125;;</span><br><span class=\"line\">[dict enumerateKeysAndObjectsUsingBlock:^(<span class=\"keyword\">id</span> key, <span class=\"keyword\">id</span> obj, <span class=\"built_in\">BOOL</span> *stop) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"key: %@, value: %@\"</span>, key, obj);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"对于耗时且顺序无关的遍历，使用并发版本\"><a href=\"#对于耗时且顺序无关的遍历，使用并发版本\" class=\"headerlink\" title=\"对于耗时且顺序无关的遍历，使用并发版本\"></a>对于耗时且顺序无关的遍历，使用并发版本</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[array enumerateObjectsWithOptions:<span class=\"built_in\">NSEnumerationConcurrent</span> usingBlock:^(Sark *sark, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> *stop) &#123;</span><br><span class=\"line\">    [sark doSomethingSlow];</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>遍历执行block会分配在多核cpu上执行（底层很可能就是gcd的并发queue），对于耗时的任务来说是很值得这么做的，而且在以后cpu升级成更多核心后不用改代码也可以享受带来的好处。同时，对于遍历的外部是保持同步的（遍历都完成后才继续执行下一行），猜想内部大概是gcd的dispatch_group或者信号量控制。</p>\n<h2 id=\"代码可读性和效率的权衡\"><a href=\"#代码可读性和效率的权衡\" class=\"headerlink\" title=\"代码可读性和效率的权衡\"></a>代码可读性和效率的权衡</h2><p>虽然说上面的测试结果表明，在集合内元素不多时，经典for循环的效率要比forin要高，但是从代码可读性上来看，就远不如forin看着更顺畅；同样的还有kvc的集合运算符，一些内置的操作以<code>keypath</code>的方式声明，相比自己用for循环实现，一行代码就能搞定，清楚明了，还省去了重复工作；在framework中增加了集合遍历的block支持后，对于需要index的遍历再也不需要经典for循环的写法了。</p>\n<hr>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"http://nshipster.com/enumerators/\" target=\"_blank\" rel=\"external\">http://nshipster.com/enumerators/</a><br><a href=\"http://iosdevelopertips.com/objective-c/fast-enumeration-on-the-iphone.html\" target=\"_blank\" rel=\"external\">http://iosdevelopertips.com/objective-c/fast-enumeration-on-the-iphone.html</a>   </p>\n<hr>\n<p>原创文章，转载请注明源地址，<a href=\"http://blog.sunnyxx.com\">blog.sunnyxx.com</a></p>\n","excerpt":"","more":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>集合的遍历操作是开发中最常见的操作之一，从C语言经典的for循环到利用多核cpu的优势进行遍历，开发中ios有若干集合遍历方法，本文通过研究和测试比较了各个操作方法的效率和优略势，并总结几个使用集合遍历时的小技巧。</p>\n<hr>\n<h1 id=\"ios中常用的遍历运算方法\"><a href=\"#ios中常用的遍历运算方法\" class=\"headerlink\" title=\"ios中常用的遍历运算方法\"></a>ios中常用的遍历运算方法</h1><p>遍历的目的是获取集合中的某个对象或执行某个操作，所以能满足这个条件的方法都可以作为备选：  </p>\n<ul>\n<li>经典for循环</li>\n<li>for in (NSFastEnumeration)，若不熟悉可以参考<a href=\"http://nshipster.com/enumerators/\">《nshipster介绍NSFastEnumeration的文章》</a></li>\n<li>makeObjectsPerformSelector</li>\n<li>kvc集合运算符</li>\n<li>enumerateObjectsUsingBlock</li>\n<li>enumerateObjectsWithOptions(NSEnumerationConcurrent)</li>\n<li>dispatch_apply</li>\n</ul>\n<hr>\n<h1 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h1><h2 id=\"实验条件\"><a href=\"#实验条件\" class=\"headerlink\" title=\"实验条件\"></a>实验条件</h2><p>测试类如下：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSInteger</span> number;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomethingSlow; <span class=\"comment\">// sleep(0.01)</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>实验从两个方面来评价：  </p>\n<ol>\n<li>分别使用有 100 个对象和 1000000 个对象的 NSArray，只取对象，不执行操作，测试遍历速度  </li>\n<li>使用有 100 个对象的 NSArray 遍历执行<code>doSomethingSlow</code>方法，测试遍历中多任务运行速度</li>\n</ol>\n<p>实验使用<code>CFAbsoluteTimeGetCurrent()</code>记录时间戳来计算运行时间，单位秒。<br>运行在 iPhone5 真机（双核cpu）  </p>\n<h2 id=\"实验数据\"><a href=\"#实验数据\" class=\"headerlink\" title=\"实验数据\"></a>实验数据</h2><p>100对象遍历操作：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">经典<span class=\"keyword\">for</span>循环 - <span class=\"number\">0.001355</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">in</span> (<span class=\"built_in\">NSFastEnumeration</span>) - <span class=\"number\">0.002308</span></span><br><span class=\"line\">makeObjectsPerformSelector - <span class=\"number\">0.001120</span></span><br><span class=\"line\">kvc集合运算符(@sum.number) - <span class=\"number\">0.004272</span></span><br><span class=\"line\">enumerateObjectsUsingBlock - <span class=\"number\">0.001145</span></span><br><span class=\"line\">enumerateObjectsWithOptions(<span class=\"built_in\">NSEnumerationConcurrent</span>) - <span class=\"number\">0.001605</span></span><br><span class=\"line\">dispatch_apply(Concurrent) - <span class=\"number\">0.001380</span></span><br></pre></td></tr></table></figure>\n<p>1000000对象遍历操作：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">经典<span class=\"keyword\">for</span>循环 - <span class=\"number\">1.246721</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">in</span> (<span class=\"built_in\">NSFastEnumeration</span>) - <span class=\"number\">0.025955</span></span><br><span class=\"line\">makeObjectsPerformSelector - <span class=\"number\">0.068234</span></span><br><span class=\"line\">kvc集合运算符(@sum.number) - <span class=\"number\">21.677246</span></span><br><span class=\"line\">enumerateObjectsUsingBlock - <span class=\"number\">0.586034</span></span><br><span class=\"line\">enumerateObjectsWithOptions(<span class=\"built_in\">NSEnumerationConcurrent</span>) - <span class=\"number\">0.722548</span></span><br><span class=\"line\">dispatch_apply(Concurrent) - <span class=\"number\">0.607100</span></span><br></pre></td></tr></table></figure>\n<p>100对象遍历执行一个很费时的操作：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">经典<span class=\"keyword\">for</span>循环 - <span class=\"number\">1.106567</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">in</span> (<span class=\"built_in\">NSFastEnumeration</span>) - <span class=\"number\">1.102643</span></span><br><span class=\"line\">makeObjectsPerformSelector - <span class=\"number\">1.103965</span></span><br><span class=\"line\">kvc集合运算符(@sum.number) - N/A</span><br><span class=\"line\">enumerateObjectsUsingBlock - <span class=\"number\">1.104888</span></span><br><span class=\"line\">enumerateObjectsWithOptions(<span class=\"built_in\">NSEnumerationConcurrent</span>) - <span class=\"number\">0.554670</span></span><br><span class=\"line\">dispatch_apply(Concurrent) - <span class=\"number\">0.554858</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"值得注意的\"><a href=\"#值得注意的\" class=\"headerlink\" title=\"值得注意的\"></a>值得注意的</h2><ul>\n<li>对于集合中对象数很多的情况下，<code>for in (NSFastEnumeration)</code>的遍历速度非常之快，但小规模的遍历并不明显（还没普通for循环快）</li>\n<li>使用<code>kvc集合运算符</code>运算很大规模的集合时，效率明显下降（100万的数组离谱的21秒多），同时占用了大量内存和cpu</li>\n<li><code>enumerateObjectsWithOptions(NSEnumerationConcurrent)</code>和<code>dispatch_apply(Concurrent)</code>的遍历执行可以利用到多核cpu的优势（实验中在双核cpu上效率基本上x2）</li>\n</ul>\n<hr>\n<h1 id=\"遍历实践Tips\"><a href=\"#遍历实践Tips\" class=\"headerlink\" title=\"遍历实践Tips\"></a>遍历实践Tips</h1><h2 id=\"倒序遍历\"><a href=\"#倒序遍历\" class=\"headerlink\" title=\"倒序遍历\"></a>倒序遍历</h2><p><code>NSArray</code>和<code>NSOrderedSet</code>都支持使用<code>reverseObjectEnumerator</code>倒序遍历，如：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *strings = @[<span class=\"string\">@\"1\"</span>, <span class=\"string\">@\"2\"</span>, <span class=\"string\">@\"3\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *string <span class=\"keyword\">in</span> [strings reverseObjectEnumerator]) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, string);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法只在循环第一次被调用，所以也不必担心循环每次计算的问题。  </p>\n<p>同时，使用<code>enumerateObjectsWithOptions:NSEnumerationReverse</code>也可以实现倒序遍历：   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[array enumerateObjectsWithOptions:<span class=\"built_in\">NSEnumerationReverse</span> usingBlock:^(Sark *sark, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> *stop) &#123;</span><br><span class=\"line\">    [sark doSomething];</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用block同时遍历字典key，value\"><a href=\"#使用block同时遍历字典key，value\" class=\"headerlink\" title=\"使用block同时遍历字典key，value\"></a>使用block同时遍历字典key，value</h2><p>block版本的字典遍历可以同时取key和value（forin只能取key再手动取value），如：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *dict = @&#123;<span class=\"string\">@\"a\"</span>: <span class=\"string\">@\"1\"</span>, <span class=\"string\">@\"b\"</span>: <span class=\"string\">@\"2\"</span>&#125;;</span><br><span class=\"line\">[dict enumerateKeysAndObjectsUsingBlock:^(<span class=\"keyword\">id</span> key, <span class=\"keyword\">id</span> obj, <span class=\"built_in\">BOOL</span> *stop) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"key: %@, value: %@\"</span>, key, obj);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"对于耗时且顺序无关的遍历，使用并发版本\"><a href=\"#对于耗时且顺序无关的遍历，使用并发版本\" class=\"headerlink\" title=\"对于耗时且顺序无关的遍历，使用并发版本\"></a>对于耗时且顺序无关的遍历，使用并发版本</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[array enumerateObjectsWithOptions:<span class=\"built_in\">NSEnumerationConcurrent</span> usingBlock:^(Sark *sark, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> *stop) &#123;</span><br><span class=\"line\">    [sark doSomethingSlow];</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>遍历执行block会分配在多核cpu上执行（底层很可能就是gcd的并发queue），对于耗时的任务来说是很值得这么做的，而且在以后cpu升级成更多核心后不用改代码也可以享受带来的好处。同时，对于遍历的外部是保持同步的（遍历都完成后才继续执行下一行），猜想内部大概是gcd的dispatch_group或者信号量控制。</p>\n<h2 id=\"代码可读性和效率的权衡\"><a href=\"#代码可读性和效率的权衡\" class=\"headerlink\" title=\"代码可读性和效率的权衡\"></a>代码可读性和效率的权衡</h2><p>虽然说上面的测试结果表明，在集合内元素不多时，经典for循环的效率要比forin要高，但是从代码可读性上来看，就远不如forin看着更顺畅；同样的还有kvc的集合运算符，一些内置的操作以<code>keypath</code>的方式声明，相比自己用for循环实现，一行代码就能搞定，清楚明了，还省去了重复工作；在framework中增加了集合遍历的block支持后，对于需要index的遍历再也不需要经典for循环的写法了。</p>\n<hr>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"http://nshipster.com/enumerators/\">http://nshipster.com/enumerators/</a><br><a href=\"http://iosdevelopertips.com/objective-c/fast-enumeration-on-the-iphone.html\">http://iosdevelopertips.com/objective-c/fast-enumeration-on-the-iphone.html</a>   </p>\n<hr>\n<p>原创文章，转载请注明源地址，<a href=\"http://blog.sunnyxx.com\">blog.sunnyxx.com</a></p>\n"},{"title":"iPhone6分辨率与适配","date":"2014-09-10T11:43:05.000Z","_content":"\n# 分辨率和像素\n\n经新xcode6模拟器验证（分辨率为pt，像素为真实pixel）：\n\n0. iPhone5分辨率320x568，像素640x1136，@2x\n1. iPhone6分辨率375x667，像素750x1334，@2x\n2. iPhone6 Plus分辨率414x736，像素1242x2208，@3x，（注意，在这个分辨率下渲染后，图像等比降低pixel分辨率至1080p(1080x1920)）\n\n![](http://ww3.sinaimg.cn/mw690/51530583gw1ek7mqv36zxj20go099jrm.jpg)\n\nPaintCode做了[几个图讲解的非常明了](http://www.paintcodeapp.com/news/iphone-6-screens-demystified)\n\n# 自动适配\n\n不处理时自动等比拉伸，如果在老工程打印屏幕frame，依然是`320x568` \n对比自动适配的和完美适配的导航栏就能看出问题：\n\n![](http://ww1.sinaimg.cn/large/51530583gw1ek7mze3ckrj219y060glw.jpg)\n\n因为拉伸所以会有一些虚，导航栏明显比64要大，但相比3.5寸到4寸的留黑边还是好很多。\n如何关闭自动适配方案呢？这个还是老思路，换启动图：  \n\n![](http://ww4.sinaimg.cn/mw690/51530583gw1ek7n9aqlnsj20oc08maa9.jpg)\n\n除了换启动图外，不得不说的是，新Xcode中可以使用一个`xib`来设置启动图：\n\n![](http://ww2.sinaimg.cn/mw690/51530583gw1ek7nce5e1uj20pe07cgmj.jpg)\n\n不过这个xib不能关联任何的代码（不能自定义View的Class，不能IBOutlet，不能加Object），可以理解成这个xib就是一张截图，这个方案的好处在于可以使用到`Size Classes`来针对不同屏幕布局这个xib（感兴趣可以看[《Size Classes初探》](http://blog.sunnyxx.com/2014/09/09/ios8-size-classes/)）\n\n\n# 关于手动适配\n\n只要手动指定了启动图或者那个xib，屏幕分辨率就已经变成应有的大小了，老代码中所有关于写死frame值的代码通通倒霉，如果去手动适配就要全部适配，建议**在找到个可行方案前先不要做修改**，自动适配方案还算不影响使用。  \n\n面对4个分辨率的iPhone，建议使用`Auto Layout`布局 + `Image Assets`管理各个分辨率的图片 + `Interface Builder`（xib+storyboard）构建UI，`Size Classes`在低版本iOS系统的表现未知。想要这套手动适配方案，起码你的工程需要部署在iOS6+，还不用AutoLayout布局的会死的蛮惨。\n\n# 关于Xcode6\n\n1. 模拟器路径被换成了 `~/Library/Developer/CoreSimulator/Devices/`\n2. xcode6中已经找不到iOS6的模拟器了，是时候说服大家放弃iOS7-了\n3. ~~现在起提交App Store强制需要支持64位，是时候梳理一遍所有依赖的第三方lib，更新到64位~~\n\n\n---\n\nOne more thing...按这名命的规律...\n\n`iPhone6` -> `iPhone6+` -> `iPhone6++`? -> `iPhone6#`?\n\n","source":"_posts/iphone6-resolution.md","raw":"title: iPhone6分辨率与适配\ndate: 2014-09-10 19:43:05\ntags: iOS8\n---\n\n# 分辨率和像素\n\n经新xcode6模拟器验证（分辨率为pt，像素为真实pixel）：\n\n0. iPhone5分辨率320x568，像素640x1136，@2x\n1. iPhone6分辨率375x667，像素750x1334，@2x\n2. iPhone6 Plus分辨率414x736，像素1242x2208，@3x，（注意，在这个分辨率下渲染后，图像等比降低pixel分辨率至1080p(1080x1920)）\n\n![](http://ww3.sinaimg.cn/mw690/51530583gw1ek7mqv36zxj20go099jrm.jpg)\n\nPaintCode做了[几个图讲解的非常明了](http://www.paintcodeapp.com/news/iphone-6-screens-demystified)\n\n# 自动适配\n\n不处理时自动等比拉伸，如果在老工程打印屏幕frame，依然是`320x568` \n对比自动适配的和完美适配的导航栏就能看出问题：\n\n![](http://ww1.sinaimg.cn/large/51530583gw1ek7mze3ckrj219y060glw.jpg)\n\n因为拉伸所以会有一些虚，导航栏明显比64要大，但相比3.5寸到4寸的留黑边还是好很多。\n如何关闭自动适配方案呢？这个还是老思路，换启动图：  \n\n![](http://ww4.sinaimg.cn/mw690/51530583gw1ek7n9aqlnsj20oc08maa9.jpg)\n\n除了换启动图外，不得不说的是，新Xcode中可以使用一个`xib`来设置启动图：\n\n![](http://ww2.sinaimg.cn/mw690/51530583gw1ek7nce5e1uj20pe07cgmj.jpg)\n\n不过这个xib不能关联任何的代码（不能自定义View的Class，不能IBOutlet，不能加Object），可以理解成这个xib就是一张截图，这个方案的好处在于可以使用到`Size Classes`来针对不同屏幕布局这个xib（感兴趣可以看[《Size Classes初探》](http://blog.sunnyxx.com/2014/09/09/ios8-size-classes/)）\n\n\n# 关于手动适配\n\n只要手动指定了启动图或者那个xib，屏幕分辨率就已经变成应有的大小了，老代码中所有关于写死frame值的代码通通倒霉，如果去手动适配就要全部适配，建议**在找到个可行方案前先不要做修改**，自动适配方案还算不影响使用。  \n\n面对4个分辨率的iPhone，建议使用`Auto Layout`布局 + `Image Assets`管理各个分辨率的图片 + `Interface Builder`（xib+storyboard）构建UI，`Size Classes`在低版本iOS系统的表现未知。想要这套手动适配方案，起码你的工程需要部署在iOS6+，还不用AutoLayout布局的会死的蛮惨。\n\n# 关于Xcode6\n\n1. 模拟器路径被换成了 `~/Library/Developer/CoreSimulator/Devices/`\n2. xcode6中已经找不到iOS6的模拟器了，是时候说服大家放弃iOS7-了\n3. ~~现在起提交App Store强制需要支持64位，是时候梳理一遍所有依赖的第三方lib，更新到64位~~\n\n\n---\n\nOne more thing...按这名命的规律...\n\n`iPhone6` -> `iPhone6+` -> `iPhone6++`? -> `iPhone6#`?\n\n","slug":"iphone6-resolution","published":1,"updated":"2016-03-23T13:53:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxl50012ev12hrgazec6","content":"<h1 id=\"分辨率和像素\"><a href=\"#分辨率和像素\" class=\"headerlink\" title=\"分辨率和像素\"></a>分辨率和像素</h1><p>经新xcode6模拟器验证（分辨率为pt，像素为真实pixel）：</p>\n<ol>\n<li>iPhone5分辨率320x568，像素640x1136，@2x</li>\n<li>iPhone6分辨率375x667，像素750x1334，@2x</li>\n<li>iPhone6 Plus分辨率414x736，像素1242x2208，@3x，（注意，在这个分辨率下渲染后，图像等比降低pixel分辨率至1080p(1080x1920)）</li>\n</ol>\n<p><img src=\"http://ww3.sinaimg.cn/mw690/51530583gw1ek7mqv36zxj20go099jrm.jpg\" alt=\"\"></p>\n<p>PaintCode做了<a href=\"http://www.paintcodeapp.com/news/iphone-6-screens-demystified\" target=\"_blank\" rel=\"external\">几个图讲解的非常明了</a></p>\n<h1 id=\"自动适配\"><a href=\"#自动适配\" class=\"headerlink\" title=\"自动适配\"></a>自动适配</h1><p>不处理时自动等比拉伸，如果在老工程打印屏幕frame，依然是<code>320x568</code><br>对比自动适配的和完美适配的导航栏就能看出问题：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/51530583gw1ek7mze3ckrj219y060glw.jpg\" alt=\"\"></p>\n<p>因为拉伸所以会有一些虚，导航栏明显比64要大，但相比3.5寸到4寸的留黑边还是好很多。<br>如何关闭自动适配方案呢？这个还是老思路，换启动图：  </p>\n<p><img src=\"http://ww4.sinaimg.cn/mw690/51530583gw1ek7n9aqlnsj20oc08maa9.jpg\" alt=\"\"></p>\n<p>除了换启动图外，不得不说的是，新Xcode中可以使用一个<code>xib</code>来设置启动图：</p>\n<p><img src=\"http://ww2.sinaimg.cn/mw690/51530583gw1ek7nce5e1uj20pe07cgmj.jpg\" alt=\"\"></p>\n<p>不过这个xib不能关联任何的代码（不能自定义View的Class，不能IBOutlet，不能加Object），可以理解成这个xib就是一张截图，这个方案的好处在于可以使用到<code>Size Classes</code>来针对不同屏幕布局这个xib（感兴趣可以看<a href=\"http://blog.sunnyxx.com/2014/09/09/ios8-size-classes/\">《Size Classes初探》</a>）</p>\n<h1 id=\"关于手动适配\"><a href=\"#关于手动适配\" class=\"headerlink\" title=\"关于手动适配\"></a>关于手动适配</h1><p>只要手动指定了启动图或者那个xib，屏幕分辨率就已经变成应有的大小了，老代码中所有关于写死frame值的代码通通倒霉，如果去手动适配就要全部适配，建议<strong>在找到个可行方案前先不要做修改</strong>，自动适配方案还算不影响使用。  </p>\n<p>面对4个分辨率的iPhone，建议使用<code>Auto Layout</code>布局 + <code>Image Assets</code>管理各个分辨率的图片 + <code>Interface Builder</code>（xib+storyboard）构建UI，<code>Size Classes</code>在低版本iOS系统的表现未知。想要这套手动适配方案，起码你的工程需要部署在iOS6+，还不用AutoLayout布局的会死的蛮惨。</p>\n<h1 id=\"关于Xcode6\"><a href=\"#关于Xcode6\" class=\"headerlink\" title=\"关于Xcode6\"></a>关于Xcode6</h1><ol>\n<li>模拟器路径被换成了 <code>~/Library/Developer/CoreSimulator/Devices/</code></li>\n<li>xcode6中已经找不到iOS6的模拟器了，是时候说服大家放弃iOS7-了</li>\n<li><del>现在起提交App Store强制需要支持64位，是时候梳理一遍所有依赖的第三方lib，更新到64位</del></li>\n</ol>\n<hr>\n<p>One more thing…按这名命的规律…</p>\n<p><code>iPhone6</code> -&gt; <code>iPhone6+</code> -&gt; <code>iPhone6++</code>? -&gt; <code>iPhone6#</code>?</p>\n","excerpt":"","more":"<h1 id=\"分辨率和像素\"><a href=\"#分辨率和像素\" class=\"headerlink\" title=\"分辨率和像素\"></a>分辨率和像素</h1><p>经新xcode6模拟器验证（分辨率为pt，像素为真实pixel）：</p>\n<ol>\n<li>iPhone5分辨率320x568，像素640x1136，@2x</li>\n<li>iPhone6分辨率375x667，像素750x1334，@2x</li>\n<li>iPhone6 Plus分辨率414x736，像素1242x2208，@3x，（注意，在这个分辨率下渲染后，图像等比降低pixel分辨率至1080p(1080x1920)）</li>\n</ol>\n<p><img src=\"http://ww3.sinaimg.cn/mw690/51530583gw1ek7mqv36zxj20go099jrm.jpg\" alt=\"\"></p>\n<p>PaintCode做了<a href=\"http://www.paintcodeapp.com/news/iphone-6-screens-demystified\">几个图讲解的非常明了</a></p>\n<h1 id=\"自动适配\"><a href=\"#自动适配\" class=\"headerlink\" title=\"自动适配\"></a>自动适配</h1><p>不处理时自动等比拉伸，如果在老工程打印屏幕frame，依然是<code>320x568</code><br>对比自动适配的和完美适配的导航栏就能看出问题：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/51530583gw1ek7mze3ckrj219y060glw.jpg\" alt=\"\"></p>\n<p>因为拉伸所以会有一些虚，导航栏明显比64要大，但相比3.5寸到4寸的留黑边还是好很多。<br>如何关闭自动适配方案呢？这个还是老思路，换启动图：  </p>\n<p><img src=\"http://ww4.sinaimg.cn/mw690/51530583gw1ek7n9aqlnsj20oc08maa9.jpg\" alt=\"\"></p>\n<p>除了换启动图外，不得不说的是，新Xcode中可以使用一个<code>xib</code>来设置启动图：</p>\n<p><img src=\"http://ww2.sinaimg.cn/mw690/51530583gw1ek7nce5e1uj20pe07cgmj.jpg\" alt=\"\"></p>\n<p>不过这个xib不能关联任何的代码（不能自定义View的Class，不能IBOutlet，不能加Object），可以理解成这个xib就是一张截图，这个方案的好处在于可以使用到<code>Size Classes</code>来针对不同屏幕布局这个xib（感兴趣可以看<a href=\"http://blog.sunnyxx.com/2014/09/09/ios8-size-classes/\">《Size Classes初探》</a>）</p>\n<h1 id=\"关于手动适配\"><a href=\"#关于手动适配\" class=\"headerlink\" title=\"关于手动适配\"></a>关于手动适配</h1><p>只要手动指定了启动图或者那个xib，屏幕分辨率就已经变成应有的大小了，老代码中所有关于写死frame值的代码通通倒霉，如果去手动适配就要全部适配，建议<strong>在找到个可行方案前先不要做修改</strong>，自动适配方案还算不影响使用。  </p>\n<p>面对4个分辨率的iPhone，建议使用<code>Auto Layout</code>布局 + <code>Image Assets</code>管理各个分辨率的图片 + <code>Interface Builder</code>（xib+storyboard）构建UI，<code>Size Classes</code>在低版本iOS系统的表现未知。想要这套手动适配方案，起码你的工程需要部署在iOS6+，还不用AutoLayout布局的会死的蛮惨。</p>\n<h1 id=\"关于Xcode6\"><a href=\"#关于Xcode6\" class=\"headerlink\" title=\"关于Xcode6\"></a>关于Xcode6</h1><ol>\n<li>模拟器路径被换成了 <code>~/Library/Developer/CoreSimulator/Devices/</code></li>\n<li>xcode6中已经找不到iOS6的模拟器了，是时候说服大家放弃iOS7-了</li>\n<li><del>现在起提交App Store强制需要支持64位，是时候梳理一遍所有依赖的第三方lib，更新到64位</del></li>\n</ol>\n<hr>\n<p>One more thing…按这名命的规律…</p>\n<p><code>iPhone6</code> -&gt; <code>iPhone6+</code> -&gt; <code>iPhone6++</code>? -&gt; <code>iPhone6#</code>?</p>\n"},{"title":"巧用多字符Char常量","date":"2015-05-07T00:03:20.000Z","_content":"\n###巧用多字符Char\n\n我们很熟悉`char`这个数据类型和它的使用方式：  \n\n``` objc\nchar c = 'a';\n```\n这个 c 变量在 **ASCII** 编码下是 **97**  \n还有一种不常见的多字符 char 的写法：  \n\n``` objc\nint i = 'AaBb';\n```\n这个 i 变量的值按每个 char 的 ASCII 值转 16 进制拼在一起，也就是说：  \n\n``` objc\n'AaBb'\n-> '0x41'+'0x61'+'0x42'+'0x62'\n-> '0x41614262' // 十进制1096893026\n```\n\nPS：这个组合方式和“大小端”有关系，上面是 i386 下的结果  \n多字符的长度限度为最多 **4** 个 char\n\n知道了这个特性，我们就可以做些坏事，比如：\n\n``` objc\nself.someButton.tag = 'SHIT';\n...\n\nif (button.tag == 'SHIT') {\n    NSLog(@\"I've got this shit button\");\n}\n```\n\n当然使用tag是很不推荐的写法，尽量不用。使用这个特性来避免些魔法数字或标记些整型数字还是极好的。\n","source":"_posts/multiple-char.md","raw":"title: 巧用多字符Char常量\ndate: 2015-05-07 08:03:20\ntags: wtf\n---\n\n###巧用多字符Char\n\n我们很熟悉`char`这个数据类型和它的使用方式：  \n\n``` objc\nchar c = 'a';\n```\n这个 c 变量在 **ASCII** 编码下是 **97**  \n还有一种不常见的多字符 char 的写法：  \n\n``` objc\nint i = 'AaBb';\n```\n这个 i 变量的值按每个 char 的 ASCII 值转 16 进制拼在一起，也就是说：  \n\n``` objc\n'AaBb'\n-> '0x41'+'0x61'+'0x42'+'0x62'\n-> '0x41614262' // 十进制1096893026\n```\n\nPS：这个组合方式和“大小端”有关系，上面是 i386 下的结果  \n多字符的长度限度为最多 **4** 个 char\n\n知道了这个特性，我们就可以做些坏事，比如：\n\n``` objc\nself.someButton.tag = 'SHIT';\n...\n\nif (button.tag == 'SHIT') {\n    NSLog(@\"I've got this shit button\");\n}\n```\n\n当然使用tag是很不推荐的写法，尽量不用。使用这个特性来避免些魔法数字或标记些整型数字还是极好的。\n","slug":"multiple-char","published":1,"updated":"2016-03-27T07:45:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxl90015ev12tncb2xeg","content":"<p>###巧用多字符Char</p>\n<p>我们很熟悉<code>char</code>这个数据类型和它的使用方式：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> c = <span class=\"string\">'a'</span>;</span><br></pre></td></tr></table></figure>\n<p>这个 c 变量在 <strong>ASCII</strong> 编码下是 <strong>97</strong><br>还有一种不常见的多字符 char 的写法：  </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 'AaBb';</span><br></pre></td></tr></table></figure>\n<p>这个 i 变量的值按每个 char 的 ASCII 值转 16 进制拼在一起，也就是说：  </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">'AaBb'</span><br><span class=\"line\">-&gt; '0x41'+'0x61'+'0x42'+'0x62'</span><br><span class=\"line\">-&gt; '0x41614262' // 十进制1096893026</span><br></pre></td></tr></table></figure>\n<p>PS：这个组合方式和“大小端”有关系，上面是 i386 下的结果<br>多字符的长度限度为最多 <strong>4</strong> 个 char</p>\n<p>知道了这个特性，我们就可以做些坏事，比如：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.someButton.tag = 'SHIT';</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">if (button.tag == 'SHIT') &#123;</span><br><span class=\"line\">    NSLog(@\"I've got this shit button\");</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然使用tag是很不推荐的写法，尽量不用。使用这个特性来避免些魔法数字或标记些整型数字还是极好的。</p>\n","excerpt":"","more":"<p>###巧用多字符Char</p>\n<p>我们很熟悉<code>char</code>这个数据类型和它的使用方式：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> c = <span class=\"string\">'a'</span>;</span><br></pre></td></tr></table></figure>\n<p>这个 c 变量在 <strong>ASCII</strong> 编码下是 <strong>97</strong><br>还有一种不常见的多字符 char 的写法：  </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 'AaBb';</span><br></pre></td></tr></table></figure>\n<p>这个 i 变量的值按每个 char 的 ASCII 值转 16 进制拼在一起，也就是说：  </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">'AaBb'</span><br><span class=\"line\">-&gt; '0x41'+'0x61'+'0x42'+'0x62'</span><br><span class=\"line\">-&gt; '0x41614262' // 十进制1096893026</span><br></pre></td></tr></table></figure>\n<p>PS：这个组合方式和“大小端”有关系，上面是 i386 下的结果<br>多字符的长度限度为最多 <strong>4</strong> 个 char</p>\n<p>知道了这个特性，我们就可以做些坏事，比如：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.someButton.tag = 'SHIT';</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">if (button.tag == 'SHIT') &#123;</span><br><span class=\"line\">    NSLog(@\"I've got this shit button\");</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然使用tag是很不推荐的写法，尽量不用。使用这个特性来避免些魔法数字或标记些整型数字还是极好的。</p>\n"},{"title":"Notification Once","date":"2015-03-09T11:31:55.000Z","_content":"\n前段时间整理项目中的`AppDelegate`，发现很多写在`- application:didFinishLaunchingWithOptions:`中的代码都只是为了在程序启动时获得一次调用机会，多为某些模块的初始化工作，如：\n\n``` objc\n- (BOOL)application:(UIApplication *)application\ndidFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    // ...\n    [FooModule setup];\n    [[BarModule sharedInstance] setup];\n    // ...\n    return YES;\n}\n```\n\n其实这些代码完全可以利用`Notification`的方式在自己的模块内部搞定，分享一个巧妙的方法：  \n\n``` objc\n/// FooModule.m\n+ (void)load\n{\n    __block id observer =\n    [[NSNotificationCenter defaultCenter]\n     addObserverForName:UIApplicationDidFinishLaunchingNotification\n     object:nil\n     queue:nil\n     usingBlock:^(NSNotification *note) {\n         [self setup]; // Do whatever you want\n         [[NSNotificationCenter defaultCenter] removeObserver:observer];\n     }];\n}\n```\n\n解释：\n - `+ load`方法在足够早的时间点被调用\n - block 版本的通知注册会产生一个`__NSObserver *`对象用来给外部 remove 观察者\n - block 对 observer 对象的捕获早于函数的返回，所以若不加`__block`，会捕获到 nil\n - 在 block 执行结束时移除 observer，无需其他清理工作\n - 这样，在模块内部就完成了在程序启动点代码的挂载\n\n值得注意的是，通知是在`- application:didFinishLaunchingWithOptions:`调用完成后才发送的。  \n顺便提下给 AppDelegate 瘦身的建议：AppDelegate 作为程序级状态变化的 delegate，应该只做**路由**和**分发**的作用，具体逻辑实现代码还是应该在分别的模块中，这个文件应该保持整洁，除了`<UIApplicationDelegate>`的方法外不应该出现其他方法。\n","source":"_posts/notification-once.md","raw":"title: Notification Once\ndate: 2015-03-09 19:31:55\ntags: ios最佳实践\n---\n\n前段时间整理项目中的`AppDelegate`，发现很多写在`- application:didFinishLaunchingWithOptions:`中的代码都只是为了在程序启动时获得一次调用机会，多为某些模块的初始化工作，如：\n\n``` objc\n- (BOOL)application:(UIApplication *)application\ndidFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    // ...\n    [FooModule setup];\n    [[BarModule sharedInstance] setup];\n    // ...\n    return YES;\n}\n```\n\n其实这些代码完全可以利用`Notification`的方式在自己的模块内部搞定，分享一个巧妙的方法：  \n\n``` objc\n/// FooModule.m\n+ (void)load\n{\n    __block id observer =\n    [[NSNotificationCenter defaultCenter]\n     addObserverForName:UIApplicationDidFinishLaunchingNotification\n     object:nil\n     queue:nil\n     usingBlock:^(NSNotification *note) {\n         [self setup]; // Do whatever you want\n         [[NSNotificationCenter defaultCenter] removeObserver:observer];\n     }];\n}\n```\n\n解释：\n - `+ load`方法在足够早的时间点被调用\n - block 版本的通知注册会产生一个`__NSObserver *`对象用来给外部 remove 观察者\n - block 对 observer 对象的捕获早于函数的返回，所以若不加`__block`，会捕获到 nil\n - 在 block 执行结束时移除 observer，无需其他清理工作\n - 这样，在模块内部就完成了在程序启动点代码的挂载\n\n值得注意的是，通知是在`- application:didFinishLaunchingWithOptions:`调用完成后才发送的。  \n顺便提下给 AppDelegate 瘦身的建议：AppDelegate 作为程序级状态变化的 delegate，应该只做**路由**和**分发**的作用，具体逻辑实现代码还是应该在分别的模块中，这个文件应该保持整洁，除了`<UIApplicationDelegate>`的方法外不应该出现其他方法。\n","slug":"notification-once","published":1,"updated":"2016-03-27T07:47:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxle0017ev12hhtydqze","content":"<p>前段时间整理项目中的<code>AppDelegate</code>，发现很多写在<code>- application:didFinishLaunchingWithOptions:</code>中的代码都只是为了在程序启动时获得一次调用机会，多为某些模块的初始化工作，如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application</span><br><span class=\"line\">didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    [FooModule setup];</span><br><span class=\"line\">    [[BarModule sharedInstance] setup];</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实这些代码完全可以利用<code>Notification</code>的方式在自己的模块内部搞定，分享一个巧妙的方法：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// FooModule.m</span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)load</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __block <span class=\"keyword\">id</span> observer =</span><br><span class=\"line\">    [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter]</span><br><span class=\"line\">     addObserverForName:<span class=\"built_in\">UIApplicationDidFinishLaunchingNotification</span></span><br><span class=\"line\">     object:<span class=\"literal\">nil</span></span><br><span class=\"line\">     queue:<span class=\"literal\">nil</span></span><br><span class=\"line\">     usingBlock:^(<span class=\"built_in\">NSNotification</span> *note) &#123;</span><br><span class=\"line\">         [<span class=\"keyword\">self</span> setup]; <span class=\"comment\">// Do whatever you want</span></span><br><span class=\"line\">         [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] removeObserver:observer];</span><br><span class=\"line\">     &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释：</p>\n<ul>\n<li><code>+ load</code>方法在足够早的时间点被调用</li>\n<li>block 版本的通知注册会产生一个<code>__NSObserver *</code>对象用来给外部 remove 观察者</li>\n<li>block 对 observer 对象的捕获早于函数的返回，所以若不加<code>__block</code>，会捕获到 nil</li>\n<li>在 block 执行结束时移除 observer，无需其他清理工作</li>\n<li>这样，在模块内部就完成了在程序启动点代码的挂载</li>\n</ul>\n<p>值得注意的是，通知是在<code>- application:didFinishLaunchingWithOptions:</code>调用完成后才发送的。<br>顺便提下给 AppDelegate 瘦身的建议：AppDelegate 作为程序级状态变化的 delegate，应该只做<strong>路由</strong>和<strong>分发</strong>的作用，具体逻辑实现代码还是应该在分别的模块中，这个文件应该保持整洁，除了<code>&lt;UIApplicationDelegate&gt;</code>的方法外不应该出现其他方法。</p>\n","excerpt":"","more":"<p>前段时间整理项目中的<code>AppDelegate</code>，发现很多写在<code>- application:didFinishLaunchingWithOptions:</code>中的代码都只是为了在程序启动时获得一次调用机会，多为某些模块的初始化工作，如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application</span><br><span class=\"line\">didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    [FooModule setup];</span><br><span class=\"line\">    [[BarModule sharedInstance] setup];</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实这些代码完全可以利用<code>Notification</code>的方式在自己的模块内部搞定，分享一个巧妙的方法：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// FooModule.m</span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)load</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __block <span class=\"keyword\">id</span> observer =</span><br><span class=\"line\">    [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter]</span><br><span class=\"line\">     addObserverForName:<span class=\"built_in\">UIApplicationDidFinishLaunchingNotification</span></span><br><span class=\"line\">     object:<span class=\"literal\">nil</span></span><br><span class=\"line\">     queue:<span class=\"literal\">nil</span></span><br><span class=\"line\">     usingBlock:^(<span class=\"built_in\">NSNotification</span> *note) &#123;</span><br><span class=\"line\">         [<span class=\"keyword\">self</span> setup]; <span class=\"comment\">// Do whatever you want</span></span><br><span class=\"line\">         [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] removeObserver:observer];</span><br><span class=\"line\">     &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释：</p>\n<ul>\n<li><code>+ load</code>方法在足够早的时间点被调用</li>\n<li>block 版本的通知注册会产生一个<code>__NSObserver *</code>对象用来给外部 remove 观察者</li>\n<li>block 对 observer 对象的捕获早于函数的返回，所以若不加<code>__block</code>，会捕获到 nil</li>\n<li>在 block 执行结束时移除 observer，无需其他清理工作</li>\n<li>这样，在模块内部就完成了在程序启动点代码的挂载</li>\n</ul>\n<p>值得注意的是，通知是在<code>- application:didFinishLaunchingWithOptions:</code>调用完成后才发送的。<br>顺便提下给 AppDelegate 瘦身的建议：AppDelegate 作为程序级状态变化的 delegate，应该只做<strong>路由</strong>和<strong>分发</strong>的作用，具体逻辑实现代码还是应该在分别的模块中，这个文件应该保持整洁，除了<code>&lt;UIApplicationDelegate&gt;</code>的方法外不应该出现其他方法。</p>\n"},{"title":"黑魔法__attribute__((cleanup))","date":"2014-09-15T09:09:36.000Z","_content":"\n编译器属性`__attribute__`用于向编译器描述特殊的标识、检查或优化，几个常用的用法看[《mattt大神的文章》](http://nshipster.com/__attribute__/)就好。今天发现一个名为`cleanup`的黑魔法属性，简单介绍下。\n\n---\n\n## 基本用法\n\n`__attribute__((cleanup(...)))`，用于修饰一个变量，**在它的作用域结束时可以自动执行一个指定的方法**，如：\n\n\n``` objc\n// 指定一个cleanup方法，注意入参是所修饰变量的地址，类型要一样\n// 对于指向objc对象的指针(id *)，如果不强制声明__strong默认是__autoreleasing，造成类型不匹配\nstatic void stringCleanUp(__strong NSString **string) {\n    NSLog(@\"%@\", *string);\n}\n// 在某个方法中：\n{\n    __strong NSString *string __attribute__((cleanup(stringCleanUp))) = @\"sunnyxx\";\n} // 当运行到这个作用域结束时，自动调用stringCleanUp\n\n```\n\n所谓作用域结束，包括大括号结束、return、goto、break、exception等各种情况。\n当然，可以修饰的变量不止NSString，`自定义Class`或`基本类型`都是可以的：\n\n``` objc\n// 自定义的Class\nstatic void sarkCleanUp(__strong Sark **sark) {\n    NSLog(@\"%@\", *sark);\n}\n__strong Sark *sark __attribute__((cleanup(sarkCleanUp))) = [Sark new];\n// 基本类型\nstatic void intCleanUp(NSInteger *integer) {\n    NSLog(@\"%d\", *integer);\n}\nNSInteger integer __attribute__((cleanup(intCleanUp))) = 1;\n```\n\n假如一个作用域内有若干个cleanup的变量，他们的调用顺序是`先入后出`的栈式顺序；  \n而且，cleanup是先于这个对象的`dealloc`调用的。\n\n\n## 进阶用法\n\n既然`__attribute__((cleanup(...)))`可以用来修饰变量，`block`当然也是其中之一，写一个block的cleanup函数非常有趣：\n\n``` objc\n// void(^block)(void)的指针是void(^*block)(void)\nstatic void blockCleanUp(__strong void(^*block)(void)) {\n    (*block)();\n}\n```\n\n于是在一个作用域里声明一个block：\n\n``` objc\n{\n   // 加了个`unused`的attribute用来消除`unused variable`的warning\n    __strong void(^block)(void) __attribute__((cleanup(blockCleanUp), unused)) = ^{\n        NSLog(@\"I'm dying...\");\n    };\n} // 这里输出\"I'm dying...\"\n```\n\n这里不得不提万能的`Reactive Cocoa`中神奇的`@onExit`方法，其实正是上面的写法，简单定义个宏：\n\n``` objc\n#define onExit\\\n    __strong void(^block)(void) __attribute__((cleanup(blockCleanUp), unused)) = ^\n```\n\n用这个宏就能将一段写在前面的代码最后执行：  \n\n``` objc\n{\n    onExit {\n        NSLog(@\"yo\");\n    };\n} // Log \"yo\"\n```\n\n这样的写法可以将成对出现的代码写在一起，比如说一个lock：\n\n``` objc\nNSRecursiveLock *aLock = [[NSRecursiveLock alloc] init];\n[aLock lock];\n// 这里\n//     有\n//        100多万行\n[aLock unlock]; // 看到这儿的时候早忘了和哪个lock对应着了\n```\n\n用了`onExit`之后，代码更集中了：\n\n\n``` objc\nNSRecursiveLock *aLock = [[NSRecursiveLock alloc] init];\n[aLock lock];\nonExit {\n    [aLock unlock]; // 妈妈再也不用担心我忘写后半段了\n};\n// 这里\n//    爱多少行\n//           就多少行\n\n```\n\n还是那句老话：剩下的就全靠想象力了。\n","source":"_posts/objc-attribute-cleanup.md","raw":"title: 黑魔法__attribute__((cleanup))\ndate: 2014-09-15 17:09:36\ntags: objc的秘密\n---\n\n编译器属性`__attribute__`用于向编译器描述特殊的标识、检查或优化，几个常用的用法看[《mattt大神的文章》](http://nshipster.com/__attribute__/)就好。今天发现一个名为`cleanup`的黑魔法属性，简单介绍下。\n\n---\n\n## 基本用法\n\n`__attribute__((cleanup(...)))`，用于修饰一个变量，**在它的作用域结束时可以自动执行一个指定的方法**，如：\n\n\n``` objc\n// 指定一个cleanup方法，注意入参是所修饰变量的地址，类型要一样\n// 对于指向objc对象的指针(id *)，如果不强制声明__strong默认是__autoreleasing，造成类型不匹配\nstatic void stringCleanUp(__strong NSString **string) {\n    NSLog(@\"%@\", *string);\n}\n// 在某个方法中：\n{\n    __strong NSString *string __attribute__((cleanup(stringCleanUp))) = @\"sunnyxx\";\n} // 当运行到这个作用域结束时，自动调用stringCleanUp\n\n```\n\n所谓作用域结束，包括大括号结束、return、goto、break、exception等各种情况。\n当然，可以修饰的变量不止NSString，`自定义Class`或`基本类型`都是可以的：\n\n``` objc\n// 自定义的Class\nstatic void sarkCleanUp(__strong Sark **sark) {\n    NSLog(@\"%@\", *sark);\n}\n__strong Sark *sark __attribute__((cleanup(sarkCleanUp))) = [Sark new];\n// 基本类型\nstatic void intCleanUp(NSInteger *integer) {\n    NSLog(@\"%d\", *integer);\n}\nNSInteger integer __attribute__((cleanup(intCleanUp))) = 1;\n```\n\n假如一个作用域内有若干个cleanup的变量，他们的调用顺序是`先入后出`的栈式顺序；  \n而且，cleanup是先于这个对象的`dealloc`调用的。\n\n\n## 进阶用法\n\n既然`__attribute__((cleanup(...)))`可以用来修饰变量，`block`当然也是其中之一，写一个block的cleanup函数非常有趣：\n\n``` objc\n// void(^block)(void)的指针是void(^*block)(void)\nstatic void blockCleanUp(__strong void(^*block)(void)) {\n    (*block)();\n}\n```\n\n于是在一个作用域里声明一个block：\n\n``` objc\n{\n   // 加了个`unused`的attribute用来消除`unused variable`的warning\n    __strong void(^block)(void) __attribute__((cleanup(blockCleanUp), unused)) = ^{\n        NSLog(@\"I'm dying...\");\n    };\n} // 这里输出\"I'm dying...\"\n```\n\n这里不得不提万能的`Reactive Cocoa`中神奇的`@onExit`方法，其实正是上面的写法，简单定义个宏：\n\n``` objc\n#define onExit\\\n    __strong void(^block)(void) __attribute__((cleanup(blockCleanUp), unused)) = ^\n```\n\n用这个宏就能将一段写在前面的代码最后执行：  \n\n``` objc\n{\n    onExit {\n        NSLog(@\"yo\");\n    };\n} // Log \"yo\"\n```\n\n这样的写法可以将成对出现的代码写在一起，比如说一个lock：\n\n``` objc\nNSRecursiveLock *aLock = [[NSRecursiveLock alloc] init];\n[aLock lock];\n// 这里\n//     有\n//        100多万行\n[aLock unlock]; // 看到这儿的时候早忘了和哪个lock对应着了\n```\n\n用了`onExit`之后，代码更集中了：\n\n\n``` objc\nNSRecursiveLock *aLock = [[NSRecursiveLock alloc] init];\n[aLock lock];\nonExit {\n    [aLock unlock]; // 妈妈再也不用担心我忘写后半段了\n};\n// 这里\n//    爱多少行\n//           就多少行\n\n```\n\n还是那句老话：剩下的就全靠想象力了。\n","slug":"objc-attribute-cleanup","published":1,"updated":"2016-03-27T07:55:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxlh0019ev12i8o8r92u","content":"<p>编译器属性<code>__attribute__</code>用于向编译器描述特殊的标识、检查或优化，几个常用的用法看<a href=\"http://nshipster.com/__attribute__/\" target=\"_blank\" rel=\"external\">《mattt大神的文章》</a>就好。今天发现一个名为<code>cleanup</code>的黑魔法属性，简单介绍下。</p>\n<hr>\n<h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p><code>__attribute__((cleanup(...)))</code>，用于修饰一个变量，<strong>在它的作用域结束时可以自动执行一个指定的方法</strong>，如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 指定一个cleanup方法，注意入参是所修饰变量的地址，类型要一样</span></span><br><span class=\"line\"><span class=\"comment\">// 对于指向objc对象的指针(id *)，如果不强制声明__strong默认是__autoreleasing，造成类型不匹配</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> stringCleanUp(__<span class=\"keyword\">strong</span> <span class=\"built_in\">NSString</span> **string) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, *string);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 在某个方法中：</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"built_in\">NSString</span> *string __attribute__((cleanup(stringCleanUp))) = <span class=\"string\">@\"sunnyxx\"</span>;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 当运行到这个作用域结束时，自动调用stringCleanUp</span></span><br></pre></td></tr></table></figure>\n<p>所谓作用域结束，包括大括号结束、return、goto、break、exception等各种情况。<br>当然，可以修饰的变量不止NSString，<code>自定义Class</code>或<code>基本类型</code>都是可以的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自定义的Class</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> sarkCleanUp(__<span class=\"keyword\">strong</span> Sark **sark) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, *sark);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">__<span class=\"keyword\">strong</span> Sark *sark __attribute__((cleanup(sarkCleanUp))) = [Sark new];</span><br><span class=\"line\"><span class=\"comment\">// 基本类型</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> intCleanUp(<span class=\"built_in\">NSInteger</span> *integer) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>, *integer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">NSInteger</span> integer __attribute__((cleanup(intCleanUp))) = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>假如一个作用域内有若干个cleanup的变量，他们的调用顺序是<code>先入后出</code>的栈式顺序；<br>而且，cleanup是先于这个对象的<code>dealloc</code>调用的。</p>\n<h2 id=\"进阶用法\"><a href=\"#进阶用法\" class=\"headerlink\" title=\"进阶用法\"></a>进阶用法</h2><p>既然<code>__attribute__((cleanup(...)))</code>可以用来修饰变量，<code>block</code>当然也是其中之一，写一个block的cleanup函数非常有趣：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// void(^block)(void)的指针是void(^*block)(void)</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> blockCleanUp(__<span class=\"keyword\">strong</span> <span class=\"keyword\">void</span>(^*block)(<span class=\"keyword\">void</span>)) &#123;</span><br><span class=\"line\">    (*block)();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>于是在一个作用域里声明一个block：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 加了个`unused`的attribute用来消除`unused variable`的warning</span></span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"keyword\">void</span>(^block)(<span class=\"keyword\">void</span>) __attribute__((cleanup(blockCleanUp), unused)) = ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"I'm dying...\"</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 这里输出\"I'm dying...\"</span></span><br></pre></td></tr></table></figure>\n<p>这里不得不提万能的<code>Reactive Cocoa</code>中神奇的<code>@onExit</code>方法，其实正是上面的写法，简单定义个宏：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define onExit\\</span></span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"keyword\">void</span>(^block)(<span class=\"keyword\">void</span>) __attribute__((cleanup(blockCleanUp), unused)) = ^</span><br></pre></td></tr></table></figure>\n<p>用这个宏就能将一段写在前面的代码最后执行：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    onExit &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"yo\"</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125; <span class=\"comment\">// Log \"yo\"</span></span><br></pre></td></tr></table></figure>\n<p>这样的写法可以将成对出现的代码写在一起，比如说一个lock：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSRecursiveLock</span> *aLock = [[<span class=\"built_in\">NSRecursiveLock</span> alloc] init];</span><br><span class=\"line\">[aLock lock];</span><br><span class=\"line\"><span class=\"comment\">// 这里</span></span><br><span class=\"line\"><span class=\"comment\">//     有</span></span><br><span class=\"line\"><span class=\"comment\">//        100多万行</span></span><br><span class=\"line\">[aLock unlock]; <span class=\"comment\">// 看到这儿的时候早忘了和哪个lock对应着了</span></span><br></pre></td></tr></table></figure>\n<p>用了<code>onExit</code>之后，代码更集中了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSRecursiveLock</span> *aLock = [[<span class=\"built_in\">NSRecursiveLock</span> alloc] init];</span><br><span class=\"line\">[aLock lock];</span><br><span class=\"line\">onExit &#123;</span><br><span class=\"line\">    [aLock unlock]; <span class=\"comment\">// 妈妈再也不用担心我忘写后半段了</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 这里</span></span><br><span class=\"line\"><span class=\"comment\">//    爱多少行</span></span><br><span class=\"line\"><span class=\"comment\">//           就多少行</span></span><br></pre></td></tr></table></figure>\n<p>还是那句老话：剩下的就全靠想象力了。</p>\n","excerpt":"","more":"<p>编译器属性<code>__attribute__</code>用于向编译器描述特殊的标识、检查或优化，几个常用的用法看<a href=\"http://nshipster.com/__attribute__/\">《mattt大神的文章》</a>就好。今天发现一个名为<code>cleanup</code>的黑魔法属性，简单介绍下。</p>\n<hr>\n<h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p><code>__attribute__((cleanup(...)))</code>，用于修饰一个变量，<strong>在它的作用域结束时可以自动执行一个指定的方法</strong>，如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 指定一个cleanup方法，注意入参是所修饰变量的地址，类型要一样</span></span><br><span class=\"line\"><span class=\"comment\">// 对于指向objc对象的指针(id *)，如果不强制声明__strong默认是__autoreleasing，造成类型不匹配</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> stringCleanUp(__<span class=\"keyword\">strong</span> <span class=\"built_in\">NSString</span> **string) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, *string);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 在某个方法中：</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"built_in\">NSString</span> *string __attribute__((cleanup(stringCleanUp))) = <span class=\"string\">@\"sunnyxx\"</span>;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 当运行到这个作用域结束时，自动调用stringCleanUp</span></span><br></pre></td></tr></table></figure>\n<p>所谓作用域结束，包括大括号结束、return、goto、break、exception等各种情况。<br>当然，可以修饰的变量不止NSString，<code>自定义Class</code>或<code>基本类型</code>都是可以的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自定义的Class</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> sarkCleanUp(__<span class=\"keyword\">strong</span> Sark **sark) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, *sark);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">__<span class=\"keyword\">strong</span> Sark *sark __attribute__((cleanup(sarkCleanUp))) = [Sark new];</span><br><span class=\"line\"><span class=\"comment\">// 基本类型</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> intCleanUp(<span class=\"built_in\">NSInteger</span> *integer) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>, *integer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">NSInteger</span> integer __attribute__((cleanup(intCleanUp))) = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>假如一个作用域内有若干个cleanup的变量，他们的调用顺序是<code>先入后出</code>的栈式顺序；<br>而且，cleanup是先于这个对象的<code>dealloc</code>调用的。</p>\n<h2 id=\"进阶用法\"><a href=\"#进阶用法\" class=\"headerlink\" title=\"进阶用法\"></a>进阶用法</h2><p>既然<code>__attribute__((cleanup(...)))</code>可以用来修饰变量，<code>block</code>当然也是其中之一，写一个block的cleanup函数非常有趣：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// void(^block)(void)的指针是void(^*block)(void)</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> blockCleanUp(__<span class=\"keyword\">strong</span> <span class=\"keyword\">void</span>(^*block)(<span class=\"keyword\">void</span>)) &#123;</span><br><span class=\"line\">    (*block)();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>于是在一个作用域里声明一个block：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 加了个`unused`的attribute用来消除`unused variable`的warning</span></span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"keyword\">void</span>(^block)(<span class=\"keyword\">void</span>) __attribute__((cleanup(blockCleanUp), unused)) = ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"I'm dying...\"</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 这里输出\"I'm dying...\"</span></span><br></pre></td></tr></table></figure>\n<p>这里不得不提万能的<code>Reactive Cocoa</code>中神奇的<code>@onExit</code>方法，其实正是上面的写法，简单定义个宏：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define onExit\\</span></span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"keyword\">void</span>(^block)(<span class=\"keyword\">void</span>) __attribute__((cleanup(blockCleanUp), unused)) = ^</span><br></pre></td></tr></table></figure>\n<p>用这个宏就能将一段写在前面的代码最后执行：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    onExit &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"yo\"</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125; <span class=\"comment\">// Log \"yo\"</span></span><br></pre></td></tr></table></figure>\n<p>这样的写法可以将成对出现的代码写在一起，比如说一个lock：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSRecursiveLock</span> *aLock = [[<span class=\"built_in\">NSRecursiveLock</span> alloc] init];</span><br><span class=\"line\">[aLock lock];</span><br><span class=\"line\"><span class=\"comment\">// 这里</span></span><br><span class=\"line\"><span class=\"comment\">//     有</span></span><br><span class=\"line\"><span class=\"comment\">//        100多万行</span></span><br><span class=\"line\">[aLock unlock]; <span class=\"comment\">// 看到这儿的时候早忘了和哪个lock对应着了</span></span><br></pre></td></tr></table></figure>\n<p>用了<code>onExit</code>之后，代码更集中了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSRecursiveLock</span> *aLock = [[<span class=\"built_in\">NSRecursiveLock</span> alloc] init];</span><br><span class=\"line\">[aLock lock];</span><br><span class=\"line\">onExit &#123;</span><br><span class=\"line\">    [aLock unlock]; <span class=\"comment\">// 妈妈再也不用担心我忘写后半段了</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 这里</span></span><br><span class=\"line\"><span class=\"comment\">//    爱多少行</span></span><br><span class=\"line\"><span class=\"comment\">//           就多少行</span></span><br></pre></td></tr></table></figure>\n<p>还是那句老话：剩下的就全靠想象力了。</p>\n"},{"title":"objc与鸭子对象（下）","date":"2014-08-26T14:26:56.000Z","_content":"\n# 我是前言\n这是《objc与鸭子对象》的下半部分，[《objc与鸭子对象（上）》](http://blog.sunnyxx.com/2014/08/24/objc-duck/)中介绍了鸭子类型和它在objc中的实践，以及一个使用NSProxy实现JSON Entity的鸭子类。下半部分介绍鸭子对象的进阶用法，并简单介绍由鸭子对象思想衍生出的`依赖注入`，实现一个demo。\n\n---\n\n# 被误解了的面向对象\n\nSmalltalk之父或者说面向对象之父（之一）的**Alan Kay**曾写过：\n\n> I'm sorry that I long ago coined the term \"objects\" for this topic because it gets many people to focus on the lesser idea. The big idea is \"messaging\" - that is what the kernal of Smalltalk/Squeak is all about.\n\n面向对象的思想的核心并不在于`object`或者`class`，而在于`message`，或者说**对象和类只是消息的载体**。面向对象思想将程序按功能和逻辑分成了若干个类，每个类包含自己的代码、功能实现并提供对外接口，以黑箱模式运行，使得外部无需了解内部而协同使用，分解了复杂度并控制在一个个较小规模中，以消息作为其间所有的协作方式。\n回到主题，理解了message才是全部，鸭子对象又可以更近一层，试想下整个程序，每个类除了知道自己的类之外其他类名一无所知，全部通过协议发消息：\n\n``` objc\n- (void)schoolWillStart:(id<School>)school\n{\n    id<Teacher> teacher = school.teacher;\n    for (id<Student> student in scholl.allStudents) {\n        [student handIn:student.homework to:teacher];\n    }\n}\n```\n\n----\n\n# Json Entity的重构\n\n回想上一篇中的JSON Entity类：\n\n``` objc\n// XXDuckEntity.h\n@interface XXDuckEntity : NSProxy\n- (instancetype)initWithJSONString:(NSString *)json;\n@end\n```\n\n干嘛caller要知道有这么个`Class`存在呢？它关心的只是能用哪些message通信而已。于是把类声明移动到`.m`中，简化成一个C的创建方法（类工厂方法同样会暴露类名）：  \n\n``` objc\n// XXDuckEntity.h\nextern id XXDuckEntityCreateWithJSON(NSString *json);\n// XXDuckEntity.m\nid XXDuckEntityCreateWithJSON(NSString *json)\n{\n    return [[XXDuckEntity alloc] initWithJSONString:json];\n}\n```\n\n如果这个类需要提供其他message接口供caller使用，则：  \n\n``` objc\n@protocol XXDuckEntity <NSObject, NSCopying, NSCoding>\n@property (nonatomic, copy, readonly) NSString *jsonString;\n- (void)foo;\n@end\nextern id/*<XXDuckEntity>*/ XXDuckEntityCreateWithJSON(NSString *json);\n```\n\n`<XXDuckEntity>`被注释掉是因为真实使用场景会造成类型不匹配造成编译警告，所以caller使用起来：\n\n\n``` objc\nNSString *json = @\"{\\\"name\\\": \\\"sunnyxx\\\", \\\"sex\\\": \\\"boy\\\", \\\"age\\\": 24}\";\nid<XXDuckEntity, XXUserEntity> entity= XXDuckEntityCreateWithJSON(json);\nid<XXUserEntity> copied = [entity copy];\nNSLog(@\"%@, %@, %@\", copied.jsonString, copied.name, copied.age);\n```\n\n这样重构的鸭子对象不仅隐藏了内部实现是个字典的事实，连它究竟是什么Class都隐藏了，但程序运行并无影响，骗一骗编译器罢了。不过这个思路的改变确引出另一个技术思路，那就是`依赖注入`。\n\n----  \n\n# 依赖注入\n\n`Dependency Injection`，简称`DI`，其实在这个场景下叫`动态实现注入`更合适。它的思想是将一个“对象”分成三部分，**protocol**、**proxy**和**implementation**，试想有两个协议，他们定义了彼此间该如何发送message：\n![](http://ww1.sinaimg.cn/bmiddle/51530583jw1ejqir7ys6zj20lu04ywes.jpg)\n运行时他们都是由proxy对象扮演：  \n![](http://ww3.sinaimg.cn/bmiddle/51530583jw1ejqj0qchl2j20m009eq3k.jpg)\n但DI Proxy并不能响应任何message，真正的实现是动态被“注入”到Proxy中的：  \n![](http://ww3.sinaimg.cn/bmiddle/51530583jw1ejqj6c7uqrj20l60dw75f.jpg)\n由于调用层只有协议没有类名，所以`Implement A`实现类并不依赖`Implement B`，就像贩毒团伙的两方只靠小弟来交易，完全不知道幕后大哥是谁，这就是所谓的“面向接口编程”吧。  \n\n## Let's demo it  \n\n重点在实现这个Proxy类，按照刚才重构Json Entity类的思路，头文件定义十分精简：  \n\n``` objc\n// XXDIProxy.h\n@protocol XXDIProxy <NSObject>\n- (void)injectDependencyObject:(id)object forProtocol:(Protocol *)protocol;\n@end\nextern id/*<XXDIProxy>*/ XXDIProxyCreate();\n```\n\n既然都叫Proxy了，再不使用`NSProxy`类都对不起它了。这个类使用一个字典来存储被注入的实现对象，以及与protocol的对应关系：\n\n``` objc\n// XXDIProxy.m 这是个私有类\n@interface XXDIProxy : NSProxy <XXDIProxy>\n@property (nonatomic, strong) NSMutableDictionary *implementations;\n- (id)init;\n@end\n```\n\n实现`<XXDIProxy>`协议内容：  \n\n``` objc\n// XXDIProxy.m\n- (void)injectDependencyObject:(id)object forProtocol:(Protocol *)protocol\n{\n    NSParameterAssert(object && protocol);\n    NSAssert([object conformsToProtocol:protocol], @\"object %@ does not conform to protocol: %@\", object, protocol);\n    self.implementations[NSStringFromProtocol(protocol)] = object;\n}\n```\n\n关键步骤还是消息转发，非常简单，把收到的消息转发给能处理的implementation对象（如果用NSObject的`forwardingTargetForSelector`将更加简单）：  \n\n``` objc\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel\n{\n    for (id object in self.implementations.allValues) {\n        if ([object respondsToSelector:sel]) {\n            return [object methodSignatureForSelector:sel];\n        }\n    }\n    return [super methodSignatureForSelector:sel];\n}\n- (void)forwardInvocation:(NSInvocation *)invocation\n{\n    for (id object in self.implementations.allValues) {\n        if ([object respondsToSelector:invocation.selector]) {\n            [invocation invokeWithTarget:object];\n            return;\n        }\n    }\n    [super forwardInvocation:invocation];\n}\n```\n\n有了Proxy类，下面是另外两个角色的测试代码，协议：    \n\n``` objc\n@protocol XXGirlFriend <NSObject>\n- (void)kiss;\n@end\n```\n\n实现类（汉字是可以正常编译运行的- -）：  \n\n``` objc\n@interface 林志玲 : NSObject <XXGirlFriend>\n@end\n@interface 凤姐 : NSObject <XXGirlFriend>\n@end\n```\n\n测试代码：  \n\n``` objc\n林志玲 *implementA = [林志玲 new];\n凤姐 *implementB = [凤姐 new];\n\nid<XXDIProxy, XXGirlFriend> gf = XXDIProxyCreate();\n[gf injectDependencyObject:implementA forProtocol:@protocol(XXGirlFriend)];\n[gf kiss]; // Log: 林志玲 kissed me\n[gf injectDependencyObject:implementB forProtocol:@protocol(XXGirlFriend)];\n[gf kiss]; // Log: 凤姐 kissed me\n```\n\n这个简单的demo就完成了。\n这个demo的`源码`可以[->从这里下载<-](https://github.com/sunnyxx/XXDuckDemo)，have fun.\n\n---\n\n# 我是后语\n\n现在有一个完整的依赖注入框架[typhoon](http://www.typhoonframework.org/)，感兴趣的可以把玩一下。  \n依赖注入不仅可以解耦依赖关系，也可以更好的Test和Mock，想测试某个对象只需要将实现对象注入成Test对象，想造假数据只需要将response对象替换成一个Mock对象，无需修改调用代码，天然不刺激~  \n\n_PS： 实际使用中可不要过度设计哦。。。_\n\n---\n\n# Reference\n\nhttp://c2.com/cgi/wiki?AlanKayOnMessaging\nhttp://www.typhoonframework.org/\n","source":"_posts/objc-duck-advanced.md","raw":"title: objc与鸭子对象（下）\ndate: 2014-08-26 22:26:56\ntags: ios最佳实践\n---\n\n# 我是前言\n这是《objc与鸭子对象》的下半部分，[《objc与鸭子对象（上）》](http://blog.sunnyxx.com/2014/08/24/objc-duck/)中介绍了鸭子类型和它在objc中的实践，以及一个使用NSProxy实现JSON Entity的鸭子类。下半部分介绍鸭子对象的进阶用法，并简单介绍由鸭子对象思想衍生出的`依赖注入`，实现一个demo。\n\n---\n\n# 被误解了的面向对象\n\nSmalltalk之父或者说面向对象之父（之一）的**Alan Kay**曾写过：\n\n> I'm sorry that I long ago coined the term \"objects\" for this topic because it gets many people to focus on the lesser idea. The big idea is \"messaging\" - that is what the kernal of Smalltalk/Squeak is all about.\n\n面向对象的思想的核心并不在于`object`或者`class`，而在于`message`，或者说**对象和类只是消息的载体**。面向对象思想将程序按功能和逻辑分成了若干个类，每个类包含自己的代码、功能实现并提供对外接口，以黑箱模式运行，使得外部无需了解内部而协同使用，分解了复杂度并控制在一个个较小规模中，以消息作为其间所有的协作方式。\n回到主题，理解了message才是全部，鸭子对象又可以更近一层，试想下整个程序，每个类除了知道自己的类之外其他类名一无所知，全部通过协议发消息：\n\n``` objc\n- (void)schoolWillStart:(id<School>)school\n{\n    id<Teacher> teacher = school.teacher;\n    for (id<Student> student in scholl.allStudents) {\n        [student handIn:student.homework to:teacher];\n    }\n}\n```\n\n----\n\n# Json Entity的重构\n\n回想上一篇中的JSON Entity类：\n\n``` objc\n// XXDuckEntity.h\n@interface XXDuckEntity : NSProxy\n- (instancetype)initWithJSONString:(NSString *)json;\n@end\n```\n\n干嘛caller要知道有这么个`Class`存在呢？它关心的只是能用哪些message通信而已。于是把类声明移动到`.m`中，简化成一个C的创建方法（类工厂方法同样会暴露类名）：  \n\n``` objc\n// XXDuckEntity.h\nextern id XXDuckEntityCreateWithJSON(NSString *json);\n// XXDuckEntity.m\nid XXDuckEntityCreateWithJSON(NSString *json)\n{\n    return [[XXDuckEntity alloc] initWithJSONString:json];\n}\n```\n\n如果这个类需要提供其他message接口供caller使用，则：  \n\n``` objc\n@protocol XXDuckEntity <NSObject, NSCopying, NSCoding>\n@property (nonatomic, copy, readonly) NSString *jsonString;\n- (void)foo;\n@end\nextern id/*<XXDuckEntity>*/ XXDuckEntityCreateWithJSON(NSString *json);\n```\n\n`<XXDuckEntity>`被注释掉是因为真实使用场景会造成类型不匹配造成编译警告，所以caller使用起来：\n\n\n``` objc\nNSString *json = @\"{\\\"name\\\": \\\"sunnyxx\\\", \\\"sex\\\": \\\"boy\\\", \\\"age\\\": 24}\";\nid<XXDuckEntity, XXUserEntity> entity= XXDuckEntityCreateWithJSON(json);\nid<XXUserEntity> copied = [entity copy];\nNSLog(@\"%@, %@, %@\", copied.jsonString, copied.name, copied.age);\n```\n\n这样重构的鸭子对象不仅隐藏了内部实现是个字典的事实，连它究竟是什么Class都隐藏了，但程序运行并无影响，骗一骗编译器罢了。不过这个思路的改变确引出另一个技术思路，那就是`依赖注入`。\n\n----  \n\n# 依赖注入\n\n`Dependency Injection`，简称`DI`，其实在这个场景下叫`动态实现注入`更合适。它的思想是将一个“对象”分成三部分，**protocol**、**proxy**和**implementation**，试想有两个协议，他们定义了彼此间该如何发送message：\n![](http://ww1.sinaimg.cn/bmiddle/51530583jw1ejqir7ys6zj20lu04ywes.jpg)\n运行时他们都是由proxy对象扮演：  \n![](http://ww3.sinaimg.cn/bmiddle/51530583jw1ejqj0qchl2j20m009eq3k.jpg)\n但DI Proxy并不能响应任何message，真正的实现是动态被“注入”到Proxy中的：  \n![](http://ww3.sinaimg.cn/bmiddle/51530583jw1ejqj6c7uqrj20l60dw75f.jpg)\n由于调用层只有协议没有类名，所以`Implement A`实现类并不依赖`Implement B`，就像贩毒团伙的两方只靠小弟来交易，完全不知道幕后大哥是谁，这就是所谓的“面向接口编程”吧。  \n\n## Let's demo it  \n\n重点在实现这个Proxy类，按照刚才重构Json Entity类的思路，头文件定义十分精简：  \n\n``` objc\n// XXDIProxy.h\n@protocol XXDIProxy <NSObject>\n- (void)injectDependencyObject:(id)object forProtocol:(Protocol *)protocol;\n@end\nextern id/*<XXDIProxy>*/ XXDIProxyCreate();\n```\n\n既然都叫Proxy了，再不使用`NSProxy`类都对不起它了。这个类使用一个字典来存储被注入的实现对象，以及与protocol的对应关系：\n\n``` objc\n// XXDIProxy.m 这是个私有类\n@interface XXDIProxy : NSProxy <XXDIProxy>\n@property (nonatomic, strong) NSMutableDictionary *implementations;\n- (id)init;\n@end\n```\n\n实现`<XXDIProxy>`协议内容：  \n\n``` objc\n// XXDIProxy.m\n- (void)injectDependencyObject:(id)object forProtocol:(Protocol *)protocol\n{\n    NSParameterAssert(object && protocol);\n    NSAssert([object conformsToProtocol:protocol], @\"object %@ does not conform to protocol: %@\", object, protocol);\n    self.implementations[NSStringFromProtocol(protocol)] = object;\n}\n```\n\n关键步骤还是消息转发，非常简单，把收到的消息转发给能处理的implementation对象（如果用NSObject的`forwardingTargetForSelector`将更加简单）：  \n\n``` objc\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel\n{\n    for (id object in self.implementations.allValues) {\n        if ([object respondsToSelector:sel]) {\n            return [object methodSignatureForSelector:sel];\n        }\n    }\n    return [super methodSignatureForSelector:sel];\n}\n- (void)forwardInvocation:(NSInvocation *)invocation\n{\n    for (id object in self.implementations.allValues) {\n        if ([object respondsToSelector:invocation.selector]) {\n            [invocation invokeWithTarget:object];\n            return;\n        }\n    }\n    [super forwardInvocation:invocation];\n}\n```\n\n有了Proxy类，下面是另外两个角色的测试代码，协议：    \n\n``` objc\n@protocol XXGirlFriend <NSObject>\n- (void)kiss;\n@end\n```\n\n实现类（汉字是可以正常编译运行的- -）：  \n\n``` objc\n@interface 林志玲 : NSObject <XXGirlFriend>\n@end\n@interface 凤姐 : NSObject <XXGirlFriend>\n@end\n```\n\n测试代码：  \n\n``` objc\n林志玲 *implementA = [林志玲 new];\n凤姐 *implementB = [凤姐 new];\n\nid<XXDIProxy, XXGirlFriend> gf = XXDIProxyCreate();\n[gf injectDependencyObject:implementA forProtocol:@protocol(XXGirlFriend)];\n[gf kiss]; // Log: 林志玲 kissed me\n[gf injectDependencyObject:implementB forProtocol:@protocol(XXGirlFriend)];\n[gf kiss]; // Log: 凤姐 kissed me\n```\n\n这个简单的demo就完成了。\n这个demo的`源码`可以[->从这里下载<-](https://github.com/sunnyxx/XXDuckDemo)，have fun.\n\n---\n\n# 我是后语\n\n现在有一个完整的依赖注入框架[typhoon](http://www.typhoonframework.org/)，感兴趣的可以把玩一下。  \n依赖注入不仅可以解耦依赖关系，也可以更好的Test和Mock，想测试某个对象只需要将实现对象注入成Test对象，想造假数据只需要将response对象替换成一个Mock对象，无需修改调用代码，天然不刺激~  \n\n_PS： 实际使用中可不要过度设计哦。。。_\n\n---\n\n# Reference\n\nhttp://c2.com/cgi/wiki?AlanKayOnMessaging\nhttp://www.typhoonframework.org/\n","slug":"objc-duck-advanced","published":1,"updated":"2016-03-27T08:18:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxlk001cev128hqmeqfj","content":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>这是《objc与鸭子对象》的下半部分，<a href=\"http://blog.sunnyxx.com/2014/08/24/objc-duck/\">《objc与鸭子对象（上）》</a>中介绍了鸭子类型和它在objc中的实践，以及一个使用NSProxy实现JSON Entity的鸭子类。下半部分介绍鸭子对象的进阶用法，并简单介绍由鸭子对象思想衍生出的<code>依赖注入</code>，实现一个demo。</p>\n<hr>\n<h1 id=\"被误解了的面向对象\"><a href=\"#被误解了的面向对象\" class=\"headerlink\" title=\"被误解了的面向对象\"></a>被误解了的面向对象</h1><p>Smalltalk之父或者说面向对象之父（之一）的<strong>Alan Kay</strong>曾写过：</p>\n<blockquote>\n<p>I’m sorry that I long ago coined the term “objects” for this topic because it gets many people to focus on the lesser idea. The big idea is “messaging” - that is what the kernal of Smalltalk/Squeak is all about.</p>\n</blockquote>\n<p>面向对象的思想的核心并不在于<code>object</code>或者<code>class</code>，而在于<code>message</code>，或者说<strong>对象和类只是消息的载体</strong>。面向对象思想将程序按功能和逻辑分成了若干个类，每个类包含自己的代码、功能实现并提供对外接口，以黑箱模式运行，使得外部无需了解内部而协同使用，分解了复杂度并控制在一个个较小规模中，以消息作为其间所有的协作方式。<br>回到主题，理解了message才是全部，鸭子对象又可以更近一层，试想下整个程序，每个类除了知道自己的类之外其他类名一无所知，全部通过协议发消息：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)schoolWillStart:(<span class=\"keyword\">id</span>&lt;School&gt;)school</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">id</span>&lt;Teacher&gt; teacher = school.teacher;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">id</span>&lt;Student&gt; student <span class=\"keyword\">in</span> scholl.allStudents) &#123;</span><br><span class=\"line\">        [student handIn:student.homework to:teacher];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"Json-Entity的重构\"><a href=\"#Json-Entity的重构\" class=\"headerlink\" title=\"Json Entity的重构\"></a>Json Entity的重构</h1><p>回想上一篇中的JSON Entity类：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// XXDuckEntity.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">XXDuckEntity</span> : <span class=\"title\">NSProxy</span></span></span><br><span class=\"line\">- (instancetype)initWithJSO<span class=\"built_in\">NString</span>:(<span class=\"built_in\">NSString</span> *)json;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>干嘛caller要知道有这么个<code>Class</code>存在呢？它关心的只是能用哪些message通信而已。于是把类声明移动到<code>.m</code>中，简化成一个C的创建方法（类工厂方法同样会暴露类名）：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// XXDuckEntity.h</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">id</span> XXDuckEntityCreateWithJSON(<span class=\"built_in\">NSString</span> *json);</span><br><span class=\"line\"><span class=\"comment\">// XXDuckEntity.m</span></span><br><span class=\"line\"><span class=\"keyword\">id</span> XXDuckEntityCreateWithJSON(<span class=\"built_in\">NSString</span> *json)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[XXDuckEntity alloc] initWithJSO<span class=\"built_in\">NString</span>:json];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果这个类需要提供其他message接口供caller使用，则：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">XXDuckEntity</span> &lt;<span class=\"title\">NSObject</span>, <span class=\"title\">NSCopying</span>, <span class=\"title\">NSCoding</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *jsonString;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)foo;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">id</span><span class=\"comment\">/*&lt;XXDuckEntity&gt;*/</span> XXDuckEntityCreateWithJSON(<span class=\"built_in\">NSString</span> *json);</span><br></pre></td></tr></table></figure>\n<p><code>&lt;XXDuckEntity&gt;</code>被注释掉是因为真实使用场景会造成类型不匹配造成编译警告，所以caller使用起来：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *json = <span class=\"string\">@\"&#123;\\\"name\\\": \\\"sunnyxx\\\", \\\"sex\\\": \\\"boy\\\", \\\"age\\\": 24&#125;\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">id</span>&lt;XXDuckEntity, XXUserEntity&gt; entity= XXDuckEntityCreateWithJSON(json);</span><br><span class=\"line\"><span class=\"keyword\">id</span>&lt;XXUserEntity&gt; copied = [entity <span class=\"keyword\">copy</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@, %@, %@\"</span>, copied.jsonString, copied.name, copied.age);</span><br></pre></td></tr></table></figure>\n<p>这样重构的鸭子对象不仅隐藏了内部实现是个字典的事实，连它究竟是什么Class都隐藏了，但程序运行并无影响，骗一骗编译器罢了。不过这个思路的改变确引出另一个技术思路，那就是<code>依赖注入</code>。</p>\n<hr>\n<h1 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h1><p><code>Dependency Injection</code>，简称<code>DI</code>，其实在这个场景下叫<code>动态实现注入</code>更合适。它的思想是将一个“对象”分成三部分，<strong>protocol</strong>、<strong>proxy</strong>和<strong>implementation</strong>，试想有两个协议，他们定义了彼此间该如何发送message：<br><img src=\"http://ww1.sinaimg.cn/bmiddle/51530583jw1ejqir7ys6zj20lu04ywes.jpg\" alt=\"\"><br>运行时他们都是由proxy对象扮演：<br><img src=\"http://ww3.sinaimg.cn/bmiddle/51530583jw1ejqj0qchl2j20m009eq3k.jpg\" alt=\"\"><br>但DI Proxy并不能响应任何message，真正的实现是动态被“注入”到Proxy中的：<br><img src=\"http://ww3.sinaimg.cn/bmiddle/51530583jw1ejqj6c7uqrj20l60dw75f.jpg\" alt=\"\"><br>由于调用层只有协议没有类名，所以<code>Implement A</code>实现类并不依赖<code>Implement B</code>，就像贩毒团伙的两方只靠小弟来交易，完全不知道幕后大哥是谁，这就是所谓的“面向接口编程”吧。  </p>\n<h2 id=\"Let’s-demo-it\"><a href=\"#Let’s-demo-it\" class=\"headerlink\" title=\"Let’s demo it\"></a>Let’s demo it</h2><p>重点在实现这个Proxy类，按照刚才重构Json Entity类的思路，头文件定义十分精简：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// XXDIProxy.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">XXDIProxy</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)injectDependencyObject:(<span class=\"keyword\">id</span>)object forProtocol:(Protocol *)protocol;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">id</span><span class=\"comment\">/*&lt;XXDIProxy&gt;*/</span> XXDIProxyCreate();</span><br></pre></td></tr></table></figure>\n<p>既然都叫Proxy了，再不使用<code>NSProxy</code>类都对不起它了。这个类使用一个字典来存储被注入的实现对象，以及与protocol的对应关系：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// XXDIProxy.m 这是个私有类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">XXDIProxy</span> : <span class=\"title\">NSProxy</span> &lt;<span class=\"title\">XXDIProxy</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableDictionary</span> *implementations;</span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>实现<code>&lt;XXDIProxy&gt;</code>协议内容：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// XXDIProxy.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)injectDependencyObject:(<span class=\"keyword\">id</span>)object forProtocol:(Protocol *)protocol</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSParameterAssert</span>(object &amp;&amp; protocol);</span><br><span class=\"line\">    <span class=\"built_in\">NSAssert</span>([object conformsToProtocol:protocol], <span class=\"string\">@\"object %@ does not conform to protocol: %@\"</span>, object, protocol);</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.implementations[<span class=\"built_in\">NSStringFromProtocol</span>(protocol)] = object;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关键步骤还是消息转发，非常简单，把收到的消息转发给能处理的implementation对象（如果用NSObject的<code>forwardingTargetForSelector</code>将更加简单）：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> object <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.implementations.allValues) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([object respondsToSelector:sel]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [object methodSignatureForSelector:sel];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> methodSignatureForSelector:sel];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)invocation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> object <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.implementations.allValues) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([object respondsToSelector:invocation.selector]) &#123;</span><br><span class=\"line\">            [invocation invokeWithTarget:object];</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> forwardInvocation:invocation];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有了Proxy类，下面是另外两个角色的测试代码，协议：    </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">XXGirlFriend</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)kiss;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>实现类（汉字是可以正常编译运行的- -）：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> 林志玲 : <span class=\"title\">NSObject</span> &lt;<span class=\"title\">XXGirlFriend</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> 凤姐 : <span class=\"title\">NSObject</span> &lt;<span class=\"title\">XXGirlFriend</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>测试代码：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">林志玲 *implementA = [林志玲 new];</span><br><span class=\"line\">凤姐 *implementB = [凤姐 new];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">id</span>&lt;XXDIProxy, XXGirlFriend&gt; gf = XXDIProxyCreate();</span><br><span class=\"line\">[gf injectDependencyObject:implementA forProtocol:<span class=\"class\"><span class=\"keyword\">@protocol</span>(<span class=\"title\">XXGirlFriend</span>)];</span></span><br><span class=\"line\">[gf kiss]; <span class=\"comment\">// Log: 林志玲 kissed me</span></span><br><span class=\"line\">[gf injectDependencyObject:implementB forProtocol:<span class=\"class\"><span class=\"keyword\">@protocol</span>(<span class=\"title\">XXGirlFriend</span>)];</span></span><br><span class=\"line\">[gf kiss]; <span class=\"comment\">// Log: 凤姐 kissed me</span></span><br></pre></td></tr></table></figure>\n<p>这个简单的demo就完成了。<br>这个demo的<code>源码</code>可以<a href=\"https://github.com/sunnyxx/XXDuckDemo\" target=\"_blank\" rel=\"external\">-&gt;从这里下载&lt;-</a>，have fun.</p>\n<hr>\n<h1 id=\"我是后语\"><a href=\"#我是后语\" class=\"headerlink\" title=\"我是后语\"></a>我是后语</h1><p>现在有一个完整的依赖注入框架<a href=\"http://www.typhoonframework.org/\" target=\"_blank\" rel=\"external\">typhoon</a>，感兴趣的可以把玩一下。<br>依赖注入不仅可以解耦依赖关系，也可以更好的Test和Mock，想测试某个对象只需要将实现对象注入成Test对象，想造假数据只需要将response对象替换成一个Mock对象，无需修改调用代码，天然不刺激~  </p>\n<p><em>PS： 实际使用中可不要过度设计哦。。。</em></p>\n<hr>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p><a href=\"http://c2.com/cgi/wiki?AlanKayOnMessaging\" target=\"_blank\" rel=\"external\">http://c2.com/cgi/wiki?AlanKayOnMessaging</a><br><a href=\"http://www.typhoonframework.org/\" target=\"_blank\" rel=\"external\">http://www.typhoonframework.org/</a></p>\n","excerpt":"","more":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>这是《objc与鸭子对象》的下半部分，<a href=\"http://blog.sunnyxx.com/2014/08/24/objc-duck/\">《objc与鸭子对象（上）》</a>中介绍了鸭子类型和它在objc中的实践，以及一个使用NSProxy实现JSON Entity的鸭子类。下半部分介绍鸭子对象的进阶用法，并简单介绍由鸭子对象思想衍生出的<code>依赖注入</code>，实现一个demo。</p>\n<hr>\n<h1 id=\"被误解了的面向对象\"><a href=\"#被误解了的面向对象\" class=\"headerlink\" title=\"被误解了的面向对象\"></a>被误解了的面向对象</h1><p>Smalltalk之父或者说面向对象之父（之一）的<strong>Alan Kay</strong>曾写过：</p>\n<blockquote>\n<p>I’m sorry that I long ago coined the term “objects” for this topic because it gets many people to focus on the lesser idea. The big idea is “messaging” - that is what the kernal of Smalltalk/Squeak is all about.</p>\n</blockquote>\n<p>面向对象的思想的核心并不在于<code>object</code>或者<code>class</code>，而在于<code>message</code>，或者说<strong>对象和类只是消息的载体</strong>。面向对象思想将程序按功能和逻辑分成了若干个类，每个类包含自己的代码、功能实现并提供对外接口，以黑箱模式运行，使得外部无需了解内部而协同使用，分解了复杂度并控制在一个个较小规模中，以消息作为其间所有的协作方式。<br>回到主题，理解了message才是全部，鸭子对象又可以更近一层，试想下整个程序，每个类除了知道自己的类之外其他类名一无所知，全部通过协议发消息：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)schoolWillStart:(<span class=\"keyword\">id</span>&lt;School&gt;)school</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">id</span>&lt;Teacher&gt; teacher = school.teacher;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">id</span>&lt;Student&gt; student <span class=\"keyword\">in</span> scholl.allStudents) &#123;</span><br><span class=\"line\">        [student handIn:student.homework to:teacher];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"Json-Entity的重构\"><a href=\"#Json-Entity的重构\" class=\"headerlink\" title=\"Json Entity的重构\"></a>Json Entity的重构</h1><p>回想上一篇中的JSON Entity类：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// XXDuckEntity.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">XXDuckEntity</span> : <span class=\"title\">NSProxy</span></span></span><br><span class=\"line\">- (instancetype)initWithJSO<span class=\"built_in\">NString</span>:(<span class=\"built_in\">NSString</span> *)json;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>干嘛caller要知道有这么个<code>Class</code>存在呢？它关心的只是能用哪些message通信而已。于是把类声明移动到<code>.m</code>中，简化成一个C的创建方法（类工厂方法同样会暴露类名）：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// XXDuckEntity.h</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">id</span> XXDuckEntityCreateWithJSON(<span class=\"built_in\">NSString</span> *json);</span><br><span class=\"line\"><span class=\"comment\">// XXDuckEntity.m</span></span><br><span class=\"line\"><span class=\"keyword\">id</span> XXDuckEntityCreateWithJSON(<span class=\"built_in\">NSString</span> *json)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[XXDuckEntity alloc] initWithJSO<span class=\"built_in\">NString</span>:json];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果这个类需要提供其他message接口供caller使用，则：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">XXDuckEntity</span> &lt;<span class=\"title\">NSObject</span>, <span class=\"title\">NSCopying</span>, <span class=\"title\">NSCoding</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *jsonString;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)foo;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">id</span><span class=\"comment\">/*&lt;XXDuckEntity&gt;*/</span> XXDuckEntityCreateWithJSON(<span class=\"built_in\">NSString</span> *json);</span><br></pre></td></tr></table></figure>\n<p><code>&lt;XXDuckEntity&gt;</code>被注释掉是因为真实使用场景会造成类型不匹配造成编译警告，所以caller使用起来：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *json = <span class=\"string\">@\"&#123;\\\"name\\\": \\\"sunnyxx\\\", \\\"sex\\\": \\\"boy\\\", \\\"age\\\": 24&#125;\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">id</span>&lt;XXDuckEntity, XXUserEntity&gt; entity= XXDuckEntityCreateWithJSON(json);</span><br><span class=\"line\"><span class=\"keyword\">id</span>&lt;XXUserEntity&gt; copied = [entity <span class=\"keyword\">copy</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@, %@, %@\"</span>, copied.jsonString, copied.name, copied.age);</span><br></pre></td></tr></table></figure>\n<p>这样重构的鸭子对象不仅隐藏了内部实现是个字典的事实，连它究竟是什么Class都隐藏了，但程序运行并无影响，骗一骗编译器罢了。不过这个思路的改变确引出另一个技术思路，那就是<code>依赖注入</code>。</p>\n<hr>\n<h1 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h1><p><code>Dependency Injection</code>，简称<code>DI</code>，其实在这个场景下叫<code>动态实现注入</code>更合适。它的思想是将一个“对象”分成三部分，<strong>protocol</strong>、<strong>proxy</strong>和<strong>implementation</strong>，试想有两个协议，他们定义了彼此间该如何发送message：<br><img src=\"http://ww1.sinaimg.cn/bmiddle/51530583jw1ejqir7ys6zj20lu04ywes.jpg\" alt=\"\"><br>运行时他们都是由proxy对象扮演：<br><img src=\"http://ww3.sinaimg.cn/bmiddle/51530583jw1ejqj0qchl2j20m009eq3k.jpg\" alt=\"\"><br>但DI Proxy并不能响应任何message，真正的实现是动态被“注入”到Proxy中的：<br><img src=\"http://ww3.sinaimg.cn/bmiddle/51530583jw1ejqj6c7uqrj20l60dw75f.jpg\" alt=\"\"><br>由于调用层只有协议没有类名，所以<code>Implement A</code>实现类并不依赖<code>Implement B</code>，就像贩毒团伙的两方只靠小弟来交易，完全不知道幕后大哥是谁，这就是所谓的“面向接口编程”吧。  </p>\n<h2 id=\"Let’s-demo-it\"><a href=\"#Let’s-demo-it\" class=\"headerlink\" title=\"Let’s demo it\"></a>Let’s demo it</h2><p>重点在实现这个Proxy类，按照刚才重构Json Entity类的思路，头文件定义十分精简：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// XXDIProxy.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">XXDIProxy</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)injectDependencyObject:(<span class=\"keyword\">id</span>)object forProtocol:(Protocol *)protocol;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">id</span><span class=\"comment\">/*&lt;XXDIProxy&gt;*/</span> XXDIProxyCreate();</span><br></pre></td></tr></table></figure>\n<p>既然都叫Proxy了，再不使用<code>NSProxy</code>类都对不起它了。这个类使用一个字典来存储被注入的实现对象，以及与protocol的对应关系：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// XXDIProxy.m 这是个私有类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">XXDIProxy</span> : <span class=\"title\">NSProxy</span> &lt;<span class=\"title\">XXDIProxy</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableDictionary</span> *implementations;</span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>实现<code>&lt;XXDIProxy&gt;</code>协议内容：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// XXDIProxy.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)injectDependencyObject:(<span class=\"keyword\">id</span>)object forProtocol:(Protocol *)protocol</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSParameterAssert</span>(object &amp;&amp; protocol);</span><br><span class=\"line\">    <span class=\"built_in\">NSAssert</span>([object conformsToProtocol:protocol], <span class=\"string\">@\"object %@ does not conform to protocol: %@\"</span>, object, protocol);</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.implementations[<span class=\"built_in\">NSStringFromProtocol</span>(protocol)] = object;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关键步骤还是消息转发，非常简单，把收到的消息转发给能处理的implementation对象（如果用NSObject的<code>forwardingTargetForSelector</code>将更加简单）：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> object <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.implementations.allValues) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([object respondsToSelector:sel]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [object methodSignatureForSelector:sel];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> methodSignatureForSelector:sel];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)invocation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> object <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.implementations.allValues) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([object respondsToSelector:invocation.selector]) &#123;</span><br><span class=\"line\">            [invocation invokeWithTarget:object];</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> forwardInvocation:invocation];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有了Proxy类，下面是另外两个角色的测试代码，协议：    </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">XXGirlFriend</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)kiss;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>实现类（汉字是可以正常编译运行的- -）：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> 林志玲 : <span class=\"title\">NSObject</span> &lt;<span class=\"title\">XXGirlFriend</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> 凤姐 : <span class=\"title\">NSObject</span> &lt;<span class=\"title\">XXGirlFriend</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>测试代码：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">林志玲 *implementA = [林志玲 new];</span><br><span class=\"line\">凤姐 *implementB = [凤姐 new];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">id</span>&lt;XXDIProxy, XXGirlFriend&gt; gf = XXDIProxyCreate();</span><br><span class=\"line\">[gf injectDependencyObject:implementA forProtocol:<span class=\"class\"><span class=\"keyword\">@protocol</span>(<span class=\"title\">XXGirlFriend</span>)];</span></span><br><span class=\"line\">[gf kiss]; <span class=\"comment\">// Log: 林志玲 kissed me</span></span><br><span class=\"line\">[gf injectDependencyObject:implementB forProtocol:<span class=\"class\"><span class=\"keyword\">@protocol</span>(<span class=\"title\">XXGirlFriend</span>)];</span></span><br><span class=\"line\">[gf kiss]; <span class=\"comment\">// Log: 凤姐 kissed me</span></span><br></pre></td></tr></table></figure>\n<p>这个简单的demo就完成了。<br>这个demo的<code>源码</code>可以<a href=\"https://github.com/sunnyxx/XXDuckDemo\">-&gt;从这里下载&lt;-</a>，have fun.</p>\n<hr>\n<h1 id=\"我是后语\"><a href=\"#我是后语\" class=\"headerlink\" title=\"我是后语\"></a>我是后语</h1><p>现在有一个完整的依赖注入框架<a href=\"http://www.typhoonframework.org/\">typhoon</a>，感兴趣的可以把玩一下。<br>依赖注入不仅可以解耦依赖关系，也可以更好的Test和Mock，想测试某个对象只需要将实现对象注入成Test对象，想造假数据只需要将response对象替换成一个Mock对象，无需修改调用代码，天然不刺激~  </p>\n<p><em>PS： 实际使用中可不要过度设计哦。。。</em></p>\n<hr>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p><a href=\"http://c2.com/cgi/wiki?AlanKayOnMessaging\">http://c2.com/cgi/wiki?AlanKayOnMessaging</a><br><a href=\"http://www.typhoonframework.org/\">http://www.typhoonframework.org/</a></p>\n"},{"title":"objc与鸭子对象（上）","date":"2014-08-24T10:09:40.000Z","_content":"\n这是《objc与鸭子对象》的上半部分，[《objc与鸭子对象（下）》](http://blog.sunnyxx.com/2014/08/26/objc-duck-advanced/)中介绍了鸭子类型的进阶用法、依赖注入以及demo。\n\n# 我是前言\n\n<img src=\"http://ww1.sinaimg.cn/mw690/51530583jw1ejqkwtxr1dj20rs0ijgo7.jpg\" width = \"300\"/>\n`鸭子类型`(Duck Type)即：**“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子”**，换成程序猿语言就是：**“当调用者知道这个对象能调用什么方法时，管它这个对象到底是什么类的实例呢”**。本文对objc中的鸭子类型对象进行简单探究，并用一个“只用一个类实现Json Entity”的小demo实践下这个思路的魔力。进阶篇请看下半部分。\n\n---\n\n\n# objc与鸭子类型\n\n## id类型是个大鸭子\n\n鸭子类型是动态语言的特性，编译时并不决定函数调用关系，说白了所有的类型声明都是给编译器看的。objc在动态和静态方面找到了不错的平衡，既保留了严格的静态检查也没破坏运行时的动态特性。\n我们知道，向一个objc对象（或Class）发消息，实际上就是沿着它的`isa`指针寻找真正函数地址，所以只要一个对象满足下面的结构，就可以对它发送消息：\n\n``` objc\nstruct objc_object {\n    Class isa;\n} *id;\n```\n\n也就是熟知的`id`类型，objc在语言层面先天就支持了这个基本的鸭子类型，我们可以将任意一个对象强转为id类型从而向它发送消息，就算它并不能响应这个消息，编译器也无从知晓。\n正如[这篇文章](http://www.informit.com/articles/article.aspx?p=1353396)中对objc对象的简短定义：`The best definition for a Smalltalk or Objective-C \"object\" is \"something that can respond to messages.` object并非一定是某个特定类型的实例，只要它能响应需要的消息就可以了。\n\n## 从@interface到@protocol\n\n正如objc先天支持的动态的`id`类型，`@protocol`为鸭子类型提供了编译时的强类型检查，实现了Cocoa中经典的鸭子类型使用场景：\n\n``` objc\n@property (nonatomic, assign) id <UITableViewDataSource> dataSource;\n@property (nonatomic, assign) id <UITableViewDelegate>   delegate;\n```\n\n利用鸭子类型设计的接口会给使用者更大的灵活度。同时`@protocol`可以用来建立`伪继承`关系  \n\n``` objc\n@protocol UIScrollViewDelegate<NSObject>\n@protocol UITableViewDelegate<NSObject, UIScrollViewDelegate>\n```\n\n`<NSObject>`协议的存在一方面是给`NSProxy`这样的其他根类使用，同时也给了鸭子协议类型一个根类型，正如给了大部分类一个NSObject根类一样。说个小插曲，由于objc中Class也是`id`类型，形如`id<UITableViewDataSource>`的鸭子类型是可以用Class对象来扮演的，只需要把实例方法替换成类方法，如：  \n\n\n``` objc\n@implementation DataSource\n+ (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {\n    return 0;\n}\n+ (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return 0;\n}\n@end\n```\n\n设置table view的data source：   \n\n``` objc\nself.tableView.dataSource = (Class<UITableViewDataSource>)[DataSource class];\n```\n\n这种非主流写法合法且运行正常，归功于objc中加号和减号方法在`@selector`中并未体现，在`@protocol`中也是形同虚设，这种代码我相信没人真的写，但确实能体现鸭子类型的灵活性。\n\n\n---  \n\n# [Demo]一个类实现Json Entity\n\n`Entity`对象表示某个**纯数据**的结构，如：  \n\n``` objc\n@interface XXUserEntity : NSObject\n@property (nonatomic, copy) NSString *name;\n@property (nonatomic, copy) NSString *sex;\n@property (nonatomic, assign) NSInteger age;\n// balabala....\n@end\n```\n\n实际开发中这种类往往对应着server端返回的一个JSON串，如：\n\n```\n{\"name\": \"sunnyxx\", \"sex\": \"boy\", \"age\": 24, ...}\n```\n\n解析这些映射是个纯重复工作，建类、写属性、解析...如今已经有[JSONModel](https://github.com/icanzilb/JSONModel)，[Mantle](https://github.com/Mantle/Mantle)等不错的框架帮忙。这个demo我们要用鸭子类型的思想去重新设计，把这些Entity类简化成一个鸭子类。\n\n由于上面的`UserEntity`类，只有属性的getter和setter，这正对应了`NSMutableDictionary`的`objectForKey:`和`setObjectForKey:`，同时，JSON数据也会解析成字典，这就完成了巧妙的对接，下面去实现这个类。\n\n真正干活的是一个字典，保证封装性和纯粹性，这个类直接使用`NSProxy`作为纯代理类，只暴露一个初始化方法就好了：\n\n``` objc\n// XXDuckEntity.h\n@interface XXDuckEntity : NSProxy\n- (instancetype)initWithJSONString:(NSString *)json;\n@end\n// XXDuckEntity.m\n@interface XXDuckEntity ()\n@property (nonatomic, strong) NSMutableDictionary *innerDictionary;\n@end\n```\n\n`NSProxy`默认是没有初始化方法的，也省去了去规避其他初始化方法的麻烦，为了简单直接初始化时就把json串解开成字典（暂不考虑json是个array）：\n\n``` objc\n- (instancetype)initWithJSONString:(NSString *)json\n{\n    NSData *data = [json dataUsingEncoding:NSUTF8StringEncoding];\n    id jsonObject = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:nil];\n    if ([jsonObject isKindOfClass:[NSDictionary class]]) {\n        self.innerDictionary = [jsonObject mutableCopy];\n    }\n    return self;\n}\n```\n\n`NSProxy`可以说除了重载消息转发机制外没有别的用法，这也是它被设计的初衷，自己什么都不干，转给代理对象就好。往这个proxy发消息是注定会走消息转发的，首先判断下是不是一个getter或setter的selector：  \n\n``` objc\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n{\n    SEL changedSelector = aSelector;\n    if ([self propertyNameScanFromGetterSelector:aSelector]) {\n        changedSelector = @selector(objectForKey:);\n    }\n    else if ([self propertyNameScanFromSetterSelector:aSelector]) {\n        changedSelector = @selector(setObject:forKey:);\n    }\n    return [[self.innerDictionary class] instanceMethodSignatureForSelector:changedSelector];\n}\n```\n\n签名替换成字典的两个方法后开始走转发，在这里设置参数和对内部字典的真正调用：   \n\n\n``` objc\n- (void)forwardInvocation:(NSInvocation *)invocation\n{\n    NSString *propertyName = nil;\n    // Try getter\n    propertyName = [self propertyNameScanFromGetterSelector:invocation.selector];\n    if (propertyName) {\n        invocation.selector = @selector(objectForKey:);\n        [invocation setArgument:&propertyName atIndex:2]; // self, _cmd, key\n        [invocation invokeWithTarget:self.innerDictionary];\n        return;\n    }\n    // Try setter\n    propertyName = [self propertyNameScanFromSetterSelector:invocation.selector];\n    if (propertyName) {\n        invocation.selector = @selector(setObject:forKey:);\n        [invocation setArgument:&propertyName atIndex:3]; // self, _cmd, obj, key\n        [invocation invokeWithTarget:self.innerDictionary];\n        return;\n    }\n    [super forwardInvocation:invocation];\n}\n```\n\n当然还有这两个必不可少的从getter和setter中获取属性名的Helper：  \n\n``` objc\n- (NSString *)propertyNameScanFromGetterSelector:(SEL)selector\n{\n    NSString *selectorName = NSStringFromSelector(selector);\n    NSUInteger parameterCount = [[selectorName componentsSeparatedByString:@\":\"] count] - 1;\n    if (parameterCount == 0) {\n        return selectorName;\n    }\n    return nil;\n}\n- (NSString *)propertyNameScanFromSetterSelector:(SEL)selector\n{\n    NSString *selectorName = NSStringFromSelector(selector);\n    NSUInteger parameterCount = [[selectorName componentsSeparatedByString:@\":\"] count] - 1;\n    if ([selectorName hasPrefix:@\"set\"] && parameterCount == 1) {\n        NSUInteger firstColonLocation = [selectorName rangeOfString:@\":\"].location;\n        return [selectorName substringWithRange:NSMakeRange(3, firstColonLocation - 3)].lowercaseString;\n    }\n    return nil;\n}\n```\n\n一个简单的鸭子Entity就完成了，之后所有的Entity都可以使用`@protocol`而非子类化的方式来定义，如：  \n\n``` objc\n@protocol XXUserEntity <NSObject>\n@property (nonatomic, copy) NSString *name;\n@property (nonatomic, copy) NSString *sex;\n@property (nonatomic, strong) NSNumber *age;\n@end\n@protocol XXStudentEntity <XXUserEntity>\n@property (nonatomic, copy) NSString *school;\n@property (nonatomic, copy) NSString *teacher;\n@end\n```\n\n当数据从网络层回来时，鸭子类型让这个对象用起来和真有这么个类没什么两样：   \n\n``` objc\n- (void)requestFinished:(XXDuckEntity<XXStudentEntity> *)student {\n    NSLog(@\"name: %@, school:%@\", student.name, student.school);\n}\n```\n\n至此，所有的entity被表示成了N个`<Protocol>`的`.h`文件加一个`XXDuckEntity`类，剩下的就靠想象力了。\n这个demo的源码将在[下半部分](http://blog.sunnyxx.com/2014/08/26/objc-duck-advanced/)之后给出\n\n---\n\n# Reference\nhttp://en.wikipedia.org/wiki/Duck_typing\nhttp://www.informit.com/articles/article.aspx?p=1353396   \nhttps://github.com/facebook/facebook-ios-sdk  \n","source":"_posts/objc-duck.md","raw":"title: objc与鸭子对象（上）\ndate: 2014-08-24 18:09:40\ntags: ios最佳实践\n---\n\n这是《objc与鸭子对象》的上半部分，[《objc与鸭子对象（下）》](http://blog.sunnyxx.com/2014/08/26/objc-duck-advanced/)中介绍了鸭子类型的进阶用法、依赖注入以及demo。\n\n# 我是前言\n\n<img src=\"http://ww1.sinaimg.cn/mw690/51530583jw1ejqkwtxr1dj20rs0ijgo7.jpg\" width = \"300\"/>\n`鸭子类型`(Duck Type)即：**“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子”**，换成程序猿语言就是：**“当调用者知道这个对象能调用什么方法时，管它这个对象到底是什么类的实例呢”**。本文对objc中的鸭子类型对象进行简单探究，并用一个“只用一个类实现Json Entity”的小demo实践下这个思路的魔力。进阶篇请看下半部分。\n\n---\n\n\n# objc与鸭子类型\n\n## id类型是个大鸭子\n\n鸭子类型是动态语言的特性，编译时并不决定函数调用关系，说白了所有的类型声明都是给编译器看的。objc在动态和静态方面找到了不错的平衡，既保留了严格的静态检查也没破坏运行时的动态特性。\n我们知道，向一个objc对象（或Class）发消息，实际上就是沿着它的`isa`指针寻找真正函数地址，所以只要一个对象满足下面的结构，就可以对它发送消息：\n\n``` objc\nstruct objc_object {\n    Class isa;\n} *id;\n```\n\n也就是熟知的`id`类型，objc在语言层面先天就支持了这个基本的鸭子类型，我们可以将任意一个对象强转为id类型从而向它发送消息，就算它并不能响应这个消息，编译器也无从知晓。\n正如[这篇文章](http://www.informit.com/articles/article.aspx?p=1353396)中对objc对象的简短定义：`The best definition for a Smalltalk or Objective-C \"object\" is \"something that can respond to messages.` object并非一定是某个特定类型的实例，只要它能响应需要的消息就可以了。\n\n## 从@interface到@protocol\n\n正如objc先天支持的动态的`id`类型，`@protocol`为鸭子类型提供了编译时的强类型检查，实现了Cocoa中经典的鸭子类型使用场景：\n\n``` objc\n@property (nonatomic, assign) id <UITableViewDataSource> dataSource;\n@property (nonatomic, assign) id <UITableViewDelegate>   delegate;\n```\n\n利用鸭子类型设计的接口会给使用者更大的灵活度。同时`@protocol`可以用来建立`伪继承`关系  \n\n``` objc\n@protocol UIScrollViewDelegate<NSObject>\n@protocol UITableViewDelegate<NSObject, UIScrollViewDelegate>\n```\n\n`<NSObject>`协议的存在一方面是给`NSProxy`这样的其他根类使用，同时也给了鸭子协议类型一个根类型，正如给了大部分类一个NSObject根类一样。说个小插曲，由于objc中Class也是`id`类型，形如`id<UITableViewDataSource>`的鸭子类型是可以用Class对象来扮演的，只需要把实例方法替换成类方法，如：  \n\n\n``` objc\n@implementation DataSource\n+ (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {\n    return 0;\n}\n+ (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return 0;\n}\n@end\n```\n\n设置table view的data source：   \n\n``` objc\nself.tableView.dataSource = (Class<UITableViewDataSource>)[DataSource class];\n```\n\n这种非主流写法合法且运行正常，归功于objc中加号和减号方法在`@selector`中并未体现，在`@protocol`中也是形同虚设，这种代码我相信没人真的写，但确实能体现鸭子类型的灵活性。\n\n\n---  \n\n# [Demo]一个类实现Json Entity\n\n`Entity`对象表示某个**纯数据**的结构，如：  \n\n``` objc\n@interface XXUserEntity : NSObject\n@property (nonatomic, copy) NSString *name;\n@property (nonatomic, copy) NSString *sex;\n@property (nonatomic, assign) NSInteger age;\n// balabala....\n@end\n```\n\n实际开发中这种类往往对应着server端返回的一个JSON串，如：\n\n```\n{\"name\": \"sunnyxx\", \"sex\": \"boy\", \"age\": 24, ...}\n```\n\n解析这些映射是个纯重复工作，建类、写属性、解析...如今已经有[JSONModel](https://github.com/icanzilb/JSONModel)，[Mantle](https://github.com/Mantle/Mantle)等不错的框架帮忙。这个demo我们要用鸭子类型的思想去重新设计，把这些Entity类简化成一个鸭子类。\n\n由于上面的`UserEntity`类，只有属性的getter和setter，这正对应了`NSMutableDictionary`的`objectForKey:`和`setObjectForKey:`，同时，JSON数据也会解析成字典，这就完成了巧妙的对接，下面去实现这个类。\n\n真正干活的是一个字典，保证封装性和纯粹性，这个类直接使用`NSProxy`作为纯代理类，只暴露一个初始化方法就好了：\n\n``` objc\n// XXDuckEntity.h\n@interface XXDuckEntity : NSProxy\n- (instancetype)initWithJSONString:(NSString *)json;\n@end\n// XXDuckEntity.m\n@interface XXDuckEntity ()\n@property (nonatomic, strong) NSMutableDictionary *innerDictionary;\n@end\n```\n\n`NSProxy`默认是没有初始化方法的，也省去了去规避其他初始化方法的麻烦，为了简单直接初始化时就把json串解开成字典（暂不考虑json是个array）：\n\n``` objc\n- (instancetype)initWithJSONString:(NSString *)json\n{\n    NSData *data = [json dataUsingEncoding:NSUTF8StringEncoding];\n    id jsonObject = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:nil];\n    if ([jsonObject isKindOfClass:[NSDictionary class]]) {\n        self.innerDictionary = [jsonObject mutableCopy];\n    }\n    return self;\n}\n```\n\n`NSProxy`可以说除了重载消息转发机制外没有别的用法，这也是它被设计的初衷，自己什么都不干，转给代理对象就好。往这个proxy发消息是注定会走消息转发的，首先判断下是不是一个getter或setter的selector：  \n\n``` objc\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n{\n    SEL changedSelector = aSelector;\n    if ([self propertyNameScanFromGetterSelector:aSelector]) {\n        changedSelector = @selector(objectForKey:);\n    }\n    else if ([self propertyNameScanFromSetterSelector:aSelector]) {\n        changedSelector = @selector(setObject:forKey:);\n    }\n    return [[self.innerDictionary class] instanceMethodSignatureForSelector:changedSelector];\n}\n```\n\n签名替换成字典的两个方法后开始走转发，在这里设置参数和对内部字典的真正调用：   \n\n\n``` objc\n- (void)forwardInvocation:(NSInvocation *)invocation\n{\n    NSString *propertyName = nil;\n    // Try getter\n    propertyName = [self propertyNameScanFromGetterSelector:invocation.selector];\n    if (propertyName) {\n        invocation.selector = @selector(objectForKey:);\n        [invocation setArgument:&propertyName atIndex:2]; // self, _cmd, key\n        [invocation invokeWithTarget:self.innerDictionary];\n        return;\n    }\n    // Try setter\n    propertyName = [self propertyNameScanFromSetterSelector:invocation.selector];\n    if (propertyName) {\n        invocation.selector = @selector(setObject:forKey:);\n        [invocation setArgument:&propertyName atIndex:3]; // self, _cmd, obj, key\n        [invocation invokeWithTarget:self.innerDictionary];\n        return;\n    }\n    [super forwardInvocation:invocation];\n}\n```\n\n当然还有这两个必不可少的从getter和setter中获取属性名的Helper：  \n\n``` objc\n- (NSString *)propertyNameScanFromGetterSelector:(SEL)selector\n{\n    NSString *selectorName = NSStringFromSelector(selector);\n    NSUInteger parameterCount = [[selectorName componentsSeparatedByString:@\":\"] count] - 1;\n    if (parameterCount == 0) {\n        return selectorName;\n    }\n    return nil;\n}\n- (NSString *)propertyNameScanFromSetterSelector:(SEL)selector\n{\n    NSString *selectorName = NSStringFromSelector(selector);\n    NSUInteger parameterCount = [[selectorName componentsSeparatedByString:@\":\"] count] - 1;\n    if ([selectorName hasPrefix:@\"set\"] && parameterCount == 1) {\n        NSUInteger firstColonLocation = [selectorName rangeOfString:@\":\"].location;\n        return [selectorName substringWithRange:NSMakeRange(3, firstColonLocation - 3)].lowercaseString;\n    }\n    return nil;\n}\n```\n\n一个简单的鸭子Entity就完成了，之后所有的Entity都可以使用`@protocol`而非子类化的方式来定义，如：  \n\n``` objc\n@protocol XXUserEntity <NSObject>\n@property (nonatomic, copy) NSString *name;\n@property (nonatomic, copy) NSString *sex;\n@property (nonatomic, strong) NSNumber *age;\n@end\n@protocol XXStudentEntity <XXUserEntity>\n@property (nonatomic, copy) NSString *school;\n@property (nonatomic, copy) NSString *teacher;\n@end\n```\n\n当数据从网络层回来时，鸭子类型让这个对象用起来和真有这么个类没什么两样：   \n\n``` objc\n- (void)requestFinished:(XXDuckEntity<XXStudentEntity> *)student {\n    NSLog(@\"name: %@, school:%@\", student.name, student.school);\n}\n```\n\n至此，所有的entity被表示成了N个`<Protocol>`的`.h`文件加一个`XXDuckEntity`类，剩下的就靠想象力了。\n这个demo的源码将在[下半部分](http://blog.sunnyxx.com/2014/08/26/objc-duck-advanced/)之后给出\n\n---\n\n# Reference\nhttp://en.wikipedia.org/wiki/Duck_typing\nhttp://www.informit.com/articles/article.aspx?p=1353396   \nhttps://github.com/facebook/facebook-ios-sdk  \n","slug":"objc-duck","published":1,"updated":"2016-03-27T08:18:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxln001eev12manxriwp","content":"<p>这是《objc与鸭子对象》的上半部分，<a href=\"http://blog.sunnyxx.com/2014/08/26/objc-duck-advanced/\">《objc与鸭子对象（下）》</a>中介绍了鸭子类型的进阶用法、依赖注入以及demo。</p>\n<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p><img src=\"http://ww1.sinaimg.cn/mw690/51530583jw1ejqkwtxr1dj20rs0ijgo7.jpg\" width=\"300\"><br><code>鸭子类型</code>(Duck Type)即：<strong>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子”</strong>，换成程序猿语言就是：<strong>“当调用者知道这个对象能调用什么方法时，管它这个对象到底是什么类的实例呢”</strong>。本文对objc中的鸭子类型对象进行简单探究，并用一个“只用一个类实现Json Entity”的小demo实践下这个思路的魔力。进阶篇请看下半部分。</p>\n<hr>\n<h1 id=\"objc与鸭子类型\"><a href=\"#objc与鸭子类型\" class=\"headerlink\" title=\"objc与鸭子类型\"></a>objc与鸭子类型</h1><h2 id=\"id类型是个大鸭子\"><a href=\"#id类型是个大鸭子\" class=\"headerlink\" title=\"id类型是个大鸭子\"></a>id类型是个大鸭子</h2><p>鸭子类型是动态语言的特性，编译时并不决定函数调用关系，说白了所有的类型声明都是给编译器看的。objc在动态和静态方面找到了不错的平衡，既保留了严格的静态检查也没破坏运行时的动态特性。<br>我们知道，向一个objc对象（或Class）发消息，实际上就是沿着它的<code>isa</code>指针寻找真正函数地址，所以只要一个对象满足下面的结构，就可以对它发送消息：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_object &#123;</span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">&#125; *<span class=\"keyword\">id</span>;</span><br></pre></td></tr></table></figure>\n<p>也就是熟知的<code>id</code>类型，objc在语言层面先天就支持了这个基本的鸭子类型，我们可以将任意一个对象强转为id类型从而向它发送消息，就算它并不能响应这个消息，编译器也无从知晓。<br>正如<a href=\"http://www.informit.com/articles/article.aspx?p=1353396\" target=\"_blank\" rel=\"external\">这篇文章</a>中对objc对象的简短定义：<code>The best definition for a Smalltalk or Objective-C &quot;object&quot; is &quot;something that can respond to messages.</code> object并非一定是某个特定类型的实例，只要它能响应需要的消息就可以了。</p>\n<h2 id=\"从-interface到-protocol\"><a href=\"#从-interface到-protocol\" class=\"headerlink\" title=\"从@interface到@protocol\"></a>从@interface到@protocol</h2><p>正如objc先天支持的动态的<code>id</code>类型，<code>@protocol</code>为鸭子类型提供了编译时的强类型检查，实现了Cocoa中经典的鸭子类型使用场景：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"keyword\">id</span> &lt;<span class=\"built_in\">UITableViewDataSource</span>&gt; dataSource;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"keyword\">id</span> &lt;<span class=\"built_in\">UITableViewDelegate</span>&gt;   delegate;</span><br></pre></td></tr></table></figure>\n<p>利用鸭子类型设计的接口会给使用者更大的灵活度。同时<code>@protocol</code>可以用来建立<code>伪继承</code>关系  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">UIScrollViewDelegate</span>&lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">UITableViewDelegate</span>&lt;<span class=\"title\">NSObject</span>, <span class=\"title\">UIScrollViewDelegate</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>&lt;NSObject&gt;</code>协议的存在一方面是给<code>NSProxy</code>这样的其他根类使用，同时也给了鸭子协议类型一个根类型，正如给了大部分类一个NSObject根类一样。说个小插曲，由于objc中Class也是<code>id</code>类型，形如<code>id&lt;UITableViewDataSource&gt;</code>的鸭子类型是可以用Class对象来扮演的，只需要把实例方法替换成类方法，如：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">DataSource</span></span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSInteger</span>)numberOfSectionsInTableView:(<span class=\"built_in\">UITableView</span> *)tableView &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSInteger</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView numberOfRowsInSection:(<span class=\"built_in\">NSInteger</span>)section &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>设置table view的data source：   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.tableView.dataSource = (Class&lt;<span class=\"built_in\">UITableViewDataSource</span>&gt;)[DataSource class];</span><br></pre></td></tr></table></figure>\n<p>这种非主流写法合法且运行正常，归功于objc中加号和减号方法在<code>@selector</code>中并未体现，在<code>@protocol</code>中也是形同虚设，这种代码我相信没人真的写，但确实能体现鸭子类型的灵活性。</p>\n<hr>\n<h1 id=\"Demo-一个类实现Json-Entity\"><a href=\"#Demo-一个类实现Json-Entity\" class=\"headerlink\" title=\"[Demo]一个类实现Json Entity\"></a>[Demo]一个类实现Json Entity</h1><p><code>Entity</code>对象表示某个<strong>纯数据</strong>的结构，如：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">XXUserEntity</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *sex;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSInteger</span> age;</span><br><span class=\"line\"><span class=\"comment\">// balabala....</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>实际开发中这种类往往对应着server端返回的一个JSON串，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;name&quot;: &quot;sunnyxx&quot;, &quot;sex&quot;: &quot;boy&quot;, &quot;age&quot;: 24, ...&#125;</span><br></pre></td></tr></table></figure>\n<p>解析这些映射是个纯重复工作，建类、写属性、解析…如今已经有<a href=\"https://github.com/icanzilb/JSONModel\" target=\"_blank\" rel=\"external\">JSONModel</a>，<a href=\"https://github.com/Mantle/Mantle\" target=\"_blank\" rel=\"external\">Mantle</a>等不错的框架帮忙。这个demo我们要用鸭子类型的思想去重新设计，把这些Entity类简化成一个鸭子类。</p>\n<p>由于上面的<code>UserEntity</code>类，只有属性的getter和setter，这正对应了<code>NSMutableDictionary</code>的<code>objectForKey:</code>和<code>setObjectForKey:</code>，同时，JSON数据也会解析成字典，这就完成了巧妙的对接，下面去实现这个类。</p>\n<p>真正干活的是一个字典，保证封装性和纯粹性，这个类直接使用<code>NSProxy</code>作为纯代理类，只暴露一个初始化方法就好了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// XXDuckEntity.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">XXDuckEntity</span> : <span class=\"title\">NSProxy</span></span></span><br><span class=\"line\">- (instancetype)initWithJSO<span class=\"built_in\">NString</span>:(<span class=\"built_in\">NSString</span> *)json;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"comment\">// XXDuckEntity.m</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">XXDuckEntity</span> ()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableDictionary</span> *innerDictionary;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p><code>NSProxy</code>默认是没有初始化方法的，也省去了去规避其他初始化方法的麻烦，为了简单直接初始化时就把json串解开成字典（暂不考虑json是个array）：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithJSO<span class=\"built_in\">NString</span>:(<span class=\"built_in\">NSString</span> *)json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSData</span> *data = [json dataUsingEncoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">    <span class=\"keyword\">id</span> jsonObject = [<span class=\"built_in\">NSJSONSerialization</span> JSONObjectWithData:data options:<span class=\"built_in\">NSJSONReadingAllowFragments</span> error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([jsonObject isKindOfClass:[<span class=\"built_in\">NSDictionary</span> class]]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.innerDictionary = [jsonObject mutableCopy];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>NSProxy</code>可以说除了重载消息转发机制外没有别的用法，这也是它被设计的初衷，自己什么都不干，转给代理对象就好。往这个proxy发消息是注定会走消息转发的，首先判断下是不是一个getter或setter的selector：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SEL changedSelector = aSelector;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> propertyNameScanFromGetterSelector:aSelector]) &#123;</span><br><span class=\"line\">        changedSelector = <span class=\"keyword\">@selector</span>(objectForKey:);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> propertyNameScanFromSetterSelector:aSelector]) &#123;</span><br><span class=\"line\">        changedSelector = <span class=\"keyword\">@selector</span>(setObject:forKey:);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[<span class=\"keyword\">self</span>.innerDictionary class] instanceMethodSignatureForSelector:changedSelector];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>签名替换成字典的两个方法后开始走转发，在这里设置参数和对内部字典的真正调用：   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)invocation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *propertyName = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Try getter</span></span><br><span class=\"line\">    propertyName = [<span class=\"keyword\">self</span> propertyNameScanFromGetterSelector:invocation.selector];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (propertyName) &#123;</span><br><span class=\"line\">        invocation.selector = <span class=\"keyword\">@selector</span>(objectForKey:);</span><br><span class=\"line\">        [invocation setArgument:&amp;propertyName atIndex:<span class=\"number\">2</span>]; <span class=\"comment\">// self, _cmd, key</span></span><br><span class=\"line\">        [invocation invokeWithTarget:<span class=\"keyword\">self</span>.innerDictionary];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Try setter</span></span><br><span class=\"line\">    propertyName = [<span class=\"keyword\">self</span> propertyNameScanFromSetterSelector:invocation.selector];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (propertyName) &#123;</span><br><span class=\"line\">        invocation.selector = <span class=\"keyword\">@selector</span>(setObject:forKey:);</span><br><span class=\"line\">        [invocation setArgument:&amp;propertyName atIndex:<span class=\"number\">3</span>]; <span class=\"comment\">// self, _cmd, obj, key</span></span><br><span class=\"line\">        [invocation invokeWithTarget:<span class=\"keyword\">self</span>.innerDictionary];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> forwardInvocation:invocation];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然还有这两个必不可少的从getter和setter中获取属性名的Helper：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)propertyNameScanFromGetterSelector:(SEL)selector</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *selectorName = <span class=\"built_in\">NSStringFromSelector</span>(selector);</span><br><span class=\"line\">    <span class=\"built_in\">NSUInteger</span> parameterCount = [[selectorName componentsSeparatedByString:<span class=\"string\">@\":\"</span>] count] - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parameterCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> selectorName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)propertyNameScanFromSetterSelector:(SEL)selector</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *selectorName = <span class=\"built_in\">NSStringFromSelector</span>(selector);</span><br><span class=\"line\">    <span class=\"built_in\">NSUInteger</span> parameterCount = [[selectorName componentsSeparatedByString:<span class=\"string\">@\":\"</span>] count] - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([selectorName hasPrefix:<span class=\"string\">@\"set\"</span>] &amp;&amp; parameterCount == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSUInteger</span> firstColonLocation = [selectorName rangeOfString:<span class=\"string\">@\":\"</span>].location;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [selectorName substringWithRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">3</span>, firstColonLocation - <span class=\"number\">3</span>)].lowercaseString;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个简单的鸭子Entity就完成了，之后所有的Entity都可以使用<code>@protocol</code>而非子类化的方式来定义，如：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">XXUserEntity</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *sex;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSNumber</span> *age;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">XXStudentEntity</span> &lt;<span class=\"title\">XXUserEntity</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *school;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *teacher;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>当数据从网络层回来时，鸭子类型让这个对象用起来和真有这么个类没什么两样：   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)requestFinished:(XXDuckEntity&lt;XXStudentEntity&gt; *)student &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"name: %@, school:%@\"</span>, student.name, student.school);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，所有的entity被表示成了N个<code>&lt;Protocol&gt;</code>的<code>.h</code>文件加一个<code>XXDuckEntity</code>类，剩下的就靠想象力了。<br>这个demo的源码将在<a href=\"http://blog.sunnyxx.com/2014/08/26/objc-duck-advanced/\">下半部分</a>之后给出</p>\n<hr>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p><a href=\"http://en.wikipedia.org/wiki/Duck_typing\" target=\"_blank\" rel=\"external\">http://en.wikipedia.org/wiki/Duck_typing</a><br><a href=\"http://www.informit.com/articles/article.aspx?p=1353396\" target=\"_blank\" rel=\"external\">http://www.informit.com/articles/article.aspx?p=1353396</a><br><a href=\"https://github.com/facebook/facebook-ios-sdk\" target=\"_blank\" rel=\"external\">https://github.com/facebook/facebook-ios-sdk</a>  </p>\n","excerpt":"","more":"<p>这是《objc与鸭子对象》的上半部分，<a href=\"http://blog.sunnyxx.com/2014/08/26/objc-duck-advanced/\">《objc与鸭子对象（下）》</a>中介绍了鸭子类型的进阶用法、依赖注入以及demo。</p>\n<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p><img src=\"http://ww1.sinaimg.cn/mw690/51530583jw1ejqkwtxr1dj20rs0ijgo7.jpg\" width = \"300\"/><br><code>鸭子类型</code>(Duck Type)即：<strong>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子”</strong>，换成程序猿语言就是：<strong>“当调用者知道这个对象能调用什么方法时，管它这个对象到底是什么类的实例呢”</strong>。本文对objc中的鸭子类型对象进行简单探究，并用一个“只用一个类实现Json Entity”的小demo实践下这个思路的魔力。进阶篇请看下半部分。</p>\n<hr>\n<h1 id=\"objc与鸭子类型\"><a href=\"#objc与鸭子类型\" class=\"headerlink\" title=\"objc与鸭子类型\"></a>objc与鸭子类型</h1><h2 id=\"id类型是个大鸭子\"><a href=\"#id类型是个大鸭子\" class=\"headerlink\" title=\"id类型是个大鸭子\"></a>id类型是个大鸭子</h2><p>鸭子类型是动态语言的特性，编译时并不决定函数调用关系，说白了所有的类型声明都是给编译器看的。objc在动态和静态方面找到了不错的平衡，既保留了严格的静态检查也没破坏运行时的动态特性。<br>我们知道，向一个objc对象（或Class）发消息，实际上就是沿着它的<code>isa</code>指针寻找真正函数地址，所以只要一个对象满足下面的结构，就可以对它发送消息：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_object &#123;</span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">&#125; *<span class=\"keyword\">id</span>;</span><br></pre></td></tr></table></figure>\n<p>也就是熟知的<code>id</code>类型，objc在语言层面先天就支持了这个基本的鸭子类型，我们可以将任意一个对象强转为id类型从而向它发送消息，就算它并不能响应这个消息，编译器也无从知晓。<br>正如<a href=\"http://www.informit.com/articles/article.aspx?p=1353396\">这篇文章</a>中对objc对象的简短定义：<code>The best definition for a Smalltalk or Objective-C &quot;object&quot; is &quot;something that can respond to messages.</code> object并非一定是某个特定类型的实例，只要它能响应需要的消息就可以了。</p>\n<h2 id=\"从-interface到-protocol\"><a href=\"#从-interface到-protocol\" class=\"headerlink\" title=\"从@interface到@protocol\"></a>从@interface到@protocol</h2><p>正如objc先天支持的动态的<code>id</code>类型，<code>@protocol</code>为鸭子类型提供了编译时的强类型检查，实现了Cocoa中经典的鸭子类型使用场景：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"keyword\">id</span> &lt;<span class=\"built_in\">UITableViewDataSource</span>&gt; dataSource;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"keyword\">id</span> &lt;<span class=\"built_in\">UITableViewDelegate</span>&gt;   delegate;</span><br></pre></td></tr></table></figure>\n<p>利用鸭子类型设计的接口会给使用者更大的灵活度。同时<code>@protocol</code>可以用来建立<code>伪继承</code>关系  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">UIScrollViewDelegate</span>&lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">UITableViewDelegate</span>&lt;<span class=\"title\">NSObject</span>, <span class=\"title\">UIScrollViewDelegate</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>&lt;NSObject&gt;</code>协议的存在一方面是给<code>NSProxy</code>这样的其他根类使用，同时也给了鸭子协议类型一个根类型，正如给了大部分类一个NSObject根类一样。说个小插曲，由于objc中Class也是<code>id</code>类型，形如<code>id&lt;UITableViewDataSource&gt;</code>的鸭子类型是可以用Class对象来扮演的，只需要把实例方法替换成类方法，如：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">DataSource</span></span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSInteger</span>)numberOfSectionsInTableView:(<span class=\"built_in\">UITableView</span> *)tableView &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSInteger</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView numberOfRowsInSection:(<span class=\"built_in\">NSInteger</span>)section &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>设置table view的data source：   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.tableView.dataSource = (Class&lt;<span class=\"built_in\">UITableViewDataSource</span>&gt;)[DataSource class];</span><br></pre></td></tr></table></figure>\n<p>这种非主流写法合法且运行正常，归功于objc中加号和减号方法在<code>@selector</code>中并未体现，在<code>@protocol</code>中也是形同虚设，这种代码我相信没人真的写，但确实能体现鸭子类型的灵活性。</p>\n<hr>\n<h1 id=\"Demo-一个类实现Json-Entity\"><a href=\"#Demo-一个类实现Json-Entity\" class=\"headerlink\" title=\"[Demo]一个类实现Json Entity\"></a>[Demo]一个类实现Json Entity</h1><p><code>Entity</code>对象表示某个<strong>纯数据</strong>的结构，如：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">XXUserEntity</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *sex;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSInteger</span> age;</span><br><span class=\"line\"><span class=\"comment\">// balabala....</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>实际开发中这种类往往对应着server端返回的一个JSON串，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;name&quot;: &quot;sunnyxx&quot;, &quot;sex&quot;: &quot;boy&quot;, &quot;age&quot;: 24, ...&#125;</span><br></pre></td></tr></table></figure>\n<p>解析这些映射是个纯重复工作，建类、写属性、解析…如今已经有<a href=\"https://github.com/icanzilb/JSONModel\">JSONModel</a>，<a href=\"https://github.com/Mantle/Mantle\">Mantle</a>等不错的框架帮忙。这个demo我们要用鸭子类型的思想去重新设计，把这些Entity类简化成一个鸭子类。</p>\n<p>由于上面的<code>UserEntity</code>类，只有属性的getter和setter，这正对应了<code>NSMutableDictionary</code>的<code>objectForKey:</code>和<code>setObjectForKey:</code>，同时，JSON数据也会解析成字典，这就完成了巧妙的对接，下面去实现这个类。</p>\n<p>真正干活的是一个字典，保证封装性和纯粹性，这个类直接使用<code>NSProxy</code>作为纯代理类，只暴露一个初始化方法就好了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// XXDuckEntity.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">XXDuckEntity</span> : <span class=\"title\">NSProxy</span></span></span><br><span class=\"line\">- (instancetype)initWithJSO<span class=\"built_in\">NString</span>:(<span class=\"built_in\">NSString</span> *)json;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"comment\">// XXDuckEntity.m</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">XXDuckEntity</span> ()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableDictionary</span> *innerDictionary;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p><code>NSProxy</code>默认是没有初始化方法的，也省去了去规避其他初始化方法的麻烦，为了简单直接初始化时就把json串解开成字典（暂不考虑json是个array）：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithJSO<span class=\"built_in\">NString</span>:(<span class=\"built_in\">NSString</span> *)json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSData</span> *data = [json dataUsingEncoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">    <span class=\"keyword\">id</span> jsonObject = [<span class=\"built_in\">NSJSONSerialization</span> JSONObjectWithData:data options:<span class=\"built_in\">NSJSONReadingAllowFragments</span> error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([jsonObject isKindOfClass:[<span class=\"built_in\">NSDictionary</span> class]]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.innerDictionary = [jsonObject mutableCopy];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>NSProxy</code>可以说除了重载消息转发机制外没有别的用法，这也是它被设计的初衷，自己什么都不干，转给代理对象就好。往这个proxy发消息是注定会走消息转发的，首先判断下是不是一个getter或setter的selector：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SEL changedSelector = aSelector;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> propertyNameScanFromGetterSelector:aSelector]) &#123;</span><br><span class=\"line\">        changedSelector = <span class=\"keyword\">@selector</span>(objectForKey:);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> propertyNameScanFromSetterSelector:aSelector]) &#123;</span><br><span class=\"line\">        changedSelector = <span class=\"keyword\">@selector</span>(setObject:forKey:);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[<span class=\"keyword\">self</span>.innerDictionary class] instanceMethodSignatureForSelector:changedSelector];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>签名替换成字典的两个方法后开始走转发，在这里设置参数和对内部字典的真正调用：   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)invocation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *propertyName = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Try getter</span></span><br><span class=\"line\">    propertyName = [<span class=\"keyword\">self</span> propertyNameScanFromGetterSelector:invocation.selector];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (propertyName) &#123;</span><br><span class=\"line\">        invocation.selector = <span class=\"keyword\">@selector</span>(objectForKey:);</span><br><span class=\"line\">        [invocation setArgument:&amp;propertyName atIndex:<span class=\"number\">2</span>]; <span class=\"comment\">// self, _cmd, key</span></span><br><span class=\"line\">        [invocation invokeWithTarget:<span class=\"keyword\">self</span>.innerDictionary];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Try setter</span></span><br><span class=\"line\">    propertyName = [<span class=\"keyword\">self</span> propertyNameScanFromSetterSelector:invocation.selector];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (propertyName) &#123;</span><br><span class=\"line\">        invocation.selector = <span class=\"keyword\">@selector</span>(setObject:forKey:);</span><br><span class=\"line\">        [invocation setArgument:&amp;propertyName atIndex:<span class=\"number\">3</span>]; <span class=\"comment\">// self, _cmd, obj, key</span></span><br><span class=\"line\">        [invocation invokeWithTarget:<span class=\"keyword\">self</span>.innerDictionary];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> forwardInvocation:invocation];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然还有这两个必不可少的从getter和setter中获取属性名的Helper：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)propertyNameScanFromGetterSelector:(SEL)selector</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *selectorName = <span class=\"built_in\">NSStringFromSelector</span>(selector);</span><br><span class=\"line\">    <span class=\"built_in\">NSUInteger</span> parameterCount = [[selectorName componentsSeparatedByString:<span class=\"string\">@\":\"</span>] count] - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parameterCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> selectorName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)propertyNameScanFromSetterSelector:(SEL)selector</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *selectorName = <span class=\"built_in\">NSStringFromSelector</span>(selector);</span><br><span class=\"line\">    <span class=\"built_in\">NSUInteger</span> parameterCount = [[selectorName componentsSeparatedByString:<span class=\"string\">@\":\"</span>] count] - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([selectorName hasPrefix:<span class=\"string\">@\"set\"</span>] &amp;&amp; parameterCount == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSUInteger</span> firstColonLocation = [selectorName rangeOfString:<span class=\"string\">@\":\"</span>].location;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [selectorName substringWithRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">3</span>, firstColonLocation - <span class=\"number\">3</span>)].lowercaseString;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个简单的鸭子Entity就完成了，之后所有的Entity都可以使用<code>@protocol</code>而非子类化的方式来定义，如：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">XXUserEntity</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *sex;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSNumber</span> *age;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">XXStudentEntity</span> &lt;<span class=\"title\">XXUserEntity</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *school;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *teacher;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>当数据从网络层回来时，鸭子类型让这个对象用起来和真有这么个类没什么两样：   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)requestFinished:(XXDuckEntity&lt;XXStudentEntity&gt; *)student &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"name: %@, school:%@\"</span>, student.name, student.school);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，所有的entity被表示成了N个<code>&lt;Protocol&gt;</code>的<code>.h</code>文件加一个<code>XXDuckEntity</code>类，剩下的就靠想象力了。<br>这个demo的源码将在<a href=\"http://blog.sunnyxx.com/2014/08/26/objc-duck-advanced/\">下半部分</a>之后给出</p>\n<hr>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p><a href=\"http://en.wikipedia.org/wiki/Duck_typing\">http://en.wikipedia.org/wiki/Duck_typing</a><br><a href=\"http://www.informit.com/articles/article.aspx?p=1353396\">http://www.informit.com/articles/article.aspx?p=1353396</a><br><a href=\"https://github.com/facebook/facebook-ios-sdk\">https://github.com/facebook/facebook-ios-sdk</a>  </p>\n"},{"title":"2015 Objective-C 新特性","date":"2015-06-12T15:12:56.000Z","_content":"\n# Overview\n\n自 WWDC 2015 推出和开源 Swift 2.0 后，大家对 Swift 的热情又一次高涨起来，在羡慕创业公司的朋友们大谈 Swift 新特性的同时，也有很多像我一样工作上依然需要坚守着 Objective-C 语言的开发者们。今年的 WWDC 中介绍了几个 Objective-C 语言的新特性，还是在“与 Swift 协同工作”这种 Topic 里讲的，越发凸显这门语言的边缘化了，不过有新特性还是极好的，接下来，本文将介绍下面三个主要的新特性：  \n- Nullability\n- Lightweight Generics *\n- __kindof\n\n# Nullability\n\n然而 Nullability 并不算新特性了，从上一个版本的 llvm 6.1 (Xcode 6.3) 就已经支持。这个简版的 Optional ，没有 Swift 中 `?` 和 `!` 语法糖的支持，在 Objective-C 中就显得非常啰嗦了：  \n\n```objc\n@property (nonatomic, strong, nonnull) Sark *sark;\n@property (nonatomic, copy, readonly, nullable) NSArray *friends;\n+ (nullable NSString *)friendWithName:(nonnull NSString *)name;\n```\n\n假如用来修饰一个变量，前面还要加双下划线，放到 block 里面就更加诡异，比如一个 Request 的 start 方法可以写成：  \n\n``` objc\n- (void)startWithCompletionBlock:(nullable void (^)(NSError * __nullable error))block;\n```\n\n除了这俩外，还有个 **null_resettable** 来表示 setter nullable，但是 getter nonnull，绕死了，最直观例子就是 UIViewController 中的 view 属性：\n\n``` objc\n@property (null_resettable, nonatomic, strong) UIView *view;\n```\n\n它可以被设成 nil，但是调用 getter 时会触发 `-loadView` 从而创建并返回一个非 nil 的 view。  \n从 iOS9 SDK 中可以发现，头文件中所有 API 都已经增加了 Nullability 相关修饰符，想了解这个特性的用法，翻几个系统头文件就差不离了。接口中 nullable 的是少数，所以为了防止写一大堆 nonnull，Foundation 还提供了一对儿宏，包在里面的对象默认加 nonnull 修饰符，只需要把 nullable 的指出来就行，黑话叫 Audited Regions：  \n\n``` objc\nNS_ASSUME_NONNULL_BEGIN\n@interface Sark : NSObject\n@property (nonatomic, copy, nullable) NSString *workingCompany;\n@property (nonatomic, copy) NSArray *friends;\n- (nullable NSString *)gayFriend;\n@end\nNS_ASSUME_NONNULL_END\n```\n\nNullability 在编译器层面提供了空值的类型检查，在类型不符时给出 warning，方便开发者第一时间发现潜在问题。不过我想更大的意义在于能够更加清楚的描述接口，是主调者和被调者间的一个协议，比多少句文档描述都来得清晰，打个比方：  \n\n``` objc\n+ (nullable instancetype)URLWithString:(NSString *)URLString;\n```\n\nNSURL 的这个 API 前面加了 nullable 后，更加显式的指出了这个接口可能因为 URLString 的格式错误而创建失败，使用时自然而然的就考虑到了判空处理。  \n不仅是属性和方法中的对象，对于局部的对象、甚至 c 指针都可以用带双下划线的修饰符，可以理解成能用 const 关键字的地方都能用 Nullability。  \n所以 Nullability 总的来说就是，写着丑B，用着舒服 - -\n\n# Lightweight Generics\n\n**Lightweight Generics** 轻量级泛型，轻量是因为这是个纯编译器的语法支持（llvm 7.0），和 Nullability 一样，没有借助任何 objc runtime 的升级，也就是说，这个新语法在 Xcode 7 上可以使用且完全向下兼容（更低的 iOS 版本）  \n\n## 带泛型的容器\n\n这无疑是本次最重大的改进，有了泛型后终于可以指定容器类中对象的类型了：  \n\n``` objc\nNSArray<NSString *> *strings = @[@\"sun\", @\"yuan\"];\nNSDictionary<NSString *, NSNumber *> *mapping = @{@\"a\": @1, @\"b\": @2};\n```\n\n返回值的 **id** 被替换成具体的类型后，令人感动的代码提示也出来了：  \n\n<img src=\"http://ww3.sinaimg.cn/large/51530583jw1et1s9igr0wj20jc03i74z.jpg\" width=\"480\">\n\n假如向泛型容器中加入错误的对象，编译器会不开心的：  \n\n<img src=\"http://ww4.sinaimg.cn/large/51530583jw1et1sf4799fj20oo02ywfh.jpg\" width=\"480\">\n\n系统中常用的一系列容器类型都增加了泛型支持，甚至连 NSEnumerator 都支持了，这是非常 Nice 的改进。和 Nullability 一样，我认为最大的意义还是丰富了接口描述信息，对比下面两种写法：  \n\n``` objc\n@property (readonly) NSArray *imageURLs;\n@property (readonly) NSArray<NSURL *> *imageURLs;\n```\n\n不用多想就清楚下面的数组中存的是什么，避免了 NSString 和 NSURL 的混乱。\n\n## 自定义泛型类\n\n比起使用系统的泛型容器，更好玩的是自定义一个泛型类，目前这里还没什么文档，但拦不住我们写测试代码，假设我们要自定义一个 Stack 容器类：  \n\n``` objc\n@interface Stack<ObjectType> : NSObject\n- (void)pushObject:(ObjectType)object;\n- (ObjectType)popObject;\n@property (nonatomic, readonly) NSArray<ObjectType> *allObjects;\n@end\n```\n\n这个 `ObjectType` 是传入类型的 placeholder，它只能在 @interface 上定义（类声明、类扩展、Category），如果你喜欢用 **T** 表示也 ok，这个类型在 @interface 和 @end 区间的作用域有效，可以把它作为入参、出参、甚至内部 NSArray 属性的泛型类型，应该说一切都是符合预期的。我们还可以给 ObjectType 增加类型限制，比如：\n\n``` objc\n// 只接受 NSNumber * 的泛型\n@interface Stack<ObjectType: NSNumber *> : NSObject\n// 只接受满足 NSCopying 协议的泛型\n@interface Stack<ObjectType: id<NSCopying>> : NSObject\n```\n\n若什么都不加，表示接受任意类型 ( id )；当类型不满足时编译器将产生 error。  \n实例化一个 Stack，一切工作正常：  \n\n<img src=\"http://ww4.sinaimg.cn/large/51530583jw1et2eqtxt07j20n6040wft.jpg\" width=\"480\">\n\n对于多参数的泛型，用逗号隔开，其他都一样，可以参考 NSDictionary 的头文件。\n\n## 协变性和逆变性\n\n当类支持泛型后，它们的 Type 发生了变化，比如下面三个对象看上去都是 Stack，但实际上属于三个 Type：  \n\n``` objc\nStack *stack; // Stack *\nStack<NSString *> *stringStack; // Stack<NSString *>\nStack<NSMutableString *> *mutableStringStack; // Stack<NSMutableString *>\n```\n\n当其中两种类型做类型转化时，编译器需要知道哪些转化是允许的，哪些是禁止的，比如，默认情况下：  \n\n<img src=\"http://ww3.sinaimg.cn/large/51530583jw1et2fajoo7bj210o09y78w.jpg\" width=\"640\">\n\n我们可以看到，不指定泛型类型的 Stack 可以和任意泛型类型转化，但指定了泛型类型后，两个不同类型间是不可以强转的，假如你希望主动控制转化关系，就需要使用泛型的**协变性**和**逆变性**修饰符了：  \n\n`__covariant` - 协变性，子类型可以强转到父类型（里氏替换原则）  \n`__contravariant` - 逆变性，父类型可以强转到子类型（WTF?）  \n\n协变：  \n\n``` objc\n@interface Stack<__covariant ObjectType> : NSObject\n```\n\n效果：  \n\n<img src=\"http://ww2.sinaimg.cn/large/51530583jw1et2frpvgzpj212q060q5f.jpg\" width=\"640\">\n\n逆变：  \n\n``` objc\n@interface Stack<__contravariant ObjectType> : NSObject\n```\n\n效果：  \n\n<img src=\"http://ww1.sinaimg.cn/large/51530583jw1et2fsyrpfej212m05emzl.jpg\" width=\"640\">\n\n协变是非常好理解的，像 NSArray 的泛型就用了协变的修饰符，而逆变我还没有想到有什么实际的使用场景。\n\n# __kindof\n\n__kindof 这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的 UITableView 的这个方法来说：  \n\n``` objc\n- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;\n```\n\n使用时前面基本会使用 UITableViewCell 子类型的指针来接收返回值，所以这个 API 为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了 id 类型，而这个 API 实际上的意思是返回一个 UITableViewCell 或 UITableViewCell 子类的实例，于是新的 __kindof 关键字解决了这个问题：\n\n``` objc\n- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;\n```\n\n既明确表明了返回值，又让使用者不必写强转。再举个带泛型的例子，UIView 的 subviews 属性被修改成了：\n\n``` objc\n@property (nonatomic, readonly, copy) NSArray<__kindof UIView *> *subviews;\n```\n\n这样，写下面的代码时就没有任何警告了：  \n\n``` objc\nUIButton *button = view.subviews.lastObject;\n```\n\n# Where to go\n\n有了上面介绍的这些新特性以及如 **instancetype** 这样的历史更新，Objective-C 这门古老语言的类型检测和类型推断终于有所长进，现在不论是接口还是代码中的 **id** 类型都越来越少，更多潜在的类型错误可以被编译器的静态检查发现。  \n同时，个人感觉新版的 Xcode 对继承链构造器的检测也加强了，**NS_DESIGNATED_INITIALIZER** 这个宏并不是新面孔，可以使用它标志出像 Swift 一样的指定构造器和便捷构造器。  \n\n最后，附上一段用上了所有新特性的代码，Swift 是发展趋势，如果你暂时依然要写 Objective-C 代码，把所有新特性都用上，或许能让你到新语言的迁移更无痛一点。\n\n<img src=\"http://ww2.sinaimg.cn/large/51530583jw1et2iirmu7bj20ze0bojvm.jpg\" width=\"640\">\n\n\n# References\n\nhttps://msdn.microsoft.com/zh-cn/library/dd799517.aspx\nhttps://gist.github.com/jtbandes/881f07a955ff2eadd1a0\n\n# 请我喝瓶可乐？\n\n<img src=\"http://ww2.sinaimg.cn/large/51530583jw1et2mwz8hqzj20af0camy7.jpg\" width=\"240\">\n\n","source":"_posts/objc-new-features-in-2015.md","raw":"title: 2015 Objective-C 新特性\ndate: 2015-06-12 23:12:56\ntags: iOS9\n---\n\n# Overview\n\n自 WWDC 2015 推出和开源 Swift 2.0 后，大家对 Swift 的热情又一次高涨起来，在羡慕创业公司的朋友们大谈 Swift 新特性的同时，也有很多像我一样工作上依然需要坚守着 Objective-C 语言的开发者们。今年的 WWDC 中介绍了几个 Objective-C 语言的新特性，还是在“与 Swift 协同工作”这种 Topic 里讲的，越发凸显这门语言的边缘化了，不过有新特性还是极好的，接下来，本文将介绍下面三个主要的新特性：  \n- Nullability\n- Lightweight Generics *\n- __kindof\n\n# Nullability\n\n然而 Nullability 并不算新特性了，从上一个版本的 llvm 6.1 (Xcode 6.3) 就已经支持。这个简版的 Optional ，没有 Swift 中 `?` 和 `!` 语法糖的支持，在 Objective-C 中就显得非常啰嗦了：  \n\n```objc\n@property (nonatomic, strong, nonnull) Sark *sark;\n@property (nonatomic, copy, readonly, nullable) NSArray *friends;\n+ (nullable NSString *)friendWithName:(nonnull NSString *)name;\n```\n\n假如用来修饰一个变量，前面还要加双下划线，放到 block 里面就更加诡异，比如一个 Request 的 start 方法可以写成：  \n\n``` objc\n- (void)startWithCompletionBlock:(nullable void (^)(NSError * __nullable error))block;\n```\n\n除了这俩外，还有个 **null_resettable** 来表示 setter nullable，但是 getter nonnull，绕死了，最直观例子就是 UIViewController 中的 view 属性：\n\n``` objc\n@property (null_resettable, nonatomic, strong) UIView *view;\n```\n\n它可以被设成 nil，但是调用 getter 时会触发 `-loadView` 从而创建并返回一个非 nil 的 view。  \n从 iOS9 SDK 中可以发现，头文件中所有 API 都已经增加了 Nullability 相关修饰符，想了解这个特性的用法，翻几个系统头文件就差不离了。接口中 nullable 的是少数，所以为了防止写一大堆 nonnull，Foundation 还提供了一对儿宏，包在里面的对象默认加 nonnull 修饰符，只需要把 nullable 的指出来就行，黑话叫 Audited Regions：  \n\n``` objc\nNS_ASSUME_NONNULL_BEGIN\n@interface Sark : NSObject\n@property (nonatomic, copy, nullable) NSString *workingCompany;\n@property (nonatomic, copy) NSArray *friends;\n- (nullable NSString *)gayFriend;\n@end\nNS_ASSUME_NONNULL_END\n```\n\nNullability 在编译器层面提供了空值的类型检查，在类型不符时给出 warning，方便开发者第一时间发现潜在问题。不过我想更大的意义在于能够更加清楚的描述接口，是主调者和被调者间的一个协议，比多少句文档描述都来得清晰，打个比方：  \n\n``` objc\n+ (nullable instancetype)URLWithString:(NSString *)URLString;\n```\n\nNSURL 的这个 API 前面加了 nullable 后，更加显式的指出了这个接口可能因为 URLString 的格式错误而创建失败，使用时自然而然的就考虑到了判空处理。  \n不仅是属性和方法中的对象，对于局部的对象、甚至 c 指针都可以用带双下划线的修饰符，可以理解成能用 const 关键字的地方都能用 Nullability。  \n所以 Nullability 总的来说就是，写着丑B，用着舒服 - -\n\n# Lightweight Generics\n\n**Lightweight Generics** 轻量级泛型，轻量是因为这是个纯编译器的语法支持（llvm 7.0），和 Nullability 一样，没有借助任何 objc runtime 的升级，也就是说，这个新语法在 Xcode 7 上可以使用且完全向下兼容（更低的 iOS 版本）  \n\n## 带泛型的容器\n\n这无疑是本次最重大的改进，有了泛型后终于可以指定容器类中对象的类型了：  \n\n``` objc\nNSArray<NSString *> *strings = @[@\"sun\", @\"yuan\"];\nNSDictionary<NSString *, NSNumber *> *mapping = @{@\"a\": @1, @\"b\": @2};\n```\n\n返回值的 **id** 被替换成具体的类型后，令人感动的代码提示也出来了：  \n\n<img src=\"http://ww3.sinaimg.cn/large/51530583jw1et1s9igr0wj20jc03i74z.jpg\" width=\"480\">\n\n假如向泛型容器中加入错误的对象，编译器会不开心的：  \n\n<img src=\"http://ww4.sinaimg.cn/large/51530583jw1et1sf4799fj20oo02ywfh.jpg\" width=\"480\">\n\n系统中常用的一系列容器类型都增加了泛型支持，甚至连 NSEnumerator 都支持了，这是非常 Nice 的改进。和 Nullability 一样，我认为最大的意义还是丰富了接口描述信息，对比下面两种写法：  \n\n``` objc\n@property (readonly) NSArray *imageURLs;\n@property (readonly) NSArray<NSURL *> *imageURLs;\n```\n\n不用多想就清楚下面的数组中存的是什么，避免了 NSString 和 NSURL 的混乱。\n\n## 自定义泛型类\n\n比起使用系统的泛型容器，更好玩的是自定义一个泛型类，目前这里还没什么文档，但拦不住我们写测试代码，假设我们要自定义一个 Stack 容器类：  \n\n``` objc\n@interface Stack<ObjectType> : NSObject\n- (void)pushObject:(ObjectType)object;\n- (ObjectType)popObject;\n@property (nonatomic, readonly) NSArray<ObjectType> *allObjects;\n@end\n```\n\n这个 `ObjectType` 是传入类型的 placeholder，它只能在 @interface 上定义（类声明、类扩展、Category），如果你喜欢用 **T** 表示也 ok，这个类型在 @interface 和 @end 区间的作用域有效，可以把它作为入参、出参、甚至内部 NSArray 属性的泛型类型，应该说一切都是符合预期的。我们还可以给 ObjectType 增加类型限制，比如：\n\n``` objc\n// 只接受 NSNumber * 的泛型\n@interface Stack<ObjectType: NSNumber *> : NSObject\n// 只接受满足 NSCopying 协议的泛型\n@interface Stack<ObjectType: id<NSCopying>> : NSObject\n```\n\n若什么都不加，表示接受任意类型 ( id )；当类型不满足时编译器将产生 error。  \n实例化一个 Stack，一切工作正常：  \n\n<img src=\"http://ww4.sinaimg.cn/large/51530583jw1et2eqtxt07j20n6040wft.jpg\" width=\"480\">\n\n对于多参数的泛型，用逗号隔开，其他都一样，可以参考 NSDictionary 的头文件。\n\n## 协变性和逆变性\n\n当类支持泛型后，它们的 Type 发生了变化，比如下面三个对象看上去都是 Stack，但实际上属于三个 Type：  \n\n``` objc\nStack *stack; // Stack *\nStack<NSString *> *stringStack; // Stack<NSString *>\nStack<NSMutableString *> *mutableStringStack; // Stack<NSMutableString *>\n```\n\n当其中两种类型做类型转化时，编译器需要知道哪些转化是允许的，哪些是禁止的，比如，默认情况下：  \n\n<img src=\"http://ww3.sinaimg.cn/large/51530583jw1et2fajoo7bj210o09y78w.jpg\" width=\"640\">\n\n我们可以看到，不指定泛型类型的 Stack 可以和任意泛型类型转化，但指定了泛型类型后，两个不同类型间是不可以强转的，假如你希望主动控制转化关系，就需要使用泛型的**协变性**和**逆变性**修饰符了：  \n\n`__covariant` - 协变性，子类型可以强转到父类型（里氏替换原则）  \n`__contravariant` - 逆变性，父类型可以强转到子类型（WTF?）  \n\n协变：  \n\n``` objc\n@interface Stack<__covariant ObjectType> : NSObject\n```\n\n效果：  \n\n<img src=\"http://ww2.sinaimg.cn/large/51530583jw1et2frpvgzpj212q060q5f.jpg\" width=\"640\">\n\n逆变：  \n\n``` objc\n@interface Stack<__contravariant ObjectType> : NSObject\n```\n\n效果：  \n\n<img src=\"http://ww1.sinaimg.cn/large/51530583jw1et2fsyrpfej212m05emzl.jpg\" width=\"640\">\n\n协变是非常好理解的，像 NSArray 的泛型就用了协变的修饰符，而逆变我还没有想到有什么实际的使用场景。\n\n# __kindof\n\n__kindof 这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的 UITableView 的这个方法来说：  \n\n``` objc\n- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;\n```\n\n使用时前面基本会使用 UITableViewCell 子类型的指针来接收返回值，所以这个 API 为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了 id 类型，而这个 API 实际上的意思是返回一个 UITableViewCell 或 UITableViewCell 子类的实例，于是新的 __kindof 关键字解决了这个问题：\n\n``` objc\n- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;\n```\n\n既明确表明了返回值，又让使用者不必写强转。再举个带泛型的例子，UIView 的 subviews 属性被修改成了：\n\n``` objc\n@property (nonatomic, readonly, copy) NSArray<__kindof UIView *> *subviews;\n```\n\n这样，写下面的代码时就没有任何警告了：  \n\n``` objc\nUIButton *button = view.subviews.lastObject;\n```\n\n# Where to go\n\n有了上面介绍的这些新特性以及如 **instancetype** 这样的历史更新，Objective-C 这门古老语言的类型检测和类型推断终于有所长进，现在不论是接口还是代码中的 **id** 类型都越来越少，更多潜在的类型错误可以被编译器的静态检查发现。  \n同时，个人感觉新版的 Xcode 对继承链构造器的检测也加强了，**NS_DESIGNATED_INITIALIZER** 这个宏并不是新面孔，可以使用它标志出像 Swift 一样的指定构造器和便捷构造器。  \n\n最后，附上一段用上了所有新特性的代码，Swift 是发展趋势，如果你暂时依然要写 Objective-C 代码，把所有新特性都用上，或许能让你到新语言的迁移更无痛一点。\n\n<img src=\"http://ww2.sinaimg.cn/large/51530583jw1et2iirmu7bj20ze0bojvm.jpg\" width=\"640\">\n\n\n# References\n\nhttps://msdn.microsoft.com/zh-cn/library/dd799517.aspx\nhttps://gist.github.com/jtbandes/881f07a955ff2eadd1a0\n\n# 请我喝瓶可乐？\n\n<img src=\"http://ww2.sinaimg.cn/large/51530583jw1et2mwz8hqzj20af0camy7.jpg\" width=\"240\">\n\n","slug":"objc-new-features-in-2015","published":1,"updated":"2016-03-26T08:35:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxlp001hev128k91ejj4","content":"<h1 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h1><p>自 WWDC 2015 推出和开源 Swift 2.0 后，大家对 Swift 的热情又一次高涨起来，在羡慕创业公司的朋友们大谈 Swift 新特性的同时，也有很多像我一样工作上依然需要坚守着 Objective-C 语言的开发者们。今年的 WWDC 中介绍了几个 Objective-C 语言的新特性，还是在“与 Swift 协同工作”这种 Topic 里讲的，越发凸显这门语言的边缘化了，不过有新特性还是极好的，接下来，本文将介绍下面三个主要的新特性：  </p>\n<ul>\n<li>Nullability</li>\n<li>Lightweight Generics *</li>\n<li>__kindof</li>\n</ul>\n<h1 id=\"Nullability\"><a href=\"#Nullability\" class=\"headerlink\" title=\"Nullability\"></a>Nullability</h1><p>然而 Nullability 并不算新特性了，从上一个版本的 llvm 6.1 (Xcode 6.3) 就已经支持。这个简版的 Optional ，没有 Swift 中 <code>?</code> 和 <code>!</code> 语法糖的支持，在 Objective-C 中就显得非常啰嗦了：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, nonnull) Sark *sark;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>, <span class=\"keyword\">readonly</span>, nullable) <span class=\"built_in\">NSArray</span> *friends;</span><br><span class=\"line\">+ (nullable <span class=\"built_in\">NSString</span> *)friendWithName:(nonnull <span class=\"built_in\">NSString</span> *)name;</span><br></pre></td></tr></table></figure>\n<p>假如用来修饰一个变量，前面还要加双下划线，放到 block 里面就更加诡异，比如一个 Request 的 start 方法可以写成：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)startWithCompletionBlock:(nullable <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSError</span> * __nullable error))block;</span><br></pre></td></tr></table></figure>\n<p>除了这俩外，还有个 <strong>null_resettable</strong> 来表示 setter nullable，但是 getter nonnull，绕死了，最直观例子就是 UIViewController 中的 view 属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (null_resettable, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UIView</span> *view;</span><br></pre></td></tr></table></figure>\n<p>它可以被设成 nil，但是调用 getter 时会触发 <code>-loadView</code> 从而创建并返回一个非 nil 的 view。<br>从 iOS9 SDK 中可以发现，头文件中所有 API 都已经增加了 Nullability 相关修饰符，想了解这个特性的用法，翻几个系统头文件就差不离了。接口中 nullable 的是少数，所以为了防止写一大堆 nonnull，Foundation 还提供了一对儿宏，包在里面的对象默认加 nonnull 修饰符，只需要把 nullable 的指出来就行，黑话叫 Audited Regions：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>, nullable) <span class=\"built_in\">NSString</span> *workingCompany;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSArray</span> *friends;</span><br><span class=\"line\">- (nullable <span class=\"built_in\">NSString</span> *)gayFriend;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"built_in\">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>\n<p>Nullability 在编译器层面提供了空值的类型检查，在类型不符时给出 warning，方便开发者第一时间发现潜在问题。不过我想更大的意义在于能够更加清楚的描述接口，是主调者和被调者间的一个协议，比多少句文档描述都来得清晰，打个比方：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (nullable instancetype)URLWithString:(<span class=\"built_in\">NSString</span> *)URLString;</span><br></pre></td></tr></table></figure>\n<p>NSURL 的这个 API 前面加了 nullable 后，更加显式的指出了这个接口可能因为 URLString 的格式错误而创建失败，使用时自然而然的就考虑到了判空处理。<br>不仅是属性和方法中的对象，对于局部的对象、甚至 c 指针都可以用带双下划线的修饰符，可以理解成能用 const 关键字的地方都能用 Nullability。<br>所以 Nullability 总的来说就是，写着丑B，用着舒服 - -</p>\n<h1 id=\"Lightweight-Generics\"><a href=\"#Lightweight-Generics\" class=\"headerlink\" title=\"Lightweight Generics\"></a>Lightweight Generics</h1><p><strong>Lightweight Generics</strong> 轻量级泛型，轻量是因为这是个纯编译器的语法支持（llvm 7.0），和 Nullability 一样，没有借助任何 objc runtime 的升级，也就是说，这个新语法在 Xcode 7 上可以使用且完全向下兼容（更低的 iOS 版本）  </p>\n<h2 id=\"带泛型的容器\"><a href=\"#带泛型的容器\" class=\"headerlink\" title=\"带泛型的容器\"></a>带泛型的容器</h2><p>这无疑是本次最重大的改进，有了泛型后终于可以指定容器类中对象的类型了：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *strings = @[<span class=\"string\">@\"sun\"</span>, <span class=\"string\">@\"yuan\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *, <span class=\"built_in\">NSNumber</span> *&gt; *mapping = @&#123;<span class=\"string\">@\"a\"</span>: @<span class=\"number\">1</span>, <span class=\"string\">@\"b\"</span>: @<span class=\"number\">2</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p>返回值的 <strong>id</strong> 被替换成具体的类型后，令人感动的代码提示也出来了：  </p>\n<p><img src=\"http://ww3.sinaimg.cn/large/51530583jw1et1s9igr0wj20jc03i74z.jpg\" width=\"480\"></p>\n<p>假如向泛型容器中加入错误的对象，编译器会不开心的：  </p>\n<p><img src=\"http://ww4.sinaimg.cn/large/51530583jw1et1sf4799fj20oo02ywfh.jpg\" width=\"480\"></p>\n<p>系统中常用的一系列容器类型都增加了泛型支持，甚至连 NSEnumerator 都支持了，这是非常 Nice 的改进。和 Nullability 一样，我认为最大的意义还是丰富了接口描述信息，对比下面两种写法：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSArray</span> *imageURLs;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSURL</span> *&gt; *imageURLs;</span><br></pre></td></tr></table></figure>\n<p>不用多想就清楚下面的数组中存的是什么，避免了 NSString 和 NSURL 的混乱。</p>\n<h2 id=\"自定义泛型类\"><a href=\"#自定义泛型类\" class=\"headerlink\" title=\"自定义泛型类\"></a>自定义泛型类</h2><p>比起使用系统的泛型容器，更好玩的是自定义一个泛型类，目前这里还没什么文档，但拦不住我们写测试代码，假设我们要自定义一个 Stack 容器类：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Stack</span>&lt;<span class=\"title\">ObjectType</span>&gt; : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)pushObject:(ObjectType)object;</span><br><span class=\"line\">- (ObjectType)popObject;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSArray</span>&lt;ObjectType&gt; *allObjects;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>这个 <code>ObjectType</code> 是传入类型的 placeholder，它只能在 @interface 上定义（类声明、类扩展、Category），如果你喜欢用 <strong>T</strong> 表示也 ok，这个类型在 @interface 和 @end 区间的作用域有效，可以把它作为入参、出参、甚至内部 NSArray 属性的泛型类型，应该说一切都是符合预期的。我们还可以给 ObjectType 增加类型限制，比如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 只接受 NSNumber * 的泛型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Stack</span>&lt;<span class=\"title\">ObjectType</span>: <span class=\"title\">NSNumber</span> *&gt; : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"comment\">// 只接受满足 NSCopying 协议的泛型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Stack</span>&lt;<span class=\"title\">ObjectType</span>: <span class=\"title\">id</span>&lt;<span class=\"title\">NSCopying</span>&gt;&gt; : <span class=\"title\">NSObject</span></span></span><br></pre></td></tr></table></figure>\n<p>若什么都不加，表示接受任意类型 ( id )；当类型不满足时编译器将产生 error。<br>实例化一个 Stack，一切工作正常：  </p>\n<p><img src=\"http://ww4.sinaimg.cn/large/51530583jw1et2eqtxt07j20n6040wft.jpg\" width=\"480\"></p>\n<p>对于多参数的泛型，用逗号隔开，其他都一样，可以参考 NSDictionary 的头文件。</p>\n<h2 id=\"协变性和逆变性\"><a href=\"#协变性和逆变性\" class=\"headerlink\" title=\"协变性和逆变性\"></a>协变性和逆变性</h2><p>当类支持泛型后，它们的 Type 发生了变化，比如下面三个对象看上去都是 Stack，但实际上属于三个 Type：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack *stack; <span class=\"comment\">// Stack *</span></span><br><span class=\"line\">Stack&lt;<span class=\"built_in\">NSString</span> *&gt; *stringStack; <span class=\"comment\">// Stack&lt;NSString *&gt;</span></span><br><span class=\"line\">Stack&lt;<span class=\"built_in\">NSMutableString</span> *&gt; *mutableStringStack; <span class=\"comment\">// Stack&lt;NSMutableString *&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当其中两种类型做类型转化时，编译器需要知道哪些转化是允许的，哪些是禁止的，比如，默认情况下：  </p>\n<p><img src=\"http://ww3.sinaimg.cn/large/51530583jw1et2fajoo7bj210o09y78w.jpg\" width=\"640\"></p>\n<p>我们可以看到，不指定泛型类型的 Stack 可以和任意泛型类型转化，但指定了泛型类型后，两个不同类型间是不可以强转的，假如你希望主动控制转化关系，就需要使用泛型的<strong>协变性</strong>和<strong>逆变性</strong>修饰符了：  </p>\n<p><code>__covariant</code> - 协变性，子类型可以强转到父类型（里氏替换原则）<br><code>__contravariant</code> - 逆变性，父类型可以强转到子类型（WTF?）  </p>\n<p>协变：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Stack</span>&lt;<span class=\"title\">__covariant</span> <span class=\"title\">ObjectType</span>&gt; : <span class=\"title\">NSObject</span></span></span><br></pre></td></tr></table></figure>\n<p>效果：  </p>\n<p><img src=\"http://ww2.sinaimg.cn/large/51530583jw1et2frpvgzpj212q060q5f.jpg\" width=\"640\"></p>\n<p>逆变：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Stack</span>&lt;<span class=\"title\">__contravariant</span> <span class=\"title\">ObjectType</span>&gt; : <span class=\"title\">NSObject</span></span></span><br></pre></td></tr></table></figure>\n<p>效果：  </p>\n<p><img src=\"http://ww1.sinaimg.cn/large/51530583jw1et2fsyrpfej212m05emzl.jpg\" width=\"640\"></p>\n<p>协变是非常好理解的，像 NSArray 的泛型就用了协变的修饰符，而逆变我还没有想到有什么实际的使用场景。</p>\n<h1 id=\"kindof\"><a href=\"#kindof\" class=\"headerlink\" title=\"__kindof\"></a>__kindof</h1><p>__kindof 这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的 UITableView 的这个方法来说：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)dequeueReusableCellWithIdentifier:(<span class=\"built_in\">NSString</span> *)identifier;</span><br></pre></td></tr></table></figure>\n<p>使用时前面基本会使用 UITableViewCell 子类型的指针来接收返回值，所以这个 API 为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了 id 类型，而这个 API 实际上的意思是返回一个 UITableViewCell 或 UITableViewCell 子类的实例，于是新的 __kindof 关键字解决了这个问题：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (__kindof <span class=\"built_in\">UITableViewCell</span> *)dequeueReusableCellWithIdentifier:(<span class=\"built_in\">NSString</span> *)identifier;</span><br></pre></td></tr></table></figure>\n<p>既明确表明了返回值，又让使用者不必写强转。再举个带泛型的例子，UIView 的 subviews 属性被修改成了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSArray</span>&lt;__kindof <span class=\"built_in\">UIView</span> *&gt; *subviews;</span><br></pre></td></tr></table></figure>\n<p>这样，写下面的代码时就没有任何警告了：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIButton</span> *button = view.subviews.lastObject;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Where-to-go\"><a href=\"#Where-to-go\" class=\"headerlink\" title=\"Where to go\"></a>Where to go</h1><p>有了上面介绍的这些新特性以及如 <strong>instancetype</strong> 这样的历史更新，Objective-C 这门古老语言的类型检测和类型推断终于有所长进，现在不论是接口还是代码中的 <strong>id</strong> 类型都越来越少，更多潜在的类型错误可以被编译器的静态检查发现。<br>同时，个人感觉新版的 Xcode 对继承链构造器的检测也加强了，<strong>NS_DESIGNATED_INITIALIZER</strong> 这个宏并不是新面孔，可以使用它标志出像 Swift 一样的指定构造器和便捷构造器。  </p>\n<p>最后，附上一段用上了所有新特性的代码，Swift 是发展趋势，如果你暂时依然要写 Objective-C 代码，把所有新特性都用上，或许能让你到新语言的迁移更无痛一点。</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/51530583jw1et2iirmu7bj20ze0bojvm.jpg\" width=\"640\"></p>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"https://msdn.microsoft.com/zh-cn/library/dd799517.aspx\" target=\"_blank\" rel=\"external\">https://msdn.microsoft.com/zh-cn/library/dd799517.aspx</a><br><a href=\"https://gist.github.com/jtbandes/881f07a955ff2eadd1a0\" target=\"_blank\" rel=\"external\">https://gist.github.com/jtbandes/881f07a955ff2eadd1a0</a></p>\n<h1 id=\"请我喝瓶可乐？\"><a href=\"#请我喝瓶可乐？\" class=\"headerlink\" title=\"请我喝瓶可乐？\"></a>请我喝瓶可乐？</h1><p><img src=\"http://ww2.sinaimg.cn/large/51530583jw1et2mwz8hqzj20af0camy7.jpg\" width=\"240\"></p>\n","excerpt":"","more":"<h1 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h1><p>自 WWDC 2015 推出和开源 Swift 2.0 后，大家对 Swift 的热情又一次高涨起来，在羡慕创业公司的朋友们大谈 Swift 新特性的同时，也有很多像我一样工作上依然需要坚守着 Objective-C 语言的开发者们。今年的 WWDC 中介绍了几个 Objective-C 语言的新特性，还是在“与 Swift 协同工作”这种 Topic 里讲的，越发凸显这门语言的边缘化了，不过有新特性还是极好的，接下来，本文将介绍下面三个主要的新特性：  </p>\n<ul>\n<li>Nullability</li>\n<li>Lightweight Generics *</li>\n<li>__kindof</li>\n</ul>\n<h1 id=\"Nullability\"><a href=\"#Nullability\" class=\"headerlink\" title=\"Nullability\"></a>Nullability</h1><p>然而 Nullability 并不算新特性了，从上一个版本的 llvm 6.1 (Xcode 6.3) 就已经支持。这个简版的 Optional ，没有 Swift 中 <code>?</code> 和 <code>!</code> 语法糖的支持，在 Objective-C 中就显得非常啰嗦了：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, nonnull) Sark *sark;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>, <span class=\"keyword\">readonly</span>, nullable) <span class=\"built_in\">NSArray</span> *friends;</span><br><span class=\"line\">+ (nullable <span class=\"built_in\">NSString</span> *)friendWithName:(nonnull <span class=\"built_in\">NSString</span> *)name;</span><br></pre></td></tr></table></figure>\n<p>假如用来修饰一个变量，前面还要加双下划线，放到 block 里面就更加诡异，比如一个 Request 的 start 方法可以写成：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)startWithCompletionBlock:(nullable <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSError</span> * __nullable error))block;</span><br></pre></td></tr></table></figure>\n<p>除了这俩外，还有个 <strong>null_resettable</strong> 来表示 setter nullable，但是 getter nonnull，绕死了，最直观例子就是 UIViewController 中的 view 属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (null_resettable, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UIView</span> *view;</span><br></pre></td></tr></table></figure>\n<p>它可以被设成 nil，但是调用 getter 时会触发 <code>-loadView</code> 从而创建并返回一个非 nil 的 view。<br>从 iOS9 SDK 中可以发现，头文件中所有 API 都已经增加了 Nullability 相关修饰符，想了解这个特性的用法，翻几个系统头文件就差不离了。接口中 nullable 的是少数，所以为了防止写一大堆 nonnull，Foundation 还提供了一对儿宏，包在里面的对象默认加 nonnull 修饰符，只需要把 nullable 的指出来就行，黑话叫 Audited Regions：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>, nullable) <span class=\"built_in\">NSString</span> *workingCompany;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSArray</span> *friends;</span><br><span class=\"line\">- (nullable <span class=\"built_in\">NSString</span> *)gayFriend;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"built_in\">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>\n<p>Nullability 在编译器层面提供了空值的类型检查，在类型不符时给出 warning，方便开发者第一时间发现潜在问题。不过我想更大的意义在于能够更加清楚的描述接口，是主调者和被调者间的一个协议，比多少句文档描述都来得清晰，打个比方：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (nullable instancetype)URLWithString:(<span class=\"built_in\">NSString</span> *)URLString;</span><br></pre></td></tr></table></figure>\n<p>NSURL 的这个 API 前面加了 nullable 后，更加显式的指出了这个接口可能因为 URLString 的格式错误而创建失败，使用时自然而然的就考虑到了判空处理。<br>不仅是属性和方法中的对象，对于局部的对象、甚至 c 指针都可以用带双下划线的修饰符，可以理解成能用 const 关键字的地方都能用 Nullability。<br>所以 Nullability 总的来说就是，写着丑B，用着舒服 - -</p>\n<h1 id=\"Lightweight-Generics\"><a href=\"#Lightweight-Generics\" class=\"headerlink\" title=\"Lightweight Generics\"></a>Lightweight Generics</h1><p><strong>Lightweight Generics</strong> 轻量级泛型，轻量是因为这是个纯编译器的语法支持（llvm 7.0），和 Nullability 一样，没有借助任何 objc runtime 的升级，也就是说，这个新语法在 Xcode 7 上可以使用且完全向下兼容（更低的 iOS 版本）  </p>\n<h2 id=\"带泛型的容器\"><a href=\"#带泛型的容器\" class=\"headerlink\" title=\"带泛型的容器\"></a>带泛型的容器</h2><p>这无疑是本次最重大的改进，有了泛型后终于可以指定容器类中对象的类型了：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *strings = @[<span class=\"string\">@\"sun\"</span>, <span class=\"string\">@\"yuan\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *, <span class=\"built_in\">NSNumber</span> *&gt; *mapping = @&#123;<span class=\"string\">@\"a\"</span>: @<span class=\"number\">1</span>, <span class=\"string\">@\"b\"</span>: @<span class=\"number\">2</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p>返回值的 <strong>id</strong> 被替换成具体的类型后，令人感动的代码提示也出来了：  </p>\n<p><img src=\"http://ww3.sinaimg.cn/large/51530583jw1et1s9igr0wj20jc03i74z.jpg\" width=\"480\"></p>\n<p>假如向泛型容器中加入错误的对象，编译器会不开心的：  </p>\n<p><img src=\"http://ww4.sinaimg.cn/large/51530583jw1et1sf4799fj20oo02ywfh.jpg\" width=\"480\"></p>\n<p>系统中常用的一系列容器类型都增加了泛型支持，甚至连 NSEnumerator 都支持了，这是非常 Nice 的改进。和 Nullability 一样，我认为最大的意义还是丰富了接口描述信息，对比下面两种写法：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSArray</span> *imageURLs;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSURL</span> *&gt; *imageURLs;</span><br></pre></td></tr></table></figure>\n<p>不用多想就清楚下面的数组中存的是什么，避免了 NSString 和 NSURL 的混乱。</p>\n<h2 id=\"自定义泛型类\"><a href=\"#自定义泛型类\" class=\"headerlink\" title=\"自定义泛型类\"></a>自定义泛型类</h2><p>比起使用系统的泛型容器，更好玩的是自定义一个泛型类，目前这里还没什么文档，但拦不住我们写测试代码，假设我们要自定义一个 Stack 容器类：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Stack</span>&lt;<span class=\"title\">ObjectType</span>&gt; : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)pushObject:(ObjectType)object;</span><br><span class=\"line\">- (ObjectType)popObject;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSArray</span>&lt;ObjectType&gt; *allObjects;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>这个 <code>ObjectType</code> 是传入类型的 placeholder，它只能在 @interface 上定义（类声明、类扩展、Category），如果你喜欢用 <strong>T</strong> 表示也 ok，这个类型在 @interface 和 @end 区间的作用域有效，可以把它作为入参、出参、甚至内部 NSArray 属性的泛型类型，应该说一切都是符合预期的。我们还可以给 ObjectType 增加类型限制，比如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 只接受 NSNumber * 的泛型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Stack</span>&lt;<span class=\"title\">ObjectType</span>: <span class=\"title\">NSNumber</span> *&gt; : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"comment\">// 只接受满足 NSCopying 协议的泛型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Stack</span>&lt;<span class=\"title\">ObjectType</span>: <span class=\"title\">id</span>&lt;<span class=\"title\">NSCopying</span>&gt;&gt; : <span class=\"title\">NSObject</span></span></span><br></pre></td></tr></table></figure>\n<p>若什么都不加，表示接受任意类型 ( id )；当类型不满足时编译器将产生 error。<br>实例化一个 Stack，一切工作正常：  </p>\n<p><img src=\"http://ww4.sinaimg.cn/large/51530583jw1et2eqtxt07j20n6040wft.jpg\" width=\"480\"></p>\n<p>对于多参数的泛型，用逗号隔开，其他都一样，可以参考 NSDictionary 的头文件。</p>\n<h2 id=\"协变性和逆变性\"><a href=\"#协变性和逆变性\" class=\"headerlink\" title=\"协变性和逆变性\"></a>协变性和逆变性</h2><p>当类支持泛型后，它们的 Type 发生了变化，比如下面三个对象看上去都是 Stack，但实际上属于三个 Type：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack *stack; <span class=\"comment\">// Stack *</span></span><br><span class=\"line\">Stack&lt;<span class=\"built_in\">NSString</span> *&gt; *stringStack; <span class=\"comment\">// Stack&lt;NSString *&gt;</span></span><br><span class=\"line\">Stack&lt;<span class=\"built_in\">NSMutableString</span> *&gt; *mutableStringStack; <span class=\"comment\">// Stack&lt;NSMutableString *&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当其中两种类型做类型转化时，编译器需要知道哪些转化是允许的，哪些是禁止的，比如，默认情况下：  </p>\n<p><img src=\"http://ww3.sinaimg.cn/large/51530583jw1et2fajoo7bj210o09y78w.jpg\" width=\"640\"></p>\n<p>我们可以看到，不指定泛型类型的 Stack 可以和任意泛型类型转化，但指定了泛型类型后，两个不同类型间是不可以强转的，假如你希望主动控制转化关系，就需要使用泛型的<strong>协变性</strong>和<strong>逆变性</strong>修饰符了：  </p>\n<p><code>__covariant</code> - 协变性，子类型可以强转到父类型（里氏替换原则）<br><code>__contravariant</code> - 逆变性，父类型可以强转到子类型（WTF?）  </p>\n<p>协变：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Stack</span>&lt;<span class=\"title\">__covariant</span> <span class=\"title\">ObjectType</span>&gt; : <span class=\"title\">NSObject</span></span></span><br></pre></td></tr></table></figure>\n<p>效果：  </p>\n<p><img src=\"http://ww2.sinaimg.cn/large/51530583jw1et2frpvgzpj212q060q5f.jpg\" width=\"640\"></p>\n<p>逆变：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Stack</span>&lt;<span class=\"title\">__contravariant</span> <span class=\"title\">ObjectType</span>&gt; : <span class=\"title\">NSObject</span></span></span><br></pre></td></tr></table></figure>\n<p>效果：  </p>\n<p><img src=\"http://ww1.sinaimg.cn/large/51530583jw1et2fsyrpfej212m05emzl.jpg\" width=\"640\"></p>\n<p>协变是非常好理解的，像 NSArray 的泛型就用了协变的修饰符，而逆变我还没有想到有什么实际的使用场景。</p>\n<h1 id=\"kindof\"><a href=\"#kindof\" class=\"headerlink\" title=\"__kindof\"></a>__kindof</h1><p>__kindof 这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的 UITableView 的这个方法来说：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)dequeueReusableCellWithIdentifier:(<span class=\"built_in\">NSString</span> *)identifier;</span><br></pre></td></tr></table></figure>\n<p>使用时前面基本会使用 UITableViewCell 子类型的指针来接收返回值，所以这个 API 为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了 id 类型，而这个 API 实际上的意思是返回一个 UITableViewCell 或 UITableViewCell 子类的实例，于是新的 __kindof 关键字解决了这个问题：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (__kindof <span class=\"built_in\">UITableViewCell</span> *)dequeueReusableCellWithIdentifier:(<span class=\"built_in\">NSString</span> *)identifier;</span><br></pre></td></tr></table></figure>\n<p>既明确表明了返回值，又让使用者不必写强转。再举个带泛型的例子，UIView 的 subviews 属性被修改成了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSArray</span>&lt;__kindof <span class=\"built_in\">UIView</span> *&gt; *subviews;</span><br></pre></td></tr></table></figure>\n<p>这样，写下面的代码时就没有任何警告了：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIButton</span> *button = view.subviews.lastObject;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Where-to-go\"><a href=\"#Where-to-go\" class=\"headerlink\" title=\"Where to go\"></a>Where to go</h1><p>有了上面介绍的这些新特性以及如 <strong>instancetype</strong> 这样的历史更新，Objective-C 这门古老语言的类型检测和类型推断终于有所长进，现在不论是接口还是代码中的 <strong>id</strong> 类型都越来越少，更多潜在的类型错误可以被编译器的静态检查发现。<br>同时，个人感觉新版的 Xcode 对继承链构造器的检测也加强了，<strong>NS_DESIGNATED_INITIALIZER</strong> 这个宏并不是新面孔，可以使用它标志出像 Swift 一样的指定构造器和便捷构造器。  </p>\n<p>最后，附上一段用上了所有新特性的代码，Swift 是发展趋势，如果你暂时依然要写 Objective-C 代码，把所有新特性都用上，或许能让你到新语言的迁移更无痛一点。</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/51530583jw1et2iirmu7bj20ze0bojvm.jpg\" width=\"640\"></p>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"https://msdn.microsoft.com/zh-cn/library/dd799517.aspx\">https://msdn.microsoft.com/zh-cn/library/dd799517.aspx</a><br><a href=\"https://gist.github.com/jtbandes/881f07a955ff2eadd1a0\">https://gist.github.com/jtbandes/881f07a955ff2eadd1a0</a></p>\n<h1 id=\"请我喝瓶可乐？\"><a href=\"#请我喝瓶可乐？\" class=\"headerlink\" title=\"请我喝瓶可乐？\"></a>请我喝瓶可乐？</h1><p><img src=\"http://ww2.sinaimg.cn/large/51530583jw1et2mwz8hqzj20af0camy7.jpg\" width=\"240\"></p>\n"},{"title":"iOS程序main函数之前发生了什么","date":"2014-08-30T07:26:01.000Z","_content":"\n# 我是前言\n\n一个iOS app的`main()`函数位于`main.m`中，这是我们熟知的**程序入口**。但对objc了解更多之后发现，程序在进入我们的`main`函数前已经执行了很多代码，比如熟知的`+ load`方法等。本文将跟随程序执行顺序，刨根问底，从`dyld`到`runtime`，看看main函数之前都发生了什么。\n\n<!--more-->\n\n---\n\n# 从dyld开始\n\n\n## 动态链接库  \n\niOS中用到的所有系统framework都是动态链接的，类比成插头和插排，静态链接的代码在编译后的静态链接过程就将插头和插排一个个插好，运行时直接执行二进制文件；而动态链接需要在程序启动时去完成“插插销”的过程，所以在我们写的代码执行前，动态连接器需要完成准备工作。\n\n这个是在xcode中看到的Link列表：  \n![](http://ww4.sinaimg.cn/mw600/51530583jw1ejx4ul5susj20wg0803zh.jpg)\n这些framework将会在动态链接过程中被加载，另外还有隐含link的framework，可以测试出来：先找到可执行文件，我这里叫`TestMain`的工程，模拟器路径下找到`TestMain.app`，可执行文件默认同名，再通过`otool`命令：\n\n``` shell\n$ otool -L TestMain\n```\n\n**-L**参数打印出所有link的framework（去掉了版本信息）：\n\n``` shell\nTestMain:\n    /System/Library/Frameworks/CoreGraphics.framework/CoreGraphics\n    /System/Library/Frameworks/UIKit.framework/UIKit\n    /System/Library/Frameworks/Foundation.framework/Foundation\n    /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\n    /usr/lib/libobjc.A.dylib\n    /usr/lib/libSystem.dylib\n```\n\n\n除了多了的`CoreGraphics`（被UIKit依赖）外，有两个默认添加的lib。**libobjc**即objc和runtime，**libSystem**中包含了很多系统级别lib，列几个熟知的：libdispatch(GCD)，libsystem_c(C语言库)，libsystem_blocks(Block)，libcommonCrypto(常用的md5函数)等等。这些lib都是`dylib`格式（如windows中的dll），系统使用动态链接有几点好处：\n\n- 代码共用：很多程序都动态链接了这些lib，但它们在内存和磁盘中中只有一份\n- 易于维护：由于被依赖的lib是程序执行时才link的，所以这些lib很容易做更新，比如`libSystem.dylib`是`libSystem.B.dylib`的替身，哪天想升级直接换成`libSystem.C.dylib`然后再替换替身就行了\n- 减少可执行文件体积：相比静态链接，可执行文件的体积要小很多\n\n## dyld\n\n`dyld` - the dynamic link editor（这缩写对应的很奇怪，我感觉是DYnamic Linker Daemon呢- -？）apple的动态链接器，系统kernel做好启动程序的初始准备后，交给dyld负责，援引并翻译[《mikeask这篇blog》](https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html)对dyld作用顺序的概括：\n\n1. 从kernel留下的原始调用栈引导和启动自己\n2. 将程序依赖的动态链接库`递归`加载进内存，当然这里有`缓存机制`\n3. non-lazy符号立即link到可执行文件，lazy的存表里\n4. Runs static initializers for the executable\n5. 找到可执行文件的main函数，准备参数并调用\n6. 程序执行中负责绑定lazy符号、提供runtime dynamic loading services、提供调试器接口\n7. 程序main函数return后执行static terminator\n8. 某些场景下main函数结束后调libSystem的_exit函数\n\n得益于dyld是开源的，[github地址](https://github.com/opensource-apple/dyld)，我们可以从源码一探究竟。\n\n一切源于`dyldStartup.s`这个文件，其中用汇编实现了名为`__dyld_start`的方法，汇编太生涩，它主要干了两件事：\n1. 调用`dyldbootstrap::start()`方法（省去参数）\n2. 上个方法返回了main函数地址，填入参数并调用main函数\n\n这个步骤随手就能验证出来，设置一个`符号断点`断在`_objc_init`：\n![](http://ww1.sinaimg.cn/mw600/51530583jw1ejxgn8un3cj20oo09675i.jpg)\n这个函数是`runtime`的初始化函数，后面会提到。程序运行在很早的时候断住，这时候看调用栈：  \n![](http://ww3.sinaimg.cn/mw600/51530583jw1ejxgwiptytj20jw0f0q5r.jpg)\n看到了栈底的`dyldbootstrap::start()`方法，继而调用了`dyld::_main()`方法，其中完成了刚才说的递归加载动态库过程，由于`libSystem`默认引入，栈中出现了`libSystem_initializer`的初始化方法。\n\n## ImageLoader\n\n当然这个image不是图片的意思，它大概表示一个二进制文件（可执行文件或so文件），里面是被编译过的符号、代码等，所以`ImageLoader`作用是将这些文件加载进内存，且**每一个文件对应一个ImageLoader实例来负责加载**。\n两步走：\n1. 在程序运行时它先将动态链接的image递归加载 （也就是上面测试栈中一串的递归调用的时刻）\n2. 再从可执行文件image递归加载所有符号\n\n当然所有这些都发生在我们真正的main函数执行前。\n\n\n---\n\n# runtime与+load\n\n刚才讲到`libSystem`是若干个系统lib的集合，所以它只是一个容器lib而已，而且它也是开源的，里面实质上就一个文件，[init.c](http://www.opensource.apple.com/source/Libsystem/Libsystem-169.3/init.c)，细节不说了，由`libSystem_initializer`逐步调用到了`_objc_init`，这里就是objc和runtime的初始化入口。\n\n除了runtime环境的初始化外，`_objc_init`中绑定了新image被加载后的callback：\n\n``` objc\ndyld_register_image_state_change_handler(dyld_image_state_bound,\n                                             1/*batch*/, &map_images);\ndyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &load_images);\n```\n\n可见dyld担当了`runtime`和`ImageLoader`中间的协调者，当新image加载进来后交由runtime大厨去解析这个二进制文件的符号表和代码。继续上面的断点法，断住神秘的`+load`函数：\n\n![](http://ww1.sinaimg.cn/mw690/51530583jw1ejyjgvetq1j20jk0bc0uf.jpg)\n\n清楚的看到整个调用栈和顺序：\n\n1. dyld开始将程序二进制文件初始化\n2. 交由ImageLoader读取image，其中包含了我们的类、方法等各种符号\n3. 由于runtime向dyld绑定了回调，当image加载到内存后，dyld会通知runtime进行处理\n4. runtime接手后调用map_images做解析和处理，接下来load_images中调用call_load_methods方法，遍历所有加载进来的Class，按继承层级依次调用Class的load方法和其Category的load方法\n\n至此，可执行文件中和动态库所有的符号（Class，Protocol，Selector，IMP，...）都已经按格式成功加载到内存中，被runtime所管理，再这之后，runtime的那些方法（动态添加Class、方法混合等等才能生效）\n\n## 关于load方法的几个QA\n\nQ: 重载自己Class的load方法时需不需要调父类？\nA: runtime负责按继承顺序递归调用，所以我们不能调super\n\nQ: 在自己Class的load方法时能不能替换系统framework（比如UIKit）中的某个类的方法实现\nA: 可以，因为动态链接过程中，所有依赖库的类是先于自己的类加载的\n\nQ: 重载load时需要手动添加@autoreleasepool么？\nA: 不需要，在runtime调用load方法前后是加了`objc_autoreleasePoolPush()`和`objc_autoreleasePoolPop()`的。\n\nQ: 想让一个类的load方法被调用是否需要在某个地方import这个文件\nA: 不需要，只要这个类的符号被编译到最后的可执行文件中，load方法就会被调用（Reveal SDK就是利用这一点，只要引入到工程中就能工作）\n\n\n---\n\n\n# 简单总结\n\n整个事件由dyld主导，完成运行环境的初始化后，配合ImageLoader将二进制文件按格式加载到内存，\n动态链接依赖库，并由runtime负责加载成objc定义的结构，所有初始化工作结束后，dyld调用真正的main函数。  \n值得说明的是，这个过程远比写出来的要复杂，这里只提到了runtime这个分支，还有像`GCD`、`XPC`等重头的系统库初始化分支没有提及（当然，有缓存机制在，它们也不会玩命初始化），总结起来就是main函数执行之前，系统做了茫茫多的加载和初始化工作，但都被很好的隐藏了，我们无需关心。\n\n\n---  \n\n# 孤独的main函数\n\n当这一切都结束时，dyld会清理现场，将调用栈回归，只剩下：\n![](http://ww3.sinaimg.cn/mw690/51530583jw1ejykutdlvsj20fc02smx9.jpg)\n孤独的main函数，看上去是程序的开始，确是一段精彩的终结\n\n---\n\n# References\nhttps://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html\nhttp://newosxbook.com/articles/DYLD.html\nhttp://docstore.mik.ua/orelly/unix3/mac/ch05_02.htm\nhttps://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/dyld.1.html\n","source":"_posts/objc-pre-main.md","raw":"title: iOS程序main函数之前发生了什么\ndate: 2014-08-30 15:26:01\ntags: objc刨根问底\n---\n\n# 我是前言\n\n一个iOS app的`main()`函数位于`main.m`中，这是我们熟知的**程序入口**。但对objc了解更多之后发现，程序在进入我们的`main`函数前已经执行了很多代码，比如熟知的`+ load`方法等。本文将跟随程序执行顺序，刨根问底，从`dyld`到`runtime`，看看main函数之前都发生了什么。\n\n<!--more-->\n\n---\n\n# 从dyld开始\n\n\n## 动态链接库  \n\niOS中用到的所有系统framework都是动态链接的，类比成插头和插排，静态链接的代码在编译后的静态链接过程就将插头和插排一个个插好，运行时直接执行二进制文件；而动态链接需要在程序启动时去完成“插插销”的过程，所以在我们写的代码执行前，动态连接器需要完成准备工作。\n\n这个是在xcode中看到的Link列表：  \n![](http://ww4.sinaimg.cn/mw600/51530583jw1ejx4ul5susj20wg0803zh.jpg)\n这些framework将会在动态链接过程中被加载，另外还有隐含link的framework，可以测试出来：先找到可执行文件，我这里叫`TestMain`的工程，模拟器路径下找到`TestMain.app`，可执行文件默认同名，再通过`otool`命令：\n\n``` shell\n$ otool -L TestMain\n```\n\n**-L**参数打印出所有link的framework（去掉了版本信息）：\n\n``` shell\nTestMain:\n    /System/Library/Frameworks/CoreGraphics.framework/CoreGraphics\n    /System/Library/Frameworks/UIKit.framework/UIKit\n    /System/Library/Frameworks/Foundation.framework/Foundation\n    /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\n    /usr/lib/libobjc.A.dylib\n    /usr/lib/libSystem.dylib\n```\n\n\n除了多了的`CoreGraphics`（被UIKit依赖）外，有两个默认添加的lib。**libobjc**即objc和runtime，**libSystem**中包含了很多系统级别lib，列几个熟知的：libdispatch(GCD)，libsystem_c(C语言库)，libsystem_blocks(Block)，libcommonCrypto(常用的md5函数)等等。这些lib都是`dylib`格式（如windows中的dll），系统使用动态链接有几点好处：\n\n- 代码共用：很多程序都动态链接了这些lib，但它们在内存和磁盘中中只有一份\n- 易于维护：由于被依赖的lib是程序执行时才link的，所以这些lib很容易做更新，比如`libSystem.dylib`是`libSystem.B.dylib`的替身，哪天想升级直接换成`libSystem.C.dylib`然后再替换替身就行了\n- 减少可执行文件体积：相比静态链接，可执行文件的体积要小很多\n\n## dyld\n\n`dyld` - the dynamic link editor（这缩写对应的很奇怪，我感觉是DYnamic Linker Daemon呢- -？）apple的动态链接器，系统kernel做好启动程序的初始准备后，交给dyld负责，援引并翻译[《mikeask这篇blog》](https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html)对dyld作用顺序的概括：\n\n1. 从kernel留下的原始调用栈引导和启动自己\n2. 将程序依赖的动态链接库`递归`加载进内存，当然这里有`缓存机制`\n3. non-lazy符号立即link到可执行文件，lazy的存表里\n4. Runs static initializers for the executable\n5. 找到可执行文件的main函数，准备参数并调用\n6. 程序执行中负责绑定lazy符号、提供runtime dynamic loading services、提供调试器接口\n7. 程序main函数return后执行static terminator\n8. 某些场景下main函数结束后调libSystem的_exit函数\n\n得益于dyld是开源的，[github地址](https://github.com/opensource-apple/dyld)，我们可以从源码一探究竟。\n\n一切源于`dyldStartup.s`这个文件，其中用汇编实现了名为`__dyld_start`的方法，汇编太生涩，它主要干了两件事：\n1. 调用`dyldbootstrap::start()`方法（省去参数）\n2. 上个方法返回了main函数地址，填入参数并调用main函数\n\n这个步骤随手就能验证出来，设置一个`符号断点`断在`_objc_init`：\n![](http://ww1.sinaimg.cn/mw600/51530583jw1ejxgn8un3cj20oo09675i.jpg)\n这个函数是`runtime`的初始化函数，后面会提到。程序运行在很早的时候断住，这时候看调用栈：  \n![](http://ww3.sinaimg.cn/mw600/51530583jw1ejxgwiptytj20jw0f0q5r.jpg)\n看到了栈底的`dyldbootstrap::start()`方法，继而调用了`dyld::_main()`方法，其中完成了刚才说的递归加载动态库过程，由于`libSystem`默认引入，栈中出现了`libSystem_initializer`的初始化方法。\n\n## ImageLoader\n\n当然这个image不是图片的意思，它大概表示一个二进制文件（可执行文件或so文件），里面是被编译过的符号、代码等，所以`ImageLoader`作用是将这些文件加载进内存，且**每一个文件对应一个ImageLoader实例来负责加载**。\n两步走：\n1. 在程序运行时它先将动态链接的image递归加载 （也就是上面测试栈中一串的递归调用的时刻）\n2. 再从可执行文件image递归加载所有符号\n\n当然所有这些都发生在我们真正的main函数执行前。\n\n\n---\n\n# runtime与+load\n\n刚才讲到`libSystem`是若干个系统lib的集合，所以它只是一个容器lib而已，而且它也是开源的，里面实质上就一个文件，[init.c](http://www.opensource.apple.com/source/Libsystem/Libsystem-169.3/init.c)，细节不说了，由`libSystem_initializer`逐步调用到了`_objc_init`，这里就是objc和runtime的初始化入口。\n\n除了runtime环境的初始化外，`_objc_init`中绑定了新image被加载后的callback：\n\n``` objc\ndyld_register_image_state_change_handler(dyld_image_state_bound,\n                                             1/*batch*/, &map_images);\ndyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &load_images);\n```\n\n可见dyld担当了`runtime`和`ImageLoader`中间的协调者，当新image加载进来后交由runtime大厨去解析这个二进制文件的符号表和代码。继续上面的断点法，断住神秘的`+load`函数：\n\n![](http://ww1.sinaimg.cn/mw690/51530583jw1ejyjgvetq1j20jk0bc0uf.jpg)\n\n清楚的看到整个调用栈和顺序：\n\n1. dyld开始将程序二进制文件初始化\n2. 交由ImageLoader读取image，其中包含了我们的类、方法等各种符号\n3. 由于runtime向dyld绑定了回调，当image加载到内存后，dyld会通知runtime进行处理\n4. runtime接手后调用map_images做解析和处理，接下来load_images中调用call_load_methods方法，遍历所有加载进来的Class，按继承层级依次调用Class的load方法和其Category的load方法\n\n至此，可执行文件中和动态库所有的符号（Class，Protocol，Selector，IMP，...）都已经按格式成功加载到内存中，被runtime所管理，再这之后，runtime的那些方法（动态添加Class、方法混合等等才能生效）\n\n## 关于load方法的几个QA\n\nQ: 重载自己Class的load方法时需不需要调父类？\nA: runtime负责按继承顺序递归调用，所以我们不能调super\n\nQ: 在自己Class的load方法时能不能替换系统framework（比如UIKit）中的某个类的方法实现\nA: 可以，因为动态链接过程中，所有依赖库的类是先于自己的类加载的\n\nQ: 重载load时需要手动添加@autoreleasepool么？\nA: 不需要，在runtime调用load方法前后是加了`objc_autoreleasePoolPush()`和`objc_autoreleasePoolPop()`的。\n\nQ: 想让一个类的load方法被调用是否需要在某个地方import这个文件\nA: 不需要，只要这个类的符号被编译到最后的可执行文件中，load方法就会被调用（Reveal SDK就是利用这一点，只要引入到工程中就能工作）\n\n\n---\n\n\n# 简单总结\n\n整个事件由dyld主导，完成运行环境的初始化后，配合ImageLoader将二进制文件按格式加载到内存，\n动态链接依赖库，并由runtime负责加载成objc定义的结构，所有初始化工作结束后，dyld调用真正的main函数。  \n值得说明的是，这个过程远比写出来的要复杂，这里只提到了runtime这个分支，还有像`GCD`、`XPC`等重头的系统库初始化分支没有提及（当然，有缓存机制在，它们也不会玩命初始化），总结起来就是main函数执行之前，系统做了茫茫多的加载和初始化工作，但都被很好的隐藏了，我们无需关心。\n\n\n---  \n\n# 孤独的main函数\n\n当这一切都结束时，dyld会清理现场，将调用栈回归，只剩下：\n![](http://ww3.sinaimg.cn/mw690/51530583jw1ejykutdlvsj20fc02smx9.jpg)\n孤独的main函数，看上去是程序的开始，确是一段精彩的终结\n\n---\n\n# References\nhttps://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html\nhttp://newosxbook.com/articles/DYLD.html\nhttp://docstore.mik.ua/orelly/unix3/mac/ch05_02.htm\nhttps://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/dyld.1.html\n","slug":"objc-pre-main","published":1,"updated":"2016-03-27T07:57:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxlt001jev12hbpf5a2z","content":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>一个iOS app的<code>main()</code>函数位于<code>main.m</code>中，这是我们熟知的<strong>程序入口</strong>。但对objc了解更多之后发现，程序在进入我们的<code>main</code>函数前已经执行了很多代码，比如熟知的<code>+ load</code>方法等。本文将跟随程序执行顺序，刨根问底，从<code>dyld</code>到<code>runtime</code>，看看main函数之前都发生了什么。</p>\n<a id=\"more\"></a>\n<hr>\n<h1 id=\"从dyld开始\"><a href=\"#从dyld开始\" class=\"headerlink\" title=\"从dyld开始\"></a>从dyld开始</h1><h2 id=\"动态链接库\"><a href=\"#动态链接库\" class=\"headerlink\" title=\"动态链接库\"></a>动态链接库</h2><p>iOS中用到的所有系统framework都是动态链接的，类比成插头和插排，静态链接的代码在编译后的静态链接过程就将插头和插排一个个插好，运行时直接执行二进制文件；而动态链接需要在程序启动时去完成“插插销”的过程，所以在我们写的代码执行前，动态连接器需要完成准备工作。</p>\n<p>这个是在xcode中看到的Link列表：<br><img src=\"http://ww4.sinaimg.cn/mw600/51530583jw1ejx4ul5susj20wg0803zh.jpg\" alt=\"\"><br>这些framework将会在动态链接过程中被加载，另外还有隐含link的framework，可以测试出来：先找到可执行文件，我这里叫<code>TestMain</code>的工程，模拟器路径下找到<code>TestMain.app</code>，可执行文件默认同名，再通过<code>otool</code>命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ otool -L TestMain</span><br></pre></td></tr></table></figure>\n<p><strong>-L</strong>参数打印出所有link的framework（去掉了版本信息）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestMain:</span><br><span class=\"line\">    /System/Library/Frameworks/CoreGraphics.framework/CoreGraphics</span><br><span class=\"line\">    /System/Library/Frameworks/UIKit.framework/UIKit</span><br><span class=\"line\">    /System/Library/Frameworks/Foundation.framework/Foundation</span><br><span class=\"line\">    /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation</span><br><span class=\"line\">    /usr/lib/libobjc.A.dylib</span><br><span class=\"line\">    /usr/lib/libSystem.dylib</span><br></pre></td></tr></table></figure>\n<p>除了多了的<code>CoreGraphics</code>（被UIKit依赖）外，有两个默认添加的lib。<strong>libobjc</strong>即objc和runtime，<strong>libSystem</strong>中包含了很多系统级别lib，列几个熟知的：libdispatch(GCD)，libsystem_c(C语言库)，libsystem_blocks(Block)，libcommonCrypto(常用的md5函数)等等。这些lib都是<code>dylib</code>格式（如windows中的dll），系统使用动态链接有几点好处：</p>\n<ul>\n<li>代码共用：很多程序都动态链接了这些lib，但它们在内存和磁盘中中只有一份</li>\n<li>易于维护：由于被依赖的lib是程序执行时才link的，所以这些lib很容易做更新，比如<code>libSystem.dylib</code>是<code>libSystem.B.dylib</code>的替身，哪天想升级直接换成<code>libSystem.C.dylib</code>然后再替换替身就行了</li>\n<li>减少可执行文件体积：相比静态链接，可执行文件的体积要小很多</li>\n</ul>\n<h2 id=\"dyld\"><a href=\"#dyld\" class=\"headerlink\" title=\"dyld\"></a>dyld</h2><p><code>dyld</code> - the dynamic link editor（这缩写对应的很奇怪，我感觉是DYnamic Linker Daemon呢- -？）apple的动态链接器，系统kernel做好启动程序的初始准备后，交给dyld负责，援引并翻译<a href=\"https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html\" target=\"_blank\" rel=\"external\">《mikeask这篇blog》</a>对dyld作用顺序的概括：</p>\n<ol>\n<li>从kernel留下的原始调用栈引导和启动自己</li>\n<li>将程序依赖的动态链接库<code>递归</code>加载进内存，当然这里有<code>缓存机制</code></li>\n<li>non-lazy符号立即link到可执行文件，lazy的存表里</li>\n<li>Runs static initializers for the executable</li>\n<li>找到可执行文件的main函数，准备参数并调用</li>\n<li>程序执行中负责绑定lazy符号、提供runtime dynamic loading services、提供调试器接口</li>\n<li>程序main函数return后执行static terminator</li>\n<li>某些场景下main函数结束后调libSystem的_exit函数</li>\n</ol>\n<p>得益于dyld是开源的，<a href=\"https://github.com/opensource-apple/dyld\" target=\"_blank\" rel=\"external\">github地址</a>，我们可以从源码一探究竟。</p>\n<p>一切源于<code>dyldStartup.s</code>这个文件，其中用汇编实现了名为<code>__dyld_start</code>的方法，汇编太生涩，它主要干了两件事：</p>\n<ol>\n<li>调用<code>dyldbootstrap::start()</code>方法（省去参数）</li>\n<li>上个方法返回了main函数地址，填入参数并调用main函数</li>\n</ol>\n<p>这个步骤随手就能验证出来，设置一个<code>符号断点</code>断在<code>_objc_init</code>：<br><img src=\"http://ww1.sinaimg.cn/mw600/51530583jw1ejxgn8un3cj20oo09675i.jpg\" alt=\"\"><br>这个函数是<code>runtime</code>的初始化函数，后面会提到。程序运行在很早的时候断住，这时候看调用栈：<br><img src=\"http://ww3.sinaimg.cn/mw600/51530583jw1ejxgwiptytj20jw0f0q5r.jpg\" alt=\"\"><br>看到了栈底的<code>dyldbootstrap::start()</code>方法，继而调用了<code>dyld::_main()</code>方法，其中完成了刚才说的递归加载动态库过程，由于<code>libSystem</code>默认引入，栈中出现了<code>libSystem_initializer</code>的初始化方法。</p>\n<h2 id=\"ImageLoader\"><a href=\"#ImageLoader\" class=\"headerlink\" title=\"ImageLoader\"></a>ImageLoader</h2><p>当然这个image不是图片的意思，它大概表示一个二进制文件（可执行文件或so文件），里面是被编译过的符号、代码等，所以<code>ImageLoader</code>作用是将这些文件加载进内存，且<strong>每一个文件对应一个ImageLoader实例来负责加载</strong>。<br>两步走：</p>\n<ol>\n<li>在程序运行时它先将动态链接的image递归加载 （也就是上面测试栈中一串的递归调用的时刻）</li>\n<li>再从可执行文件image递归加载所有符号</li>\n</ol>\n<p>当然所有这些都发生在我们真正的main函数执行前。</p>\n<hr>\n<h1 id=\"runtime与-load\"><a href=\"#runtime与-load\" class=\"headerlink\" title=\"runtime与+load\"></a>runtime与+load</h1><p>刚才讲到<code>libSystem</code>是若干个系统lib的集合，所以它只是一个容器lib而已，而且它也是开源的，里面实质上就一个文件，<a href=\"http://www.opensource.apple.com/source/Libsystem/Libsystem-169.3/init.c\" target=\"_blank\" rel=\"external\">init.c</a>，细节不说了，由<code>libSystem_initializer</code>逐步调用到了<code>_objc_init</code>，这里就是objc和runtime的初始化入口。</p>\n<p>除了runtime环境的初始化外，<code>_objc_init</code>中绑定了新image被加载后的callback：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dyld_register_image_state_change_handler(dyld_image_state_bound,</span><br><span class=\"line\">                                             <span class=\"number\">1</span><span class=\"comment\">/*batch*/</span>, &amp;map_images);</span><br><span class=\"line\">dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, <span class=\"number\">0</span><span class=\"comment\">/*not batch*/</span>, &amp;load_images);</span><br></pre></td></tr></table></figure>\n<p>可见dyld担当了<code>runtime</code>和<code>ImageLoader</code>中间的协调者，当新image加载进来后交由runtime大厨去解析这个二进制文件的符号表和代码。继续上面的断点法，断住神秘的<code>+load</code>函数：</p>\n<p><img src=\"http://ww1.sinaimg.cn/mw690/51530583jw1ejyjgvetq1j20jk0bc0uf.jpg\" alt=\"\"></p>\n<p>清楚的看到整个调用栈和顺序：</p>\n<ol>\n<li>dyld开始将程序二进制文件初始化</li>\n<li>交由ImageLoader读取image，其中包含了我们的类、方法等各种符号</li>\n<li>由于runtime向dyld绑定了回调，当image加载到内存后，dyld会通知runtime进行处理</li>\n<li>runtime接手后调用map_images做解析和处理，接下来load_images中调用call_load_methods方法，遍历所有加载进来的Class，按继承层级依次调用Class的load方法和其Category的load方法</li>\n</ol>\n<p>至此，可执行文件中和动态库所有的符号（Class，Protocol，Selector，IMP，…）都已经按格式成功加载到内存中，被runtime所管理，再这之后，runtime的那些方法（动态添加Class、方法混合等等才能生效）</p>\n<h2 id=\"关于load方法的几个QA\"><a href=\"#关于load方法的几个QA\" class=\"headerlink\" title=\"关于load方法的几个QA\"></a>关于load方法的几个QA</h2><p>Q: 重载自己Class的load方法时需不需要调父类？<br>A: runtime负责按继承顺序递归调用，所以我们不能调super</p>\n<p>Q: 在自己Class的load方法时能不能替换系统framework（比如UIKit）中的某个类的方法实现<br>A: 可以，因为动态链接过程中，所有依赖库的类是先于自己的类加载的</p>\n<p>Q: 重载load时需要手动添加@autoreleasepool么？<br>A: 不需要，在runtime调用load方法前后是加了<code>objc_autoreleasePoolPush()</code>和<code>objc_autoreleasePoolPop()</code>的。</p>\n<p>Q: 想让一个类的load方法被调用是否需要在某个地方import这个文件<br>A: 不需要，只要这个类的符号被编译到最后的可执行文件中，load方法就会被调用（Reveal SDK就是利用这一点，只要引入到工程中就能工作）</p>\n<hr>\n<h1 id=\"简单总结\"><a href=\"#简单总结\" class=\"headerlink\" title=\"简单总结\"></a>简单总结</h1><p>整个事件由dyld主导，完成运行环境的初始化后，配合ImageLoader将二进制文件按格式加载到内存，<br>动态链接依赖库，并由runtime负责加载成objc定义的结构，所有初始化工作结束后，dyld调用真正的main函数。<br>值得说明的是，这个过程远比写出来的要复杂，这里只提到了runtime这个分支，还有像<code>GCD</code>、<code>XPC</code>等重头的系统库初始化分支没有提及（当然，有缓存机制在，它们也不会玩命初始化），总结起来就是main函数执行之前，系统做了茫茫多的加载和初始化工作，但都被很好的隐藏了，我们无需关心。</p>\n<hr>\n<h1 id=\"孤独的main函数\"><a href=\"#孤独的main函数\" class=\"headerlink\" title=\"孤独的main函数\"></a>孤独的main函数</h1><p>当这一切都结束时，dyld会清理现场，将调用栈回归，只剩下：<br><img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1ejykutdlvsj20fc02smx9.jpg\" alt=\"\"><br>孤独的main函数，看上去是程序的开始，确是一段精彩的终结</p>\n<hr>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html\" target=\"_blank\" rel=\"external\">https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html</a><br><a href=\"http://newosxbook.com/articles/DYLD.html\" target=\"_blank\" rel=\"external\">http://newosxbook.com/articles/DYLD.html</a><br><a href=\"http://docstore.mik.ua/orelly/unix3/mac/ch05_02.htm\" target=\"_blank\" rel=\"external\">http://docstore.mik.ua/orelly/unix3/mac/ch05_02.htm</a><br><a href=\"https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/dyld.1.html\" target=\"_blank\" rel=\"external\">https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/dyld.1.html</a></p>\n","excerpt":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>一个iOS app的<code>main()</code>函数位于<code>main.m</code>中，这是我们熟知的<strong>程序入口</strong>。但对objc了解更多之后发现，程序在进入我们的<code>main</code>函数前已经执行了很多代码，比如熟知的<code>+ load</code>方法等。本文将跟随程序执行顺序，刨根问底，从<code>dyld</code>到<code>runtime</code>，看看main函数之前都发生了什么。</p>","more":"<hr>\n<h1 id=\"从dyld开始\"><a href=\"#从dyld开始\" class=\"headerlink\" title=\"从dyld开始\"></a>从dyld开始</h1><h2 id=\"动态链接库\"><a href=\"#动态链接库\" class=\"headerlink\" title=\"动态链接库\"></a>动态链接库</h2><p>iOS中用到的所有系统framework都是动态链接的，类比成插头和插排，静态链接的代码在编译后的静态链接过程就将插头和插排一个个插好，运行时直接执行二进制文件；而动态链接需要在程序启动时去完成“插插销”的过程，所以在我们写的代码执行前，动态连接器需要完成准备工作。</p>\n<p>这个是在xcode中看到的Link列表：<br><img src=\"http://ww4.sinaimg.cn/mw600/51530583jw1ejx4ul5susj20wg0803zh.jpg\" alt=\"\"><br>这些framework将会在动态链接过程中被加载，另外还有隐含link的framework，可以测试出来：先找到可执行文件，我这里叫<code>TestMain</code>的工程，模拟器路径下找到<code>TestMain.app</code>，可执行文件默认同名，再通过<code>otool</code>命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ otool -L TestMain</span><br></pre></td></tr></table></figure>\n<p><strong>-L</strong>参数打印出所有link的framework（去掉了版本信息）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestMain:</span><br><span class=\"line\">    /System/Library/Frameworks/CoreGraphics.framework/CoreGraphics</span><br><span class=\"line\">    /System/Library/Frameworks/UIKit.framework/UIKit</span><br><span class=\"line\">    /System/Library/Frameworks/Foundation.framework/Foundation</span><br><span class=\"line\">    /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation</span><br><span class=\"line\">    /usr/lib/libobjc.A.dylib</span><br><span class=\"line\">    /usr/lib/libSystem.dylib</span><br></pre></td></tr></table></figure>\n<p>除了多了的<code>CoreGraphics</code>（被UIKit依赖）外，有两个默认添加的lib。<strong>libobjc</strong>即objc和runtime，<strong>libSystem</strong>中包含了很多系统级别lib，列几个熟知的：libdispatch(GCD)，libsystem_c(C语言库)，libsystem_blocks(Block)，libcommonCrypto(常用的md5函数)等等。这些lib都是<code>dylib</code>格式（如windows中的dll），系统使用动态链接有几点好处：</p>\n<ul>\n<li>代码共用：很多程序都动态链接了这些lib，但它们在内存和磁盘中中只有一份</li>\n<li>易于维护：由于被依赖的lib是程序执行时才link的，所以这些lib很容易做更新，比如<code>libSystem.dylib</code>是<code>libSystem.B.dylib</code>的替身，哪天想升级直接换成<code>libSystem.C.dylib</code>然后再替换替身就行了</li>\n<li>减少可执行文件体积：相比静态链接，可执行文件的体积要小很多</li>\n</ul>\n<h2 id=\"dyld\"><a href=\"#dyld\" class=\"headerlink\" title=\"dyld\"></a>dyld</h2><p><code>dyld</code> - the dynamic link editor（这缩写对应的很奇怪，我感觉是DYnamic Linker Daemon呢- -？）apple的动态链接器，系统kernel做好启动程序的初始准备后，交给dyld负责，援引并翻译<a href=\"https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html\">《mikeask这篇blog》</a>对dyld作用顺序的概括：</p>\n<ol>\n<li>从kernel留下的原始调用栈引导和启动自己</li>\n<li>将程序依赖的动态链接库<code>递归</code>加载进内存，当然这里有<code>缓存机制</code></li>\n<li>non-lazy符号立即link到可执行文件，lazy的存表里</li>\n<li>Runs static initializers for the executable</li>\n<li>找到可执行文件的main函数，准备参数并调用</li>\n<li>程序执行中负责绑定lazy符号、提供runtime dynamic loading services、提供调试器接口</li>\n<li>程序main函数return后执行static terminator</li>\n<li>某些场景下main函数结束后调libSystem的_exit函数</li>\n</ol>\n<p>得益于dyld是开源的，<a href=\"https://github.com/opensource-apple/dyld\">github地址</a>，我们可以从源码一探究竟。</p>\n<p>一切源于<code>dyldStartup.s</code>这个文件，其中用汇编实现了名为<code>__dyld_start</code>的方法，汇编太生涩，它主要干了两件事：</p>\n<ol>\n<li>调用<code>dyldbootstrap::start()</code>方法（省去参数）</li>\n<li>上个方法返回了main函数地址，填入参数并调用main函数</li>\n</ol>\n<p>这个步骤随手就能验证出来，设置一个<code>符号断点</code>断在<code>_objc_init</code>：<br><img src=\"http://ww1.sinaimg.cn/mw600/51530583jw1ejxgn8un3cj20oo09675i.jpg\" alt=\"\"><br>这个函数是<code>runtime</code>的初始化函数，后面会提到。程序运行在很早的时候断住，这时候看调用栈：<br><img src=\"http://ww3.sinaimg.cn/mw600/51530583jw1ejxgwiptytj20jw0f0q5r.jpg\" alt=\"\"><br>看到了栈底的<code>dyldbootstrap::start()</code>方法，继而调用了<code>dyld::_main()</code>方法，其中完成了刚才说的递归加载动态库过程，由于<code>libSystem</code>默认引入，栈中出现了<code>libSystem_initializer</code>的初始化方法。</p>\n<h2 id=\"ImageLoader\"><a href=\"#ImageLoader\" class=\"headerlink\" title=\"ImageLoader\"></a>ImageLoader</h2><p>当然这个image不是图片的意思，它大概表示一个二进制文件（可执行文件或so文件），里面是被编译过的符号、代码等，所以<code>ImageLoader</code>作用是将这些文件加载进内存，且<strong>每一个文件对应一个ImageLoader实例来负责加载</strong>。<br>两步走：</p>\n<ol>\n<li>在程序运行时它先将动态链接的image递归加载 （也就是上面测试栈中一串的递归调用的时刻）</li>\n<li>再从可执行文件image递归加载所有符号</li>\n</ol>\n<p>当然所有这些都发生在我们真正的main函数执行前。</p>\n<hr>\n<h1 id=\"runtime与-load\"><a href=\"#runtime与-load\" class=\"headerlink\" title=\"runtime与+load\"></a>runtime与+load</h1><p>刚才讲到<code>libSystem</code>是若干个系统lib的集合，所以它只是一个容器lib而已，而且它也是开源的，里面实质上就一个文件，<a href=\"http://www.opensource.apple.com/source/Libsystem/Libsystem-169.3/init.c\">init.c</a>，细节不说了，由<code>libSystem_initializer</code>逐步调用到了<code>_objc_init</code>，这里就是objc和runtime的初始化入口。</p>\n<p>除了runtime环境的初始化外，<code>_objc_init</code>中绑定了新image被加载后的callback：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dyld_register_image_state_change_handler(dyld_image_state_bound,</span><br><span class=\"line\">                                             <span class=\"number\">1</span><span class=\"comment\">/*batch*/</span>, &amp;map_images);</span><br><span class=\"line\">dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, <span class=\"number\">0</span><span class=\"comment\">/*not batch*/</span>, &amp;load_images);</span><br></pre></td></tr></table></figure>\n<p>可见dyld担当了<code>runtime</code>和<code>ImageLoader</code>中间的协调者，当新image加载进来后交由runtime大厨去解析这个二进制文件的符号表和代码。继续上面的断点法，断住神秘的<code>+load</code>函数：</p>\n<p><img src=\"http://ww1.sinaimg.cn/mw690/51530583jw1ejyjgvetq1j20jk0bc0uf.jpg\" alt=\"\"></p>\n<p>清楚的看到整个调用栈和顺序：</p>\n<ol>\n<li>dyld开始将程序二进制文件初始化</li>\n<li>交由ImageLoader读取image，其中包含了我们的类、方法等各种符号</li>\n<li>由于runtime向dyld绑定了回调，当image加载到内存后，dyld会通知runtime进行处理</li>\n<li>runtime接手后调用map_images做解析和处理，接下来load_images中调用call_load_methods方法，遍历所有加载进来的Class，按继承层级依次调用Class的load方法和其Category的load方法</li>\n</ol>\n<p>至此，可执行文件中和动态库所有的符号（Class，Protocol，Selector，IMP，…）都已经按格式成功加载到内存中，被runtime所管理，再这之后，runtime的那些方法（动态添加Class、方法混合等等才能生效）</p>\n<h2 id=\"关于load方法的几个QA\"><a href=\"#关于load方法的几个QA\" class=\"headerlink\" title=\"关于load方法的几个QA\"></a>关于load方法的几个QA</h2><p>Q: 重载自己Class的load方法时需不需要调父类？<br>A: runtime负责按继承顺序递归调用，所以我们不能调super</p>\n<p>Q: 在自己Class的load方法时能不能替换系统framework（比如UIKit）中的某个类的方法实现<br>A: 可以，因为动态链接过程中，所有依赖库的类是先于自己的类加载的</p>\n<p>Q: 重载load时需要手动添加@autoreleasepool么？<br>A: 不需要，在runtime调用load方法前后是加了<code>objc_autoreleasePoolPush()</code>和<code>objc_autoreleasePoolPop()</code>的。</p>\n<p>Q: 想让一个类的load方法被调用是否需要在某个地方import这个文件<br>A: 不需要，只要这个类的符号被编译到最后的可执行文件中，load方法就会被调用（Reveal SDK就是利用这一点，只要引入到工程中就能工作）</p>\n<hr>\n<h1 id=\"简单总结\"><a href=\"#简单总结\" class=\"headerlink\" title=\"简单总结\"></a>简单总结</h1><p>整个事件由dyld主导，完成运行环境的初始化后，配合ImageLoader将二进制文件按格式加载到内存，<br>动态链接依赖库，并由runtime负责加载成objc定义的结构，所有初始化工作结束后，dyld调用真正的main函数。<br>值得说明的是，这个过程远比写出来的要复杂，这里只提到了runtime这个分支，还有像<code>GCD</code>、<code>XPC</code>等重头的系统库初始化分支没有提及（当然，有缓存机制在，它们也不会玩命初始化），总结起来就是main函数执行之前，系统做了茫茫多的加载和初始化工作，但都被很好的隐藏了，我们无需关心。</p>\n<hr>\n<h1 id=\"孤独的main函数\"><a href=\"#孤独的main函数\" class=\"headerlink\" title=\"孤独的main函数\"></a>孤独的main函数</h1><p>当这一切都结束时，dyld会清理现场，将调用栈回归，只剩下：<br><img src=\"http://ww3.sinaimg.cn/mw690/51530583jw1ejykutdlvsj20fc02smx9.jpg\" alt=\"\"><br>孤独的main函数，看上去是程序的开始，确是一段精彩的终结</p>\n<hr>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html\">https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html</a><br><a href=\"http://newosxbook.com/articles/DYLD.html\">http://newosxbook.com/articles/DYLD.html</a><br><a href=\"http://docstore.mik.ua/orelly/unix3/mac/ch05_02.htm\">http://docstore.mik.ua/orelly/unix3/mac/ch05_02.htm</a><br><a href=\"https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/dyld.1.html\">https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/dyld.1.html</a></p>"},{"title":"objc非主流代码技巧","date":"2014-08-02T06:00:00.000Z","_content":"## 我是前言\n\n看开源代码时，总会看到一些大神级别的代码，给人眼前一亮的感觉，多数都是被淡忘的C语言语法，总结下objc写码中遇到的各类`非主流`代码技巧和一些妙用：\n\n- [娱乐向]objc最短的方法声明\n- [C]结构体的初始化\n- [C]三元条件表达式的两元使用\n- [C]数组的下标初始化\n- [objc]可变参数类型的block\n- [objc]readonly属性支持扩展的写法\n- [C]小括号内联复合表达式\n- [娱乐向]奇葩的C函数写法\n- [Macro]预处理时计算可变参数个数\n- [Macro]预处理断言\n- [多重]带自动提示的keypath宏\n\n---\n\n## [娱乐向]objc最短的方法声明\n\n先来个娱乐向的。  \n方法声明时有一下几个trick：  \n\n返回值的`- (TYPE)`如果不写括号，编译器默认认为是`- (id)`类型:\n\n``` objc\n- init;\n- (id)init; // 等价于\n```\n\n同理，参数如果不写类型默认也是`id`类型:  \n\n``` objc\n- (void)foo:arg;\n- (void)foo:(id)arg; // 等价于\n```\n\n还有，有多参数时`方法名`和`参数提示语`可以为空\n\n``` objc\n- (void):(id)arg1 :(id)arg2;\n- (void)foo:(id)arg1 bar:(id)arg2; // 省略前\n```\n\n综上，最短的函数可以写成这样：\n\n``` objc\n- _;   // 没错，这是一个oc方法声明\n- :_;  // 这是一个带一个参数的oc方法声明\n// 等价于\n- (id)_;\n- (id) :(id)_;\n```\n\n_PS: 方法名都没的方法只能靠`performSelector`来调用了，`selector`是`\":\"`  _\n\n-----\n\n\n## [C]结构体的初始化\n\n``` objc\n// 不加(CGRect)强转也不会warning\nCGRect rect1 = {1, 2, 3, 4};\nCGRect rect2 = {.origin.x=5, .size={10, 10}}; // {5, 0, 10, 10}\nCGRect rect3 = {1, 2}; // {1, 2, 0, 0}\n```\n\n\n## [C]三元条件表达式的两元使用  \n\n三元条件表达式`?:`是C中唯一一个三目运算符，用来替代简单的`if-else`语句，同时也是可以**两元**使用的：\n\n``` objc\nNSString *string = inputString ?: @\"default\";\nNSString *string = inputString ? inputString : @\"default\"; // 等价\n```\n利用这个特性，我们还脑洞出了一个一行代码的 block 调用，平时我们的 block 是这样调用：\n\n``` objc\nif (block0) {\n  block0();\n}\n// or\nif (block1) {\n  int result = block1(1, 2);\n}\n```\n\n居然可以简化成下面的样子：\n\n``` objc\n!block0 ?: block0();\nint result = !block1 ?: block1(1, 2);\n```\n\n## [C]数组的下标初始化  \n\n``` objc\nconst int numbers[] = {\n    [1] = 3,\n    [2] = 2,\n    [3] = 1,\n    [5] = 12306\n};\n// {0, 3, 2, 1, 0, 12306}\n```\n\n这个特性可以用来做`枚举值和字符串的映射`\n\n``` objc\ntypedef NS_ENUM(NSInteger, XXType){\n    XXType1,\n    XXType2\n};\nconst NSString *XXTypeNameMapping[] = {\n    [XXType1] = @\"Type1\",\n    [XXType2] = @\"Type2\"\n};\n```\n\n---\n\n## [objc]可变参数类型的block\n\n一个block像下面一样声明：\n\n``` objc\nvoid(^block1)(void);\nvoid(^block2)(int a);\nvoid(^block3)(NSNumber *a, NSString *b);\n```\n**如果block的参数列表为空的话，相当于可变参数（不是void）**\n\n``` objc\nvoid(^block)(); // 返回值为void，参数可变的block\nblock = block1; // 正常\nblock = block2; // 正常\nblock = block3; // 正常\nblock(@1, @\"string\");  // 对应上面的block3\nblock(@1); // block3的第一个参数为@1，第二个为nil\n```\n\n这样，block的主调和回调之间可以通过`约定`来决定block回传回来的参数是什么，有几个。如一个对网络层的调用：  \n\n``` objc\n- (void)requestDataWithApi:(NSInteger)api block:(void(^)())block {\n    if (api == 0) {\n        block(1, 2);\n    }\n    else if (api == 1) {\n        block(@\"1\", @2, @[@\"3\", @\"4\", @\"5\"]);\n    }\n}\n\n```\n\n主调者知道自己请求的是哪个Api，那么根据`约定`，他就知道block里面应该接受哪几个参数：\n\n``` objc\n[server requestDataWithApi:0 block:^(NSInteger a, NSInteger b){\n    // ...\n}];\n[server requestDataWithApi:1 block:^(NSString *s, NSNumber *n, NSArray *a){\n    // ...\n}];\n```\n\n这个特性在`Reactive Cocoa`的`-combineLatest:reduce:`等类似方法中已经使用的相当好了。\n\n``` objc\n+ (RACSignal *)combineLatest:(id<NSFastEnumeration>)signals reduce:(id (^)())reduceBlock;\n```\n\n## [objc]readonly属性支持扩展的写法\n\n假如一个类有一个`readonly`属性：\n\n``` objc\n@interface Sark : NSObject\n@property (nonatomic, readonly) NSArray *friends;\n@end\n```\n`.m`中可以使用`_friends`来使用自动合成的这个变量，但假如：\n\n - 习惯使用`self.`来set实例变量时（只合成了getter）\n - 希望重写getter进行懒加载时（重写getter时则不会生成下划线的变量，除非手动`@synthesize`）\n - 允许子类重载这个属性来修改它时（编译报错属性修饰符不匹配）\n\n这种`readonly`声明方法就行不通了，所以下面的写法更有通用性：\n\n``` objc\n@interface Sark : NSObject\n@property (nonatomic, readonly, copy/*加上setter属性修饰符*/) NSArray *friends;\n@end\n```\n如想在`.m`中像正常属性一样使用：\n\n``` objc\n@interface Sark ()\n@property (nonatomic, copy) NSArray *friends;\n@end\n```\n\n子类化时同理。iOS SDK中很多地方都用到了这个特性。  \n\n-----\n\n## [C]小括号内联复合表达式\n\n`A compound statement enclosed in parentheses`原谅我的渣翻译- -，来自[《gcc官方对此的说明》](https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html)，源自gcc对c的扩展，如今被clang继承。  \n\n``` objc\nRETURN_VALUE_RECEIVER = {(\n    // Do whatever you want\n    RETURN_VALUE; // 返回值\n)};\n```\n于是乎可以发挥想象力了：\n\n``` objc\nself.backgroundView = ({\n    UIView *view = [[UIView alloc] initWithFrame:self.view.bounds];\n    view.backgroundColor = [UIColor redColor];\n    view.alpha = 0.8f;\n    view;\n});\n```\n\n有点像block和内联函数的结合体，它最大的意义在于将代码`整理分块`，将同一个逻辑层级的代码包在一起；同时对于一个无需复用小段逻辑，也免去了重量级的调用函数，如：\n\n``` objc\nself.result = ({\n    double result = 0;\n    for (int i = 0; i <= M_2_PI; i+= M_PI_4) {\n        result += sin(i);\n    }\n    result;\n});\n```\n\n这样使得代码量增大时层次仍然能比较明确。  \n\n_PS: 返回值和代码块结束点必须在结尾_\n\n\n## [娱乐向]奇葩的C函数写法\n\n正常编译执行：  \n\n``` c\nint sum(a,b)\nint a; int b;\n{\n    return a + b;\n}\n```\n\n## [Macro]预处理时计算可变参数个数\n\n``` c\n#define COUNT_PARMS2(_a1, _a2, _a3, _a4, _a5, RESULT, ...) RESULT\n#define COUNT_PARMS(...) COUNT_PARMS2(__VA_ARGS__, 5, 4, 3, 2, 1)\nint count = COUNT_PARMS(1,2,3); // 预处理时count==3\n```\n\n## [Macro]预处理断言  \n\n下面的断言在编译前就生效  \n\n``` c\n#define C_ASSERT(test) \\\n    switch(0) {\\\n          case 0:\\\n          case test:;\\\n    }\n\n```\n\n如断言上面预处理时计算可变参数个数：  \n\n``` c\nC_ASSERT(COUNT_PARMS(1,2,3) == 2);\n```\n\n如果断言失败，相当于`switch-case`中出现了两个`case:0`，则编译报错。  \n\n## [多重]带自动提示的keypath宏  \n\n源自`Reactive Cocoa`中的宏：  \n\n``` c\n#define keypath2(OBJ, PATH) \\\n    (((void)(NO && ((void)OBJ.PATH, NO)), # PATH))\n```\n\n原来写过一篇[《介绍RAC宏的文章》](http://blog.sunnyxx.com/2014/03/06/rac_1_macros/)中曾经写过。这个宏在写PATH参数的同时是带自动提示的：  \n![](http://images.cnitblog.com/blog/401798/201402/112147518936541.png)\n\n### 逗号表达式\n逗号表达式取后值，但前值的表达式参与运算，可用void忽略编译器警告\n\n``` c\nint a = ((void)(1+2), 2); // a == 2\n```\n\n于是上面的keypath宏的输出结果是`#PATH`也就是一个c字符串\n\n### 逻辑最短路径   \n\n之前的文章没有弄清上面宏中`NO&&NO`的含义，其实这用到了编译器优化的特性：  \n\n```\nif (NO && [self shouldDo]/*不执行*/) {\n    // 不执行\n}\n```  \n\n编译器知道在NO后且什么的结果都是NO，于是后面的语句被优化掉了。也就是说keypath宏中这个`NO && ((void)OBJ.PATH, NO)`就使得在编译后后面的部分不出现在最后的代码中，于是乎既实现了keypath的自动提示功能，又保证编译后不执行多余的代码。  \n\n-----\n\n# References  \nhttps://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html\n","source":"_posts/objc-weird-code.md","raw":"title: objc非主流代码技巧\ndate: 2014-08-02 14:00:00\ntags: ios最佳实践\n---\n## 我是前言\n\n看开源代码时，总会看到一些大神级别的代码，给人眼前一亮的感觉，多数都是被淡忘的C语言语法，总结下objc写码中遇到的各类`非主流`代码技巧和一些妙用：\n\n- [娱乐向]objc最短的方法声明\n- [C]结构体的初始化\n- [C]三元条件表达式的两元使用\n- [C]数组的下标初始化\n- [objc]可变参数类型的block\n- [objc]readonly属性支持扩展的写法\n- [C]小括号内联复合表达式\n- [娱乐向]奇葩的C函数写法\n- [Macro]预处理时计算可变参数个数\n- [Macro]预处理断言\n- [多重]带自动提示的keypath宏\n\n---\n\n## [娱乐向]objc最短的方法声明\n\n先来个娱乐向的。  \n方法声明时有一下几个trick：  \n\n返回值的`- (TYPE)`如果不写括号，编译器默认认为是`- (id)`类型:\n\n``` objc\n- init;\n- (id)init; // 等价于\n```\n\n同理，参数如果不写类型默认也是`id`类型:  \n\n``` objc\n- (void)foo:arg;\n- (void)foo:(id)arg; // 等价于\n```\n\n还有，有多参数时`方法名`和`参数提示语`可以为空\n\n``` objc\n- (void):(id)arg1 :(id)arg2;\n- (void)foo:(id)arg1 bar:(id)arg2; // 省略前\n```\n\n综上，最短的函数可以写成这样：\n\n``` objc\n- _;   // 没错，这是一个oc方法声明\n- :_;  // 这是一个带一个参数的oc方法声明\n// 等价于\n- (id)_;\n- (id) :(id)_;\n```\n\n_PS: 方法名都没的方法只能靠`performSelector`来调用了，`selector`是`\":\"`  _\n\n-----\n\n\n## [C]结构体的初始化\n\n``` objc\n// 不加(CGRect)强转也不会warning\nCGRect rect1 = {1, 2, 3, 4};\nCGRect rect2 = {.origin.x=5, .size={10, 10}}; // {5, 0, 10, 10}\nCGRect rect3 = {1, 2}; // {1, 2, 0, 0}\n```\n\n\n## [C]三元条件表达式的两元使用  \n\n三元条件表达式`?:`是C中唯一一个三目运算符，用来替代简单的`if-else`语句，同时也是可以**两元**使用的：\n\n``` objc\nNSString *string = inputString ?: @\"default\";\nNSString *string = inputString ? inputString : @\"default\"; // 等价\n```\n利用这个特性，我们还脑洞出了一个一行代码的 block 调用，平时我们的 block 是这样调用：\n\n``` objc\nif (block0) {\n  block0();\n}\n// or\nif (block1) {\n  int result = block1(1, 2);\n}\n```\n\n居然可以简化成下面的样子：\n\n``` objc\n!block0 ?: block0();\nint result = !block1 ?: block1(1, 2);\n```\n\n## [C]数组的下标初始化  \n\n``` objc\nconst int numbers[] = {\n    [1] = 3,\n    [2] = 2,\n    [3] = 1,\n    [5] = 12306\n};\n// {0, 3, 2, 1, 0, 12306}\n```\n\n这个特性可以用来做`枚举值和字符串的映射`\n\n``` objc\ntypedef NS_ENUM(NSInteger, XXType){\n    XXType1,\n    XXType2\n};\nconst NSString *XXTypeNameMapping[] = {\n    [XXType1] = @\"Type1\",\n    [XXType2] = @\"Type2\"\n};\n```\n\n---\n\n## [objc]可变参数类型的block\n\n一个block像下面一样声明：\n\n``` objc\nvoid(^block1)(void);\nvoid(^block2)(int a);\nvoid(^block3)(NSNumber *a, NSString *b);\n```\n**如果block的参数列表为空的话，相当于可变参数（不是void）**\n\n``` objc\nvoid(^block)(); // 返回值为void，参数可变的block\nblock = block1; // 正常\nblock = block2; // 正常\nblock = block3; // 正常\nblock(@1, @\"string\");  // 对应上面的block3\nblock(@1); // block3的第一个参数为@1，第二个为nil\n```\n\n这样，block的主调和回调之间可以通过`约定`来决定block回传回来的参数是什么，有几个。如一个对网络层的调用：  \n\n``` objc\n- (void)requestDataWithApi:(NSInteger)api block:(void(^)())block {\n    if (api == 0) {\n        block(1, 2);\n    }\n    else if (api == 1) {\n        block(@\"1\", @2, @[@\"3\", @\"4\", @\"5\"]);\n    }\n}\n\n```\n\n主调者知道自己请求的是哪个Api，那么根据`约定`，他就知道block里面应该接受哪几个参数：\n\n``` objc\n[server requestDataWithApi:0 block:^(NSInteger a, NSInteger b){\n    // ...\n}];\n[server requestDataWithApi:1 block:^(NSString *s, NSNumber *n, NSArray *a){\n    // ...\n}];\n```\n\n这个特性在`Reactive Cocoa`的`-combineLatest:reduce:`等类似方法中已经使用的相当好了。\n\n``` objc\n+ (RACSignal *)combineLatest:(id<NSFastEnumeration>)signals reduce:(id (^)())reduceBlock;\n```\n\n## [objc]readonly属性支持扩展的写法\n\n假如一个类有一个`readonly`属性：\n\n``` objc\n@interface Sark : NSObject\n@property (nonatomic, readonly) NSArray *friends;\n@end\n```\n`.m`中可以使用`_friends`来使用自动合成的这个变量，但假如：\n\n - 习惯使用`self.`来set实例变量时（只合成了getter）\n - 希望重写getter进行懒加载时（重写getter时则不会生成下划线的变量，除非手动`@synthesize`）\n - 允许子类重载这个属性来修改它时（编译报错属性修饰符不匹配）\n\n这种`readonly`声明方法就行不通了，所以下面的写法更有通用性：\n\n``` objc\n@interface Sark : NSObject\n@property (nonatomic, readonly, copy/*加上setter属性修饰符*/) NSArray *friends;\n@end\n```\n如想在`.m`中像正常属性一样使用：\n\n``` objc\n@interface Sark ()\n@property (nonatomic, copy) NSArray *friends;\n@end\n```\n\n子类化时同理。iOS SDK中很多地方都用到了这个特性。  \n\n-----\n\n## [C]小括号内联复合表达式\n\n`A compound statement enclosed in parentheses`原谅我的渣翻译- -，来自[《gcc官方对此的说明》](https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html)，源自gcc对c的扩展，如今被clang继承。  \n\n``` objc\nRETURN_VALUE_RECEIVER = {(\n    // Do whatever you want\n    RETURN_VALUE; // 返回值\n)};\n```\n于是乎可以发挥想象力了：\n\n``` objc\nself.backgroundView = ({\n    UIView *view = [[UIView alloc] initWithFrame:self.view.bounds];\n    view.backgroundColor = [UIColor redColor];\n    view.alpha = 0.8f;\n    view;\n});\n```\n\n有点像block和内联函数的结合体，它最大的意义在于将代码`整理分块`，将同一个逻辑层级的代码包在一起；同时对于一个无需复用小段逻辑，也免去了重量级的调用函数，如：\n\n``` objc\nself.result = ({\n    double result = 0;\n    for (int i = 0; i <= M_2_PI; i+= M_PI_4) {\n        result += sin(i);\n    }\n    result;\n});\n```\n\n这样使得代码量增大时层次仍然能比较明确。  \n\n_PS: 返回值和代码块结束点必须在结尾_\n\n\n## [娱乐向]奇葩的C函数写法\n\n正常编译执行：  \n\n``` c\nint sum(a,b)\nint a; int b;\n{\n    return a + b;\n}\n```\n\n## [Macro]预处理时计算可变参数个数\n\n``` c\n#define COUNT_PARMS2(_a1, _a2, _a3, _a4, _a5, RESULT, ...) RESULT\n#define COUNT_PARMS(...) COUNT_PARMS2(__VA_ARGS__, 5, 4, 3, 2, 1)\nint count = COUNT_PARMS(1,2,3); // 预处理时count==3\n```\n\n## [Macro]预处理断言  \n\n下面的断言在编译前就生效  \n\n``` c\n#define C_ASSERT(test) \\\n    switch(0) {\\\n          case 0:\\\n          case test:;\\\n    }\n\n```\n\n如断言上面预处理时计算可变参数个数：  \n\n``` c\nC_ASSERT(COUNT_PARMS(1,2,3) == 2);\n```\n\n如果断言失败，相当于`switch-case`中出现了两个`case:0`，则编译报错。  \n\n## [多重]带自动提示的keypath宏  \n\n源自`Reactive Cocoa`中的宏：  \n\n``` c\n#define keypath2(OBJ, PATH) \\\n    (((void)(NO && ((void)OBJ.PATH, NO)), # PATH))\n```\n\n原来写过一篇[《介绍RAC宏的文章》](http://blog.sunnyxx.com/2014/03/06/rac_1_macros/)中曾经写过。这个宏在写PATH参数的同时是带自动提示的：  \n![](http://images.cnitblog.com/blog/401798/201402/112147518936541.png)\n\n### 逗号表达式\n逗号表达式取后值，但前值的表达式参与运算，可用void忽略编译器警告\n\n``` c\nint a = ((void)(1+2), 2); // a == 2\n```\n\n于是上面的keypath宏的输出结果是`#PATH`也就是一个c字符串\n\n### 逻辑最短路径   \n\n之前的文章没有弄清上面宏中`NO&&NO`的含义，其实这用到了编译器优化的特性：  \n\n```\nif (NO && [self shouldDo]/*不执行*/) {\n    // 不执行\n}\n```  \n\n编译器知道在NO后且什么的结果都是NO，于是后面的语句被优化掉了。也就是说keypath宏中这个`NO && ((void)OBJ.PATH, NO)`就使得在编译后后面的部分不出现在最后的代码中，于是乎既实现了keypath的自动提示功能，又保证编译后不执行多余的代码。  \n\n-----\n\n# References  \nhttps://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html\n","slug":"objc-weird-code","published":1,"updated":"2016-03-27T08:18:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxlx001mev12bif5jkkk","content":"<h2 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h2><p>看开源代码时，总会看到一些大神级别的代码，给人眼前一亮的感觉，多数都是被淡忘的C语言语法，总结下objc写码中遇到的各类<code>非主流</code>代码技巧和一些妙用：</p>\n<ul>\n<li>[娱乐向]objc最短的方法声明</li>\n<li>[C]结构体的初始化</li>\n<li>[C]三元条件表达式的两元使用</li>\n<li>[C]数组的下标初始化</li>\n<li>[objc]可变参数类型的block</li>\n<li>[objc]readonly属性支持扩展的写法</li>\n<li>[C]小括号内联复合表达式</li>\n<li>[娱乐向]奇葩的C函数写法</li>\n<li>[Macro]预处理时计算可变参数个数</li>\n<li>[Macro]预处理断言</li>\n<li>[多重]带自动提示的keypath宏</li>\n</ul>\n<hr>\n<h2 id=\"娱乐向-objc最短的方法声明\"><a href=\"#娱乐向-objc最短的方法声明\" class=\"headerlink\" title=\"[娱乐向]objc最短的方法声明\"></a>[娱乐向]objc最短的方法声明</h2><p>先来个娱乐向的。<br>方法声明时有一下几个trick：  </p>\n<p>返回值的<code>- (TYPE)</code>如果不写括号，编译器默认认为是<code>- (id)</code>类型:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- init;</span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init; <span class=\"comment\">// 等价于</span></span><br></pre></td></tr></table></figure>\n<p>同理，参数如果不写类型默认也是<code>id</code>类型:  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)foo:arg;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)foo:(<span class=\"keyword\">id</span>)arg; <span class=\"comment\">// 等价于</span></span><br></pre></td></tr></table></figure>\n<p>还有，有多参数时<code>方法名</code>和<code>参数提示语</code>可以为空</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>):(<span class=\"keyword\">id</span>)arg1 :(<span class=\"keyword\">id</span>)arg2;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)foo:(<span class=\"keyword\">id</span>)arg1 bar:(<span class=\"keyword\">id</span>)arg2; <span class=\"comment\">// 省略前</span></span><br></pre></td></tr></table></figure>\n<p>综上，最短的函数可以写成这样：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- _;   <span class=\"comment\">// 没错，这是一个oc方法声明</span></span><br><span class=\"line\">- :_;  <span class=\"comment\">// 这是一个带一个参数的oc方法声明</span></span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)_;</span><br><span class=\"line\">- (<span class=\"keyword\">id</span>) :(<span class=\"keyword\">id</span>)_;</span><br></pre></td></tr></table></figure>\n<p><em>PS: 方法名都没的方法只能靠<code>performSelector</code>来调用了，<code>selector</code>是<code>&quot;:&quot;</code>  </em></p>\n<hr>\n<h2 id=\"C-结构体的初始化\"><a href=\"#C-结构体的初始化\" class=\"headerlink\" title=\"[C]结构体的初始化\"></a>[C]结构体的初始化</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不加(CGRect)强转也不会warning</span></span><br><span class=\"line\"><span class=\"built_in\">CGRect</span> rect1 = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">CGRect</span> rect2 = &#123;.origin.x=<span class=\"number\">5</span>, .size=&#123;<span class=\"number\">10</span>, <span class=\"number\">10</span>&#125;&#125;; <span class=\"comment\">// &#123;5, 0, 10, 10&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">CGRect</span> rect3 = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;; <span class=\"comment\">// &#123;1, 2, 0, 0&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"C-三元条件表达式的两元使用\"><a href=\"#C-三元条件表达式的两元使用\" class=\"headerlink\" title=\"[C]三元条件表达式的两元使用\"></a>[C]三元条件表达式的两元使用</h2><p>三元条件表达式<code>?:</code>是C中唯一一个三目运算符，用来替代简单的<code>if-else</code>语句，同时也是可以<strong>两元</strong>使用的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *string = inputString ?: <span class=\"string\">@\"default\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *string = inputString ? inputString : <span class=\"string\">@\"default\"</span>; <span class=\"comment\">// 等价</span></span><br></pre></td></tr></table></figure>\n<p>利用这个特性，我们还脑洞出了一个一行代码的 block 调用，平时我们的 block 是这样调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (block0) &#123;</span><br><span class=\"line\">  block0();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// or</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (block1) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> result = block1(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>居然可以简化成下面的样子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">!block0 ?: block0();</span><br><span class=\"line\"><span class=\"keyword\">int</span> result = !block1 ?: block1(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"C-数组的下标初始化\"><a href=\"#C-数组的下标初始化\" class=\"headerlink\" title=\"[C]数组的下标初始化\"></a>[C]数组的下标初始化</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> numbers[] = &#123;</span><br><span class=\"line\">    [<span class=\"number\">1</span>] = <span class=\"number\">3</span>,</span><br><span class=\"line\">    [<span class=\"number\">2</span>] = <span class=\"number\">2</span>,</span><br><span class=\"line\">    [<span class=\"number\">3</span>] = <span class=\"number\">1</span>,</span><br><span class=\"line\">    [<span class=\"number\">5</span>] = <span class=\"number\">12306</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// &#123;0, 3, 2, 1, 0, 12306&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这个特性可以用来做<code>枚举值和字符串的映射</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, XXType)&#123;</span><br><span class=\"line\">    XXType1,</span><br><span class=\"line\">    XXType2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">NSString</span> *XXTypeNameMapping[] = &#123;</span><br><span class=\"line\">    [XXType1] = <span class=\"string\">@\"Type1\"</span>,</span><br><span class=\"line\">    [XXType2] = <span class=\"string\">@\"Type2\"</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"objc-可变参数类型的block\"><a href=\"#objc-可变参数类型的block\" class=\"headerlink\" title=\"[objc]可变参数类型的block\"></a>[objc]可变参数类型的block</h2><p>一个block像下面一样声明：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span>(^block1)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\"><span class=\"keyword\">void</span>(^block2)(<span class=\"keyword\">int</span> a);</span><br><span class=\"line\"><span class=\"keyword\">void</span>(^block3)(<span class=\"built_in\">NSNumber</span> *a, <span class=\"built_in\">NSString</span> *b);</span><br></pre></td></tr></table></figure>\n<p><strong>如果block的参数列表为空的话，相当于可变参数（不是void）</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span>(^block)(); <span class=\"comment\">// 返回值为void，参数可变的block</span></span><br><span class=\"line\">block = block1; <span class=\"comment\">// 正常</span></span><br><span class=\"line\">block = block2; <span class=\"comment\">// 正常</span></span><br><span class=\"line\">block = block3; <span class=\"comment\">// 正常</span></span><br><span class=\"line\">block(@<span class=\"number\">1</span>, <span class=\"string\">@\"string\"</span>);  <span class=\"comment\">// 对应上面的block3</span></span><br><span class=\"line\">block(@<span class=\"number\">1</span>); <span class=\"comment\">// block3的第一个参数为@1，第二个为nil</span></span><br></pre></td></tr></table></figure>\n<p>这样，block的主调和回调之间可以通过<code>约定</code>来决定block回传回来的参数是什么，有几个。如一个对网络层的调用：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)requestDataWithApi:(<span class=\"built_in\">NSInteger</span>)api block:(<span class=\"keyword\">void</span>(^)())block &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (api == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        block(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (api == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        block(<span class=\"string\">@\"1\"</span>, @<span class=\"number\">2</span>, @[<span class=\"string\">@\"3\"</span>, <span class=\"string\">@\"4\"</span>, <span class=\"string\">@\"5\"</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主调者知道自己请求的是哪个Api，那么根据<code>约定</code>，他就知道block里面应该接受哪几个参数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[server requestDataWithApi:<span class=\"number\">0</span> block:^(<span class=\"built_in\">NSInteger</span> a, <span class=\"built_in\">NSInteger</span> b)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">[server requestDataWithApi:<span class=\"number\">1</span> block:^(<span class=\"built_in\">NSString</span> *s, <span class=\"built_in\">NSNumber</span> *n, <span class=\"built_in\">NSArray</span> *a)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>这个特性在<code>Reactive Cocoa</code>的<code>-combineLatest:reduce:</code>等类似方法中已经使用的相当好了。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (RACSignal *)combineLatest:(<span class=\"keyword\">id</span>&lt;<span class=\"built_in\">NSFastEnumeration</span>&gt;)signals reduce:(<span class=\"keyword\">id</span> (^)())reduceBlock;</span><br></pre></td></tr></table></figure>\n<h2 id=\"objc-readonly属性支持扩展的写法\"><a href=\"#objc-readonly属性支持扩展的写法\" class=\"headerlink\" title=\"[objc]readonly属性支持扩展的写法\"></a>[objc]readonly属性支持扩展的写法</h2><p>假如一个类有一个<code>readonly</code>属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSArray</span> *friends;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p><code>.m</code>中可以使用<code>_friends</code>来使用自动合成的这个变量，但假如：</p>\n<ul>\n<li>习惯使用<code>self.</code>来set实例变量时（只合成了getter）</li>\n<li>希望重写getter进行懒加载时（重写getter时则不会生成下划线的变量，除非手动<code>@synthesize</code>）</li>\n<li>允许子类重载这个属性来修改它时（编译报错属性修饰符不匹配）</li>\n</ul>\n<p>这种<code>readonly</code>声明方法就行不通了，所以下面的写法更有通用性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>, <span class=\"keyword\">copy</span><span class=\"comment\">/*加上setter属性修饰符*/</span>) <span class=\"built_in\">NSArray</span> *friends;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>如想在<code>.m</code>中像正常属性一样使用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> ()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSArray</span> *friends;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>子类化时同理。iOS SDK中很多地方都用到了这个特性。  </p>\n<hr>\n<h2 id=\"C-小括号内联复合表达式\"><a href=\"#C-小括号内联复合表达式\" class=\"headerlink\" title=\"[C]小括号内联复合表达式\"></a>[C]小括号内联复合表达式</h2><p><code>A compound statement enclosed in parentheses</code>原谅我的渣翻译- -，来自<a href=\"https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html\" target=\"_blank\" rel=\"external\">《gcc官方对此的说明》</a>，源自gcc对c的扩展，如今被clang继承。  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RETURN_VALUE_RECEIVER = &#123;(</span><br><span class=\"line\">    <span class=\"comment\">// Do whatever you want</span></span><br><span class=\"line\">    RETURN_VALUE; <span class=\"comment\">// 返回值</span></span><br><span class=\"line\">)&#125;;</span><br></pre></td></tr></table></figure>\n<p>于是乎可以发挥想象力了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.backgroundView = (&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIView</span> *view = [[<span class=\"built_in\">UIView</span> alloc] initWithFrame:<span class=\"keyword\">self</span>.view.bounds];</span><br><span class=\"line\">    view.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</span><br><span class=\"line\">    view.alpha = <span class=\"number\">0.8</span>f;</span><br><span class=\"line\">    view;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>有点像block和内联函数的结合体，它最大的意义在于将代码<code>整理分块</code>，将同一个逻辑层级的代码包在一起；同时对于一个无需复用小段逻辑，也免去了重量级的调用函数，如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.result = (&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= M_2_PI; i+= M_PI_4) &#123;</span><br><span class=\"line\">        result += sin(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    result;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这样使得代码量增大时层次仍然能比较明确。  </p>\n<p><em>PS: 返回值和代码块结束点必须在结尾</em></p>\n<h2 id=\"娱乐向-奇葩的C函数写法\"><a href=\"#娱乐向-奇葩的C函数写法\" class=\"headerlink\" title=\"[娱乐向]奇葩的C函数写法\"></a>[娱乐向]奇葩的C函数写法</h2><p>正常编译执行：  </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(a,b)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a</span>; <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Macro-预处理时计算可变参数个数\"><a href=\"#Macro-预处理时计算可变参数个数\" class=\"headerlink\" title=\"[Macro]预处理时计算可变参数个数\"></a>[Macro]预处理时计算可变参数个数</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> COUNT_PARMS2(_a1, _a2, _a3, _a4, _a5, RESULT, ...) RESULT</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> COUNT_PARMS(...) COUNT_PARMS2(__VA_ARGS__, 5, 4, 3, 2, 1)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> count = COUNT_PARMS(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>); <span class=\"comment\">// 预处理时count==3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Macro-预处理断言\"><a href=\"#Macro-预处理断言\" class=\"headerlink\" title=\"[Macro]预处理断言\"></a>[Macro]预处理断言</h2><p>下面的断言在编译前就生效  </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> C_ASSERT(test) \\</span><br><span class=\"line\">    switch(0) &#123;\\</span><br><span class=\"line\">          case 0:\\</span><br><span class=\"line\">          case test:;\\</span><br><span class=\"line\">    &#125;</span></span><br></pre></td></tr></table></figure>\n<p>如断言上面预处理时计算可变参数个数：  </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C_ASSERT(COUNT_PARMS(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>) == <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>如果断言失败，相当于<code>switch-case</code>中出现了两个<code>case:0</code>，则编译报错。  </p>\n<h2 id=\"多重-带自动提示的keypath宏\"><a href=\"#多重-带自动提示的keypath宏\" class=\"headerlink\" title=\"[多重]带自动提示的keypath宏\"></a>[多重]带自动提示的keypath宏</h2><p>源自<code>Reactive Cocoa</code>中的宏：  </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> keypath2(OBJ, PATH) \\</span><br><span class=\"line\">    (((void)(NO &amp;&amp; ((void)OBJ.PATH, NO)), # PATH))</span></span><br></pre></td></tr></table></figure>\n<p>原来写过一篇<a href=\"http://blog.sunnyxx.com/2014/03/06/rac_1_macros/\">《介绍RAC宏的文章》</a>中曾经写过。这个宏在写PATH参数的同时是带自动提示的：<br><img src=\"http://images.cnitblog.com/blog/401798/201402/112147518936541.png\" alt=\"\"></p>\n<h3 id=\"逗号表达式\"><a href=\"#逗号表达式\" class=\"headerlink\" title=\"逗号表达式\"></a>逗号表达式</h3><p>逗号表达式取后值，但前值的表达式参与运算，可用void忽略编译器警告</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = ((<span class=\"keyword\">void</span>)(<span class=\"number\">1</span>+<span class=\"number\">2</span>), <span class=\"number\">2</span>); <span class=\"comment\">// a == 2</span></span><br></pre></td></tr></table></figure>\n<p>于是上面的keypath宏的输出结果是<code>#PATH</code>也就是一个c字符串</p>\n<h3 id=\"逻辑最短路径\"><a href=\"#逻辑最短路径\" class=\"headerlink\" title=\"逻辑最短路径\"></a>逻辑最短路径</h3><p>之前的文章没有弄清上面宏中<code>NO&amp;&amp;NO</code>的含义，其实这用到了编译器优化的特性：  </p>\n<pre><code>if (NO &amp;&amp; [self shouldDo]/*不执行*/) {\n    // 不执行\n}\n</code></pre><p>编译器知道在NO后且什么的结果都是NO，于是后面的语句被优化掉了。也就是说keypath宏中这个<code>NO &amp;&amp; ((void)OBJ.PATH, NO)</code>就使得在编译后后面的部分不出现在最后的代码中，于是乎既实现了keypath的自动提示功能，又保证编译后不执行多余的代码。  </p>\n<hr>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html\" target=\"_blank\" rel=\"external\">https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html</a></p>\n","excerpt":"","more":"<h2 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h2><p>看开源代码时，总会看到一些大神级别的代码，给人眼前一亮的感觉，多数都是被淡忘的C语言语法，总结下objc写码中遇到的各类<code>非主流</code>代码技巧和一些妙用：</p>\n<ul>\n<li>[娱乐向]objc最短的方法声明</li>\n<li>[C]结构体的初始化</li>\n<li>[C]三元条件表达式的两元使用</li>\n<li>[C]数组的下标初始化</li>\n<li>[objc]可变参数类型的block</li>\n<li>[objc]readonly属性支持扩展的写法</li>\n<li>[C]小括号内联复合表达式</li>\n<li>[娱乐向]奇葩的C函数写法</li>\n<li>[Macro]预处理时计算可变参数个数</li>\n<li>[Macro]预处理断言</li>\n<li>[多重]带自动提示的keypath宏</li>\n</ul>\n<hr>\n<h2 id=\"娱乐向-objc最短的方法声明\"><a href=\"#娱乐向-objc最短的方法声明\" class=\"headerlink\" title=\"[娱乐向]objc最短的方法声明\"></a>[娱乐向]objc最短的方法声明</h2><p>先来个娱乐向的。<br>方法声明时有一下几个trick：  </p>\n<p>返回值的<code>- (TYPE)</code>如果不写括号，编译器默认认为是<code>- (id)</code>类型:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- init;</span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init; <span class=\"comment\">// 等价于</span></span><br></pre></td></tr></table></figure>\n<p>同理，参数如果不写类型默认也是<code>id</code>类型:  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)foo:arg;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)foo:(<span class=\"keyword\">id</span>)arg; <span class=\"comment\">// 等价于</span></span><br></pre></td></tr></table></figure>\n<p>还有，有多参数时<code>方法名</code>和<code>参数提示语</code>可以为空</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>):(<span class=\"keyword\">id</span>)arg1 :(<span class=\"keyword\">id</span>)arg2;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)foo:(<span class=\"keyword\">id</span>)arg1 bar:(<span class=\"keyword\">id</span>)arg2; <span class=\"comment\">// 省略前</span></span><br></pre></td></tr></table></figure>\n<p>综上，最短的函数可以写成这样：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- _;   <span class=\"comment\">// 没错，这是一个oc方法声明</span></span><br><span class=\"line\">- :_;  <span class=\"comment\">// 这是一个带一个参数的oc方法声明</span></span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)_;</span><br><span class=\"line\">- (<span class=\"keyword\">id</span>) :(<span class=\"keyword\">id</span>)_;</span><br></pre></td></tr></table></figure>\n<p><em>PS: 方法名都没的方法只能靠<code>performSelector</code>来调用了，<code>selector</code>是<code>&quot;:&quot;</code>  </em></p>\n<hr>\n<h2 id=\"C-结构体的初始化\"><a href=\"#C-结构体的初始化\" class=\"headerlink\" title=\"[C]结构体的初始化\"></a>[C]结构体的初始化</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不加(CGRect)强转也不会warning</span></span><br><span class=\"line\"><span class=\"built_in\">CGRect</span> rect1 = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">CGRect</span> rect2 = &#123;.origin.x=<span class=\"number\">5</span>, .size=&#123;<span class=\"number\">10</span>, <span class=\"number\">10</span>&#125;&#125;; <span class=\"comment\">// &#123;5, 0, 10, 10&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">CGRect</span> rect3 = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;; <span class=\"comment\">// &#123;1, 2, 0, 0&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"C-三元条件表达式的两元使用\"><a href=\"#C-三元条件表达式的两元使用\" class=\"headerlink\" title=\"[C]三元条件表达式的两元使用\"></a>[C]三元条件表达式的两元使用</h2><p>三元条件表达式<code>?:</code>是C中唯一一个三目运算符，用来替代简单的<code>if-else</code>语句，同时也是可以<strong>两元</strong>使用的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *string = inputString ?: <span class=\"string\">@\"default\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *string = inputString ? inputString : <span class=\"string\">@\"default\"</span>; <span class=\"comment\">// 等价</span></span><br></pre></td></tr></table></figure>\n<p>利用这个特性，我们还脑洞出了一个一行代码的 block 调用，平时我们的 block 是这样调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (block0) &#123;</span><br><span class=\"line\">  block0();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// or</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (block1) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> result = block1(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>居然可以简化成下面的样子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">!block0 ?: block0();</span><br><span class=\"line\"><span class=\"keyword\">int</span> result = !block1 ?: block1(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"C-数组的下标初始化\"><a href=\"#C-数组的下标初始化\" class=\"headerlink\" title=\"[C]数组的下标初始化\"></a>[C]数组的下标初始化</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> numbers[] = &#123;</span><br><span class=\"line\">    [<span class=\"number\">1</span>] = <span class=\"number\">3</span>,</span><br><span class=\"line\">    [<span class=\"number\">2</span>] = <span class=\"number\">2</span>,</span><br><span class=\"line\">    [<span class=\"number\">3</span>] = <span class=\"number\">1</span>,</span><br><span class=\"line\">    [<span class=\"number\">5</span>] = <span class=\"number\">12306</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// &#123;0, 3, 2, 1, 0, 12306&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这个特性可以用来做<code>枚举值和字符串的映射</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, XXType)&#123;</span><br><span class=\"line\">    XXType1,</span><br><span class=\"line\">    XXType2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">NSString</span> *XXTypeNameMapping[] = &#123;</span><br><span class=\"line\">    [XXType1] = <span class=\"string\">@\"Type1\"</span>,</span><br><span class=\"line\">    [XXType2] = <span class=\"string\">@\"Type2\"</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"objc-可变参数类型的block\"><a href=\"#objc-可变参数类型的block\" class=\"headerlink\" title=\"[objc]可变参数类型的block\"></a>[objc]可变参数类型的block</h2><p>一个block像下面一样声明：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span>(^block1)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\"><span class=\"keyword\">void</span>(^block2)(<span class=\"keyword\">int</span> a);</span><br><span class=\"line\"><span class=\"keyword\">void</span>(^block3)(<span class=\"built_in\">NSNumber</span> *a, <span class=\"built_in\">NSString</span> *b);</span><br></pre></td></tr></table></figure>\n<p><strong>如果block的参数列表为空的话，相当于可变参数（不是void）</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span>(^block)(); <span class=\"comment\">// 返回值为void，参数可变的block</span></span><br><span class=\"line\">block = block1; <span class=\"comment\">// 正常</span></span><br><span class=\"line\">block = block2; <span class=\"comment\">// 正常</span></span><br><span class=\"line\">block = block3; <span class=\"comment\">// 正常</span></span><br><span class=\"line\">block(@<span class=\"number\">1</span>, <span class=\"string\">@\"string\"</span>);  <span class=\"comment\">// 对应上面的block3</span></span><br><span class=\"line\">block(@<span class=\"number\">1</span>); <span class=\"comment\">// block3的第一个参数为@1，第二个为nil</span></span><br></pre></td></tr></table></figure>\n<p>这样，block的主调和回调之间可以通过<code>约定</code>来决定block回传回来的参数是什么，有几个。如一个对网络层的调用：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)requestDataWithApi:(<span class=\"built_in\">NSInteger</span>)api block:(<span class=\"keyword\">void</span>(^)())block &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (api == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        block(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (api == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        block(<span class=\"string\">@\"1\"</span>, @<span class=\"number\">2</span>, @[<span class=\"string\">@\"3\"</span>, <span class=\"string\">@\"4\"</span>, <span class=\"string\">@\"5\"</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主调者知道自己请求的是哪个Api，那么根据<code>约定</code>，他就知道block里面应该接受哪几个参数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[server requestDataWithApi:<span class=\"number\">0</span> block:^(<span class=\"built_in\">NSInteger</span> a, <span class=\"built_in\">NSInteger</span> b)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">[server requestDataWithApi:<span class=\"number\">1</span> block:^(<span class=\"built_in\">NSString</span> *s, <span class=\"built_in\">NSNumber</span> *n, <span class=\"built_in\">NSArray</span> *a)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>这个特性在<code>Reactive Cocoa</code>的<code>-combineLatest:reduce:</code>等类似方法中已经使用的相当好了。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (RACSignal *)combineLatest:(<span class=\"keyword\">id</span>&lt;<span class=\"built_in\">NSFastEnumeration</span>&gt;)signals reduce:(<span class=\"keyword\">id</span> (^)())reduceBlock;</span><br></pre></td></tr></table></figure>\n<h2 id=\"objc-readonly属性支持扩展的写法\"><a href=\"#objc-readonly属性支持扩展的写法\" class=\"headerlink\" title=\"[objc]readonly属性支持扩展的写法\"></a>[objc]readonly属性支持扩展的写法</h2><p>假如一个类有一个<code>readonly</code>属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSArray</span> *friends;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p><code>.m</code>中可以使用<code>_friends</code>来使用自动合成的这个变量，但假如：</p>\n<ul>\n<li>习惯使用<code>self.</code>来set实例变量时（只合成了getter）</li>\n<li>希望重写getter进行懒加载时（重写getter时则不会生成下划线的变量，除非手动<code>@synthesize</code>）</li>\n<li>允许子类重载这个属性来修改它时（编译报错属性修饰符不匹配）</li>\n</ul>\n<p>这种<code>readonly</code>声明方法就行不通了，所以下面的写法更有通用性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>, <span class=\"keyword\">copy</span><span class=\"comment\">/*加上setter属性修饰符*/</span>) <span class=\"built_in\">NSArray</span> *friends;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>如想在<code>.m</code>中像正常属性一样使用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> ()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSArray</span> *friends;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>子类化时同理。iOS SDK中很多地方都用到了这个特性。  </p>\n<hr>\n<h2 id=\"C-小括号内联复合表达式\"><a href=\"#C-小括号内联复合表达式\" class=\"headerlink\" title=\"[C]小括号内联复合表达式\"></a>[C]小括号内联复合表达式</h2><p><code>A compound statement enclosed in parentheses</code>原谅我的渣翻译- -，来自<a href=\"https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html\">《gcc官方对此的说明》</a>，源自gcc对c的扩展，如今被clang继承。  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RETURN_VALUE_RECEIVER = &#123;(</span><br><span class=\"line\">    <span class=\"comment\">// Do whatever you want</span></span><br><span class=\"line\">    RETURN_VALUE; <span class=\"comment\">// 返回值</span></span><br><span class=\"line\">)&#125;;</span><br></pre></td></tr></table></figure>\n<p>于是乎可以发挥想象力了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.backgroundView = (&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIView</span> *view = [[<span class=\"built_in\">UIView</span> alloc] initWithFrame:<span class=\"keyword\">self</span>.view.bounds];</span><br><span class=\"line\">    view.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</span><br><span class=\"line\">    view.alpha = <span class=\"number\">0.8</span>f;</span><br><span class=\"line\">    view;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>有点像block和内联函数的结合体，它最大的意义在于将代码<code>整理分块</code>，将同一个逻辑层级的代码包在一起；同时对于一个无需复用小段逻辑，也免去了重量级的调用函数，如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.result = (&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= M_2_PI; i+= M_PI_4) &#123;</span><br><span class=\"line\">        result += sin(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    result;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这样使得代码量增大时层次仍然能比较明确。  </p>\n<p><em>PS: 返回值和代码块结束点必须在结尾</em></p>\n<h2 id=\"娱乐向-奇葩的C函数写法\"><a href=\"#娱乐向-奇葩的C函数写法\" class=\"headerlink\" title=\"[娱乐向]奇葩的C函数写法\"></a>[娱乐向]奇葩的C函数写法</h2><p>正常编译执行：  </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(a,b)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a</span>; <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Macro-预处理时计算可变参数个数\"><a href=\"#Macro-预处理时计算可变参数个数\" class=\"headerlink\" title=\"[Macro]预处理时计算可变参数个数\"></a>[Macro]预处理时计算可变参数个数</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> COUNT_PARMS2(_a1, _a2, _a3, _a4, _a5, RESULT, ...) RESULT</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> COUNT_PARMS(...) COUNT_PARMS2(__VA_ARGS__, 5, 4, 3, 2, 1)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> count = COUNT_PARMS(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>); <span class=\"comment\">// 预处理时count==3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Macro-预处理断言\"><a href=\"#Macro-预处理断言\" class=\"headerlink\" title=\"[Macro]预处理断言\"></a>[Macro]预处理断言</h2><p>下面的断言在编译前就生效  </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> C_ASSERT(test) \\</span><br><span class=\"line\">    switch(0) &#123;\\</span><br><span class=\"line\">          case 0:\\</span><br><span class=\"line\">          case test:;\\</span><br><span class=\"line\">    &#125;</span></span><br></pre></td></tr></table></figure>\n<p>如断言上面预处理时计算可变参数个数：  </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C_ASSERT(COUNT_PARMS(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>) == <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>如果断言失败，相当于<code>switch-case</code>中出现了两个<code>case:0</code>，则编译报错。  </p>\n<h2 id=\"多重-带自动提示的keypath宏\"><a href=\"#多重-带自动提示的keypath宏\" class=\"headerlink\" title=\"[多重]带自动提示的keypath宏\"></a>[多重]带自动提示的keypath宏</h2><p>源自<code>Reactive Cocoa</code>中的宏：  </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> keypath2(OBJ, PATH) \\</span><br><span class=\"line\">    (((void)(NO &amp;&amp; ((void)OBJ.PATH, NO)), # PATH))</span></span><br></pre></td></tr></table></figure>\n<p>原来写过一篇<a href=\"http://blog.sunnyxx.com/2014/03/06/rac_1_macros/\">《介绍RAC宏的文章》</a>中曾经写过。这个宏在写PATH参数的同时是带自动提示的：<br><img src=\"http://images.cnitblog.com/blog/401798/201402/112147518936541.png\" alt=\"\"></p>\n<h3 id=\"逗号表达式\"><a href=\"#逗号表达式\" class=\"headerlink\" title=\"逗号表达式\"></a>逗号表达式</h3><p>逗号表达式取后值，但前值的表达式参与运算，可用void忽略编译器警告</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = ((<span class=\"keyword\">void</span>)(<span class=\"number\">1</span>+<span class=\"number\">2</span>), <span class=\"number\">2</span>); <span class=\"comment\">// a == 2</span></span><br></pre></td></tr></table></figure>\n<p>于是上面的keypath宏的输出结果是<code>#PATH</code>也就是一个c字符串</p>\n<h3 id=\"逻辑最短路径\"><a href=\"#逻辑最短路径\" class=\"headerlink\" title=\"逻辑最短路径\"></a>逻辑最短路径</h3><p>之前的文章没有弄清上面宏中<code>NO&amp;&amp;NO</code>的含义，其实这用到了编译器优化的特性：  </p>\n<pre><code>if (NO &amp;&amp; [self shouldDo]/*不执行*/) {\n    // 不执行\n}\n</code></pre><p>编译器知道在NO后且什么的结果都是NO，于是后面的语句被优化掉了。也就是说keypath宏中这个<code>NO &amp;&amp; ((void)OBJ.PATH, NO)</code>就使得在编译后后面的部分不出现在最后的代码中，于是乎既实现了keypath的自动提示功能，又保证编译后不执行多余的代码。  </p>\n<hr>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html\">https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html</a></p>\n"},{"title":"objc arc的简单探索","date":"2014-03-15T11:02:59.000Z","_content":"## ARC or not？\n\n`Automatic Reference Counting`是objc发展以来相当重要的一个进步  \n> 对于开发者，任何能降低开发难度，简化代码的功能，我们都应该去了解和使用。\n> 我们应该利用一切“偷懒”的机会，将软件开发的复杂度分解并控制在一个个小的范围内，使得对于分解后的每一个小的任务，都能被新手掌握和维护。  \n\n基于简化开发的思想来看，ARC绝对是一个**没理由拒绝**的技术进步。  \nARC随着iOS5问世，到现在iOS8都快出了，你还在手动写retain，release么？除了固守思想外，对ARC的恐惧大都来自对它的未知。  \n\n比如我在公司尝试说服team使用ARC时被质疑的几个问题：\n\n> ARC和Java的GC一样，会导致一部分性能损耗？\n\n首先，ARC和GC是两码事，ARC是编译时编译器“帮你”插入了原本需要自己手写的内存管理代码，而非像GC一样运行时的垃圾回收系统  \n\n> ARC内存不知道什么时候释放，导致不可控的内存涨落？  \n\n了解ARC的原理后，就知道，ARC下编译器插入的内存管理的代码是经过优化的，对于使用完的内存，多运行一行代码都不会浪费，可以这么说，手写的内存管理必须达到很严谨的水平才可能达到ARC自动生成的一样完整且没有疏漏\n\n> ARC下面自己不管理内存，很不爽，很没有安全感  \n\n这纯粹是习惯的问题了，开发者的目标是用最简化的手段完成一个最可靠的程序，进步需要改变的。好在编译选项中提供了`-fobjc-arc`和`-fno-objc-arc`来保证整个的变革的继续下去，就像社会主义中国里的港澳\n\n> ARC的约定  \n\n使用ARC之后一个费解的地方是，一个方法生成的对象，没有任何附加标示，ARC怎么知道生成的对象是不是`autorelease`的呢？\n\n``` objc\n@interface Sark : NSObject\n+ (instancetype)sarkWithMark:(NSString *)mark; // 1\n- (instancetype)initWithMark:(NSString *)mark; // 2\n@end\n```\n\n这是非ARC时常用的手段，1生成autorelease对象，2生成普通对象，而现在ARC不能调用autorelease，使用时怎么能知道呢？\n\n``` objc\n{\n    // ...\n    Sark *sark1 = [Sark sarkWithMark:@\"萨萨萨\"];\n    Sark *sark2 = [[Sark alloc] initWithMark:@\"萨萨萨\"];\n}\n```\n\n使用`约定`，NS定义了下面三个编译属性  \n\n``` objc\n#define NS_RETURNS_RETAINED __attribute__((ns_returns_retained))\n#define NS_RETURNS_NOT_RETAINED __attribute__((ns_returns_not_retained))\n#define NS_RETURNS_INNER_POINTER __attribute__((objc_returns_inner_pointer))\n```\n\n这三个属性是Clang自己使用的标示，除非`特殊情况`不要自己使用，但是这些对理解ARC是很有帮助的。  \n这里还要介绍一个概念，`Method family`\n\n> An Objective-C method may fall into a method family, which is a conventional set of behaviors ascribed to it by the Cocoa conventions.\n\n指的是命名上表示一类型的方法，比如`- init`和`- initWithMark:`都属于`init`的family  \n于是乎，编译器约定，对于`alloc`,`init`,`copy`,`mutableCopy`,`new`这几个家族的方法，后面默认加`NS_RETURNS_RETAINED`标识；而其他不指名标识的family的方法默认添加`NS_RETURNS_NOT_RETAINED`标识  \n也就是说刚才的方法，在编译器看来是这样的：\n\n``` objc\n@interface Sark : NSObject\n+ (instancetype)sarkWithMark:(NSString *)mark NS_RETURNS_NOT_RETAINED; // 1\n- (instancetype)initWithMark:(NSString *)mark NS_RETURNS_RETAINED; // 2\n@end\n```\n\n这也就是为什么ARC下面，不能把一个属性定义成名字是这样的：\n\n``` objc\n@property (nonatomic, copy) NSString *newString; // 编译器不允许\n```\n\n`- newString`就成了`new`家族的方法，内存就不对了\n对于`NS_RETURNS_INNER_POINTER`这货，主要使用在返回的是一个对象的**内部C指针**的情况，如NSString的方法：\n\n``` objc\n- (__strong const char *)UTF8String NS_RETURNS_INNER_POINTER;\n```\n\n就使用了这个标识，这个就不深入研究了，直接上文档：\n> An Objective-C method returning a non-retainable pointer may be annotated with the objc_returns_inner_pointer attribute to indicate that it returns a handle to the internal data of an object, and that this reference will be invalidated if the object is destroyed. When such a message is sent to an object, the object’s lifetime will be extended until at least the earliest of:\nthe last use of the returned pointer, or any pointer derived from it, in the calling function or\nthe autorelease pool is restored to a previous state.\n","source":"_posts/objc_arc_secret.md","raw":"title: objc arc的简单探索\ndate: 2014-03-15 19:02:59\ntags: objc的秘密\n---\n## ARC or not？\n\n`Automatic Reference Counting`是objc发展以来相当重要的一个进步  \n> 对于开发者，任何能降低开发难度，简化代码的功能，我们都应该去了解和使用。\n> 我们应该利用一切“偷懒”的机会，将软件开发的复杂度分解并控制在一个个小的范围内，使得对于分解后的每一个小的任务，都能被新手掌握和维护。  \n\n基于简化开发的思想来看，ARC绝对是一个**没理由拒绝**的技术进步。  \nARC随着iOS5问世，到现在iOS8都快出了，你还在手动写retain，release么？除了固守思想外，对ARC的恐惧大都来自对它的未知。  \n\n比如我在公司尝试说服team使用ARC时被质疑的几个问题：\n\n> ARC和Java的GC一样，会导致一部分性能损耗？\n\n首先，ARC和GC是两码事，ARC是编译时编译器“帮你”插入了原本需要自己手写的内存管理代码，而非像GC一样运行时的垃圾回收系统  \n\n> ARC内存不知道什么时候释放，导致不可控的内存涨落？  \n\n了解ARC的原理后，就知道，ARC下编译器插入的内存管理的代码是经过优化的，对于使用完的内存，多运行一行代码都不会浪费，可以这么说，手写的内存管理必须达到很严谨的水平才可能达到ARC自动生成的一样完整且没有疏漏\n\n> ARC下面自己不管理内存，很不爽，很没有安全感  \n\n这纯粹是习惯的问题了，开发者的目标是用最简化的手段完成一个最可靠的程序，进步需要改变的。好在编译选项中提供了`-fobjc-arc`和`-fno-objc-arc`来保证整个的变革的继续下去，就像社会主义中国里的港澳\n\n> ARC的约定  \n\n使用ARC之后一个费解的地方是，一个方法生成的对象，没有任何附加标示，ARC怎么知道生成的对象是不是`autorelease`的呢？\n\n``` objc\n@interface Sark : NSObject\n+ (instancetype)sarkWithMark:(NSString *)mark; // 1\n- (instancetype)initWithMark:(NSString *)mark; // 2\n@end\n```\n\n这是非ARC时常用的手段，1生成autorelease对象，2生成普通对象，而现在ARC不能调用autorelease，使用时怎么能知道呢？\n\n``` objc\n{\n    // ...\n    Sark *sark1 = [Sark sarkWithMark:@\"萨萨萨\"];\n    Sark *sark2 = [[Sark alloc] initWithMark:@\"萨萨萨\"];\n}\n```\n\n使用`约定`，NS定义了下面三个编译属性  \n\n``` objc\n#define NS_RETURNS_RETAINED __attribute__((ns_returns_retained))\n#define NS_RETURNS_NOT_RETAINED __attribute__((ns_returns_not_retained))\n#define NS_RETURNS_INNER_POINTER __attribute__((objc_returns_inner_pointer))\n```\n\n这三个属性是Clang自己使用的标示，除非`特殊情况`不要自己使用，但是这些对理解ARC是很有帮助的。  \n这里还要介绍一个概念，`Method family`\n\n> An Objective-C method may fall into a method family, which is a conventional set of behaviors ascribed to it by the Cocoa conventions.\n\n指的是命名上表示一类型的方法，比如`- init`和`- initWithMark:`都属于`init`的family  \n于是乎，编译器约定，对于`alloc`,`init`,`copy`,`mutableCopy`,`new`这几个家族的方法，后面默认加`NS_RETURNS_RETAINED`标识；而其他不指名标识的family的方法默认添加`NS_RETURNS_NOT_RETAINED`标识  \n也就是说刚才的方法，在编译器看来是这样的：\n\n``` objc\n@interface Sark : NSObject\n+ (instancetype)sarkWithMark:(NSString *)mark NS_RETURNS_NOT_RETAINED; // 1\n- (instancetype)initWithMark:(NSString *)mark NS_RETURNS_RETAINED; // 2\n@end\n```\n\n这也就是为什么ARC下面，不能把一个属性定义成名字是这样的：\n\n``` objc\n@property (nonatomic, copy) NSString *newString; // 编译器不允许\n```\n\n`- newString`就成了`new`家族的方法，内存就不对了\n对于`NS_RETURNS_INNER_POINTER`这货，主要使用在返回的是一个对象的**内部C指针**的情况，如NSString的方法：\n\n``` objc\n- (__strong const char *)UTF8String NS_RETURNS_INNER_POINTER;\n```\n\n就使用了这个标识，这个就不深入研究了，直接上文档：\n> An Objective-C method returning a non-retainable pointer may be annotated with the objc_returns_inner_pointer attribute to indicate that it returns a handle to the internal data of an object, and that this reference will be invalidated if the object is destroyed. When such a message is sent to an object, the object’s lifetime will be extended until at least the earliest of:\nthe last use of the returned pointer, or any pointer derived from it, in the calling function or\nthe autorelease pool is restored to a previous state.\n","slug":"objc_arc_secret","published":1,"updated":"2016-03-27T08:35:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxm1001oev128qbxzzhg","content":"<h2 id=\"ARC-or-not？\"><a href=\"#ARC-or-not？\" class=\"headerlink\" title=\"ARC or not？\"></a>ARC or not？</h2><p><code>Automatic Reference Counting</code>是objc发展以来相当重要的一个进步  </p>\n<blockquote>\n<p>对于开发者，任何能降低开发难度，简化代码的功能，我们都应该去了解和使用。<br>我们应该利用一切“偷懒”的机会，将软件开发的复杂度分解并控制在一个个小的范围内，使得对于分解后的每一个小的任务，都能被新手掌握和维护。  </p>\n</blockquote>\n<p>基于简化开发的思想来看，ARC绝对是一个<strong>没理由拒绝</strong>的技术进步。<br>ARC随着iOS5问世，到现在iOS8都快出了，你还在手动写retain，release么？除了固守思想外，对ARC的恐惧大都来自对它的未知。  </p>\n<p>比如我在公司尝试说服team使用ARC时被质疑的几个问题：</p>\n<blockquote>\n<p>ARC和Java的GC一样，会导致一部分性能损耗？</p>\n</blockquote>\n<p>首先，ARC和GC是两码事，ARC是编译时编译器“帮你”插入了原本需要自己手写的内存管理代码，而非像GC一样运行时的垃圾回收系统  </p>\n<blockquote>\n<p>ARC内存不知道什么时候释放，导致不可控的内存涨落？  </p>\n</blockquote>\n<p>了解ARC的原理后，就知道，ARC下编译器插入的内存管理的代码是经过优化的，对于使用完的内存，多运行一行代码都不会浪费，可以这么说，手写的内存管理必须达到很严谨的水平才可能达到ARC自动生成的一样完整且没有疏漏</p>\n<blockquote>\n<p>ARC下面自己不管理内存，很不爽，很没有安全感  </p>\n</blockquote>\n<p>这纯粹是习惯的问题了，开发者的目标是用最简化的手段完成一个最可靠的程序，进步需要改变的。好在编译选项中提供了<code>-fobjc-arc</code>和<code>-fno-objc-arc</code>来保证整个的变革的继续下去，就像社会主义中国里的港澳</p>\n<blockquote>\n<p>ARC的约定  </p>\n</blockquote>\n<p>使用ARC之后一个费解的地方是，一个方法生成的对象，没有任何附加标示，ARC怎么知道生成的对象是不是<code>autorelease</code>的呢？</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">+ (instancetype)sarkWithMark:(<span class=\"built_in\">NSString</span> *)mark; <span class=\"comment\">// 1</span></span><br><span class=\"line\">- (instancetype)initWithMark:(<span class=\"built_in\">NSString</span> *)mark; <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>这是非ARC时常用的手段，1生成autorelease对象，2生成普通对象，而现在ARC不能调用autorelease，使用时怎么能知道呢？</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    Sark *sark1 = [Sark sarkWithMark:<span class=\"string\">@\"萨萨萨\"</span>];</span><br><span class=\"line\">    Sark *sark2 = [[Sark alloc] initWithMark:<span class=\"string\">@\"萨萨萨\"</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用<code>约定</code>，NS定义了下面三个编译属性  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define NS_RETURNS_RETAINED __attribute__((ns_returns_retained))</span></span><br><span class=\"line\"><span class=\"meta\">#define NS_RETURNS_NOT_RETAINED __attribute__((ns_returns_not_retained))</span></span><br><span class=\"line\"><span class=\"meta\">#define NS_RETURNS_INNER_POINTER __attribute__((objc_returns_inner_pointer))</span></span><br></pre></td></tr></table></figure>\n<p>这三个属性是Clang自己使用的标示，除非<code>特殊情况</code>不要自己使用，但是这些对理解ARC是很有帮助的。<br>这里还要介绍一个概念，<code>Method family</code></p>\n<blockquote>\n<p>An Objective-C method may fall into a method family, which is a conventional set of behaviors ascribed to it by the Cocoa conventions.</p>\n</blockquote>\n<p>指的是命名上表示一类型的方法，比如<code>- init</code>和<code>- initWithMark:</code>都属于<code>init</code>的family<br>于是乎，编译器约定，对于<code>alloc</code>,<code>init</code>,<code>copy</code>,<code>mutableCopy</code>,<code>new</code>这几个家族的方法，后面默认加<code>NS_RETURNS_RETAINED</code>标识；而其他不指名标识的family的方法默认添加<code>NS_RETURNS_NOT_RETAINED</code>标识<br>也就是说刚才的方法，在编译器看来是这样的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">+ (instancetype)sarkWithMark:(<span class=\"built_in\">NSString</span> *)mark <span class=\"built_in\">NS_RETURNS_NOT_RETAINED</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\">- (instancetype)initWithMark:(<span class=\"built_in\">NSString</span> *)mark <span class=\"built_in\">NS_RETURNS_RETAINED</span>; <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>这也就是为什么ARC下面，不能把一个属性定义成名字是这样的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *newString; <span class=\"comment\">// 编译器不允许</span></span><br></pre></td></tr></table></figure>\n<p><code>- newString</code>就成了<code>new</code>家族的方法，内存就不对了<br>对于<code>NS_RETURNS_INNER_POINTER</code>这货，主要使用在返回的是一个对象的<strong>内部C指针</strong>的情况，如NSString的方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (__<span class=\"keyword\">strong</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *)UTF8String <span class=\"built_in\">NS_RETURNS_INNER_POINTER</span>;</span><br></pre></td></tr></table></figure>\n<p>就使用了这个标识，这个就不深入研究了，直接上文档：</p>\n<blockquote>\n<p>An Objective-C method returning a non-retainable pointer may be annotated with the objc_returns_inner_pointer attribute to indicate that it returns a handle to the internal data of an object, and that this reference will be invalidated if the object is destroyed. When such a message is sent to an object, the object’s lifetime will be extended until at least the earliest of:<br>the last use of the returned pointer, or any pointer derived from it, in the calling function or<br>the autorelease pool is restored to a previous state.</p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"ARC-or-not？\"><a href=\"#ARC-or-not？\" class=\"headerlink\" title=\"ARC or not？\"></a>ARC or not？</h2><p><code>Automatic Reference Counting</code>是objc发展以来相当重要的一个进步  </p>\n<blockquote>\n<p>对于开发者，任何能降低开发难度，简化代码的功能，我们都应该去了解和使用。<br>我们应该利用一切“偷懒”的机会，将软件开发的复杂度分解并控制在一个个小的范围内，使得对于分解后的每一个小的任务，都能被新手掌握和维护。  </p>\n</blockquote>\n<p>基于简化开发的思想来看，ARC绝对是一个<strong>没理由拒绝</strong>的技术进步。<br>ARC随着iOS5问世，到现在iOS8都快出了，你还在手动写retain，release么？除了固守思想外，对ARC的恐惧大都来自对它的未知。  </p>\n<p>比如我在公司尝试说服team使用ARC时被质疑的几个问题：</p>\n<blockquote>\n<p>ARC和Java的GC一样，会导致一部分性能损耗？</p>\n</blockquote>\n<p>首先，ARC和GC是两码事，ARC是编译时编译器“帮你”插入了原本需要自己手写的内存管理代码，而非像GC一样运行时的垃圾回收系统  </p>\n<blockquote>\n<p>ARC内存不知道什么时候释放，导致不可控的内存涨落？  </p>\n</blockquote>\n<p>了解ARC的原理后，就知道，ARC下编译器插入的内存管理的代码是经过优化的，对于使用完的内存，多运行一行代码都不会浪费，可以这么说，手写的内存管理必须达到很严谨的水平才可能达到ARC自动生成的一样完整且没有疏漏</p>\n<blockquote>\n<p>ARC下面自己不管理内存，很不爽，很没有安全感  </p>\n</blockquote>\n<p>这纯粹是习惯的问题了，开发者的目标是用最简化的手段完成一个最可靠的程序，进步需要改变的。好在编译选项中提供了<code>-fobjc-arc</code>和<code>-fno-objc-arc</code>来保证整个的变革的继续下去，就像社会主义中国里的港澳</p>\n<blockquote>\n<p>ARC的约定  </p>\n</blockquote>\n<p>使用ARC之后一个费解的地方是，一个方法生成的对象，没有任何附加标示，ARC怎么知道生成的对象是不是<code>autorelease</code>的呢？</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">+ (instancetype)sarkWithMark:(<span class=\"built_in\">NSString</span> *)mark; <span class=\"comment\">// 1</span></span><br><span class=\"line\">- (instancetype)initWithMark:(<span class=\"built_in\">NSString</span> *)mark; <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>这是非ARC时常用的手段，1生成autorelease对象，2生成普通对象，而现在ARC不能调用autorelease，使用时怎么能知道呢？</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    Sark *sark1 = [Sark sarkWithMark:<span class=\"string\">@\"萨萨萨\"</span>];</span><br><span class=\"line\">    Sark *sark2 = [[Sark alloc] initWithMark:<span class=\"string\">@\"萨萨萨\"</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用<code>约定</code>，NS定义了下面三个编译属性  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define NS_RETURNS_RETAINED __attribute__((ns_returns_retained))</span></span><br><span class=\"line\"><span class=\"meta\">#define NS_RETURNS_NOT_RETAINED __attribute__((ns_returns_not_retained))</span></span><br><span class=\"line\"><span class=\"meta\">#define NS_RETURNS_INNER_POINTER __attribute__((objc_returns_inner_pointer))</span></span><br></pre></td></tr></table></figure>\n<p>这三个属性是Clang自己使用的标示，除非<code>特殊情况</code>不要自己使用，但是这些对理解ARC是很有帮助的。<br>这里还要介绍一个概念，<code>Method family</code></p>\n<blockquote>\n<p>An Objective-C method may fall into a method family, which is a conventional set of behaviors ascribed to it by the Cocoa conventions.</p>\n</blockquote>\n<p>指的是命名上表示一类型的方法，比如<code>- init</code>和<code>- initWithMark:</code>都属于<code>init</code>的family<br>于是乎，编译器约定，对于<code>alloc</code>,<code>init</code>,<code>copy</code>,<code>mutableCopy</code>,<code>new</code>这几个家族的方法，后面默认加<code>NS_RETURNS_RETAINED</code>标识；而其他不指名标识的family的方法默认添加<code>NS_RETURNS_NOT_RETAINED</code>标识<br>也就是说刚才的方法，在编译器看来是这样的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">+ (instancetype)sarkWithMark:(<span class=\"built_in\">NSString</span> *)mark <span class=\"built_in\">NS_RETURNS_NOT_RETAINED</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\">- (instancetype)initWithMark:(<span class=\"built_in\">NSString</span> *)mark <span class=\"built_in\">NS_RETURNS_RETAINED</span>; <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>这也就是为什么ARC下面，不能把一个属性定义成名字是这样的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *newString; <span class=\"comment\">// 编译器不允许</span></span><br></pre></td></tr></table></figure>\n<p><code>- newString</code>就成了<code>new</code>家族的方法，内存就不对了<br>对于<code>NS_RETURNS_INNER_POINTER</code>这货，主要使用在返回的是一个对象的<strong>内部C指针</strong>的情况，如NSString的方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (__<span class=\"keyword\">strong</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *)UTF8String <span class=\"built_in\">NS_RETURNS_INNER_POINTER</span>;</span><br></pre></td></tr></table></figure>\n<p>就使用了这个标识，这个就不深入研究了，直接上文档：</p>\n<blockquote>\n<p>An Objective-C method returning a non-retainable pointer may be annotated with the objc_returns_inner_pointer attribute to indicate that it returns a handle to the internal data of an object, and that this reference will be invalidated if the object is destroyed. When such a message is sent to an object, the object’s lifetime will be extended until at least the earliest of:<br>the last use of the returned pointer, or any pointer derived from it, in the calling function or<br>the autorelease pool is restored to a previous state.</p>\n</blockquote>\n"},{"layout":"objc","title":"objc category的秘密","date":"2014-03-05T09:37:19.000Z","_content":"\n## category的真面目\nobjc所有类和对象都是c结构体，category当然也一样，下面是`runtime`中category的结构：\n\n``` objc\nstruct _category_t {\n\tconst char *name; // 1\n\tstruct _class_t *cls; // 2\n\tconst struct _method_list_t *instance_methods; // 3\n\tconst struct _method_list_t *class_methods; // 4\n\tconst struct _protocol_list_t *protocols; // 5\n\tconst struct _prop_list_t *properties; // 6\n};\n```\n\n1. `name`注意，并不是category小括号里写的名字，而是类的名字\n2. `cls`要扩展的类对象，编译期间这个值是不会有的，在app被runtime加载时才会根据`name`对应到类对象\n3. `instance_methods`这个category所有的`-`方法\n4. `class_methods`这个category所有的`+`方法\n5. `protocols`这个category实现的protocol，比较不常用在category里面实现协议，但是确实支持的\n6. `properties`这个category所有的property，这也是category里面可以定义属性的原因，不过这个property不会`@synthesize`实例变量，一般有需求添加实例变量属性时会采用`objc_setAssociatedObject`和`objc_getAssociatedObject`方法绑定方法绑定，不过这种方法生成的与一个普通的实例变量完全是两码事。\n\n### 编译器，你对category干了什么？\n\n举个栗子看，定义下面一个类和它的category，实现忽略，保存为`sark.h`和`sark.m`\n``` objc\n@interface Sark : NSObject\n- (void)speak;\n@end\n\n@interface Sark (GayExtention)\n- (void)burst;\n@end\n```\n请出clang的重写命令：\n``` bash\n$ clang -rewrite-objc sark.m\n```\n同级目录下会生成`sark.cpp`，这就是`objc`代码重写成`c++`(基本就是c)的实现。\n打开生成的文件，发现茫茫多，排除include进来的header，自己的代码都在文件尾部了，看看上面的category被编译器搞成什么样子了：\n``` c\nstatic struct _category_t _OBJC_$_CATEGORY_Sark_$_GayExtention __attribute__ ((used, section (\"__DATA,__objc_const\"))) =\n{\n  \"Sark\",\n  0, // &OBJC_CLASS_$_Sark,\n  (const struct _method_list_t *)&_OBJC_$_CATEGORY_INSTANCE_METHODS_Sark_$_GayExtention,\n  0,\n  0,\n  0\n};\n```\n先注意这个category的名字`_OBJC_$_CATEGORY_Sark_$_GayExtention`，这是一个按规则生成的符号了，中间的`Sark`是类名，后面的`GayExtention`是类别的名字，这也就是为什么**同一个类的category名不能冲突**了  \n\n对应看上面`_category_t`的定义，因为category里面只添加了一个`- burst`方法，所以只有实例方法那一项被填充了值`_OBJC_$_CATEGORY_INSTANCE_METHODS_Sark_$_GayExtention`\n\n其中`_I_Sark_GayExtention_burst`符号就代表了category里面的`- burst`方法，同样遵循了一定的命名规范，里面的`I`表示实例方法\n\n最后，这个类的category们生成了一个数组，存在了`__DATA`段下的`__objc_catlist`section里\n``` c\nstatic struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (\"__DATA, __objc_catlist,regular,no_dead_strip\")))= {\n\t&_OBJC_$_CATEGORY_Sark_$_GayExtention,\n};\n```\n至此编译器的任务完成了。\n\n### runtime，我的category哪儿去了？\n\n我们知道，category动态扩展了原来类的方法，在调用者看来好像原来类本来就有这些方法似的，有两个事实：\n\n 1. 不论有没有import category 的`.h`，都可以成功调用category的方法，都影响不到category的加载流程，import只是帮助了编译检查和链接过程\n 2. runtime加载完成后，category的**原始信息**在**类结构里**将不会存在\n\n\n这需要探究下**runtime对category的加载过程**，这里就简单说一下\n\n 1. objc runtime的加载入口是一个叫`_objc_init`的方法，在library加载前由libSystem dyld调用，进行初始化操作\n 2. 调用`map_images`方法将文件中的`image`map到内存\n 3. 调用`_read_images`方法初始化map后的`image`，这里面干了很多的事情，像load所有的类、协议和**category**，著名的`+ load`方法就是这一步调用的\n 4. 仔细看category的初始化，循环调用了`_getObjc2CategoryList`方法，这个方法拿出来看看：\n 5. ...\n\n\n``` objc\n#define GETSECT(name, type, sectname)                                   \\\n    type *name(const header_info *hi, size_t *outCount)  \\\n    {                                                                   \\\n        unsigned long byteCount = 0;                                    \\\n        type *data = (type *)                                           \\\n            getsectiondata(hi->mhdr, SEG_DATA, sectname, &byteCount);   \\\n        *outCount = byteCount / sizeof(type);                           \\\n        return data;                                                    \\\n    }\n\n// ... //\n\nGETSECT(_getObjc2CategoryList, category_t *, \"__objc_catlist\");\n```\n眼熟的`__objc_catlist`，就是上面category存放的数据段了，可以串连起来了\n\n在调用完`_getObjc2CategoryList`后，runtime终于开始了**category的处理**，简化的代码如下\n``` objc\n// Process this category.\n// First, register the category with its target class.\n// Then, rebuild the class's method lists (etc) if\n// the class is realized.\nBOOL classExists = NO;\nif (cat->instanceMethods ||  cat->protocols  ||  cat->instanceProperties)\n{\n    addUnattachedCategoryForClass(cat, cls, hi);\n    if (isRealized(cls)) {\n        remethodizeClass(cls);\n        classExists = YES;\n    }\n}\n\nif (cat->classMethods  ||  cat->protocols )\n{\n    addUnattachedCategoryForClass(cat, cls->isa, hi);\n    if (isRealized(cls->isa)) {\n        remethodizeClass(cls->isa);\n    }\n}\n```\n首先分成两拨，一拨是实例对象相关的调用`addUnattachedCategoryForClass`，一拨是类对象相关的调用`addUnattachedCategoryForClass`，然后会调到`attachCategoryMethods`方法，这个方法把一个类所有的category_list的所有方法取出来组成一个`method_list_t **`，注意，这里是`倒序`添加的，也就是说，新生成的category的方法会先于旧的category的方法插入\n\n``` c\nstatic void\nattachCategoryMethods(class_t *cls, category_list *cats,\n                      BOOL *inoutVtablesAffected)\n{\n    if (!cats) return;\n    if (PrintReplacedMethods) printReplacements(cls, cats);\n\n    BOOL isMeta = isMetaClass(cls);\n    method_list_t **mlists = (method_list_t **)\n        _malloc_internal(cats->count * sizeof(*mlists));\n\n    // Count backwards through cats to get newest categories first\n    int mcount = 0;\n    int i = cats->count;\n    BOOL fromBundle = NO;\n    while (i--) {\n        method_list_t *mlist = cat_method_list(cats->list[i].cat, isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist;\n            fromBundle |= cats->list[i].fromBundle;\n        }\n    }\n\n    attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);\n\n    _free_internal(mlists);\n\n}\n```\n生成了所有method的list之后，调用`attachMethodLists`将所有方法`前序`添加进类的方法的数组中，也就是说，如果原来类的方法是a,b,c，类别的方法是1,2,3，那么插入之后的方法将会是1,2,3,a,b,c，也就是说，原来类的方法被category的方法`覆盖`了，但被覆盖的方法确实还在那里。\n","source":"_posts/objc_category_secret.md","raw":"layout: objc\ntitle: objc category的秘密\ndate: 2014-03-05 17:37:19\ntags: objc的秘密\n---\n\n## category的真面目\nobjc所有类和对象都是c结构体，category当然也一样，下面是`runtime`中category的结构：\n\n``` objc\nstruct _category_t {\n\tconst char *name; // 1\n\tstruct _class_t *cls; // 2\n\tconst struct _method_list_t *instance_methods; // 3\n\tconst struct _method_list_t *class_methods; // 4\n\tconst struct _protocol_list_t *protocols; // 5\n\tconst struct _prop_list_t *properties; // 6\n};\n```\n\n1. `name`注意，并不是category小括号里写的名字，而是类的名字\n2. `cls`要扩展的类对象，编译期间这个值是不会有的，在app被runtime加载时才会根据`name`对应到类对象\n3. `instance_methods`这个category所有的`-`方法\n4. `class_methods`这个category所有的`+`方法\n5. `protocols`这个category实现的protocol，比较不常用在category里面实现协议，但是确实支持的\n6. `properties`这个category所有的property，这也是category里面可以定义属性的原因，不过这个property不会`@synthesize`实例变量，一般有需求添加实例变量属性时会采用`objc_setAssociatedObject`和`objc_getAssociatedObject`方法绑定方法绑定，不过这种方法生成的与一个普通的实例变量完全是两码事。\n\n### 编译器，你对category干了什么？\n\n举个栗子看，定义下面一个类和它的category，实现忽略，保存为`sark.h`和`sark.m`\n``` objc\n@interface Sark : NSObject\n- (void)speak;\n@end\n\n@interface Sark (GayExtention)\n- (void)burst;\n@end\n```\n请出clang的重写命令：\n``` bash\n$ clang -rewrite-objc sark.m\n```\n同级目录下会生成`sark.cpp`，这就是`objc`代码重写成`c++`(基本就是c)的实现。\n打开生成的文件，发现茫茫多，排除include进来的header，自己的代码都在文件尾部了，看看上面的category被编译器搞成什么样子了：\n``` c\nstatic struct _category_t _OBJC_$_CATEGORY_Sark_$_GayExtention __attribute__ ((used, section (\"__DATA,__objc_const\"))) =\n{\n  \"Sark\",\n  0, // &OBJC_CLASS_$_Sark,\n  (const struct _method_list_t *)&_OBJC_$_CATEGORY_INSTANCE_METHODS_Sark_$_GayExtention,\n  0,\n  0,\n  0\n};\n```\n先注意这个category的名字`_OBJC_$_CATEGORY_Sark_$_GayExtention`，这是一个按规则生成的符号了，中间的`Sark`是类名，后面的`GayExtention`是类别的名字，这也就是为什么**同一个类的category名不能冲突**了  \n\n对应看上面`_category_t`的定义，因为category里面只添加了一个`- burst`方法，所以只有实例方法那一项被填充了值`_OBJC_$_CATEGORY_INSTANCE_METHODS_Sark_$_GayExtention`\n\n其中`_I_Sark_GayExtention_burst`符号就代表了category里面的`- burst`方法，同样遵循了一定的命名规范，里面的`I`表示实例方法\n\n最后，这个类的category们生成了一个数组，存在了`__DATA`段下的`__objc_catlist`section里\n``` c\nstatic struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (\"__DATA, __objc_catlist,regular,no_dead_strip\")))= {\n\t&_OBJC_$_CATEGORY_Sark_$_GayExtention,\n};\n```\n至此编译器的任务完成了。\n\n### runtime，我的category哪儿去了？\n\n我们知道，category动态扩展了原来类的方法，在调用者看来好像原来类本来就有这些方法似的，有两个事实：\n\n 1. 不论有没有import category 的`.h`，都可以成功调用category的方法，都影响不到category的加载流程，import只是帮助了编译检查和链接过程\n 2. runtime加载完成后，category的**原始信息**在**类结构里**将不会存在\n\n\n这需要探究下**runtime对category的加载过程**，这里就简单说一下\n\n 1. objc runtime的加载入口是一个叫`_objc_init`的方法，在library加载前由libSystem dyld调用，进行初始化操作\n 2. 调用`map_images`方法将文件中的`image`map到内存\n 3. 调用`_read_images`方法初始化map后的`image`，这里面干了很多的事情，像load所有的类、协议和**category**，著名的`+ load`方法就是这一步调用的\n 4. 仔细看category的初始化，循环调用了`_getObjc2CategoryList`方法，这个方法拿出来看看：\n 5. ...\n\n\n``` objc\n#define GETSECT(name, type, sectname)                                   \\\n    type *name(const header_info *hi, size_t *outCount)  \\\n    {                                                                   \\\n        unsigned long byteCount = 0;                                    \\\n        type *data = (type *)                                           \\\n            getsectiondata(hi->mhdr, SEG_DATA, sectname, &byteCount);   \\\n        *outCount = byteCount / sizeof(type);                           \\\n        return data;                                                    \\\n    }\n\n// ... //\n\nGETSECT(_getObjc2CategoryList, category_t *, \"__objc_catlist\");\n```\n眼熟的`__objc_catlist`，就是上面category存放的数据段了，可以串连起来了\n\n在调用完`_getObjc2CategoryList`后，runtime终于开始了**category的处理**，简化的代码如下\n``` objc\n// Process this category.\n// First, register the category with its target class.\n// Then, rebuild the class's method lists (etc) if\n// the class is realized.\nBOOL classExists = NO;\nif (cat->instanceMethods ||  cat->protocols  ||  cat->instanceProperties)\n{\n    addUnattachedCategoryForClass(cat, cls, hi);\n    if (isRealized(cls)) {\n        remethodizeClass(cls);\n        classExists = YES;\n    }\n}\n\nif (cat->classMethods  ||  cat->protocols )\n{\n    addUnattachedCategoryForClass(cat, cls->isa, hi);\n    if (isRealized(cls->isa)) {\n        remethodizeClass(cls->isa);\n    }\n}\n```\n首先分成两拨，一拨是实例对象相关的调用`addUnattachedCategoryForClass`，一拨是类对象相关的调用`addUnattachedCategoryForClass`，然后会调到`attachCategoryMethods`方法，这个方法把一个类所有的category_list的所有方法取出来组成一个`method_list_t **`，注意，这里是`倒序`添加的，也就是说，新生成的category的方法会先于旧的category的方法插入\n\n``` c\nstatic void\nattachCategoryMethods(class_t *cls, category_list *cats,\n                      BOOL *inoutVtablesAffected)\n{\n    if (!cats) return;\n    if (PrintReplacedMethods) printReplacements(cls, cats);\n\n    BOOL isMeta = isMetaClass(cls);\n    method_list_t **mlists = (method_list_t **)\n        _malloc_internal(cats->count * sizeof(*mlists));\n\n    // Count backwards through cats to get newest categories first\n    int mcount = 0;\n    int i = cats->count;\n    BOOL fromBundle = NO;\n    while (i--) {\n        method_list_t *mlist = cat_method_list(cats->list[i].cat, isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist;\n            fromBundle |= cats->list[i].fromBundle;\n        }\n    }\n\n    attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);\n\n    _free_internal(mlists);\n\n}\n```\n生成了所有method的list之后，调用`attachMethodLists`将所有方法`前序`添加进类的方法的数组中，也就是说，如果原来类的方法是a,b,c，类别的方法是1,2,3，那么插入之后的方法将会是1,2,3,a,b,c，也就是说，原来类的方法被category的方法`覆盖`了，但被覆盖的方法确实还在那里。\n","slug":"objc_category_secret","published":1,"updated":"2016-03-27T09:20:28.000Z","comments":1,"photos":[],"link":"","_id":"cimd6pxm3001qev12778qqixj","content":"<h2 id=\"category的真面目\"><a href=\"#category的真面目\" class=\"headerlink\" title=\"category的真面目\"></a>category的真面目</h2><p>objc所有类和对象都是c结构体，category当然也一样，下面是<code>runtime</code>中category的结构：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> _category_t &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name; <span class=\"comment\">// 1</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> _class_t *cls; <span class=\"comment\">// 2</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> _method_list_t *instance_methods; <span class=\"comment\">// 3</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> _method_list_t *class_methods; <span class=\"comment\">// 4</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> _protocol_list_t *protocols; <span class=\"comment\">// 5</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> _prop_list_t *properties; <span class=\"comment\">// 6</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>name</code>注意，并不是category小括号里写的名字，而是类的名字</li>\n<li><code>cls</code>要扩展的类对象，编译期间这个值是不会有的，在app被runtime加载时才会根据<code>name</code>对应到类对象</li>\n<li><code>instance_methods</code>这个category所有的<code>-</code>方法</li>\n<li><code>class_methods</code>这个category所有的<code>+</code>方法</li>\n<li><code>protocols</code>这个category实现的protocol，比较不常用在category里面实现协议，但是确实支持的</li>\n<li><code>properties</code>这个category所有的property，这也是category里面可以定义属性的原因，不过这个property不会<code>@synthesize</code>实例变量，一般有需求添加实例变量属性时会采用<code>objc_setAssociatedObject</code>和<code>objc_getAssociatedObject</code>方法绑定方法绑定，不过这种方法生成的与一个普通的实例变量完全是两码事。</li>\n</ol>\n<h3 id=\"编译器，你对category干了什么？\"><a href=\"#编译器，你对category干了什么？\" class=\"headerlink\" title=\"编译器，你对category干了什么？\"></a>编译器，你对category干了什么？</h3><p>举个栗子看，定义下面一个类和它的category，实现忽略，保存为<code>sark.h</code>和<code>sark.m</code><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)speak;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> (<span class=\"title\">GayExtention</span>)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)burst;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>请出clang的重写命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ clang -rewrite-objc sark.m</span><br></pre></td></tr></table></figure></p>\n<p>同级目录下会生成<code>sark.cpp</code>，这就是<code>objc</code>代码重写成<code>c++</code>(基本就是c)的实现。<br>打开生成的文件，发现茫茫多，排除include进来的header，自己的代码都在文件尾部了，看看上面的category被编译器搞成什么样子了：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">struct</span> <span class=\"keyword\">_category_t</span> _OBJC_$_CATEGORY_Sark_$_GayExtention __attribute__ ((used, section (<span class=\"string\">\"__DATA,__objc_const\"</span>))) =</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"Sark\"</span>,</span><br><span class=\"line\">  <span class=\"number\">0</span>, <span class=\"comment\">// &amp;OBJC_CLASS_$_Sark,</span></span><br><span class=\"line\">  (<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> <span class=\"keyword\">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Sark_$_GayExtention,</span><br><span class=\"line\">  <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"number\">0</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>先注意这个category的名字<code>_OBJC_$_CATEGORY_Sark_$_GayExtention</code>，这是一个按规则生成的符号了，中间的<code>Sark</code>是类名，后面的<code>GayExtention</code>是类别的名字，这也就是为什么<strong>同一个类的category名不能冲突</strong>了  </p>\n<p>对应看上面<code>_category_t</code>的定义，因为category里面只添加了一个<code>- burst</code>方法，所以只有实例方法那一项被填充了值<code>_OBJC_$_CATEGORY_INSTANCE_METHODS_Sark_$_GayExtention</code></p>\n<p>其中<code>_I_Sark_GayExtention_burst</code>符号就代表了category里面的<code>- burst</code>方法，同样遵循了一定的命名规范，里面的<code>I</code>表示实例方法</p>\n<p>最后，这个类的category们生成了一个数组，存在了<code>__DATA</code>段下的<code>__objc_catlist</code>section里<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">struct</span> <span class=\"keyword\">_category_t</span> *L_OBJC_LABEL_CATEGORY_$ [<span class=\"number\">1</span>] __attribute__((used, section (<span class=\"string\">\"__DATA, __objc_catlist,regular,no_dead_strip\"</span>)))= &#123;</span><br><span class=\"line\">\t&amp;_OBJC_$_CATEGORY_Sark_$_GayExtention,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>至此编译器的任务完成了。</p>\n<h3 id=\"runtime，我的category哪儿去了？\"><a href=\"#runtime，我的category哪儿去了？\" class=\"headerlink\" title=\"runtime，我的category哪儿去了？\"></a>runtime，我的category哪儿去了？</h3><p>我们知道，category动态扩展了原来类的方法，在调用者看来好像原来类本来就有这些方法似的，有两个事实：</p>\n<ol>\n<li>不论有没有import category 的<code>.h</code>，都可以成功调用category的方法，都影响不到category的加载流程，import只是帮助了编译检查和链接过程</li>\n<li>runtime加载完成后，category的<strong>原始信息</strong>在<strong>类结构里</strong>将不会存在</li>\n</ol>\n<p>这需要探究下<strong>runtime对category的加载过程</strong>，这里就简单说一下</p>\n<ol>\n<li>objc runtime的加载入口是一个叫<code>_objc_init</code>的方法，在library加载前由libSystem dyld调用，进行初始化操作</li>\n<li>调用<code>map_images</code>方法将文件中的<code>image</code>map到内存</li>\n<li>调用<code>_read_images</code>方法初始化map后的<code>image</code>，这里面干了很多的事情，像load所有的类、协议和<strong>category</strong>，著名的<code>+ load</code>方法就是这一步调用的</li>\n<li>仔细看category的初始化，循环调用了<code>_getObjc2CategoryList</code>方法，这个方法拿出来看看：</li>\n<li>…</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define GETSECT(name, type, sectname)                                   \\</span></span><br><span class=\"line\">    type *name(<span class=\"keyword\">const</span> header_info *hi, size_t *outCount)  \\</span><br><span class=\"line\">    &#123;                                                                   \\</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> byteCount = <span class=\"number\">0</span>;                                    \\</span><br><span class=\"line\">        type *data = (type *)                                           \\</span><br><span class=\"line\">            getsectiondata(hi-&gt;mhdr, SEG_DATA, sectname, &amp;byteCount);   \\</span><br><span class=\"line\">        *outCount = byteCount / <span class=\"keyword\">sizeof</span>(type);                           \\</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data;                                                    \\</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... //</span></span><br><span class=\"line\"></span><br><span class=\"line\">GETSECT(_getObjc2CategoryList, category_t *, <span class=\"string\">\"__objc_catlist\"</span>);</span><br></pre></td></tr></table></figure>\n<p>眼熟的<code>__objc_catlist</code>，就是上面category存放的数据段了，可以串连起来了</p>\n<p>在调用完<code>_getObjc2CategoryList</code>后，runtime终于开始了<strong>category的处理</strong>，简化的代码如下<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Process this category.</span></span><br><span class=\"line\"><span class=\"comment\">// First, register the category with its target class.</span></span><br><span class=\"line\"><span class=\"comment\">// Then, rebuild the class's method lists (etc) if</span></span><br><span class=\"line\"><span class=\"comment\">// the class is realized.</span></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> classExists = <span class=\"literal\">NO</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  ||  cat-&gt;instanceProperties)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRealized(cls)) &#123;</span><br><span class=\"line\">        remethodizeClass(cls);</span><br><span class=\"line\">        classExists = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    addUnattachedCategoryForClass(cat, cls-&gt;isa, hi);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRealized(cls-&gt;isa)) &#123;</span><br><span class=\"line\">        remethodizeClass(cls-&gt;isa);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先分成两拨，一拨是实例对象相关的调用<code>addUnattachedCategoryForClass</code>，一拨是类对象相关的调用<code>addUnattachedCategoryForClass</code>，然后会调到<code>attachCategoryMethods</code>方法，这个方法把一个类所有的category_list的所有方法取出来组成一个<code>method_list_t **</code>，注意，这里是<code>倒序</code>添加的，也就是说，新生成的category的方法会先于旧的category的方法插入</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void</span><br><span class=\"line\">attachCategoryMethods(class_t *cls, category_list *cats,</span><br><span class=\"line\">                      BOOL *inoutVtablesAffected)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!cats) return;</span><br><span class=\"line\">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class=\"line\"></span><br><span class=\"line\">    BOOL isMeta = isMetaClass(cls);</span><br><span class=\"line\">    method_list_t **mlists = (method_list_t **)</span><br><span class=\"line\">        _malloc_internal(cats-&gt;count * sizeof(*mlists));</span><br><span class=\"line\"></span><br><span class=\"line\">    // Count backwards through cats to get newest categories first</span><br><span class=\"line\">    int mcount = 0;</span><br><span class=\"line\">    int i = cats-&gt;count;</span><br><span class=\"line\">    BOOL fromBundle = NO;</span><br><span class=\"line\">    while (i--) &#123;</span><br><span class=\"line\">        method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta);</span><br><span class=\"line\">        if (mlist) &#123;</span><br><span class=\"line\">            mlists[mcount++] = mlist;</span><br><span class=\"line\">            fromBundle |= cats-&gt;list[i].fromBundle;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);</span><br><span class=\"line\"></span><br><span class=\"line\">    _free_internal(mlists);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生成了所有method的list之后，调用<code>attachMethodLists</code>将所有方法<code>前序</code>添加进类的方法的数组中，也就是说，如果原来类的方法是a,b,c，类别的方法是1,2,3，那么插入之后的方法将会是1,2,3,a,b,c，也就是说，原来类的方法被category的方法<code>覆盖</code>了，但被覆盖的方法确实还在那里。</p>\n","excerpt":"","more":"<h2 id=\"category的真面目\"><a href=\"#category的真面目\" class=\"headerlink\" title=\"category的真面目\"></a>category的真面目</h2><p>objc所有类和对象都是c结构体，category当然也一样，下面是<code>runtime</code>中category的结构：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> _category_t &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name; <span class=\"comment\">// 1</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> _class_t *cls; <span class=\"comment\">// 2</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> _method_list_t *instance_methods; <span class=\"comment\">// 3</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> _method_list_t *class_methods; <span class=\"comment\">// 4</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> _protocol_list_t *protocols; <span class=\"comment\">// 5</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> _prop_list_t *properties; <span class=\"comment\">// 6</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>name</code>注意，并不是category小括号里写的名字，而是类的名字</li>\n<li><code>cls</code>要扩展的类对象，编译期间这个值是不会有的，在app被runtime加载时才会根据<code>name</code>对应到类对象</li>\n<li><code>instance_methods</code>这个category所有的<code>-</code>方法</li>\n<li><code>class_methods</code>这个category所有的<code>+</code>方法</li>\n<li><code>protocols</code>这个category实现的protocol，比较不常用在category里面实现协议，但是确实支持的</li>\n<li><code>properties</code>这个category所有的property，这也是category里面可以定义属性的原因，不过这个property不会<code>@synthesize</code>实例变量，一般有需求添加实例变量属性时会采用<code>objc_setAssociatedObject</code>和<code>objc_getAssociatedObject</code>方法绑定方法绑定，不过这种方法生成的与一个普通的实例变量完全是两码事。</li>\n</ol>\n<h3 id=\"编译器，你对category干了什么？\"><a href=\"#编译器，你对category干了什么？\" class=\"headerlink\" title=\"编译器，你对category干了什么？\"></a>编译器，你对category干了什么？</h3><p>举个栗子看，定义下面一个类和它的category，实现忽略，保存为<code>sark.h</code>和<code>sark.m</code><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)speak;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> (<span class=\"title\">GayExtention</span>)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)burst;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>请出clang的重写命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ clang -rewrite-objc sark.m</span><br></pre></td></tr></table></figure></p>\n<p>同级目录下会生成<code>sark.cpp</code>，这就是<code>objc</code>代码重写成<code>c++</code>(基本就是c)的实现。<br>打开生成的文件，发现茫茫多，排除include进来的header，自己的代码都在文件尾部了，看看上面的category被编译器搞成什么样子了：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">struct</span> <span class=\"keyword\">_category_t</span> _OBJC_$_CATEGORY_Sark_$_GayExtention __attribute__ ((used, section (<span class=\"string\">\"__DATA,__objc_const\"</span>))) =</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"Sark\"</span>,</span><br><span class=\"line\">  <span class=\"number\">0</span>, <span class=\"comment\">// &amp;OBJC_CLASS_$_Sark,</span></span><br><span class=\"line\">  (<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> <span class=\"keyword\">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Sark_$_GayExtention,</span><br><span class=\"line\">  <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"number\">0</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>先注意这个category的名字<code>_OBJC_$_CATEGORY_Sark_$_GayExtention</code>，这是一个按规则生成的符号了，中间的<code>Sark</code>是类名，后面的<code>GayExtention</code>是类别的名字，这也就是为什么<strong>同一个类的category名不能冲突</strong>了  </p>\n<p>对应看上面<code>_category_t</code>的定义，因为category里面只添加了一个<code>- burst</code>方法，所以只有实例方法那一项被填充了值<code>_OBJC_$_CATEGORY_INSTANCE_METHODS_Sark_$_GayExtention</code></p>\n<p>其中<code>_I_Sark_GayExtention_burst</code>符号就代表了category里面的<code>- burst</code>方法，同样遵循了一定的命名规范，里面的<code>I</code>表示实例方法</p>\n<p>最后，这个类的category们生成了一个数组，存在了<code>__DATA</code>段下的<code>__objc_catlist</code>section里<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">struct</span> <span class=\"keyword\">_category_t</span> *L_OBJC_LABEL_CATEGORY_$ [<span class=\"number\">1</span>] __attribute__((used, section (<span class=\"string\">\"__DATA, __objc_catlist,regular,no_dead_strip\"</span>)))= &#123;</span><br><span class=\"line\">\t&amp;_OBJC_$_CATEGORY_Sark_$_GayExtention,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>至此编译器的任务完成了。</p>\n<h3 id=\"runtime，我的category哪儿去了？\"><a href=\"#runtime，我的category哪儿去了？\" class=\"headerlink\" title=\"runtime，我的category哪儿去了？\"></a>runtime，我的category哪儿去了？</h3><p>我们知道，category动态扩展了原来类的方法，在调用者看来好像原来类本来就有这些方法似的，有两个事实：</p>\n<ol>\n<li>不论有没有import category 的<code>.h</code>，都可以成功调用category的方法，都影响不到category的加载流程，import只是帮助了编译检查和链接过程</li>\n<li>runtime加载完成后，category的<strong>原始信息</strong>在<strong>类结构里</strong>将不会存在</li>\n</ol>\n<p>这需要探究下<strong>runtime对category的加载过程</strong>，这里就简单说一下</p>\n<ol>\n<li>objc runtime的加载入口是一个叫<code>_objc_init</code>的方法，在library加载前由libSystem dyld调用，进行初始化操作</li>\n<li>调用<code>map_images</code>方法将文件中的<code>image</code>map到内存</li>\n<li>调用<code>_read_images</code>方法初始化map后的<code>image</code>，这里面干了很多的事情，像load所有的类、协议和<strong>category</strong>，著名的<code>+ load</code>方法就是这一步调用的</li>\n<li>仔细看category的初始化，循环调用了<code>_getObjc2CategoryList</code>方法，这个方法拿出来看看：</li>\n<li>…</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define GETSECT(name, type, sectname)                                   \\</span></span><br><span class=\"line\">    type *name(<span class=\"keyword\">const</span> header_info *hi, size_t *outCount)  \\</span><br><span class=\"line\">    &#123;                                                                   \\</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> byteCount = <span class=\"number\">0</span>;                                    \\</span><br><span class=\"line\">        type *data = (type *)                                           \\</span><br><span class=\"line\">            getsectiondata(hi-&gt;mhdr, SEG_DATA, sectname, &amp;byteCount);   \\</span><br><span class=\"line\">        *outCount = byteCount / <span class=\"keyword\">sizeof</span>(type);                           \\</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data;                                                    \\</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... //</span></span><br><span class=\"line\"></span><br><span class=\"line\">GETSECT(_getObjc2CategoryList, category_t *, <span class=\"string\">\"__objc_catlist\"</span>);</span><br></pre></td></tr></table></figure>\n<p>眼熟的<code>__objc_catlist</code>，就是上面category存放的数据段了，可以串连起来了</p>\n<p>在调用完<code>_getObjc2CategoryList</code>后，runtime终于开始了<strong>category的处理</strong>，简化的代码如下<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Process this category.</span></span><br><span class=\"line\"><span class=\"comment\">// First, register the category with its target class.</span></span><br><span class=\"line\"><span class=\"comment\">// Then, rebuild the class's method lists (etc) if</span></span><br><span class=\"line\"><span class=\"comment\">// the class is realized.</span></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> classExists = <span class=\"literal\">NO</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  ||  cat-&gt;instanceProperties)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRealized(cls)) &#123;</span><br><span class=\"line\">        remethodizeClass(cls);</span><br><span class=\"line\">        classExists = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    addUnattachedCategoryForClass(cat, cls-&gt;isa, hi);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRealized(cls-&gt;isa)) &#123;</span><br><span class=\"line\">        remethodizeClass(cls-&gt;isa);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先分成两拨，一拨是实例对象相关的调用<code>addUnattachedCategoryForClass</code>，一拨是类对象相关的调用<code>addUnattachedCategoryForClass</code>，然后会调到<code>attachCategoryMethods</code>方法，这个方法把一个类所有的category_list的所有方法取出来组成一个<code>method_list_t **</code>，注意，这里是<code>倒序</code>添加的，也就是说，新生成的category的方法会先于旧的category的方法插入</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void</span><br><span class=\"line\">attachCategoryMethods(class_t *cls, category_list *cats,</span><br><span class=\"line\">                      BOOL *inoutVtablesAffected)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!cats) return;</span><br><span class=\"line\">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class=\"line\"></span><br><span class=\"line\">    BOOL isMeta = isMetaClass(cls);</span><br><span class=\"line\">    method_list_t **mlists = (method_list_t **)</span><br><span class=\"line\">        _malloc_internal(cats-&gt;count * sizeof(*mlists));</span><br><span class=\"line\"></span><br><span class=\"line\">    // Count backwards through cats to get newest categories first</span><br><span class=\"line\">    int mcount = 0;</span><br><span class=\"line\">    int i = cats-&gt;count;</span><br><span class=\"line\">    BOOL fromBundle = NO;</span><br><span class=\"line\">    while (i--) &#123;</span><br><span class=\"line\">        method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta);</span><br><span class=\"line\">        if (mlist) &#123;</span><br><span class=\"line\">            mlists[mcount++] = mlist;</span><br><span class=\"line\">            fromBundle |= cats-&gt;list[i].fromBundle;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);</span><br><span class=\"line\"></span><br><span class=\"line\">    _free_internal(mlists);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生成了所有method的list之后，调用<code>attachMethodLists</code>将所有方法<code>前序</code>添加进类的方法的数组中，也就是说，如果原来类的方法是a,b,c，类别的方法是1,2,3，那么插入之后的方法将会是1,2,3,a,b,c，也就是说，原来类的方法被category的方法<code>覆盖</code>了，但被覆盖的方法确实还在那里。</p>\n"},{"title":"objc@interface的设计哲学与设计技巧","date":"2014-04-13T05:01:54.000Z","_content":"\n# 我是前言\n学习objc时，尤其是先学过其他编程语言再来看objc时，总会对objc的**类**声明的关键字`interface`感到有点奇怪，在其它面向对象的语言中通常由`class`关键字来表示，而`interface`在java中表示的却大约相当于objc的`protocol`，这个关键字的区别究竟代表了objc语言的设计者怎样的思想呢，在objc类设计中需要注意哪些问题呢？接下来对这个问题进行一些思考和探究.   \n\n-----\n\n# interface?\n先来段Wiki:  \n> In object-oriented programming, a protocol or interface is a common means for unrelated objects to communicate with each other. These are definitions of methods and values which the objects agree upon in order to cooperate.\n\n接口约定了对象间交互的属性和方法，使得对象间无需了解对方就可以协作。  \n说的洋气点就是`解耦`嘛，细心点也能发现Wiki中`interface`和`protocol`表示了相近的语义。    \n引用我和项目组架构师讨论有关interface的问题时他的说法:\n\n> interface就是一个object定义的可以被外界影响的方式\n\n说着他指了下旁边桌子上放着的一把伞，说，这把伞我可以打开它，打开这个动作就是它的一个interface，桌子旁边还放着一个盒子，虽然它和伞都放在这张桌子上，但是它们之间永远不会互相影响，所以：  \n\n> interface只存在于能互相影响的两者间  \n\n-----\n\n# @interface生成了class？\n\n学习objc时最早接触的就是怎么写一个类了，从`.h`中写`@interface`声明类，再从`.m`中写`@implementation`实现方法，所以，objc中写一个`@interface`就相当于c++中写一个`class`。但这是真的么？  \n\n写个小test验证一下：\n有两个类，`Sark`和`Dark`，`Sark`类只有`.m`文件，其中只写`@implementation`；`Dark`类只有`.h`头文件，其中只写`@interface`，然后如下测试代码：  \n\n``` objc\nClass sarkClass = NSClassFromString(@\"Sark\");\nClass darkClass = NSClassFromString(@\"Dark\");\n```\n\n`NSClassFromString`方法调用了runtime方法，根据类名将加载进runtime的这个类找出来，没有这个类就回返回空(Nil)。   \n结果是`sarkClass`存在，而`darkClass`为空，说明什么？是否说明其实`@implementation`才是真正的Class？  \n进一步，不止能取到这个没有@interface的类，还可以正常调用方法（因为万能的runtime）  \n\n如下面的测试代码：\n\n``` objc\nSark *sark = [Sark new];\n[sark speak];\n```\n\n要是没有`@interface`的声明，类名，方法名都会报错说找不到，但是可以像下面一样绕一下：  \n\n``` objc\nClass cls = NSClassFromString(@\"Sark\");\nid obj = [cls performSelector:NSSelectorFromString(@\"new\")];\n[obj performSelector:NSSelectorFromString(@\"speak\")];\n```\n\n其实，从`rewrite`后的objc代码可以发现，对于消息的发送，恰恰就是会被处理成类似上面的代码，使用字符串mapping出`Class`，`selctor`等再使用`objc_msgSend()`进行函数调用，如下面所示：\n\n``` objc\n// 经过clang -rewrite-objc 命令重写后的代码\nSark *sark = ((id (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"Sark\"), sel_registerName(\"new\"));\n((void (*)(id, SEL))(void *)objc_msgSend)((id)sark, sel_registerName(\"speak\"));\n```\n\n# 对比@interface和@implementation\n\n`@interface` 我们干过的事：\n1. 继承\n2. 声明协议\n3. 定义实例变量（@interface后面加大括号那种）\n4. 定义@property\n5. 声明方法\n\n`@implementation` 我们干过的和可以干的事：  \n1. 继承\n2. 定义实例变量\n3. 合成属性（@synthesize和@dynamic）\n3. 实现方法（包括协议方法）\n\n在`@implementation`干一些事情用的相对较少，但是是完全合法的，如这样用：  \n\n``` objc\n@implementation Sark : NSObject {\n    NSString *_name;\n}\n```\n\n通过对比可以发现，**@interface对objc类结构的合成并无决定性作用**，加上**无决定性**是因为如果没有`@interface`会丢失一些类自省的原始数据，如属性列表和协议列表，但对于纯粹的对象消息发送并无影响。  \n所以说，可以得出这么一个结论，**objc中@interface就是为了给调用者看的，是和调用者的一个protocol**，没错，就是**protocol**。\n\n# 对比@interface和@protocol\n\n与其把`@implementation`扯进来不如对比下`@protocol`  \n\n\n我理解objc的`@interface`和`@protocal`间唯一的区别就是**是否和一个类型绑定**，这让我想起来`鸭子类型`(Duck typing), [wiki链接](http://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B)\n\n> “当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”\n\nDuck type在objc的体现无疑就是`@protocol`了，我们常用`id<XXXDelegate> delegate`的方式声明一个delegate，我们无需care这货到底是什么类型，我们只知道他能干什么就可以work了。同样的功能我也可以使用`XXXDelegate *delegate`的方式来定义，只不过这样的话这个类又需要耦合一个`XXXDelegate`类型，而这个delegate类是它原本并不需要关心的。  \n\n所以说，**`@interface`是`@protocol`的强类型升级版。**  \n\n举个`NSObject`的栗子最合适：  \n\n``` objc\n@interface NSObject <NSObject> {\n    Class isa;\n}\n```\nNSObject之所以成为NSObject，绝大多数都是`<NSObject>`协议定义的方法，实体类@interface定义的唯一一个变量`isa`指针，为了继承链和消息传递。    \n除了`<NSObject>`协议外，NSObject还有很多Category来补充它的功能，其实仔细想想，Category更像protocol，一个`补充协议`，同样不能添加实例变量，但是和`@interface`一样需要与Class绑定。  \n\n进一步来讲，自从属性能自动合成变量之后，在头文件`@interface`中写大括号声明实例变量的情况越来越少（可以参见近几个版本iOS SDK中类头文件里这种写法几乎消失），因此，`@interface`和`@protocol`的差别进一步缩小。  \n\n-----\n\n# 类与接口的设计原则 - 电视和遥控器\n\n我喜欢将`Class`和`interface`的关系比喻成`电视+遥控器`，那么objc中的消息机制就可以理解成：  \n**用户（caller）通过遥控器（interface）上的按钮（methods）发送红外线（message）来操纵电视（object）**  \n所以，有没有遥控器，电视都在那儿，也就是说，有没有interface，class都是存在的，只是这种存在并没有意义，就好像这个电视没人会打开，没人会用，没人能看，一堆废铁摆在那儿。  \n\n![](http://ww4.sinaimg.cn/large/51530583tw1efdy7cw48wj20c108qjru.jpg)\n\n对比简洁的遥控器，一个拥有很多按钮的老式电视遥控器，我们经常会用到的按钮能有几个呢？\n![](http://ww4.sinaimg.cn/large/51530583tw1efe08u9hb7j208c0b4jrp.jpg)\n\n所以，在设计一个类的interface的时候，如同在设计遥控器应该有怎样功能的按钮，要从调用者的角度出发，区分边界，应该时刻有以下几点考虑：\n1. 这个方法或属性真的属于这个类的职责么？（电视遥控器能遥控空调？）\n2. 这个方法或属性真的必须放在`.h`中（而不是放在`.m`的类扩展中）么？\n3. 调用者必须看文档才能知道这个类该如何使用么？（同一个业务需要调用者按顺序调用多次（而不是将这些细节隐藏，同时提供一个简洁的接口）才行）\n4. 调用者是否可以很容易发现类内部的变量和实现方式？（脑补下电视里面一块电路板漏在外面半截- -）\n5. ...  \n\n\n-----\n\n# objc的@interface设计技巧Tips  \n\n看过不少代码，从@interface设计上多少就能看出作者的水平，分享下我对于这个问题的一些拙见。\n\n## 只暴露外部需要看到的\n\n比如，有如下一个类（这个类无意义，主要关注写法）：  \n\n``` objc\n// Sark.h\n@interface SarkViewController : NSObject <NSXMLParserDelegate /*1*/, NSCopying> {\n    NSString *_name; // 2\n    IBOutlet UITextField *_nameTextField; // 2\n}\n@property (nonatomic, strong) NSXMLParser *parser; // 3\n- (IBAction)nameChangedAction:(id)sender; // 4\n@end\n```\n\n这个interface出现的问题：\n1. 类内部自己使用的协议，如`<NSXMLParserDelegate>`不应该在头文件@interface中声明，而应该在类扩展中声明；公开由外部调用的协议，如`<NSCopying>`则写在这儿是正确的。  \n2. `实例变量`和`IBOutlet`不应出现在这儿定义，这将类的内部实现暴露了出去，自从属性可以自动合成后，这里就更应该清净了。\n3. 内部使用的属性对象不要暴露在外，应该移动到类扩展中。\n4. 调用者对IBAction同样不需要关心，那么就不应该放在这儿。  \n\n## 合理分组子功能\n\n- 将相同功能的一组属性或方法写在一起  \n\n使用这个类或者对其进行修改时，一般都是从功能上找，所以把同一功能模块的一组属性或方法写在一块\n\n- 纯操作方法的子功能（无需向类添加变量）使用`Category`分块  \n- 在头文件中也可以使用`类扩展`将interface按功能分区\n\n`Category`里不能添加实例变量，但是类扩展可以，一般都在`.m`中作为私有interface使用，同样在头文件里作为分区使用，如，ReactiveCocoa中的[RACStream.h](https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/ReactiveCocoaFramework/ReactiveCocoa/RACStream.h)  \n\n## 避免头文件污染  \n首先，类实现内部.m文件中使用的其他interface应该在.m文件import，如果也写在header中就会造成对调用者的污染；当interface中出现其他`Class`或`protocol`时，可以使用前置声明`@class XXX`, `@protocol XXX`；当模块（一组类）内部间需要有一些定义（如常量、类型）而又不需要模块使用者知道时，使用一个内部头文件在模块中使用。\n\n## 避免接口过度设计\n考虑调用者的使用方便是很必要的，过火了反而增加了复杂度：  \n\n``` objc\n@interface Sark : NSObject\n- (instancetype)init;\n- (instancetype)initWithName:(NSString *)name;\n- (instancetype)initWithName:(NSString *)name sex:(NSString *)sex;\n- (instancetype)initWithName:(NSString *)name sex:(NSString *)sex age:(NSInteger)age;\n- (instancetype)initWithName:(NSString *)name sex:(NSString *)sex age:(NSInteger)age friends:(NSArray *)friends;\n// 无数多个 //\n@end\n```\n\n提供了一组这样的方法，调用者可能只能用到其中的一个，那这样倒不如只留一个接口。  \n\n## 避免单例的滥用  \n\n单例模式固然好用，但感觉有点过度，将接口设计成单例入口前需要考虑一下：  \n1. 这个类表达的含义真的只能有一个实例么？（如UIApplication）还是只是为了好调用而已？\n2. 这个单例持有的内存一直存在\n3. 是否能用类方法代替？  \n4. 这个单例对象是否能成为另一个单例对象的属性？如果是，应该作为属性  \n\n\n## 隐藏继承关系中的私有接口\n\n感谢`@像条狗在飞`在留言中提出的问题，问题大概可以总结为：当子类需要使用父类的一个私有属性（方法）时，需要把这个属性（方法）放到父类的header中，但暴露给子类的同时暴露给了外部调用者，如何解决?   \n\n我的方案是：建立一个`私有header`，使用`类扩展`定义父类需要暴露给子类的属性（方法），然后在各自的`.m`文件中引用，如：  \n\n有Father类和Son类，继承关系，可以考虑建一个如`FatherPrivate.h`的私有header：\n\n``` objc\n// FatherPrivate.h\n@interface Father ()\n@property (nonatomic, copy) NSString *privateThingSonNeed;\n- (void)privateMethodNeedsSonOverride;\n@end\n```\n\n同时在Father.m和Son.m中同时import这个私有header，这样，Father和Son内部对于定义的属性和方法都是透明的，而对外部是隐藏的（因为两个类的header中都没有import这个私有header）  \n\n\n-----\n\n# 总结  \n\n- `@implementation`合成了Class，而非`@interface`，`@interface`是`@protocol`的强类型升级版，它们和`Category`都表示了相近的含义\n- 我们应该善于面向接口编程，划清边界，将类的实现隐藏在调用者所见之外，使主调和被调者之间保持`最少知识原则`\n- `@interface`本身就是最好的文档  \n\n-----  \n\n# References\nhttp://en.m.wikipedia.org/wiki/Interface_(object-oriented_programming)  \nhttp://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B   \n\n-----\n原创文章，转载请注明源地址，[blog.sunnyxx.com](http://blog.sunnyxx.com)\n","source":"_posts/objc_dig_interface.md","raw":"title: objc@interface的设计哲学与设计技巧\ndate: 2014-04-13 13:01:54\ntags: objc刨根问底\n---\n\n# 我是前言\n学习objc时，尤其是先学过其他编程语言再来看objc时，总会对objc的**类**声明的关键字`interface`感到有点奇怪，在其它面向对象的语言中通常由`class`关键字来表示，而`interface`在java中表示的却大约相当于objc的`protocol`，这个关键字的区别究竟代表了objc语言的设计者怎样的思想呢，在objc类设计中需要注意哪些问题呢？接下来对这个问题进行一些思考和探究.   \n\n-----\n\n# interface?\n先来段Wiki:  \n> In object-oriented programming, a protocol or interface is a common means for unrelated objects to communicate with each other. These are definitions of methods and values which the objects agree upon in order to cooperate.\n\n接口约定了对象间交互的属性和方法，使得对象间无需了解对方就可以协作。  \n说的洋气点就是`解耦`嘛，细心点也能发现Wiki中`interface`和`protocol`表示了相近的语义。    \n引用我和项目组架构师讨论有关interface的问题时他的说法:\n\n> interface就是一个object定义的可以被外界影响的方式\n\n说着他指了下旁边桌子上放着的一把伞，说，这把伞我可以打开它，打开这个动作就是它的一个interface，桌子旁边还放着一个盒子，虽然它和伞都放在这张桌子上，但是它们之间永远不会互相影响，所以：  \n\n> interface只存在于能互相影响的两者间  \n\n-----\n\n# @interface生成了class？\n\n学习objc时最早接触的就是怎么写一个类了，从`.h`中写`@interface`声明类，再从`.m`中写`@implementation`实现方法，所以，objc中写一个`@interface`就相当于c++中写一个`class`。但这是真的么？  \n\n写个小test验证一下：\n有两个类，`Sark`和`Dark`，`Sark`类只有`.m`文件，其中只写`@implementation`；`Dark`类只有`.h`头文件，其中只写`@interface`，然后如下测试代码：  \n\n``` objc\nClass sarkClass = NSClassFromString(@\"Sark\");\nClass darkClass = NSClassFromString(@\"Dark\");\n```\n\n`NSClassFromString`方法调用了runtime方法，根据类名将加载进runtime的这个类找出来，没有这个类就回返回空(Nil)。   \n结果是`sarkClass`存在，而`darkClass`为空，说明什么？是否说明其实`@implementation`才是真正的Class？  \n进一步，不止能取到这个没有@interface的类，还可以正常调用方法（因为万能的runtime）  \n\n如下面的测试代码：\n\n``` objc\nSark *sark = [Sark new];\n[sark speak];\n```\n\n要是没有`@interface`的声明，类名，方法名都会报错说找不到，但是可以像下面一样绕一下：  \n\n``` objc\nClass cls = NSClassFromString(@\"Sark\");\nid obj = [cls performSelector:NSSelectorFromString(@\"new\")];\n[obj performSelector:NSSelectorFromString(@\"speak\")];\n```\n\n其实，从`rewrite`后的objc代码可以发现，对于消息的发送，恰恰就是会被处理成类似上面的代码，使用字符串mapping出`Class`，`selctor`等再使用`objc_msgSend()`进行函数调用，如下面所示：\n\n``` objc\n// 经过clang -rewrite-objc 命令重写后的代码\nSark *sark = ((id (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"Sark\"), sel_registerName(\"new\"));\n((void (*)(id, SEL))(void *)objc_msgSend)((id)sark, sel_registerName(\"speak\"));\n```\n\n# 对比@interface和@implementation\n\n`@interface` 我们干过的事：\n1. 继承\n2. 声明协议\n3. 定义实例变量（@interface后面加大括号那种）\n4. 定义@property\n5. 声明方法\n\n`@implementation` 我们干过的和可以干的事：  \n1. 继承\n2. 定义实例变量\n3. 合成属性（@synthesize和@dynamic）\n3. 实现方法（包括协议方法）\n\n在`@implementation`干一些事情用的相对较少，但是是完全合法的，如这样用：  \n\n``` objc\n@implementation Sark : NSObject {\n    NSString *_name;\n}\n```\n\n通过对比可以发现，**@interface对objc类结构的合成并无决定性作用**，加上**无决定性**是因为如果没有`@interface`会丢失一些类自省的原始数据，如属性列表和协议列表，但对于纯粹的对象消息发送并无影响。  \n所以说，可以得出这么一个结论，**objc中@interface就是为了给调用者看的，是和调用者的一个protocol**，没错，就是**protocol**。\n\n# 对比@interface和@protocol\n\n与其把`@implementation`扯进来不如对比下`@protocol`  \n\n\n我理解objc的`@interface`和`@protocal`间唯一的区别就是**是否和一个类型绑定**，这让我想起来`鸭子类型`(Duck typing), [wiki链接](http://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B)\n\n> “当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”\n\nDuck type在objc的体现无疑就是`@protocol`了，我们常用`id<XXXDelegate> delegate`的方式声明一个delegate，我们无需care这货到底是什么类型，我们只知道他能干什么就可以work了。同样的功能我也可以使用`XXXDelegate *delegate`的方式来定义，只不过这样的话这个类又需要耦合一个`XXXDelegate`类型，而这个delegate类是它原本并不需要关心的。  \n\n所以说，**`@interface`是`@protocol`的强类型升级版。**  \n\n举个`NSObject`的栗子最合适：  \n\n``` objc\n@interface NSObject <NSObject> {\n    Class isa;\n}\n```\nNSObject之所以成为NSObject，绝大多数都是`<NSObject>`协议定义的方法，实体类@interface定义的唯一一个变量`isa`指针，为了继承链和消息传递。    \n除了`<NSObject>`协议外，NSObject还有很多Category来补充它的功能，其实仔细想想，Category更像protocol，一个`补充协议`，同样不能添加实例变量，但是和`@interface`一样需要与Class绑定。  \n\n进一步来讲，自从属性能自动合成变量之后，在头文件`@interface`中写大括号声明实例变量的情况越来越少（可以参见近几个版本iOS SDK中类头文件里这种写法几乎消失），因此，`@interface`和`@protocol`的差别进一步缩小。  \n\n-----\n\n# 类与接口的设计原则 - 电视和遥控器\n\n我喜欢将`Class`和`interface`的关系比喻成`电视+遥控器`，那么objc中的消息机制就可以理解成：  \n**用户（caller）通过遥控器（interface）上的按钮（methods）发送红外线（message）来操纵电视（object）**  \n所以，有没有遥控器，电视都在那儿，也就是说，有没有interface，class都是存在的，只是这种存在并没有意义，就好像这个电视没人会打开，没人会用，没人能看，一堆废铁摆在那儿。  \n\n![](http://ww4.sinaimg.cn/large/51530583tw1efdy7cw48wj20c108qjru.jpg)\n\n对比简洁的遥控器，一个拥有很多按钮的老式电视遥控器，我们经常会用到的按钮能有几个呢？\n![](http://ww4.sinaimg.cn/large/51530583tw1efe08u9hb7j208c0b4jrp.jpg)\n\n所以，在设计一个类的interface的时候，如同在设计遥控器应该有怎样功能的按钮，要从调用者的角度出发，区分边界，应该时刻有以下几点考虑：\n1. 这个方法或属性真的属于这个类的职责么？（电视遥控器能遥控空调？）\n2. 这个方法或属性真的必须放在`.h`中（而不是放在`.m`的类扩展中）么？\n3. 调用者必须看文档才能知道这个类该如何使用么？（同一个业务需要调用者按顺序调用多次（而不是将这些细节隐藏，同时提供一个简洁的接口）才行）\n4. 调用者是否可以很容易发现类内部的变量和实现方式？（脑补下电视里面一块电路板漏在外面半截- -）\n5. ...  \n\n\n-----\n\n# objc的@interface设计技巧Tips  \n\n看过不少代码，从@interface设计上多少就能看出作者的水平，分享下我对于这个问题的一些拙见。\n\n## 只暴露外部需要看到的\n\n比如，有如下一个类（这个类无意义，主要关注写法）：  \n\n``` objc\n// Sark.h\n@interface SarkViewController : NSObject <NSXMLParserDelegate /*1*/, NSCopying> {\n    NSString *_name; // 2\n    IBOutlet UITextField *_nameTextField; // 2\n}\n@property (nonatomic, strong) NSXMLParser *parser; // 3\n- (IBAction)nameChangedAction:(id)sender; // 4\n@end\n```\n\n这个interface出现的问题：\n1. 类内部自己使用的协议，如`<NSXMLParserDelegate>`不应该在头文件@interface中声明，而应该在类扩展中声明；公开由外部调用的协议，如`<NSCopying>`则写在这儿是正确的。  \n2. `实例变量`和`IBOutlet`不应出现在这儿定义，这将类的内部实现暴露了出去，自从属性可以自动合成后，这里就更应该清净了。\n3. 内部使用的属性对象不要暴露在外，应该移动到类扩展中。\n4. 调用者对IBAction同样不需要关心，那么就不应该放在这儿。  \n\n## 合理分组子功能\n\n- 将相同功能的一组属性或方法写在一起  \n\n使用这个类或者对其进行修改时，一般都是从功能上找，所以把同一功能模块的一组属性或方法写在一块\n\n- 纯操作方法的子功能（无需向类添加变量）使用`Category`分块  \n- 在头文件中也可以使用`类扩展`将interface按功能分区\n\n`Category`里不能添加实例变量，但是类扩展可以，一般都在`.m`中作为私有interface使用，同样在头文件里作为分区使用，如，ReactiveCocoa中的[RACStream.h](https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/ReactiveCocoaFramework/ReactiveCocoa/RACStream.h)  \n\n## 避免头文件污染  \n首先，类实现内部.m文件中使用的其他interface应该在.m文件import，如果也写在header中就会造成对调用者的污染；当interface中出现其他`Class`或`protocol`时，可以使用前置声明`@class XXX`, `@protocol XXX`；当模块（一组类）内部间需要有一些定义（如常量、类型）而又不需要模块使用者知道时，使用一个内部头文件在模块中使用。\n\n## 避免接口过度设计\n考虑调用者的使用方便是很必要的，过火了反而增加了复杂度：  \n\n``` objc\n@interface Sark : NSObject\n- (instancetype)init;\n- (instancetype)initWithName:(NSString *)name;\n- (instancetype)initWithName:(NSString *)name sex:(NSString *)sex;\n- (instancetype)initWithName:(NSString *)name sex:(NSString *)sex age:(NSInteger)age;\n- (instancetype)initWithName:(NSString *)name sex:(NSString *)sex age:(NSInteger)age friends:(NSArray *)friends;\n// 无数多个 //\n@end\n```\n\n提供了一组这样的方法，调用者可能只能用到其中的一个，那这样倒不如只留一个接口。  \n\n## 避免单例的滥用  \n\n单例模式固然好用，但感觉有点过度，将接口设计成单例入口前需要考虑一下：  \n1. 这个类表达的含义真的只能有一个实例么？（如UIApplication）还是只是为了好调用而已？\n2. 这个单例持有的内存一直存在\n3. 是否能用类方法代替？  \n4. 这个单例对象是否能成为另一个单例对象的属性？如果是，应该作为属性  \n\n\n## 隐藏继承关系中的私有接口\n\n感谢`@像条狗在飞`在留言中提出的问题，问题大概可以总结为：当子类需要使用父类的一个私有属性（方法）时，需要把这个属性（方法）放到父类的header中，但暴露给子类的同时暴露给了外部调用者，如何解决?   \n\n我的方案是：建立一个`私有header`，使用`类扩展`定义父类需要暴露给子类的属性（方法），然后在各自的`.m`文件中引用，如：  \n\n有Father类和Son类，继承关系，可以考虑建一个如`FatherPrivate.h`的私有header：\n\n``` objc\n// FatherPrivate.h\n@interface Father ()\n@property (nonatomic, copy) NSString *privateThingSonNeed;\n- (void)privateMethodNeedsSonOverride;\n@end\n```\n\n同时在Father.m和Son.m中同时import这个私有header，这样，Father和Son内部对于定义的属性和方法都是透明的，而对外部是隐藏的（因为两个类的header中都没有import这个私有header）  \n\n\n-----\n\n# 总结  \n\n- `@implementation`合成了Class，而非`@interface`，`@interface`是`@protocol`的强类型升级版，它们和`Category`都表示了相近的含义\n- 我们应该善于面向接口编程，划清边界，将类的实现隐藏在调用者所见之外，使主调和被调者之间保持`最少知识原则`\n- `@interface`本身就是最好的文档  \n\n-----  \n\n# References\nhttp://en.m.wikipedia.org/wiki/Interface_(object-oriented_programming)  \nhttp://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B   \n\n-----\n原创文章，转载请注明源地址，[blog.sunnyxx.com](http://blog.sunnyxx.com)\n","slug":"objc_dig_interface","published":1,"updated":"2016-03-27T08:32:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxm5001sev12qarvnp0j","content":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>学习objc时，尤其是先学过其他编程语言再来看objc时，总会对objc的<strong>类</strong>声明的关键字<code>interface</code>感到有点奇怪，在其它面向对象的语言中通常由<code>class</code>关键字来表示，而<code>interface</code>在java中表示的却大约相当于objc的<code>protocol</code>，这个关键字的区别究竟代表了objc语言的设计者怎样的思想呢，在objc类设计中需要注意哪些问题呢？接下来对这个问题进行一些思考和探究.   </p>\n<hr>\n<h1 id=\"interface\"><a href=\"#interface\" class=\"headerlink\" title=\"interface?\"></a>interface?</h1><p>先来段Wiki:  </p>\n<blockquote>\n<p>In object-oriented programming, a protocol or interface is a common means for unrelated objects to communicate with each other. These are definitions of methods and values which the objects agree upon in order to cooperate.</p>\n</blockquote>\n<p>接口约定了对象间交互的属性和方法，使得对象间无需了解对方就可以协作。<br>说的洋气点就是<code>解耦</code>嘛，细心点也能发现Wiki中<code>interface</code>和<code>protocol</code>表示了相近的语义。<br>引用我和项目组架构师讨论有关interface的问题时他的说法:</p>\n<blockquote>\n<p>interface就是一个object定义的可以被外界影响的方式</p>\n</blockquote>\n<p>说着他指了下旁边桌子上放着的一把伞，说，这把伞我可以打开它，打开这个动作就是它的一个interface，桌子旁边还放着一个盒子，虽然它和伞都放在这张桌子上，但是它们之间永远不会互相影响，所以：  </p>\n<blockquote>\n<p>interface只存在于能互相影响的两者间  </p>\n</blockquote>\n<hr>\n<h1 id=\"interface生成了class？\"><a href=\"#interface生成了class？\" class=\"headerlink\" title=\"@interface生成了class？\"></a>@interface生成了class？</h1><p>学习objc时最早接触的就是怎么写一个类了，从<code>.h</code>中写<code>@interface</code>声明类，再从<code>.m</code>中写<code>@implementation</code>实现方法，所以，objc中写一个<code>@interface</code>就相当于c++中写一个<code>class</code>。但这是真的么？  </p>\n<p>写个小test验证一下：<br>有两个类，<code>Sark</code>和<code>Dark</code>，<code>Sark</code>类只有<code>.m</code>文件，其中只写<code>@implementation</code>；<code>Dark</code>类只有<code>.h</code>头文件，其中只写<code>@interface</code>，然后如下测试代码：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class sarkClass = <span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"Sark\"</span>);</span><br><span class=\"line\">Class darkClass = <span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"Dark\"</span>);</span><br></pre></td></tr></table></figure>\n<p><code>NSClassFromString</code>方法调用了runtime方法，根据类名将加载进runtime的这个类找出来，没有这个类就回返回空(Nil)。<br>结果是<code>sarkClass</code>存在，而<code>darkClass</code>为空，说明什么？是否说明其实<code>@implementation</code>才是真正的Class？<br>进一步，不止能取到这个没有@interface的类，还可以正常调用方法（因为万能的runtime）  </p>\n<p>如下面的测试代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sark *sark = [Sark new];</span><br><span class=\"line\">[sark speak];</span><br></pre></td></tr></table></figure>\n<p>要是没有<code>@interface</code>的声明，类名，方法名都会报错说找不到，但是可以像下面一样绕一下：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class cls = <span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"Sark\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">id</span> obj = [cls performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"new\"</span>)];</span><br><span class=\"line\">[obj performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"speak\"</span>)];</span><br></pre></td></tr></table></figure>\n<p>其实，从<code>rewrite</code>后的objc代码可以发现，对于消息的发送，恰恰就是会被处理成类似上面的代码，使用字符串mapping出<code>Class</code>，<code>selctor</code>等再使用<code>objc_msgSend()</code>进行函数调用，如下面所示：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 经过clang -rewrite-objc 命令重写后的代码</span></span><br><span class=\"line\">Sark *sark = ((<span class=\"keyword\">id</span> (*)(<span class=\"keyword\">id</span>, SEL))(<span class=\"keyword\">void</span> *)objc_msgSend)((<span class=\"keyword\">id</span>)objc_getClass(<span class=\"string\">\"Sark\"</span>), sel_registerName(<span class=\"string\">\"new\"</span>));</span><br><span class=\"line\">((<span class=\"keyword\">void</span> (*)(<span class=\"keyword\">id</span>, SEL))(<span class=\"keyword\">void</span> *)objc_msgSend)((<span class=\"keyword\">id</span>)sark, sel_registerName(<span class=\"string\">\"speak\"</span>));</span><br></pre></td></tr></table></figure>\n<h1 id=\"对比-interface和-implementation\"><a href=\"#对比-interface和-implementation\" class=\"headerlink\" title=\"对比@interface和@implementation\"></a>对比@interface和@implementation</h1><p><code>@interface</code> 我们干过的事：</p>\n<ol>\n<li>继承</li>\n<li>声明协议</li>\n<li>定义实例变量（@interface后面加大括号那种）</li>\n<li>定义@property</li>\n<li>声明方法</li>\n</ol>\n<p><code>@implementation</code> 我们干过的和可以干的事：  </p>\n<ol>\n<li>继承</li>\n<li>定义实例变量</li>\n<li>合成属性（@synthesize和@dynamic）</li>\n<li>实现方法（包括协议方法）</li>\n</ol>\n<p>在<code>@implementation</code>干一些事情用的相对较少，但是是完全合法的，如这样用：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *_name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过对比可以发现，<strong>@interface对objc类结构的合成并无决定性作用</strong>，加上<strong>无决定性</strong>是因为如果没有<code>@interface</code>会丢失一些类自省的原始数据，如属性列表和协议列表，但对于纯粹的对象消息发送并无影响。<br>所以说，可以得出这么一个结论，<strong>objc中@interface就是为了给调用者看的，是和调用者的一个protocol</strong>，没错，就是<strong>protocol</strong>。</p>\n<h1 id=\"对比-interface和-protocol\"><a href=\"#对比-interface和-protocol\" class=\"headerlink\" title=\"对比@interface和@protocol\"></a>对比@interface和@protocol</h1><p>与其把<code>@implementation</code>扯进来不如对比下<code>@protocol</code>  </p>\n<p>我理解objc的<code>@interface</code>和<code>@protocal</code>间唯一的区别就是<strong>是否和一个类型绑定</strong>，这让我想起来<code>鸭子类型</code>(Duck typing), <a href=\"http://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B\" target=\"_blank\" rel=\"external\">wiki链接</a></p>\n<blockquote>\n<p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p>\n</blockquote>\n<p>Duck type在objc的体现无疑就是<code>@protocol</code>了，我们常用<code>id&lt;XXXDelegate&gt; delegate</code>的方式声明一个delegate，我们无需care这货到底是什么类型，我们只知道他能干什么就可以work了。同样的功能我也可以使用<code>XXXDelegate *delegate</code>的方式来定义，只不过这样的话这个类又需要耦合一个<code>XXXDelegate</code>类型，而这个delegate类是它原本并不需要关心的。  </p>\n<p>所以说，<strong><code>@interface</code>是<code>@protocol</code>的强类型升级版。</strong>  </p>\n<p>举个<code>NSObject</code>的栗子最合适：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span> &lt;<span class=\"title\">NSObject</span>&gt; </span>&#123;</span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>NSObject之所以成为NSObject，绝大多数都是<code>&lt;NSObject&gt;</code>协议定义的方法，实体类@interface定义的唯一一个变量<code>isa</code>指针，为了继承链和消息传递。<br>除了<code>&lt;NSObject&gt;</code>协议外，NSObject还有很多Category来补充它的功能，其实仔细想想，Category更像protocol，一个<code>补充协议</code>，同样不能添加实例变量，但是和<code>@interface</code>一样需要与Class绑定。  </p>\n<p>进一步来讲，自从属性能自动合成变量之后，在头文件<code>@interface</code>中写大括号声明实例变量的情况越来越少（可以参见近几个版本iOS SDK中类头文件里这种写法几乎消失），因此，<code>@interface</code>和<code>@protocol</code>的差别进一步缩小。  </p>\n<hr>\n<h1 id=\"类与接口的设计原则-电视和遥控器\"><a href=\"#类与接口的设计原则-电视和遥控器\" class=\"headerlink\" title=\"类与接口的设计原则 - 电视和遥控器\"></a>类与接口的设计原则 - 电视和遥控器</h1><p>我喜欢将<code>Class</code>和<code>interface</code>的关系比喻成<code>电视+遥控器</code>，那么objc中的消息机制就可以理解成：<br><strong>用户（caller）通过遥控器（interface）上的按钮（methods）发送红外线（message）来操纵电视（object）</strong><br>所以，有没有遥控器，电视都在那儿，也就是说，有没有interface，class都是存在的，只是这种存在并没有意义，就好像这个电视没人会打开，没人会用，没人能看，一堆废铁摆在那儿。  </p>\n<p><img src=\"http://ww4.sinaimg.cn/large/51530583tw1efdy7cw48wj20c108qjru.jpg\" alt=\"\"></p>\n<p>对比简洁的遥控器，一个拥有很多按钮的老式电视遥控器，我们经常会用到的按钮能有几个呢？<br><img src=\"http://ww4.sinaimg.cn/large/51530583tw1efe08u9hb7j208c0b4jrp.jpg\" alt=\"\"></p>\n<p>所以，在设计一个类的interface的时候，如同在设计遥控器应该有怎样功能的按钮，要从调用者的角度出发，区分边界，应该时刻有以下几点考虑：</p>\n<ol>\n<li>这个方法或属性真的属于这个类的职责么？（电视遥控器能遥控空调？）</li>\n<li>这个方法或属性真的必须放在<code>.h</code>中（而不是放在<code>.m</code>的类扩展中）么？</li>\n<li>调用者必须看文档才能知道这个类该如何使用么？（同一个业务需要调用者按顺序调用多次（而不是将这些细节隐藏，同时提供一个简洁的接口）才行）</li>\n<li>调用者是否可以很容易发现类内部的变量和实现方式？（脑补下电视里面一块电路板漏在外面半截- -）</li>\n<li>…  </li>\n</ol>\n<hr>\n<h1 id=\"objc的-interface设计技巧Tips\"><a href=\"#objc的-interface设计技巧Tips\" class=\"headerlink\" title=\"objc的@interface设计技巧Tips\"></a>objc的@interface设计技巧Tips</h1><p>看过不少代码，从@interface设计上多少就能看出作者的水平，分享下我对于这个问题的一些拙见。</p>\n<h2 id=\"只暴露外部需要看到的\"><a href=\"#只暴露外部需要看到的\" class=\"headerlink\" title=\"只暴露外部需要看到的\"></a>只暴露外部需要看到的</h2><p>比如，有如下一个类（这个类无意义，主要关注写法）：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Sark.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">SarkViewController</span> : <span class=\"title\">NSObject</span> &lt;<span class=\"title\">NSXMLParserDelegate</span> /*1*/, <span class=\"title\">NSCopying</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *_name; <span class=\"comment\">// 2</span></span><br><span class=\"line\">    <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UITextField</span> *_nameTextField; <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSXMLParser</span> *parser; <span class=\"comment\">// 3</span></span><br><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)nameChangedAction:(<span class=\"keyword\">id</span>)sender; <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>这个interface出现的问题：</p>\n<ol>\n<li>类内部自己使用的协议，如<code>&lt;NSXMLParserDelegate&gt;</code>不应该在头文件@interface中声明，而应该在类扩展中声明；公开由外部调用的协议，如<code>&lt;NSCopying&gt;</code>则写在这儿是正确的。  </li>\n<li><code>实例变量</code>和<code>IBOutlet</code>不应出现在这儿定义，这将类的内部实现暴露了出去，自从属性可以自动合成后，这里就更应该清净了。</li>\n<li>内部使用的属性对象不要暴露在外，应该移动到类扩展中。</li>\n<li>调用者对IBAction同样不需要关心，那么就不应该放在这儿。  </li>\n</ol>\n<h2 id=\"合理分组子功能\"><a href=\"#合理分组子功能\" class=\"headerlink\" title=\"合理分组子功能\"></a>合理分组子功能</h2><ul>\n<li>将相同功能的一组属性或方法写在一起  </li>\n</ul>\n<p>使用这个类或者对其进行修改时，一般都是从功能上找，所以把同一功能模块的一组属性或方法写在一块</p>\n<ul>\n<li>纯操作方法的子功能（无需向类添加变量）使用<code>Category</code>分块  </li>\n<li>在头文件中也可以使用<code>类扩展</code>将interface按功能分区</li>\n</ul>\n<p><code>Category</code>里不能添加实例变量，但是类扩展可以，一般都在<code>.m</code>中作为私有interface使用，同样在头文件里作为分区使用，如，ReactiveCocoa中的<a href=\"https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/ReactiveCocoaFramework/ReactiveCocoa/RACStream.h\" target=\"_blank\" rel=\"external\">RACStream.h</a>  </p>\n<h2 id=\"避免头文件污染\"><a href=\"#避免头文件污染\" class=\"headerlink\" title=\"避免头文件污染\"></a>避免头文件污染</h2><p>首先，类实现内部.m文件中使用的其他interface应该在.m文件import，如果也写在header中就会造成对调用者的污染；当interface中出现其他<code>Class</code>或<code>protocol</code>时，可以使用前置声明<code>@class XXX</code>, <code>@protocol XXX</code>；当模块（一组类）内部间需要有一些定义（如常量、类型）而又不需要模块使用者知道时，使用一个内部头文件在模块中使用。</p>\n<h2 id=\"避免接口过度设计\"><a href=\"#避免接口过度设计\" class=\"headerlink\" title=\"避免接口过度设计\"></a>避免接口过度设计</h2><p>考虑调用者的使用方便是很必要的，过火了反而增加了复杂度：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">- (instancetype)init;</span><br><span class=\"line\">- (instancetype)initWithName:(<span class=\"built_in\">NSString</span> *)name;</span><br><span class=\"line\">- (instancetype)initWithName:(<span class=\"built_in\">NSString</span> *)name sex:(<span class=\"built_in\">NSString</span> *)sex;</span><br><span class=\"line\">- (instancetype)initWithName:(<span class=\"built_in\">NSString</span> *)name sex:(<span class=\"built_in\">NSString</span> *)sex age:(<span class=\"built_in\">NSInteger</span>)age;</span><br><span class=\"line\">- (instancetype)initWithName:(<span class=\"built_in\">NSString</span> *)name sex:(<span class=\"built_in\">NSString</span> *)sex age:(<span class=\"built_in\">NSInteger</span>)age friends:(<span class=\"built_in\">NSArray</span> *)friends;</span><br><span class=\"line\"><span class=\"comment\">// 无数多个 //</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>提供了一组这样的方法，调用者可能只能用到其中的一个，那这样倒不如只留一个接口。  </p>\n<h2 id=\"避免单例的滥用\"><a href=\"#避免单例的滥用\" class=\"headerlink\" title=\"避免单例的滥用\"></a>避免单例的滥用</h2><p>单例模式固然好用，但感觉有点过度，将接口设计成单例入口前需要考虑一下：  </p>\n<ol>\n<li>这个类表达的含义真的只能有一个实例么？（如UIApplication）还是只是为了好调用而已？</li>\n<li>这个单例持有的内存一直存在</li>\n<li>是否能用类方法代替？  </li>\n<li>这个单例对象是否能成为另一个单例对象的属性？如果是，应该作为属性  </li>\n</ol>\n<h2 id=\"隐藏继承关系中的私有接口\"><a href=\"#隐藏继承关系中的私有接口\" class=\"headerlink\" title=\"隐藏继承关系中的私有接口\"></a>隐藏继承关系中的私有接口</h2><p>感谢<code>@像条狗在飞</code>在留言中提出的问题，问题大概可以总结为：当子类需要使用父类的一个私有属性（方法）时，需要把这个属性（方法）放到父类的header中，但暴露给子类的同时暴露给了外部调用者，如何解决?   </p>\n<p>我的方案是：建立一个<code>私有header</code>，使用<code>类扩展</code>定义父类需要暴露给子类的属性（方法），然后在各自的<code>.m</code>文件中引用，如：  </p>\n<p>有Father类和Son类，继承关系，可以考虑建一个如<code>FatherPrivate.h</code>的私有header：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// FatherPrivate.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Father</span> ()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *privateThingSonNeed;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)privateMethodNeedsSonOverride;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>同时在Father.m和Son.m中同时import这个私有header，这样，Father和Son内部对于定义的属性和方法都是透明的，而对外部是隐藏的（因为两个类的header中都没有import这个私有header）  </p>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li><code>@implementation</code>合成了Class，而非<code>@interface</code>，<code>@interface</code>是<code>@protocol</code>的强类型升级版，它们和<code>Category</code>都表示了相近的含义</li>\n<li>我们应该善于面向接口编程，划清边界，将类的实现隐藏在调用者所见之外，使主调和被调者之间保持<code>最少知识原则</code></li>\n<li><code>@interface</code>本身就是最好的文档  </li>\n</ul>\n<hr>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"http://en.m.wikipedia.org/wiki/Interface_(object-oriented_programming\" target=\"_blank\" rel=\"external\">http://en.m.wikipedia.org/wiki/Interface_(object-oriented_programming</a>)<br><a href=\"http://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B\" target=\"_blank\" rel=\"external\">http://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B</a>   </p>\n<hr>\n<p>原创文章，转载请注明源地址，<a href=\"http://blog.sunnyxx.com\">blog.sunnyxx.com</a></p>\n","excerpt":"","more":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>学习objc时，尤其是先学过其他编程语言再来看objc时，总会对objc的<strong>类</strong>声明的关键字<code>interface</code>感到有点奇怪，在其它面向对象的语言中通常由<code>class</code>关键字来表示，而<code>interface</code>在java中表示的却大约相当于objc的<code>protocol</code>，这个关键字的区别究竟代表了objc语言的设计者怎样的思想呢，在objc类设计中需要注意哪些问题呢？接下来对这个问题进行一些思考和探究.   </p>\n<hr>\n<h1 id=\"interface\"><a href=\"#interface\" class=\"headerlink\" title=\"interface?\"></a>interface?</h1><p>先来段Wiki:  </p>\n<blockquote>\n<p>In object-oriented programming, a protocol or interface is a common means for unrelated objects to communicate with each other. These are definitions of methods and values which the objects agree upon in order to cooperate.</p>\n</blockquote>\n<p>接口约定了对象间交互的属性和方法，使得对象间无需了解对方就可以协作。<br>说的洋气点就是<code>解耦</code>嘛，细心点也能发现Wiki中<code>interface</code>和<code>protocol</code>表示了相近的语义。<br>引用我和项目组架构师讨论有关interface的问题时他的说法:</p>\n<blockquote>\n<p>interface就是一个object定义的可以被外界影响的方式</p>\n</blockquote>\n<p>说着他指了下旁边桌子上放着的一把伞，说，这把伞我可以打开它，打开这个动作就是它的一个interface，桌子旁边还放着一个盒子，虽然它和伞都放在这张桌子上，但是它们之间永远不会互相影响，所以：  </p>\n<blockquote>\n<p>interface只存在于能互相影响的两者间  </p>\n</blockquote>\n<hr>\n<h1 id=\"interface生成了class？\"><a href=\"#interface生成了class？\" class=\"headerlink\" title=\"@interface生成了class？\"></a>@interface生成了class？</h1><p>学习objc时最早接触的就是怎么写一个类了，从<code>.h</code>中写<code>@interface</code>声明类，再从<code>.m</code>中写<code>@implementation</code>实现方法，所以，objc中写一个<code>@interface</code>就相当于c++中写一个<code>class</code>。但这是真的么？  </p>\n<p>写个小test验证一下：<br>有两个类，<code>Sark</code>和<code>Dark</code>，<code>Sark</code>类只有<code>.m</code>文件，其中只写<code>@implementation</code>；<code>Dark</code>类只有<code>.h</code>头文件，其中只写<code>@interface</code>，然后如下测试代码：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class sarkClass = <span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"Sark\"</span>);</span><br><span class=\"line\">Class darkClass = <span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"Dark\"</span>);</span><br></pre></td></tr></table></figure>\n<p><code>NSClassFromString</code>方法调用了runtime方法，根据类名将加载进runtime的这个类找出来，没有这个类就回返回空(Nil)。<br>结果是<code>sarkClass</code>存在，而<code>darkClass</code>为空，说明什么？是否说明其实<code>@implementation</code>才是真正的Class？<br>进一步，不止能取到这个没有@interface的类，还可以正常调用方法（因为万能的runtime）  </p>\n<p>如下面的测试代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sark *sark = [Sark new];</span><br><span class=\"line\">[sark speak];</span><br></pre></td></tr></table></figure>\n<p>要是没有<code>@interface</code>的声明，类名，方法名都会报错说找不到，但是可以像下面一样绕一下：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class cls = <span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"Sark\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">id</span> obj = [cls performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"new\"</span>)];</span><br><span class=\"line\">[obj performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"speak\"</span>)];</span><br></pre></td></tr></table></figure>\n<p>其实，从<code>rewrite</code>后的objc代码可以发现，对于消息的发送，恰恰就是会被处理成类似上面的代码，使用字符串mapping出<code>Class</code>，<code>selctor</code>等再使用<code>objc_msgSend()</code>进行函数调用，如下面所示：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 经过clang -rewrite-objc 命令重写后的代码</span></span><br><span class=\"line\">Sark *sark = ((<span class=\"keyword\">id</span> (*)(<span class=\"keyword\">id</span>, SEL))(<span class=\"keyword\">void</span> *)objc_msgSend)((<span class=\"keyword\">id</span>)objc_getClass(<span class=\"string\">\"Sark\"</span>), sel_registerName(<span class=\"string\">\"new\"</span>));</span><br><span class=\"line\">((<span class=\"keyword\">void</span> (*)(<span class=\"keyword\">id</span>, SEL))(<span class=\"keyword\">void</span> *)objc_msgSend)((<span class=\"keyword\">id</span>)sark, sel_registerName(<span class=\"string\">\"speak\"</span>));</span><br></pre></td></tr></table></figure>\n<h1 id=\"对比-interface和-implementation\"><a href=\"#对比-interface和-implementation\" class=\"headerlink\" title=\"对比@interface和@implementation\"></a>对比@interface和@implementation</h1><p><code>@interface</code> 我们干过的事：</p>\n<ol>\n<li>继承</li>\n<li>声明协议</li>\n<li>定义实例变量（@interface后面加大括号那种）</li>\n<li>定义@property</li>\n<li>声明方法</li>\n</ol>\n<p><code>@implementation</code> 我们干过的和可以干的事：  </p>\n<ol>\n<li>继承</li>\n<li>定义实例变量</li>\n<li>合成属性（@synthesize和@dynamic）</li>\n<li>实现方法（包括协议方法）</li>\n</ol>\n<p>在<code>@implementation</code>干一些事情用的相对较少，但是是完全合法的，如这样用：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *_name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过对比可以发现，<strong>@interface对objc类结构的合成并无决定性作用</strong>，加上<strong>无决定性</strong>是因为如果没有<code>@interface</code>会丢失一些类自省的原始数据，如属性列表和协议列表，但对于纯粹的对象消息发送并无影响。<br>所以说，可以得出这么一个结论，<strong>objc中@interface就是为了给调用者看的，是和调用者的一个protocol</strong>，没错，就是<strong>protocol</strong>。</p>\n<h1 id=\"对比-interface和-protocol\"><a href=\"#对比-interface和-protocol\" class=\"headerlink\" title=\"对比@interface和@protocol\"></a>对比@interface和@protocol</h1><p>与其把<code>@implementation</code>扯进来不如对比下<code>@protocol</code>  </p>\n<p>我理解objc的<code>@interface</code>和<code>@protocal</code>间唯一的区别就是<strong>是否和一个类型绑定</strong>，这让我想起来<code>鸭子类型</code>(Duck typing), <a href=\"http://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B\">wiki链接</a></p>\n<blockquote>\n<p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p>\n</blockquote>\n<p>Duck type在objc的体现无疑就是<code>@protocol</code>了，我们常用<code>id&lt;XXXDelegate&gt; delegate</code>的方式声明一个delegate，我们无需care这货到底是什么类型，我们只知道他能干什么就可以work了。同样的功能我也可以使用<code>XXXDelegate *delegate</code>的方式来定义，只不过这样的话这个类又需要耦合一个<code>XXXDelegate</code>类型，而这个delegate类是它原本并不需要关心的。  </p>\n<p>所以说，<strong><code>@interface</code>是<code>@protocol</code>的强类型升级版。</strong>  </p>\n<p>举个<code>NSObject</code>的栗子最合适：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span> &lt;<span class=\"title\">NSObject</span>&gt; </span>&#123;</span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>NSObject之所以成为NSObject，绝大多数都是<code>&lt;NSObject&gt;</code>协议定义的方法，实体类@interface定义的唯一一个变量<code>isa</code>指针，为了继承链和消息传递。<br>除了<code>&lt;NSObject&gt;</code>协议外，NSObject还有很多Category来补充它的功能，其实仔细想想，Category更像protocol，一个<code>补充协议</code>，同样不能添加实例变量，但是和<code>@interface</code>一样需要与Class绑定。  </p>\n<p>进一步来讲，自从属性能自动合成变量之后，在头文件<code>@interface</code>中写大括号声明实例变量的情况越来越少（可以参见近几个版本iOS SDK中类头文件里这种写法几乎消失），因此，<code>@interface</code>和<code>@protocol</code>的差别进一步缩小。  </p>\n<hr>\n<h1 id=\"类与接口的设计原则-电视和遥控器\"><a href=\"#类与接口的设计原则-电视和遥控器\" class=\"headerlink\" title=\"类与接口的设计原则 - 电视和遥控器\"></a>类与接口的设计原则 - 电视和遥控器</h1><p>我喜欢将<code>Class</code>和<code>interface</code>的关系比喻成<code>电视+遥控器</code>，那么objc中的消息机制就可以理解成：<br><strong>用户（caller）通过遥控器（interface）上的按钮（methods）发送红外线（message）来操纵电视（object）</strong><br>所以，有没有遥控器，电视都在那儿，也就是说，有没有interface，class都是存在的，只是这种存在并没有意义，就好像这个电视没人会打开，没人会用，没人能看，一堆废铁摆在那儿。  </p>\n<p><img src=\"http://ww4.sinaimg.cn/large/51530583tw1efdy7cw48wj20c108qjru.jpg\" alt=\"\"></p>\n<p>对比简洁的遥控器，一个拥有很多按钮的老式电视遥控器，我们经常会用到的按钮能有几个呢？<br><img src=\"http://ww4.sinaimg.cn/large/51530583tw1efe08u9hb7j208c0b4jrp.jpg\" alt=\"\"></p>\n<p>所以，在设计一个类的interface的时候，如同在设计遥控器应该有怎样功能的按钮，要从调用者的角度出发，区分边界，应该时刻有以下几点考虑：</p>\n<ol>\n<li>这个方法或属性真的属于这个类的职责么？（电视遥控器能遥控空调？）</li>\n<li>这个方法或属性真的必须放在<code>.h</code>中（而不是放在<code>.m</code>的类扩展中）么？</li>\n<li>调用者必须看文档才能知道这个类该如何使用么？（同一个业务需要调用者按顺序调用多次（而不是将这些细节隐藏，同时提供一个简洁的接口）才行）</li>\n<li>调用者是否可以很容易发现类内部的变量和实现方式？（脑补下电视里面一块电路板漏在外面半截- -）</li>\n<li>…  </li>\n</ol>\n<hr>\n<h1 id=\"objc的-interface设计技巧Tips\"><a href=\"#objc的-interface设计技巧Tips\" class=\"headerlink\" title=\"objc的@interface设计技巧Tips\"></a>objc的@interface设计技巧Tips</h1><p>看过不少代码，从@interface设计上多少就能看出作者的水平，分享下我对于这个问题的一些拙见。</p>\n<h2 id=\"只暴露外部需要看到的\"><a href=\"#只暴露外部需要看到的\" class=\"headerlink\" title=\"只暴露外部需要看到的\"></a>只暴露外部需要看到的</h2><p>比如，有如下一个类（这个类无意义，主要关注写法）：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Sark.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">SarkViewController</span> : <span class=\"title\">NSObject</span> &lt;<span class=\"title\">NSXMLParserDelegate</span> /*1*/, <span class=\"title\">NSCopying</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *_name; <span class=\"comment\">// 2</span></span><br><span class=\"line\">    <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UITextField</span> *_nameTextField; <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSXMLParser</span> *parser; <span class=\"comment\">// 3</span></span><br><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)nameChangedAction:(<span class=\"keyword\">id</span>)sender; <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>这个interface出现的问题：</p>\n<ol>\n<li>类内部自己使用的协议，如<code>&lt;NSXMLParserDelegate&gt;</code>不应该在头文件@interface中声明，而应该在类扩展中声明；公开由外部调用的协议，如<code>&lt;NSCopying&gt;</code>则写在这儿是正确的。  </li>\n<li><code>实例变量</code>和<code>IBOutlet</code>不应出现在这儿定义，这将类的内部实现暴露了出去，自从属性可以自动合成后，这里就更应该清净了。</li>\n<li>内部使用的属性对象不要暴露在外，应该移动到类扩展中。</li>\n<li>调用者对IBAction同样不需要关心，那么就不应该放在这儿。  </li>\n</ol>\n<h2 id=\"合理分组子功能\"><a href=\"#合理分组子功能\" class=\"headerlink\" title=\"合理分组子功能\"></a>合理分组子功能</h2><ul>\n<li>将相同功能的一组属性或方法写在一起  </li>\n</ul>\n<p>使用这个类或者对其进行修改时，一般都是从功能上找，所以把同一功能模块的一组属性或方法写在一块</p>\n<ul>\n<li>纯操作方法的子功能（无需向类添加变量）使用<code>Category</code>分块  </li>\n<li>在头文件中也可以使用<code>类扩展</code>将interface按功能分区</li>\n</ul>\n<p><code>Category</code>里不能添加实例变量，但是类扩展可以，一般都在<code>.m</code>中作为私有interface使用，同样在头文件里作为分区使用，如，ReactiveCocoa中的<a href=\"https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/ReactiveCocoaFramework/ReactiveCocoa/RACStream.h\">RACStream.h</a>  </p>\n<h2 id=\"避免头文件污染\"><a href=\"#避免头文件污染\" class=\"headerlink\" title=\"避免头文件污染\"></a>避免头文件污染</h2><p>首先，类实现内部.m文件中使用的其他interface应该在.m文件import，如果也写在header中就会造成对调用者的污染；当interface中出现其他<code>Class</code>或<code>protocol</code>时，可以使用前置声明<code>@class XXX</code>, <code>@protocol XXX</code>；当模块（一组类）内部间需要有一些定义（如常量、类型）而又不需要模块使用者知道时，使用一个内部头文件在模块中使用。</p>\n<h2 id=\"避免接口过度设计\"><a href=\"#避免接口过度设计\" class=\"headerlink\" title=\"避免接口过度设计\"></a>避免接口过度设计</h2><p>考虑调用者的使用方便是很必要的，过火了反而增加了复杂度：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">- (instancetype)init;</span><br><span class=\"line\">- (instancetype)initWithName:(<span class=\"built_in\">NSString</span> *)name;</span><br><span class=\"line\">- (instancetype)initWithName:(<span class=\"built_in\">NSString</span> *)name sex:(<span class=\"built_in\">NSString</span> *)sex;</span><br><span class=\"line\">- (instancetype)initWithName:(<span class=\"built_in\">NSString</span> *)name sex:(<span class=\"built_in\">NSString</span> *)sex age:(<span class=\"built_in\">NSInteger</span>)age;</span><br><span class=\"line\">- (instancetype)initWithName:(<span class=\"built_in\">NSString</span> *)name sex:(<span class=\"built_in\">NSString</span> *)sex age:(<span class=\"built_in\">NSInteger</span>)age friends:(<span class=\"built_in\">NSArray</span> *)friends;</span><br><span class=\"line\"><span class=\"comment\">// 无数多个 //</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>提供了一组这样的方法，调用者可能只能用到其中的一个，那这样倒不如只留一个接口。  </p>\n<h2 id=\"避免单例的滥用\"><a href=\"#避免单例的滥用\" class=\"headerlink\" title=\"避免单例的滥用\"></a>避免单例的滥用</h2><p>单例模式固然好用，但感觉有点过度，将接口设计成单例入口前需要考虑一下：  </p>\n<ol>\n<li>这个类表达的含义真的只能有一个实例么？（如UIApplication）还是只是为了好调用而已？</li>\n<li>这个单例持有的内存一直存在</li>\n<li>是否能用类方法代替？  </li>\n<li>这个单例对象是否能成为另一个单例对象的属性？如果是，应该作为属性  </li>\n</ol>\n<h2 id=\"隐藏继承关系中的私有接口\"><a href=\"#隐藏继承关系中的私有接口\" class=\"headerlink\" title=\"隐藏继承关系中的私有接口\"></a>隐藏继承关系中的私有接口</h2><p>感谢<code>@像条狗在飞</code>在留言中提出的问题，问题大概可以总结为：当子类需要使用父类的一个私有属性（方法）时，需要把这个属性（方法）放到父类的header中，但暴露给子类的同时暴露给了外部调用者，如何解决?   </p>\n<p>我的方案是：建立一个<code>私有header</code>，使用<code>类扩展</code>定义父类需要暴露给子类的属性（方法），然后在各自的<code>.m</code>文件中引用，如：  </p>\n<p>有Father类和Son类，继承关系，可以考虑建一个如<code>FatherPrivate.h</code>的私有header：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// FatherPrivate.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Father</span> ()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *privateThingSonNeed;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)privateMethodNeedsSonOverride;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>同时在Father.m和Son.m中同时import这个私有header，这样，Father和Son内部对于定义的属性和方法都是透明的，而对外部是隐藏的（因为两个类的header中都没有import这个私有header）  </p>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li><code>@implementation</code>合成了Class，而非<code>@interface</code>，<code>@interface</code>是<code>@protocol</code>的强类型升级版，它们和<code>Category</code>都表示了相近的含义</li>\n<li>我们应该善于面向接口编程，划清边界，将类的实现隐藏在调用者所见之外，使主调和被调者之间保持<code>最少知识原则</code></li>\n<li><code>@interface</code>本身就是最好的文档  </li>\n</ul>\n<hr>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"http://en.m.wikipedia.org/wiki/Interface_(object-oriented_programming\">http://en.m.wikipedia.org/wiki/Interface_(object-oriented_programming</a>)<br><a href=\"http://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B\">http://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B</a>   </p>\n<hr>\n<p>原创文章，转载请注明源地址，<a href=\"http://blog.sunnyxx.com\">blog.sunnyxx.com</a></p>\n"},{"title":"NSLog效率低下的原因及尝试lldb断点打印Log","date":"2014-04-22T11:47:41.000Z","_content":"\n# 我是前言\n打Log是我们debug时最简单朴素的方法，`NSLog`对于objc开发就像`printf`对于c一样重要。但在使用`NSLog`打印大量Log，尤其是在游戏开发时（如每一帧都打印数据），`NSLog`会明显的拖慢程序的运行速度（游戏帧速严重下滑）。本文探究了一下`NSLog`如此之慢的原因，并尝试使用lldb断点调试器替代NSLog进行debug log。\n\n-----\n\n# 小测试\n\n测试下分别使用`NSLog`和`printf`打印10000次耗费的时间。`CFAbsoluteTimeGetCurrent()`函数可以打印出当前的时间戳，精度还是很高的，于是乎测试代码如下：\n\n``` objc\nCFAbsoluteTime startNSLog = CFAbsoluteTimeGetCurrent();\nfor (int i = 0; i < 10000; i++) {\n    NSLog(@\"%d\", i);\n}\nCFAbsoluteTime endNSLog = CFAbsoluteTimeGetCurrent();\n\nCFAbsoluteTime startPrintf = CFAbsoluteTimeGetCurrent();\nfor (int i = 0; i < 10000; i++) {\n    printf(\"%d\\n\", i);\n}\nCFAbsoluteTime endPrintf = CFAbsoluteTimeGetCurrent();\n\nNSLog(@\"NSLog time: %lf, printf time: %lf\", endNSLog - startNSLog, endPrintf - startPrintf);\n```\n\n这个时间和机器肯定有关系，只看它们的差别就好。为了全面性，尝试了三种平台：\n\n``` objc\nNSLog time: 4.985445, printf time: 0.084193 // mac\nNSLog time: 5.562460, printf time: 0.019408 // 模拟器\nNSLog time: 10.471490, printf time: 0.090503 // 真机调试(iphone5)\n```\n\n可以发现，在mac上（模拟器其实也算是mac吧）速度差别达到了60倍左右，而真机调试甚至达到了离谱的100多倍。  \n\n-----   \n\n# 探究原因\n基本上这种事情一定可以在Apple文档中找到，看`NSLog`的文档，第一句话就说：`Logs an error message to the Apple System Log facility.`，所以首先，`NSLog`就不是设计作为普通的debug log的，而是error log；其次，`NSLog`也并非是`printf`的简单封装，而是`Apple System Log`(后面简称ASL)的封装。   \n## ASL\nASL是个啥？从[官方手册](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/asl.3.html)上，或者从终端执行`man 3 asl`都可以看到说明：   \n\n>These routines provide an interface to the Apple System Log facility.  They are intended to be a\n     replacement for the syslog(3) API, which will continue to be supported for backwards compatibility.   \n\n\n大概就是个系统级别的log工具吧，syslog的替代版，提供了一系列强大的log功能。不过一般我们接触不到，NSLog就对它提供了高层次的封装，如[这篇文档](https://developer.apple.com/library/mac/documentation/macosx/conceptual/bpsystemstartup/Chapters/LoggingErrorsAndWarnings.html#//apple_ref/doc/uid/10000172i-SW8-SW1)所提到的：  \n\n>You can use two interfaces in OS X to log messages: ASL and Syslog. You can also use a number of higher-level approaches such as NSLog. However, because most daemons are not linked against Foundation or the Application Kit, the low-level APIs are often more appropriate   \n\n一些底层相关的守护进程(deamons)不会link如Foundation等高层框架，所以asl用在这儿正合适；而对于应用层的用NSLog。   \n\n在`CocoaLumberjack`的[文档](https://github.com/CocoaLumberjack/CocoaLumberjack/wiki/Performance)中也说了NSLog效率低下的问题：\n\n> NSLog does 2 things:  \n> - It writes log messages to the Apple System Logging (asl) facility. This allows log messages to show up in Console.app.   \n> - It also checks to see if the application's stderr stream is going to a terminal (such as when the application is being run via Xcode). If so it writes the log message to stderr (so that it shows up in the Xcode console).\n\n> To send a log message to the ASL facility, you basically open a client connection to the ASL daemon and send the message. BUT - each thread must use a separate client connection. So, to be thread safe, every time NSLog is called it opens a new asl client connection, sends the message, and then closes the connection.   \n\n意识大概是说，NSLog会向ASL写log，同时向Terminal写log，而且同时会出现在`Console.app`中（Mac自带软件，用NSLog打出的log在其中全部可见）；不仅如此，每一次NSLog都会新建一个ASL client并向ASL守护进程发起连接，log之后再关闭连接。所以说，当这个过程出现N次时，消耗大量资源导致程序变慢也就不奇怪了。  \n\n## 时间和进程信息\n主要原因已经找到，还有个值得注意的问题是`NSLog`每次会将当前的系统时间，进程和线程信息等作为前缀也打印出来，如：  \n\n```\n2012-34-56 12:34:56.789 XXXXXXXX[36818:303] xxxxxx\n```\n当然这些也可能是作为ASL的参数创建的，但不论如何，一定是有消耗的（虽然这个prefix十有八九不是我们需要的看到的）   \n\n------\n\n\n# 如何是好\n\nNSLog有这样的消耗问题，那该怎么办呢？\n\n1. 拒绝残留的Log。现在项目都是多人共同开发，我们应该只把Log作为错误日志或者重要信息的日志使用，commit前请把自己调试的log去掉（尤其是在循环里写log的小伙伴，简直不能一起快乐的玩耍了）\n2. release版本中消除Log。debug归debug，再慢也不能波及到release版本，用预编译宏过滤下就好。\n3. 是时候换个Log系统了，如`CocoaLumberjack`，自建一个简单的当然也挺好（其实为了项目需要自己也写了个小log系统，实现可以按名字和级别显示log和一些扩展功能，以后有机会分享下）\n\n不过个人认为debug时最好还是用调试器进行调试（尤其是只需要知道某个变量值的时候）\n\n-----\n\n\n# 尝试使用断点+lldb调试器打Log\n\n关于强大的`lldb`调试器用一个专题来讲都是应该，现在只了解一些皮毛，不过就算皮毛的功能也可以替代NSLog这种方法进行调试了，重要的一点是:**使用断点log不需要重新编译工程**，况且和Xcode已经结合的很好，在此先只说打Log这件事。   \n\n\n## 简单断点+po(p)\n断点时可以在xcode的lldb调试区使用`po`或`p`命令打印对象或变量，对于当前栈帧中引用到的变量都是可见的，所以说假如只是看一眼某个对象运行到这儿是不是存在，是什么值的话，设个断点就够了，况且IDE已经把这个功能集成，鼠标放变量上就可以了。  \n\nlldb一些常用调试技巧可以这篇[入门教程](http://www.cimgf.com/2012/12/13/xcode-lldb-tutorial/)   \n\n## Condition和Action断点\n断点不止能把程序断住，触发时也按一定条件，而且可以执行（一个或多个）Action，在断点上右键选择`Edit Breakpoint`，弹出的断点设置中可以添加一些Action：    \n![](http://ww2.sinaimg.cn/large/51530583tw1efobdj4pb3j205002wt8n.jpg)   \n其中专门有一项就是`Log Message`，做个小测试：   \n\n``` objc\nfor (int i = 0; i < 10; i++) {\n    // break point here\n}\n```\n\n设置断点后编辑断点：   \n\n![](http://ww2.sinaimg.cn/large/51530583tw1efobktq0vsj20d806r74z.jpg)\n\n输入框下面就有支持的格式，表达式(或变量)可以使用`@exp@`这种格式包起来。于是乎输出：    \n\n``` objc\nbreak at: 'main()',  count: 4, sunnyxx says : 3\nbreak at: 'main()',  count: 5, sunnyxx says : 4\nbreak at: 'main()',  count: 6, sunnyxx says : 5\n```\n\n正如所料。  \n更多的调试技巧还需要深入研究，不过可以肯定的是，比起单纯的使用`NSLog`，使用好的工具可以让我们debug的效率更高\n\n-----\n\n# 总结\n- `NSLog`耗费比较大的资源\n- `NSLog`被设计为error log，是ASL的高层封装\n- 在项目中避免提交commit自己的Debug log，release版本更要注意去除`NSLog`，可以使用自建的log系统或好用的log系统来替代`NSLog`      \n- debug不应只局限于log满天飞，`lldb`断点调试是一个优秀的debug方法，需要再深入研究下\n\n-----\n\n# References  \nhttps://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/asl.3.html\nhttp://theonlylars.com/blog/2012/07/03/ditching-nslog-advanced-ios-logging-part-1/   \nhttps://github.com/CocoaLumberjack/CocoaLumberjack/wiki/Performance   \nhttps://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/LoggingErrorsAndWarnings.html#//apple_ref/doc/uid/10000172i-SW8-SW1   \nhttp://www.cimgf.com/2012/12/13/xcode-lldb-tutorial/\n\n-----\n\n原创文章，转载请注明源地址，[blog.sunnyxx.com](http://blog.sunnyxx.com)\n","source":"_posts/objc_dig_nslog.md","raw":"title: NSLog效率低下的原因及尝试lldb断点打印Log\ndate: 2014-04-22 19:47:41\ntags: objc刨根问底\n---\n\n# 我是前言\n打Log是我们debug时最简单朴素的方法，`NSLog`对于objc开发就像`printf`对于c一样重要。但在使用`NSLog`打印大量Log，尤其是在游戏开发时（如每一帧都打印数据），`NSLog`会明显的拖慢程序的运行速度（游戏帧速严重下滑）。本文探究了一下`NSLog`如此之慢的原因，并尝试使用lldb断点调试器替代NSLog进行debug log。\n\n-----\n\n# 小测试\n\n测试下分别使用`NSLog`和`printf`打印10000次耗费的时间。`CFAbsoluteTimeGetCurrent()`函数可以打印出当前的时间戳，精度还是很高的，于是乎测试代码如下：\n\n``` objc\nCFAbsoluteTime startNSLog = CFAbsoluteTimeGetCurrent();\nfor (int i = 0; i < 10000; i++) {\n    NSLog(@\"%d\", i);\n}\nCFAbsoluteTime endNSLog = CFAbsoluteTimeGetCurrent();\n\nCFAbsoluteTime startPrintf = CFAbsoluteTimeGetCurrent();\nfor (int i = 0; i < 10000; i++) {\n    printf(\"%d\\n\", i);\n}\nCFAbsoluteTime endPrintf = CFAbsoluteTimeGetCurrent();\n\nNSLog(@\"NSLog time: %lf, printf time: %lf\", endNSLog - startNSLog, endPrintf - startPrintf);\n```\n\n这个时间和机器肯定有关系，只看它们的差别就好。为了全面性，尝试了三种平台：\n\n``` objc\nNSLog time: 4.985445, printf time: 0.084193 // mac\nNSLog time: 5.562460, printf time: 0.019408 // 模拟器\nNSLog time: 10.471490, printf time: 0.090503 // 真机调试(iphone5)\n```\n\n可以发现，在mac上（模拟器其实也算是mac吧）速度差别达到了60倍左右，而真机调试甚至达到了离谱的100多倍。  \n\n-----   \n\n# 探究原因\n基本上这种事情一定可以在Apple文档中找到，看`NSLog`的文档，第一句话就说：`Logs an error message to the Apple System Log facility.`，所以首先，`NSLog`就不是设计作为普通的debug log的，而是error log；其次，`NSLog`也并非是`printf`的简单封装，而是`Apple System Log`(后面简称ASL)的封装。   \n## ASL\nASL是个啥？从[官方手册](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/asl.3.html)上，或者从终端执行`man 3 asl`都可以看到说明：   \n\n>These routines provide an interface to the Apple System Log facility.  They are intended to be a\n     replacement for the syslog(3) API, which will continue to be supported for backwards compatibility.   \n\n\n大概就是个系统级别的log工具吧，syslog的替代版，提供了一系列强大的log功能。不过一般我们接触不到，NSLog就对它提供了高层次的封装，如[这篇文档](https://developer.apple.com/library/mac/documentation/macosx/conceptual/bpsystemstartup/Chapters/LoggingErrorsAndWarnings.html#//apple_ref/doc/uid/10000172i-SW8-SW1)所提到的：  \n\n>You can use two interfaces in OS X to log messages: ASL and Syslog. You can also use a number of higher-level approaches such as NSLog. However, because most daemons are not linked against Foundation or the Application Kit, the low-level APIs are often more appropriate   \n\n一些底层相关的守护进程(deamons)不会link如Foundation等高层框架，所以asl用在这儿正合适；而对于应用层的用NSLog。   \n\n在`CocoaLumberjack`的[文档](https://github.com/CocoaLumberjack/CocoaLumberjack/wiki/Performance)中也说了NSLog效率低下的问题：\n\n> NSLog does 2 things:  \n> - It writes log messages to the Apple System Logging (asl) facility. This allows log messages to show up in Console.app.   \n> - It also checks to see if the application's stderr stream is going to a terminal (such as when the application is being run via Xcode). If so it writes the log message to stderr (so that it shows up in the Xcode console).\n\n> To send a log message to the ASL facility, you basically open a client connection to the ASL daemon and send the message. BUT - each thread must use a separate client connection. So, to be thread safe, every time NSLog is called it opens a new asl client connection, sends the message, and then closes the connection.   \n\n意识大概是说，NSLog会向ASL写log，同时向Terminal写log，而且同时会出现在`Console.app`中（Mac自带软件，用NSLog打出的log在其中全部可见）；不仅如此，每一次NSLog都会新建一个ASL client并向ASL守护进程发起连接，log之后再关闭连接。所以说，当这个过程出现N次时，消耗大量资源导致程序变慢也就不奇怪了。  \n\n## 时间和进程信息\n主要原因已经找到，还有个值得注意的问题是`NSLog`每次会将当前的系统时间，进程和线程信息等作为前缀也打印出来，如：  \n\n```\n2012-34-56 12:34:56.789 XXXXXXXX[36818:303] xxxxxx\n```\n当然这些也可能是作为ASL的参数创建的，但不论如何，一定是有消耗的（虽然这个prefix十有八九不是我们需要的看到的）   \n\n------\n\n\n# 如何是好\n\nNSLog有这样的消耗问题，那该怎么办呢？\n\n1. 拒绝残留的Log。现在项目都是多人共同开发，我们应该只把Log作为错误日志或者重要信息的日志使用，commit前请把自己调试的log去掉（尤其是在循环里写log的小伙伴，简直不能一起快乐的玩耍了）\n2. release版本中消除Log。debug归debug，再慢也不能波及到release版本，用预编译宏过滤下就好。\n3. 是时候换个Log系统了，如`CocoaLumberjack`，自建一个简单的当然也挺好（其实为了项目需要自己也写了个小log系统，实现可以按名字和级别显示log和一些扩展功能，以后有机会分享下）\n\n不过个人认为debug时最好还是用调试器进行调试（尤其是只需要知道某个变量值的时候）\n\n-----\n\n\n# 尝试使用断点+lldb调试器打Log\n\n关于强大的`lldb`调试器用一个专题来讲都是应该，现在只了解一些皮毛，不过就算皮毛的功能也可以替代NSLog这种方法进行调试了，重要的一点是:**使用断点log不需要重新编译工程**，况且和Xcode已经结合的很好，在此先只说打Log这件事。   \n\n\n## 简单断点+po(p)\n断点时可以在xcode的lldb调试区使用`po`或`p`命令打印对象或变量，对于当前栈帧中引用到的变量都是可见的，所以说假如只是看一眼某个对象运行到这儿是不是存在，是什么值的话，设个断点就够了，况且IDE已经把这个功能集成，鼠标放变量上就可以了。  \n\nlldb一些常用调试技巧可以这篇[入门教程](http://www.cimgf.com/2012/12/13/xcode-lldb-tutorial/)   \n\n## Condition和Action断点\n断点不止能把程序断住，触发时也按一定条件，而且可以执行（一个或多个）Action，在断点上右键选择`Edit Breakpoint`，弹出的断点设置中可以添加一些Action：    \n![](http://ww2.sinaimg.cn/large/51530583tw1efobdj4pb3j205002wt8n.jpg)   \n其中专门有一项就是`Log Message`，做个小测试：   \n\n``` objc\nfor (int i = 0; i < 10; i++) {\n    // break point here\n}\n```\n\n设置断点后编辑断点：   \n\n![](http://ww2.sinaimg.cn/large/51530583tw1efobktq0vsj20d806r74z.jpg)\n\n输入框下面就有支持的格式，表达式(或变量)可以使用`@exp@`这种格式包起来。于是乎输出：    \n\n``` objc\nbreak at: 'main()',  count: 4, sunnyxx says : 3\nbreak at: 'main()',  count: 5, sunnyxx says : 4\nbreak at: 'main()',  count: 6, sunnyxx says : 5\n```\n\n正如所料。  \n更多的调试技巧还需要深入研究，不过可以肯定的是，比起单纯的使用`NSLog`，使用好的工具可以让我们debug的效率更高\n\n-----\n\n# 总结\n- `NSLog`耗费比较大的资源\n- `NSLog`被设计为error log，是ASL的高层封装\n- 在项目中避免提交commit自己的Debug log，release版本更要注意去除`NSLog`，可以使用自建的log系统或好用的log系统来替代`NSLog`      \n- debug不应只局限于log满天飞，`lldb`断点调试是一个优秀的debug方法，需要再深入研究下\n\n-----\n\n# References  \nhttps://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/asl.3.html\nhttp://theonlylars.com/blog/2012/07/03/ditching-nslog-advanced-ios-logging-part-1/   \nhttps://github.com/CocoaLumberjack/CocoaLumberjack/wiki/Performance   \nhttps://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/LoggingErrorsAndWarnings.html#//apple_ref/doc/uid/10000172i-SW8-SW1   \nhttp://www.cimgf.com/2012/12/13/xcode-lldb-tutorial/\n\n-----\n\n原创文章，转载请注明源地址，[blog.sunnyxx.com](http://blog.sunnyxx.com)\n","slug":"objc_dig_nslog","published":1,"updated":"2016-03-27T08:21:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxm8001uev12wp973vdu","content":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>打Log是我们debug时最简单朴素的方法，<code>NSLog</code>对于objc开发就像<code>printf</code>对于c一样重要。但在使用<code>NSLog</code>打印大量Log，尤其是在游戏开发时（如每一帧都打印数据），<code>NSLog</code>会明显的拖慢程序的运行速度（游戏帧速严重下滑）。本文探究了一下<code>NSLog</code>如此之慢的原因，并尝试使用lldb断点调试器替代NSLog进行debug log。</p>\n<hr>\n<h1 id=\"小测试\"><a href=\"#小测试\" class=\"headerlink\" title=\"小测试\"></a>小测试</h1><p>测试下分别使用<code>NSLog</code>和<code>printf</code>打印10000次耗费的时间。<code>CFAbsoluteTimeGetCurrent()</code>函数可以打印出当前的时间戳，精度还是很高的，于是乎测试代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFAbsoluteTime</span> start<span class=\"built_in\">NSLog</span> = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>, i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">CFAbsoluteTime</span> end<span class=\"built_in\">NSLog</span> = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFAbsoluteTime</span> startPrintf = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">    printf(<span class=\"string\">\"%d\\n\"</span>, i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">CFAbsoluteTime</span> endPrintf = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"NSLog time: %lf, printf time: %lf\"</span>, end<span class=\"built_in\">NSLog</span> - start<span class=\"built_in\">NSLog</span>, endPrintf - startPrintf);</span><br></pre></td></tr></table></figure>\n<p>这个时间和机器肯定有关系，只看它们的差别就好。为了全面性，尝试了三种平台：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSLog</span> time: <span class=\"number\">4.985445</span>, printf time: <span class=\"number\">0.084193</span> <span class=\"comment\">// mac</span></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span> time: <span class=\"number\">5.562460</span>, printf time: <span class=\"number\">0.019408</span> <span class=\"comment\">// 模拟器</span></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span> time: <span class=\"number\">10.471490</span>, printf time: <span class=\"number\">0.090503</span> <span class=\"comment\">// 真机调试(iphone5)</span></span><br></pre></td></tr></table></figure>\n<p>可以发现，在mac上（模拟器其实也算是mac吧）速度差别达到了60倍左右，而真机调试甚至达到了离谱的100多倍。  </p>\n<hr>\n<h1 id=\"探究原因\"><a href=\"#探究原因\" class=\"headerlink\" title=\"探究原因\"></a>探究原因</h1><p>基本上这种事情一定可以在Apple文档中找到，看<code>NSLog</code>的文档，第一句话就说：<code>Logs an error message to the Apple System Log facility.</code>，所以首先，<code>NSLog</code>就不是设计作为普通的debug log的，而是error log；其次，<code>NSLog</code>也并非是<code>printf</code>的简单封装，而是<code>Apple System Log</code>(后面简称ASL)的封装。   </p>\n<h2 id=\"ASL\"><a href=\"#ASL\" class=\"headerlink\" title=\"ASL\"></a>ASL</h2><p>ASL是个啥？从<a href=\"https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/asl.3.html\" target=\"_blank\" rel=\"external\">官方手册</a>上，或者从终端执行<code>man 3 asl</code>都可以看到说明：   </p>\n<blockquote>\n<p>These routines provide an interface to the Apple System Log facility.  They are intended to be a<br>     replacement for the syslog(3) API, which will continue to be supported for backwards compatibility.   </p>\n</blockquote>\n<p>大概就是个系统级别的log工具吧，syslog的替代版，提供了一系列强大的log功能。不过一般我们接触不到，NSLog就对它提供了高层次的封装，如<a href=\"https://developer.apple.com/library/mac/documentation/macosx/conceptual/bpsystemstartup/Chapters/LoggingErrorsAndWarnings.html#//apple_ref/doc/uid/10000172i-SW8-SW1\" target=\"_blank\" rel=\"external\">这篇文档</a>所提到的：  </p>\n<blockquote>\n<p>You can use two interfaces in OS X to log messages: ASL and Syslog. You can also use a number of higher-level approaches such as NSLog. However, because most daemons are not linked against Foundation or the Application Kit, the low-level APIs are often more appropriate   </p>\n</blockquote>\n<p>一些底层相关的守护进程(deamons)不会link如Foundation等高层框架，所以asl用在这儿正合适；而对于应用层的用NSLog。   </p>\n<p>在<code>CocoaLumberjack</code>的<a href=\"https://github.com/CocoaLumberjack/CocoaLumberjack/wiki/Performance\" target=\"_blank\" rel=\"external\">文档</a>中也说了NSLog效率低下的问题：</p>\n<blockquote>\n<p>NSLog does 2 things:  </p>\n<ul>\n<li>It writes log messages to the Apple System Logging (asl) facility. This allows log messages to show up in Console.app.   </li>\n<li>It also checks to see if the application’s stderr stream is going to a terminal (such as when the application is being run via Xcode). If so it writes the log message to stderr (so that it shows up in the Xcode console).</li>\n</ul>\n<p>To send a log message to the ASL facility, you basically open a client connection to the ASL daemon and send the message. BUT - each thread must use a separate client connection. So, to be thread safe, every time NSLog is called it opens a new asl client connection, sends the message, and then closes the connection.   </p>\n</blockquote>\n<p>意识大概是说，NSLog会向ASL写log，同时向Terminal写log，而且同时会出现在<code>Console.app</code>中（Mac自带软件，用NSLog打出的log在其中全部可见）；不仅如此，每一次NSLog都会新建一个ASL client并向ASL守护进程发起连接，log之后再关闭连接。所以说，当这个过程出现N次时，消耗大量资源导致程序变慢也就不奇怪了。  </p>\n<h2 id=\"时间和进程信息\"><a href=\"#时间和进程信息\" class=\"headerlink\" title=\"时间和进程信息\"></a>时间和进程信息</h2><p>主要原因已经找到，还有个值得注意的问题是<code>NSLog</code>每次会将当前的系统时间，进程和线程信息等作为前缀也打印出来，如：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2012-34-56 12:34:56.789 XXXXXXXX[36818:303] xxxxxx</span><br></pre></td></tr></table></figure>\n<p>当然这些也可能是作为ASL的参数创建的，但不论如何，一定是有消耗的（虽然这个prefix十有八九不是我们需要的看到的）   </p>\n<hr>\n<h1 id=\"如何是好\"><a href=\"#如何是好\" class=\"headerlink\" title=\"如何是好\"></a>如何是好</h1><p>NSLog有这样的消耗问题，那该怎么办呢？</p>\n<ol>\n<li>拒绝残留的Log。现在项目都是多人共同开发，我们应该只把Log作为错误日志或者重要信息的日志使用，commit前请把自己调试的log去掉（尤其是在循环里写log的小伙伴，简直不能一起快乐的玩耍了）</li>\n<li>release版本中消除Log。debug归debug，再慢也不能波及到release版本，用预编译宏过滤下就好。</li>\n<li>是时候换个Log系统了，如<code>CocoaLumberjack</code>，自建一个简单的当然也挺好（其实为了项目需要自己也写了个小log系统，实现可以按名字和级别显示log和一些扩展功能，以后有机会分享下）</li>\n</ol>\n<p>不过个人认为debug时最好还是用调试器进行调试（尤其是只需要知道某个变量值的时候）</p>\n<hr>\n<h1 id=\"尝试使用断点-lldb调试器打Log\"><a href=\"#尝试使用断点-lldb调试器打Log\" class=\"headerlink\" title=\"尝试使用断点+lldb调试器打Log\"></a>尝试使用断点+lldb调试器打Log</h1><p>关于强大的<code>lldb</code>调试器用一个专题来讲都是应该，现在只了解一些皮毛，不过就算皮毛的功能也可以替代NSLog这种方法进行调试了，重要的一点是:<strong>使用断点log不需要重新编译工程</strong>，况且和Xcode已经结合的很好，在此先只说打Log这件事。   </p>\n<h2 id=\"简单断点-po-p\"><a href=\"#简单断点-po-p\" class=\"headerlink\" title=\"简单断点+po(p)\"></a>简单断点+po(p)</h2><p>断点时可以在xcode的lldb调试区使用<code>po</code>或<code>p</code>命令打印对象或变量，对于当前栈帧中引用到的变量都是可见的，所以说假如只是看一眼某个对象运行到这儿是不是存在，是什么值的话，设个断点就够了，况且IDE已经把这个功能集成，鼠标放变量上就可以了。  </p>\n<p>lldb一些常用调试技巧可以这篇<a href=\"http://www.cimgf.com/2012/12/13/xcode-lldb-tutorial/\" target=\"_blank\" rel=\"external\">入门教程</a>   </p>\n<h2 id=\"Condition和Action断点\"><a href=\"#Condition和Action断点\" class=\"headerlink\" title=\"Condition和Action断点\"></a>Condition和Action断点</h2><p>断点不止能把程序断住，触发时也按一定条件，而且可以执行（一个或多个）Action，在断点上右键选择<code>Edit Breakpoint</code>，弹出的断点设置中可以添加一些Action：<br><img src=\"http://ww2.sinaimg.cn/large/51530583tw1efobdj4pb3j205002wt8n.jpg\" alt=\"\"><br>其中专门有一项就是<code>Log Message</code>，做个小测试：   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// break point here</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>设置断点后编辑断点：   </p>\n<p><img src=\"http://ww2.sinaimg.cn/large/51530583tw1efobktq0vsj20d806r74z.jpg\" alt=\"\"></p>\n<p>输入框下面就有支持的格式，表达式(或变量)可以使用<code>@exp@</code>这种格式包起来。于是乎输出：    </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">break at: 'main()',  count: 4, sunnyxx says : 3</span><br><span class=\"line\">break at: 'main()',  count: 5, sunnyxx says : 4</span><br><span class=\"line\">break at: 'main()',  count: 6, sunnyxx says : 5</span><br></pre></td></tr></table></figure>\n<p>正如所料。<br>更多的调试技巧还需要深入研究，不过可以肯定的是，比起单纯的使用<code>NSLog</code>，使用好的工具可以让我们debug的效率更高</p>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li><code>NSLog</code>耗费比较大的资源</li>\n<li><code>NSLog</code>被设计为error log，是ASL的高层封装</li>\n<li>在项目中避免提交commit自己的Debug log，release版本更要注意去除<code>NSLog</code>，可以使用自建的log系统或好用的log系统来替代<code>NSLog</code>      </li>\n<li>debug不应只局限于log满天飞，<code>lldb</code>断点调试是一个优秀的debug方法，需要再深入研究下</li>\n</ul>\n<hr>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/asl.3.html\" target=\"_blank\" rel=\"external\">https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/asl.3.html</a><br><a href=\"http://theonlylars.com/blog/2012/07/03/ditching-nslog-advanced-ios-logging-part-1/\" target=\"_blank\" rel=\"external\">http://theonlylars.com/blog/2012/07/03/ditching-nslog-advanced-ios-logging-part-1/</a><br><a href=\"https://github.com/CocoaLumberjack/CocoaLumberjack/wiki/Performance\" target=\"_blank\" rel=\"external\">https://github.com/CocoaLumberjack/CocoaLumberjack/wiki/Performance</a><br><a href=\"https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/LoggingErrorsAndWarnings.html#//apple_ref/doc/uid/10000172i-SW8-SW1\" target=\"_blank\" rel=\"external\">https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/LoggingErrorsAndWarnings.html#//apple_ref/doc/uid/10000172i-SW8-SW1</a><br><a href=\"http://www.cimgf.com/2012/12/13/xcode-lldb-tutorial/\" target=\"_blank\" rel=\"external\">http://www.cimgf.com/2012/12/13/xcode-lldb-tutorial/</a></p>\n<hr>\n<p>原创文章，转载请注明源地址，<a href=\"http://blog.sunnyxx.com\">blog.sunnyxx.com</a></p>\n","excerpt":"","more":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>打Log是我们debug时最简单朴素的方法，<code>NSLog</code>对于objc开发就像<code>printf</code>对于c一样重要。但在使用<code>NSLog</code>打印大量Log，尤其是在游戏开发时（如每一帧都打印数据），<code>NSLog</code>会明显的拖慢程序的运行速度（游戏帧速严重下滑）。本文探究了一下<code>NSLog</code>如此之慢的原因，并尝试使用lldb断点调试器替代NSLog进行debug log。</p>\n<hr>\n<h1 id=\"小测试\"><a href=\"#小测试\" class=\"headerlink\" title=\"小测试\"></a>小测试</h1><p>测试下分别使用<code>NSLog</code>和<code>printf</code>打印10000次耗费的时间。<code>CFAbsoluteTimeGetCurrent()</code>函数可以打印出当前的时间戳，精度还是很高的，于是乎测试代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFAbsoluteTime</span> start<span class=\"built_in\">NSLog</span> = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>, i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">CFAbsoluteTime</span> end<span class=\"built_in\">NSLog</span> = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFAbsoluteTime</span> startPrintf = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">    printf(<span class=\"string\">\"%d\\n\"</span>, i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">CFAbsoluteTime</span> endPrintf = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"NSLog time: %lf, printf time: %lf\"</span>, end<span class=\"built_in\">NSLog</span> - start<span class=\"built_in\">NSLog</span>, endPrintf - startPrintf);</span><br></pre></td></tr></table></figure>\n<p>这个时间和机器肯定有关系，只看它们的差别就好。为了全面性，尝试了三种平台：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSLog</span> time: <span class=\"number\">4.985445</span>, printf time: <span class=\"number\">0.084193</span> <span class=\"comment\">// mac</span></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span> time: <span class=\"number\">5.562460</span>, printf time: <span class=\"number\">0.019408</span> <span class=\"comment\">// 模拟器</span></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span> time: <span class=\"number\">10.471490</span>, printf time: <span class=\"number\">0.090503</span> <span class=\"comment\">// 真机调试(iphone5)</span></span><br></pre></td></tr></table></figure>\n<p>可以发现，在mac上（模拟器其实也算是mac吧）速度差别达到了60倍左右，而真机调试甚至达到了离谱的100多倍。  </p>\n<hr>\n<h1 id=\"探究原因\"><a href=\"#探究原因\" class=\"headerlink\" title=\"探究原因\"></a>探究原因</h1><p>基本上这种事情一定可以在Apple文档中找到，看<code>NSLog</code>的文档，第一句话就说：<code>Logs an error message to the Apple System Log facility.</code>，所以首先，<code>NSLog</code>就不是设计作为普通的debug log的，而是error log；其次，<code>NSLog</code>也并非是<code>printf</code>的简单封装，而是<code>Apple System Log</code>(后面简称ASL)的封装。   </p>\n<h2 id=\"ASL\"><a href=\"#ASL\" class=\"headerlink\" title=\"ASL\"></a>ASL</h2><p>ASL是个啥？从<a href=\"https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/asl.3.html\">官方手册</a>上，或者从终端执行<code>man 3 asl</code>都可以看到说明：   </p>\n<blockquote>\n<p>These routines provide an interface to the Apple System Log facility.  They are intended to be a<br>     replacement for the syslog(3) API, which will continue to be supported for backwards compatibility.   </p>\n</blockquote>\n<p>大概就是个系统级别的log工具吧，syslog的替代版，提供了一系列强大的log功能。不过一般我们接触不到，NSLog就对它提供了高层次的封装，如<a href=\"https://developer.apple.com/library/mac/documentation/macosx/conceptual/bpsystemstartup/Chapters/LoggingErrorsAndWarnings.html#//apple_ref/doc/uid/10000172i-SW8-SW1\">这篇文档</a>所提到的：  </p>\n<blockquote>\n<p>You can use two interfaces in OS X to log messages: ASL and Syslog. You can also use a number of higher-level approaches such as NSLog. However, because most daemons are not linked against Foundation or the Application Kit, the low-level APIs are often more appropriate   </p>\n</blockquote>\n<p>一些底层相关的守护进程(deamons)不会link如Foundation等高层框架，所以asl用在这儿正合适；而对于应用层的用NSLog。   </p>\n<p>在<code>CocoaLumberjack</code>的<a href=\"https://github.com/CocoaLumberjack/CocoaLumberjack/wiki/Performance\">文档</a>中也说了NSLog效率低下的问题：</p>\n<blockquote>\n<p>NSLog does 2 things:  </p>\n<ul>\n<li>It writes log messages to the Apple System Logging (asl) facility. This allows log messages to show up in Console.app.   </li>\n<li>It also checks to see if the application’s stderr stream is going to a terminal (such as when the application is being run via Xcode). If so it writes the log message to stderr (so that it shows up in the Xcode console).</li>\n</ul>\n<p>To send a log message to the ASL facility, you basically open a client connection to the ASL daemon and send the message. BUT - each thread must use a separate client connection. So, to be thread safe, every time NSLog is called it opens a new asl client connection, sends the message, and then closes the connection.   </p>\n</blockquote>\n<p>意识大概是说，NSLog会向ASL写log，同时向Terminal写log，而且同时会出现在<code>Console.app</code>中（Mac自带软件，用NSLog打出的log在其中全部可见）；不仅如此，每一次NSLog都会新建一个ASL client并向ASL守护进程发起连接，log之后再关闭连接。所以说，当这个过程出现N次时，消耗大量资源导致程序变慢也就不奇怪了。  </p>\n<h2 id=\"时间和进程信息\"><a href=\"#时间和进程信息\" class=\"headerlink\" title=\"时间和进程信息\"></a>时间和进程信息</h2><p>主要原因已经找到，还有个值得注意的问题是<code>NSLog</code>每次会将当前的系统时间，进程和线程信息等作为前缀也打印出来，如：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2012-34-56 12:34:56.789 XXXXXXXX[36818:303] xxxxxx</span><br></pre></td></tr></table></figure>\n<p>当然这些也可能是作为ASL的参数创建的，但不论如何，一定是有消耗的（虽然这个prefix十有八九不是我们需要的看到的）   </p>\n<hr>\n<h1 id=\"如何是好\"><a href=\"#如何是好\" class=\"headerlink\" title=\"如何是好\"></a>如何是好</h1><p>NSLog有这样的消耗问题，那该怎么办呢？</p>\n<ol>\n<li>拒绝残留的Log。现在项目都是多人共同开发，我们应该只把Log作为错误日志或者重要信息的日志使用，commit前请把自己调试的log去掉（尤其是在循环里写log的小伙伴，简直不能一起快乐的玩耍了）</li>\n<li>release版本中消除Log。debug归debug，再慢也不能波及到release版本，用预编译宏过滤下就好。</li>\n<li>是时候换个Log系统了，如<code>CocoaLumberjack</code>，自建一个简单的当然也挺好（其实为了项目需要自己也写了个小log系统，实现可以按名字和级别显示log和一些扩展功能，以后有机会分享下）</li>\n</ol>\n<p>不过个人认为debug时最好还是用调试器进行调试（尤其是只需要知道某个变量值的时候）</p>\n<hr>\n<h1 id=\"尝试使用断点-lldb调试器打Log\"><a href=\"#尝试使用断点-lldb调试器打Log\" class=\"headerlink\" title=\"尝试使用断点+lldb调试器打Log\"></a>尝试使用断点+lldb调试器打Log</h1><p>关于强大的<code>lldb</code>调试器用一个专题来讲都是应该，现在只了解一些皮毛，不过就算皮毛的功能也可以替代NSLog这种方法进行调试了，重要的一点是:<strong>使用断点log不需要重新编译工程</strong>，况且和Xcode已经结合的很好，在此先只说打Log这件事。   </p>\n<h2 id=\"简单断点-po-p\"><a href=\"#简单断点-po-p\" class=\"headerlink\" title=\"简单断点+po(p)\"></a>简单断点+po(p)</h2><p>断点时可以在xcode的lldb调试区使用<code>po</code>或<code>p</code>命令打印对象或变量，对于当前栈帧中引用到的变量都是可见的，所以说假如只是看一眼某个对象运行到这儿是不是存在，是什么值的话，设个断点就够了，况且IDE已经把这个功能集成，鼠标放变量上就可以了。  </p>\n<p>lldb一些常用调试技巧可以这篇<a href=\"http://www.cimgf.com/2012/12/13/xcode-lldb-tutorial/\">入门教程</a>   </p>\n<h2 id=\"Condition和Action断点\"><a href=\"#Condition和Action断点\" class=\"headerlink\" title=\"Condition和Action断点\"></a>Condition和Action断点</h2><p>断点不止能把程序断住，触发时也按一定条件，而且可以执行（一个或多个）Action，在断点上右键选择<code>Edit Breakpoint</code>，弹出的断点设置中可以添加一些Action：<br><img src=\"http://ww2.sinaimg.cn/large/51530583tw1efobdj4pb3j205002wt8n.jpg\" alt=\"\"><br>其中专门有一项就是<code>Log Message</code>，做个小测试：   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// break point here</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>设置断点后编辑断点：   </p>\n<p><img src=\"http://ww2.sinaimg.cn/large/51530583tw1efobktq0vsj20d806r74z.jpg\" alt=\"\"></p>\n<p>输入框下面就有支持的格式，表达式(或变量)可以使用<code>@exp@</code>这种格式包起来。于是乎输出：    </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">break at: 'main()',  count: 4, sunnyxx says : 3</span><br><span class=\"line\">break at: 'main()',  count: 5, sunnyxx says : 4</span><br><span class=\"line\">break at: 'main()',  count: 6, sunnyxx says : 5</span><br></pre></td></tr></table></figure>\n<p>正如所料。<br>更多的调试技巧还需要深入研究，不过可以肯定的是，比起单纯的使用<code>NSLog</code>，使用好的工具可以让我们debug的效率更高</p>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li><code>NSLog</code>耗费比较大的资源</li>\n<li><code>NSLog</code>被设计为error log，是ASL的高层封装</li>\n<li>在项目中避免提交commit自己的Debug log，release版本更要注意去除<code>NSLog</code>，可以使用自建的log系统或好用的log系统来替代<code>NSLog</code>      </li>\n<li>debug不应只局限于log满天飞，<code>lldb</code>断点调试是一个优秀的debug方法，需要再深入研究下</li>\n</ul>\n<hr>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/asl.3.html\">https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/asl.3.html</a><br><a href=\"http://theonlylars.com/blog/2012/07/03/ditching-nslog-advanced-ios-logging-part-1/\">http://theonlylars.com/blog/2012/07/03/ditching-nslog-advanced-ios-logging-part-1/</a><br><a href=\"https://github.com/CocoaLumberjack/CocoaLumberjack/wiki/Performance\">https://github.com/CocoaLumberjack/CocoaLumberjack/wiki/Performance</a><br><a href=\"https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/LoggingErrorsAndWarnings.html#//apple_ref/doc/uid/10000172i-SW8-SW1\">https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/LoggingErrorsAndWarnings.html#//apple_ref/doc/uid/10000172i-SW8-SW1</a><br><a href=\"http://www.cimgf.com/2012/12/13/xcode-lldb-tutorial/\">http://www.cimgf.com/2012/12/13/xcode-lldb-tutorial/</a></p>\n<hr>\n<p>原创文章，转载请注明源地址，<a href=\"http://blog.sunnyxx.com\">blog.sunnyxx.com</a></p>\n"},{"title":"objc kvo简单探索","date":"2014-03-09T01:47:04.000Z","_content":"KVO(Key Value Observing)，是`观察者模式`在`Foundation`中的实现\n\n## KVO的原理\n简而言之就是：\n 1. 当一个object有观察者时，动态创建这个object的类的子类\n 2. 对于每个被观察的property，重写其`set`方法\n 3. 在重写的`set`方法中调用`- willChangeValueForKey:`和`- didChangeValueForKey:`通知观察者\n 4. 当一个property没有观察者时，删除重写的方法\n 5. 当没有observer观察任何一个property时，删除动态创建的子类\n\n空说无凭，简单验证下。\n\n``` objc\n@interface Sark : NSObject\n@property (nonatomic, copy) NSString *name;\n@end\n@implementation Sark\n@end\n```\n测试代码：\n\n``` objc\nSark *sark = [Sark new];\n// breakpoint 1\n[sark addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew context:nil];\n// breakpoint 2\nsark.name = @\"萨萨萨\";\n[sark removeObserver:self forKeyPath:@\"name\"];\n// breakpoint 3\n```\n\n断住后分别使用`- class`和`object_getClass()`打出`sark`对象的Class和真实的Class   \n\n``` objc\n// breakpoint 1\n(lldb) po sark.class\nSark\n(lldb) po object_getClass(sark)\nSark\n\n// breakpoint 2\n(lldb) po sark.class\nSark\n(lldb) po object_getClass(sark)\nNSKVONotifying_Sark\n\n// breakpoint 3\n(lldb) po sark.class\nSark\n(lldb) po object_getClass(sark)\nSark\n```\n\n上面的结果说明，在sark对象被观察时，framework使用`runtime`动态创建了一个Sark类的子类`NSKVONotifying_Sark`  \n而且为了隐藏这个行为，NSKVONotifying_Sark重写了`- class`方法返回之前的类，就好像什么也没发生过一样  \n但是使用`object_getClass()`时就暴露了，因为这个方法返回的是这个对象的`isa`指针，**这个指针指向的一定是个这个对象的类对象**  \n\n-----\n\n然后来偷窥一下这个动态类实现的方法，这里请出一个NSObject的扩展`NSObject+DLIntrospection`，它封装了打印一个类的方法、属性、协议等常用调试方法，一目了然。  \n\n``` objc\n@interface NSObject (DLIntrospection)\n+ (NSArray *)classes;\n+ (NSArray *)properties;\n+ (NSArray *)instanceVariables;\n+ (NSArray *)classMethods;\n+ (NSArray *)instanceMethods;\n+ (NSArray *)protocols;\n+ (NSDictionary *)descriptionForProtocol:(Protocol *)proto;\n+ (NSString *)parentClassHierarchy;\n@end\n```\n\n然后继续在刚才的断点处调试：   \n\n``` objc\n// breakpoint 1\n(lldb) po [object_getClass(sark) instanceMethods]\n<__NSArrayI 0x8e9aa00>(\n- (void)setName:(id)arg0 ,\n- (void).cxx_destruct,\n- (id)name\n)\n// breakpoint 2\n(lldb) po [object_getClass(sark) instanceMethods]\n<__NSArrayI 0x8d55870>(\n- (void)setName:(id)arg0 ,\n- (class)class,\n- (void)dealloc,\n- (BOOL)_isKVOA\n)\n// breakpoint 3\n(lldb) po [object_getClass(sark) instanceMethods]\n<__NSArrayI 0x8e9cff0>(\n- (void)setName:(id)arg0 ,\n- (void).cxx_destruct,\n- (id)name\n)\n```\n\n首先就有个扎眼的`- .cxx_destruct`冒出来，这货是个啥？详细的探究请参考我的[另一篇文章](http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/)。\n\n大概就是说arc下这个方法在所有`dealloc`调用完成后负责释放所有的变量，当然这个和kvo没啥关系了，回到正题。  \n从上面breakpoint2的打印可以看出，动态类重写了4个方法：   \n\n1. `- setName:`最主要的重写方法，set值时调用通知函数\n2. `- class`隐藏自己必备啊，返回原来类的class\n3. `- dealloc`做清理犯罪现场工作\n4. `- _isKVOA`这就是内部使用的标示了，判断这个类有没被KVO动态生成子类\n\n-----\n\n接下来验证一下KVO重写set方法后是否调用了`- willChangeValueForKey:`和`- didChangeValueForKey:`  \n最直接的验证方法就是在Sark类中重写这两个方法：\n\n``` objc\n@implementation Sark\n\n- (void)willChangeValueForKey:(NSString *)key {\n    NSLog(@\"%@\", NSStringFromSelector(_cmd));\n    [super willChangeValueForKey:key];\n}\n\n- (void)didChangeValueForKey:(NSString *)key {\n    NSLog(@\"%@\", NSStringFromSelector(_cmd));\n    [super didChangeValueForKey:key];\n}\n\n@end\n```\n\n没问题。\n","source":"_posts/objc_kvo_secret.md","raw":"title: objc kvo简单探索\ndate: 2014-03-09 09:47:04\ntags: objc的秘密\n---\nKVO(Key Value Observing)，是`观察者模式`在`Foundation`中的实现\n\n## KVO的原理\n简而言之就是：\n 1. 当一个object有观察者时，动态创建这个object的类的子类\n 2. 对于每个被观察的property，重写其`set`方法\n 3. 在重写的`set`方法中调用`- willChangeValueForKey:`和`- didChangeValueForKey:`通知观察者\n 4. 当一个property没有观察者时，删除重写的方法\n 5. 当没有observer观察任何一个property时，删除动态创建的子类\n\n空说无凭，简单验证下。\n\n``` objc\n@interface Sark : NSObject\n@property (nonatomic, copy) NSString *name;\n@end\n@implementation Sark\n@end\n```\n测试代码：\n\n``` objc\nSark *sark = [Sark new];\n// breakpoint 1\n[sark addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew context:nil];\n// breakpoint 2\nsark.name = @\"萨萨萨\";\n[sark removeObserver:self forKeyPath:@\"name\"];\n// breakpoint 3\n```\n\n断住后分别使用`- class`和`object_getClass()`打出`sark`对象的Class和真实的Class   \n\n``` objc\n// breakpoint 1\n(lldb) po sark.class\nSark\n(lldb) po object_getClass(sark)\nSark\n\n// breakpoint 2\n(lldb) po sark.class\nSark\n(lldb) po object_getClass(sark)\nNSKVONotifying_Sark\n\n// breakpoint 3\n(lldb) po sark.class\nSark\n(lldb) po object_getClass(sark)\nSark\n```\n\n上面的结果说明，在sark对象被观察时，framework使用`runtime`动态创建了一个Sark类的子类`NSKVONotifying_Sark`  \n而且为了隐藏这个行为，NSKVONotifying_Sark重写了`- class`方法返回之前的类，就好像什么也没发生过一样  \n但是使用`object_getClass()`时就暴露了，因为这个方法返回的是这个对象的`isa`指针，**这个指针指向的一定是个这个对象的类对象**  \n\n-----\n\n然后来偷窥一下这个动态类实现的方法，这里请出一个NSObject的扩展`NSObject+DLIntrospection`，它封装了打印一个类的方法、属性、协议等常用调试方法，一目了然。  \n\n``` objc\n@interface NSObject (DLIntrospection)\n+ (NSArray *)classes;\n+ (NSArray *)properties;\n+ (NSArray *)instanceVariables;\n+ (NSArray *)classMethods;\n+ (NSArray *)instanceMethods;\n+ (NSArray *)protocols;\n+ (NSDictionary *)descriptionForProtocol:(Protocol *)proto;\n+ (NSString *)parentClassHierarchy;\n@end\n```\n\n然后继续在刚才的断点处调试：   \n\n``` objc\n// breakpoint 1\n(lldb) po [object_getClass(sark) instanceMethods]\n<__NSArrayI 0x8e9aa00>(\n- (void)setName:(id)arg0 ,\n- (void).cxx_destruct,\n- (id)name\n)\n// breakpoint 2\n(lldb) po [object_getClass(sark) instanceMethods]\n<__NSArrayI 0x8d55870>(\n- (void)setName:(id)arg0 ,\n- (class)class,\n- (void)dealloc,\n- (BOOL)_isKVOA\n)\n// breakpoint 3\n(lldb) po [object_getClass(sark) instanceMethods]\n<__NSArrayI 0x8e9cff0>(\n- (void)setName:(id)arg0 ,\n- (void).cxx_destruct,\n- (id)name\n)\n```\n\n首先就有个扎眼的`- .cxx_destruct`冒出来，这货是个啥？详细的探究请参考我的[另一篇文章](http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/)。\n\n大概就是说arc下这个方法在所有`dealloc`调用完成后负责释放所有的变量，当然这个和kvo没啥关系了，回到正题。  \n从上面breakpoint2的打印可以看出，动态类重写了4个方法：   \n\n1. `- setName:`最主要的重写方法，set值时调用通知函数\n2. `- class`隐藏自己必备啊，返回原来类的class\n3. `- dealloc`做清理犯罪现场工作\n4. `- _isKVOA`这就是内部使用的标示了，判断这个类有没被KVO动态生成子类\n\n-----\n\n接下来验证一下KVO重写set方法后是否调用了`- willChangeValueForKey:`和`- didChangeValueForKey:`  \n最直接的验证方法就是在Sark类中重写这两个方法：\n\n``` objc\n@implementation Sark\n\n- (void)willChangeValueForKey:(NSString *)key {\n    NSLog(@\"%@\", NSStringFromSelector(_cmd));\n    [super willChangeValueForKey:key];\n}\n\n- (void)didChangeValueForKey:(NSString *)key {\n    NSLog(@\"%@\", NSStringFromSelector(_cmd));\n    [super didChangeValueForKey:key];\n}\n\n@end\n```\n\n没问题。\n","slug":"objc_kvo_secret","published":1,"updated":"2016-03-27T08:37:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxmb001wev12pw892v7i","content":"<p>KVO(Key Value Observing)，是<code>观察者模式</code>在<code>Foundation</code>中的实现</p>\n<h2 id=\"KVO的原理\"><a href=\"#KVO的原理\" class=\"headerlink\" title=\"KVO的原理\"></a>KVO的原理</h2><p>简而言之就是：</p>\n<ol>\n<li>当一个object有观察者时，动态创建这个object的类的子类</li>\n<li>对于每个被观察的property，重写其<code>set</code>方法</li>\n<li>在重写的<code>set</code>方法中调用<code>- willChangeValueForKey:</code>和<code>- didChangeValueForKey:</code>通知观察者</li>\n<li>当一个property没有观察者时，删除重写的方法</li>\n<li>当没有observer观察任何一个property时，删除动态创建的子类</li>\n</ol>\n<p>空说无凭，简单验证下。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Sark</span></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>测试代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sark *sark = [Sark new];</span><br><span class=\"line\"><span class=\"comment\">// breakpoint 1</span></span><br><span class=\"line\">[sark addObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"name\"</span> options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span> context:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"><span class=\"comment\">// breakpoint 2</span></span><br><span class=\"line\">sark.name = <span class=\"string\">@\"萨萨萨\"</span>;</span><br><span class=\"line\">[sark removeObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"name\"</span>];</span><br><span class=\"line\"><span class=\"comment\">// breakpoint 3</span></span><br></pre></td></tr></table></figure>\n<p>断住后分别使用<code>- class</code>和<code>object_getClass()</code>打出<code>sark</code>对象的Class和真实的Class   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// breakpoint 1</span></span><br><span class=\"line\">(lldb) po sark.class</span><br><span class=\"line\">Sark</span><br><span class=\"line\">(lldb) po object_getClass(sark)</span><br><span class=\"line\">Sark</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// breakpoint 2</span></span><br><span class=\"line\">(lldb) po sark.class</span><br><span class=\"line\">Sark</span><br><span class=\"line\">(lldb) po object_getClass(sark)</span><br><span class=\"line\"><span class=\"built_in\">NSKVONotifying_Sark</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// breakpoint 3</span></span><br><span class=\"line\">(lldb) po sark.class</span><br><span class=\"line\">Sark</span><br><span class=\"line\">(lldb) po object_getClass(sark)</span><br><span class=\"line\">Sark</span><br></pre></td></tr></table></figure>\n<p>上面的结果说明，在sark对象被观察时，framework使用<code>runtime</code>动态创建了一个Sark类的子类<code>NSKVONotifying_Sark</code><br>而且为了隐藏这个行为，NSKVONotifying_Sark重写了<code>- class</code>方法返回之前的类，就好像什么也没发生过一样<br>但是使用<code>object_getClass()</code>时就暴露了，因为这个方法返回的是这个对象的<code>isa</code>指针，<strong>这个指针指向的一定是个这个对象的类对象</strong>  </p>\n<hr>\n<p>然后来偷窥一下这个动态类实现的方法，这里请出一个NSObject的扩展<code>NSObject+DLIntrospection</code>，它封装了打印一个类的方法、属性、协议等常用调试方法，一目了然。  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span> (<span class=\"title\">DLIntrospection</span>)</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSArray</span> *)classes;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSArray</span> *)properties;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSArray</span> *)instanceVariables;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSArray</span> *)classMethods;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSArray</span> *)instanceMethods;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSArray</span> *)protocols;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSDictionary</span> *)descriptionForProtocol:(Protocol *)proto;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSString</span> *)parentClassHierarchy;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>然后继续在刚才的断点处调试：   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// breakpoint 1</span></span><br><span class=\"line\">(lldb) po [object_getClass(sark) instanceMethods]</span><br><span class=\"line\">&lt;__<span class=\"built_in\">NSArrayI</span> <span class=\"number\">0x8e9aa00</span>&gt;(</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setName:(<span class=\"keyword\">id</span>)arg0 ,</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>).cxx_destruct,</span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)name</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// breakpoint 2</span></span><br><span class=\"line\">(lldb) po [object_getClass(sark) instanceMethods]</span><br><span class=\"line\">&lt;__<span class=\"built_in\">NSArrayI</span> <span class=\"number\">0x8d55870</span>&gt;(</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setName:(<span class=\"keyword\">id</span>)arg0 ,</span><br><span class=\"line\">- (class)class,</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc,</span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)_isKVOA</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// breakpoint 3</span></span><br><span class=\"line\">(lldb) po [object_getClass(sark) instanceMethods]</span><br><span class=\"line\">&lt;__<span class=\"built_in\">NSArrayI</span> <span class=\"number\">0x8e9cff0</span>&gt;(</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setName:(<span class=\"keyword\">id</span>)arg0 ,</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>).cxx_destruct,</span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)name</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>首先就有个扎眼的<code>- .cxx_destruct</code>冒出来，这货是个啥？详细的探究请参考我的<a href=\"http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/\">另一篇文章</a>。</p>\n<p>大概就是说arc下这个方法在所有<code>dealloc</code>调用完成后负责释放所有的变量，当然这个和kvo没啥关系了，回到正题。<br>从上面breakpoint2的打印可以看出，动态类重写了4个方法：   </p>\n<ol>\n<li><code>- setName:</code>最主要的重写方法，set值时调用通知函数</li>\n<li><code>- class</code>隐藏自己必备啊，返回原来类的class</li>\n<li><code>- dealloc</code>做清理犯罪现场工作</li>\n<li><code>- _isKVOA</code>这就是内部使用的标示了，判断这个类有没被KVO动态生成子类</li>\n</ol>\n<hr>\n<p>接下来验证一下KVO重写set方法后是否调用了<code>- willChangeValueForKey:</code>和<code>- didChangeValueForKey:</code><br>最直接的验证方法就是在Sark类中重写这两个方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Sark</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)willChangeValueForKey:(<span class=\"built_in\">NSString</span> *)key &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromSelector</span>(_cmd));</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> willChangeValueForKey:key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)didChangeValueForKey:(<span class=\"built_in\">NSString</span> *)key &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromSelector</span>(_cmd));</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> didChangeValueForKey:key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>没问题。</p>\n","excerpt":"","more":"<p>KVO(Key Value Observing)，是<code>观察者模式</code>在<code>Foundation</code>中的实现</p>\n<h2 id=\"KVO的原理\"><a href=\"#KVO的原理\" class=\"headerlink\" title=\"KVO的原理\"></a>KVO的原理</h2><p>简而言之就是：</p>\n<ol>\n<li>当一个object有观察者时，动态创建这个object的类的子类</li>\n<li>对于每个被观察的property，重写其<code>set</code>方法</li>\n<li>在重写的<code>set</code>方法中调用<code>- willChangeValueForKey:</code>和<code>- didChangeValueForKey:</code>通知观察者</li>\n<li>当一个property没有观察者时，删除重写的方法</li>\n<li>当没有observer观察任何一个property时，删除动态创建的子类</li>\n</ol>\n<p>空说无凭，简单验证下。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Sark</span></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>测试代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sark *sark = [Sark new];</span><br><span class=\"line\"><span class=\"comment\">// breakpoint 1</span></span><br><span class=\"line\">[sark addObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"name\"</span> options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span> context:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"><span class=\"comment\">// breakpoint 2</span></span><br><span class=\"line\">sark.name = <span class=\"string\">@\"萨萨萨\"</span>;</span><br><span class=\"line\">[sark removeObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"name\"</span>];</span><br><span class=\"line\"><span class=\"comment\">// breakpoint 3</span></span><br></pre></td></tr></table></figure>\n<p>断住后分别使用<code>- class</code>和<code>object_getClass()</code>打出<code>sark</code>对象的Class和真实的Class   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// breakpoint 1</span></span><br><span class=\"line\">(lldb) po sark.class</span><br><span class=\"line\">Sark</span><br><span class=\"line\">(lldb) po object_getClass(sark)</span><br><span class=\"line\">Sark</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// breakpoint 2</span></span><br><span class=\"line\">(lldb) po sark.class</span><br><span class=\"line\">Sark</span><br><span class=\"line\">(lldb) po object_getClass(sark)</span><br><span class=\"line\"><span class=\"built_in\">NSKVONotifying_Sark</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// breakpoint 3</span></span><br><span class=\"line\">(lldb) po sark.class</span><br><span class=\"line\">Sark</span><br><span class=\"line\">(lldb) po object_getClass(sark)</span><br><span class=\"line\">Sark</span><br></pre></td></tr></table></figure>\n<p>上面的结果说明，在sark对象被观察时，framework使用<code>runtime</code>动态创建了一个Sark类的子类<code>NSKVONotifying_Sark</code><br>而且为了隐藏这个行为，NSKVONotifying_Sark重写了<code>- class</code>方法返回之前的类，就好像什么也没发生过一样<br>但是使用<code>object_getClass()</code>时就暴露了，因为这个方法返回的是这个对象的<code>isa</code>指针，<strong>这个指针指向的一定是个这个对象的类对象</strong>  </p>\n<hr>\n<p>然后来偷窥一下这个动态类实现的方法，这里请出一个NSObject的扩展<code>NSObject+DLIntrospection</code>，它封装了打印一个类的方法、属性、协议等常用调试方法，一目了然。  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span> (<span class=\"title\">DLIntrospection</span>)</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSArray</span> *)classes;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSArray</span> *)properties;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSArray</span> *)instanceVariables;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSArray</span> *)classMethods;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSArray</span> *)instanceMethods;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSArray</span> *)protocols;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSDictionary</span> *)descriptionForProtocol:(Protocol *)proto;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSString</span> *)parentClassHierarchy;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>然后继续在刚才的断点处调试：   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// breakpoint 1</span></span><br><span class=\"line\">(lldb) po [object_getClass(sark) instanceMethods]</span><br><span class=\"line\">&lt;__<span class=\"built_in\">NSArrayI</span> <span class=\"number\">0x8e9aa00</span>&gt;(</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setName:(<span class=\"keyword\">id</span>)arg0 ,</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>).cxx_destruct,</span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)name</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// breakpoint 2</span></span><br><span class=\"line\">(lldb) po [object_getClass(sark) instanceMethods]</span><br><span class=\"line\">&lt;__<span class=\"built_in\">NSArrayI</span> <span class=\"number\">0x8d55870</span>&gt;(</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setName:(<span class=\"keyword\">id</span>)arg0 ,</span><br><span class=\"line\">- (class)class,</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc,</span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)_isKVOA</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// breakpoint 3</span></span><br><span class=\"line\">(lldb) po [object_getClass(sark) instanceMethods]</span><br><span class=\"line\">&lt;__<span class=\"built_in\">NSArrayI</span> <span class=\"number\">0x8e9cff0</span>&gt;(</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setName:(<span class=\"keyword\">id</span>)arg0 ,</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>).cxx_destruct,</span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)name</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>首先就有个扎眼的<code>- .cxx_destruct</code>冒出来，这货是个啥？详细的探究请参考我的<a href=\"http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/\">另一篇文章</a>。</p>\n<p>大概就是说arc下这个方法在所有<code>dealloc</code>调用完成后负责释放所有的变量，当然这个和kvo没啥关系了，回到正题。<br>从上面breakpoint2的打印可以看出，动态类重写了4个方法：   </p>\n<ol>\n<li><code>- setName:</code>最主要的重写方法，set值时调用通知函数</li>\n<li><code>- class</code>隐藏自己必备啊，返回原来类的class</li>\n<li><code>- dealloc</code>做清理犯罪现场工作</li>\n<li><code>- _isKVOA</code>这就是内部使用的标示了，判断这个类有没被KVO动态生成子类</li>\n</ol>\n<hr>\n<p>接下来验证一下KVO重写set方法后是否调用了<code>- willChangeValueForKey:</code>和<code>- didChangeValueForKey:</code><br>最直接的验证方法就是在Sark类中重写这两个方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Sark</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)willChangeValueForKey:(<span class=\"built_in\">NSString</span> *)key &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromSelector</span>(_cmd));</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> willChangeValueForKey:key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)didChangeValueForKey:(<span class=\"built_in\">NSString</span> *)key &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromSelector</span>(_cmd));</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> didChangeValueForKey:key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>没问题。</p>\n"},{"title":"Reactive Cocoa Tutorial [0] = Overview","date":"2014-03-06T13:58:30.000Z","_content":"关于这系列（如果真能写下去的话）：说是教程有点狂，边学边总结，更像个笔记吧，等完全用透之后再写就会忘了一开始学习过程中遇到的问题了，Reactive Cocoa（RAC）现在资料真心少，中文英文加起来没几篇，还都是转来转去的。这是个好东西，相信以后用的人会变多，转了请留该文原地址哦~  by sunny\n\n> PS:\n> 这篇文章原来发布在blogcn上，http://www.cnblogs.com/sunnyxx，\n> 现在建了自己的blog后会在这上面继续写了。\n\n------\n\n### 废话少说 --> **RAC**\n\n　　是什么？怎么来的？干啥用的？ 怎么用的？ 可以观摩无网不剩的blog RAC介绍1和2，在此不啰唆了，简而言之，就是一个函数响应式编程思想在Cocoa下的实现。\n\n### 说说在RAC框架下做了一个项目的赶脚吧：\n\n - 挺新鲜挺有意思，开发人员水平很高，框架封装性和实用性一流，看了看人家对宏的使用发现原来用的纯小儿科，对编译器的控制，block的使用也很值得的学习。\n - 编程思想上的一些改变。原创的一个可能也不大恰当的比喻：原来的编程思想像是“走迷宫”，RAC的编程思想是“建迷宫”。意思是，之前的编程思路是命令式，大概都是“程序启动时执行xxxx，在用户点击后的回调函数执行xxx，收到一个Notification后执行xxx”等等，如同走迷宫一样，走出迷宫需要在不同时间段记住不同状态根据不同情况而做出一系列反应，继而走出迷宫；相比下，RAC的思想是建立联系，像钟表中的齿轮组一样，一个扣着一个，从转动发条到指针走动，一个齿轮一个齿轮的传导（Reactive），复杂但完整而自然。如同迷宫的建造者，在设计时早已决定了哪里是通路，哪里是死路或是哪个路口指向了出口，当一个挑战者（Event）走入迷宫时（Signal），他一定会在设置好的迷宫中的某个路线行走（传递），继而走到终点（Completion）或困死在里面（Error）。\n - 写出代码结构明显不一样。由于RAC将Cocoa中KVO，UIKit Event，delegate，selector等都增加了RAC支持，所以都不用去做很多跨函数的事，比如KVO个对象然后在回调里面xxx，从storyboard里面连个UIButton的IBAction出来xxx，或是设个UITextField的delegate出来去取输入的文本xxx。但在RAC下就像上面比喻的建迷宫，把这些大都放在“-viewDidLoad:”就可以了，当然像UITableView的delegate和data source这么大规模的代理模式就还是老老实实写吧。\n简洁。举个栗子：\n\n\n我就想干这么个事:\n\n> 一个label一个text field，下面输啥上面显示啥\n\n　　老写法大概做法是这个vc实现UITextFieldDelegate协议，把这个text field的delegate设到vc上面，然后在要改变text的那个delegate方法里面取当前text field的text值，再赋给label上；\n\n使用RAC的话就一句话（当然得把这俩控件都IBOutlet出来）：\n\n```\nRAC(self.outputLabel, text) = self.inputTextField.rac_textSignal;\n```\n\n看着就挺爽。\n\n复杂的栗子先不举了。\n\n　　总之吧，等今后维护RAC的开发者和使用者把更多的Cocoa的东西归入RAC的框架中，这个框架基本上都可以凌驾于Cocoa这个框架了，意思是甚至用不着知道那些delegate啊KVO啊苹果告诉你是咋用的，用RAC封装的就行了。RAC对于值的显示大都是和property“绑定”的关系，像使用storyboard构建页面时，对于有响应的控件基本都得IBOutlet出来作为一个property，而不是像原来一样连个IBAction出来或者连个delegate出来。对于视图层到model层之间的绑定就显得有些生硬了，相当于视图直接耦合了model，于是应运而生M-V-VM结构，说白了就是在View和Model之间增加了一个ViewModel来解耦，这样View里面要做的基本就是绑定VM以及一些纯视图的操作（比如用什么动画效果展示一个数据）；VM里面是和View相关的数据部分的储存和操作，比如说一个UITableView的data source，一个对email输入合法性的验证方法，当然还有的是对真正Model层的调用和结果的刷新，由于View已经和VM绑定，这样VM在刷新的时候只刷新自己的属性就得了。\n\n　　其实重要的还是写代码思维方式的变化，如果全工程都使用RAC来实现，对于同一个业务逻辑终于可以在同一块代码里完成了，将UI事件，逻辑处理，文件或数据库操作，异步网络请求，UI结果显示，这一大套统统用函数式编程的思路嵌套起来，进入页面时搭建好这所有的关系，用户点击后妥妥的等着这一套联系一个个的按期望的逻辑和次序触发，最后显示给用户。感觉就像是搭好了一个精致的游乐场，然后不紧不慢地打开大门：@\"Come on 熊孩子们！\"\n\n\n\nPS：写这个blog的时候用的RAC版本是2.2.3，现在RAC3.0-dev正开发中，还会有很多变化，可能没写完就出新了，需要修改的我会update。\n","source":"_posts/rac_0_overview.md","raw":"title: Reactive Cocoa Tutorial [0] = Overview\ndate: 2014-03-06 21:58:30\ntags: Reactive Cocoa Tutorial\n---\n关于这系列（如果真能写下去的话）：说是教程有点狂，边学边总结，更像个笔记吧，等完全用透之后再写就会忘了一开始学习过程中遇到的问题了，Reactive Cocoa（RAC）现在资料真心少，中文英文加起来没几篇，还都是转来转去的。这是个好东西，相信以后用的人会变多，转了请留该文原地址哦~  by sunny\n\n> PS:\n> 这篇文章原来发布在blogcn上，http://www.cnblogs.com/sunnyxx，\n> 现在建了自己的blog后会在这上面继续写了。\n\n------\n\n### 废话少说 --> **RAC**\n\n　　是什么？怎么来的？干啥用的？ 怎么用的？ 可以观摩无网不剩的blog RAC介绍1和2，在此不啰唆了，简而言之，就是一个函数响应式编程思想在Cocoa下的实现。\n\n### 说说在RAC框架下做了一个项目的赶脚吧：\n\n - 挺新鲜挺有意思，开发人员水平很高，框架封装性和实用性一流，看了看人家对宏的使用发现原来用的纯小儿科，对编译器的控制，block的使用也很值得的学习。\n - 编程思想上的一些改变。原创的一个可能也不大恰当的比喻：原来的编程思想像是“走迷宫”，RAC的编程思想是“建迷宫”。意思是，之前的编程思路是命令式，大概都是“程序启动时执行xxxx，在用户点击后的回调函数执行xxx，收到一个Notification后执行xxx”等等，如同走迷宫一样，走出迷宫需要在不同时间段记住不同状态根据不同情况而做出一系列反应，继而走出迷宫；相比下，RAC的思想是建立联系，像钟表中的齿轮组一样，一个扣着一个，从转动发条到指针走动，一个齿轮一个齿轮的传导（Reactive），复杂但完整而自然。如同迷宫的建造者，在设计时早已决定了哪里是通路，哪里是死路或是哪个路口指向了出口，当一个挑战者（Event）走入迷宫时（Signal），他一定会在设置好的迷宫中的某个路线行走（传递），继而走到终点（Completion）或困死在里面（Error）。\n - 写出代码结构明显不一样。由于RAC将Cocoa中KVO，UIKit Event，delegate，selector等都增加了RAC支持，所以都不用去做很多跨函数的事，比如KVO个对象然后在回调里面xxx，从storyboard里面连个UIButton的IBAction出来xxx，或是设个UITextField的delegate出来去取输入的文本xxx。但在RAC下就像上面比喻的建迷宫，把这些大都放在“-viewDidLoad:”就可以了，当然像UITableView的delegate和data source这么大规模的代理模式就还是老老实实写吧。\n简洁。举个栗子：\n\n\n我就想干这么个事:\n\n> 一个label一个text field，下面输啥上面显示啥\n\n　　老写法大概做法是这个vc实现UITextFieldDelegate协议，把这个text field的delegate设到vc上面，然后在要改变text的那个delegate方法里面取当前text field的text值，再赋给label上；\n\n使用RAC的话就一句话（当然得把这俩控件都IBOutlet出来）：\n\n```\nRAC(self.outputLabel, text) = self.inputTextField.rac_textSignal;\n```\n\n看着就挺爽。\n\n复杂的栗子先不举了。\n\n　　总之吧，等今后维护RAC的开发者和使用者把更多的Cocoa的东西归入RAC的框架中，这个框架基本上都可以凌驾于Cocoa这个框架了，意思是甚至用不着知道那些delegate啊KVO啊苹果告诉你是咋用的，用RAC封装的就行了。RAC对于值的显示大都是和property“绑定”的关系，像使用storyboard构建页面时，对于有响应的控件基本都得IBOutlet出来作为一个property，而不是像原来一样连个IBAction出来或者连个delegate出来。对于视图层到model层之间的绑定就显得有些生硬了，相当于视图直接耦合了model，于是应运而生M-V-VM结构，说白了就是在View和Model之间增加了一个ViewModel来解耦，这样View里面要做的基本就是绑定VM以及一些纯视图的操作（比如用什么动画效果展示一个数据）；VM里面是和View相关的数据部分的储存和操作，比如说一个UITableView的data source，一个对email输入合法性的验证方法，当然还有的是对真正Model层的调用和结果的刷新，由于View已经和VM绑定，这样VM在刷新的时候只刷新自己的属性就得了。\n\n　　其实重要的还是写代码思维方式的变化，如果全工程都使用RAC来实现，对于同一个业务逻辑终于可以在同一块代码里完成了，将UI事件，逻辑处理，文件或数据库操作，异步网络请求，UI结果显示，这一大套统统用函数式编程的思路嵌套起来，进入页面时搭建好这所有的关系，用户点击后妥妥的等着这一套联系一个个的按期望的逻辑和次序触发，最后显示给用户。感觉就像是搭好了一个精致的游乐场，然后不紧不慢地打开大门：@\"Come on 熊孩子们！\"\n\n\n\nPS：写这个blog的时候用的RAC版本是2.2.3，现在RAC3.0-dev正开发中，还会有很多变化，可能没写完就出新了，需要修改的我会update。\n","slug":"rac_0_overview","published":1,"updated":"2016-03-27T09:18:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxmf001yev12bgw45v75","content":"<p>关于这系列（如果真能写下去的话）：说是教程有点狂，边学边总结，更像个笔记吧，等完全用透之后再写就会忘了一开始学习过程中遇到的问题了，Reactive Cocoa（RAC）现在资料真心少，中文英文加起来没几篇，还都是转来转去的。这是个好东西，相信以后用的人会变多，转了请留该文原地址哦~  by sunny</p>\n<blockquote>\n<p>PS:<br>这篇文章原来发布在blogcn上，<a href=\"http://www.cnblogs.com/sunnyxx，\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/sunnyxx，</a><br>现在建了自己的blog后会在这上面继续写了。</p>\n</blockquote>\n<hr>\n<h3 id=\"废话少说-–-gt-RAC\"><a href=\"#废话少说-–-gt-RAC\" class=\"headerlink\" title=\"废话少说 –&gt; RAC\"></a>废话少说 –&gt; <strong>RAC</strong></h3><p>　　是什么？怎么来的？干啥用的？ 怎么用的？ 可以观摩无网不剩的blog RAC介绍1和2，在此不啰唆了，简而言之，就是一个函数响应式编程思想在Cocoa下的实现。</p>\n<h3 id=\"说说在RAC框架下做了一个项目的赶脚吧：\"><a href=\"#说说在RAC框架下做了一个项目的赶脚吧：\" class=\"headerlink\" title=\"说说在RAC框架下做了一个项目的赶脚吧：\"></a>说说在RAC框架下做了一个项目的赶脚吧：</h3><ul>\n<li>挺新鲜挺有意思，开发人员水平很高，框架封装性和实用性一流，看了看人家对宏的使用发现原来用的纯小儿科，对编译器的控制，block的使用也很值得的学习。</li>\n<li>编程思想上的一些改变。原创的一个可能也不大恰当的比喻：原来的编程思想像是“走迷宫”，RAC的编程思想是“建迷宫”。意思是，之前的编程思路是命令式，大概都是“程序启动时执行xxxx，在用户点击后的回调函数执行xxx，收到一个Notification后执行xxx”等等，如同走迷宫一样，走出迷宫需要在不同时间段记住不同状态根据不同情况而做出一系列反应，继而走出迷宫；相比下，RAC的思想是建立联系，像钟表中的齿轮组一样，一个扣着一个，从转动发条到指针走动，一个齿轮一个齿轮的传导（Reactive），复杂但完整而自然。如同迷宫的建造者，在设计时早已决定了哪里是通路，哪里是死路或是哪个路口指向了出口，当一个挑战者（Event）走入迷宫时（Signal），他一定会在设置好的迷宫中的某个路线行走（传递），继而走到终点（Completion）或困死在里面（Error）。</li>\n<li>写出代码结构明显不一样。由于RAC将Cocoa中KVO，UIKit Event，delegate，selector等都增加了RAC支持，所以都不用去做很多跨函数的事，比如KVO个对象然后在回调里面xxx，从storyboard里面连个UIButton的IBAction出来xxx，或是设个UITextField的delegate出来去取输入的文本xxx。但在RAC下就像上面比喻的建迷宫，把这些大都放在“-viewDidLoad:”就可以了，当然像UITableView的delegate和data source这么大规模的代理模式就还是老老实实写吧。<br>简洁。举个栗子：</li>\n</ul>\n<p>我就想干这么个事:</p>\n<blockquote>\n<p>一个label一个text field，下面输啥上面显示啥</p>\n</blockquote>\n<p>　　老写法大概做法是这个vc实现UITextFieldDelegate协议，把这个text field的delegate设到vc上面，然后在要改变text的那个delegate方法里面取当前text field的text值，再赋给label上；</p>\n<p>使用RAC的话就一句话（当然得把这俩控件都IBOutlet出来）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RAC(self.outputLabel, text) = self.inputTextField.rac_textSignal;</span><br></pre></td></tr></table></figure>\n<p>看着就挺爽。</p>\n<p>复杂的栗子先不举了。</p>\n<p>　　总之吧，等今后维护RAC的开发者和使用者把更多的Cocoa的东西归入RAC的框架中，这个框架基本上都可以凌驾于Cocoa这个框架了，意思是甚至用不着知道那些delegate啊KVO啊苹果告诉你是咋用的，用RAC封装的就行了。RAC对于值的显示大都是和property“绑定”的关系，像使用storyboard构建页面时，对于有响应的控件基本都得IBOutlet出来作为一个property，而不是像原来一样连个IBAction出来或者连个delegate出来。对于视图层到model层之间的绑定就显得有些生硬了，相当于视图直接耦合了model，于是应运而生M-V-VM结构，说白了就是在View和Model之间增加了一个ViewModel来解耦，这样View里面要做的基本就是绑定VM以及一些纯视图的操作（比如用什么动画效果展示一个数据）；VM里面是和View相关的数据部分的储存和操作，比如说一个UITableView的data source，一个对email输入合法性的验证方法，当然还有的是对真正Model层的调用和结果的刷新，由于View已经和VM绑定，这样VM在刷新的时候只刷新自己的属性就得了。</p>\n<p>　　其实重要的还是写代码思维方式的变化，如果全工程都使用RAC来实现，对于同一个业务逻辑终于可以在同一块代码里完成了，将UI事件，逻辑处理，文件或数据库操作，异步网络请求，UI结果显示，这一大套统统用函数式编程的思路嵌套起来，进入页面时搭建好这所有的关系，用户点击后妥妥的等着这一套联系一个个的按期望的逻辑和次序触发，最后显示给用户。感觉就像是搭好了一个精致的游乐场，然后不紧不慢地打开大门：@”Come on 熊孩子们！”</p>\n<p>PS：写这个blog的时候用的RAC版本是2.2.3，现在RAC3.0-dev正开发中，还会有很多变化，可能没写完就出新了，需要修改的我会update。</p>\n","excerpt":"","more":"<p>关于这系列（如果真能写下去的话）：说是教程有点狂，边学边总结，更像个笔记吧，等完全用透之后再写就会忘了一开始学习过程中遇到的问题了，Reactive Cocoa（RAC）现在资料真心少，中文英文加起来没几篇，还都是转来转去的。这是个好东西，相信以后用的人会变多，转了请留该文原地址哦~  by sunny</p>\n<blockquote>\n<p>PS:<br>这篇文章原来发布在blogcn上，<a href=\"http://www.cnblogs.com/sunnyxx，\">http://www.cnblogs.com/sunnyxx，</a><br>现在建了自己的blog后会在这上面继续写了。</p>\n</blockquote>\n<hr>\n<h3 id=\"废话少说-–-gt-RAC\"><a href=\"#废话少说-–-gt-RAC\" class=\"headerlink\" title=\"废话少说 –&gt; RAC\"></a>废话少说 –&gt; <strong>RAC</strong></h3><p>　　是什么？怎么来的？干啥用的？ 怎么用的？ 可以观摩无网不剩的blog RAC介绍1和2，在此不啰唆了，简而言之，就是一个函数响应式编程思想在Cocoa下的实现。</p>\n<h3 id=\"说说在RAC框架下做了一个项目的赶脚吧：\"><a href=\"#说说在RAC框架下做了一个项目的赶脚吧：\" class=\"headerlink\" title=\"说说在RAC框架下做了一个项目的赶脚吧：\"></a>说说在RAC框架下做了一个项目的赶脚吧：</h3><ul>\n<li>挺新鲜挺有意思，开发人员水平很高，框架封装性和实用性一流，看了看人家对宏的使用发现原来用的纯小儿科，对编译器的控制，block的使用也很值得的学习。</li>\n<li>编程思想上的一些改变。原创的一个可能也不大恰当的比喻：原来的编程思想像是“走迷宫”，RAC的编程思想是“建迷宫”。意思是，之前的编程思路是命令式，大概都是“程序启动时执行xxxx，在用户点击后的回调函数执行xxx，收到一个Notification后执行xxx”等等，如同走迷宫一样，走出迷宫需要在不同时间段记住不同状态根据不同情况而做出一系列反应，继而走出迷宫；相比下，RAC的思想是建立联系，像钟表中的齿轮组一样，一个扣着一个，从转动发条到指针走动，一个齿轮一个齿轮的传导（Reactive），复杂但完整而自然。如同迷宫的建造者，在设计时早已决定了哪里是通路，哪里是死路或是哪个路口指向了出口，当一个挑战者（Event）走入迷宫时（Signal），他一定会在设置好的迷宫中的某个路线行走（传递），继而走到终点（Completion）或困死在里面（Error）。</li>\n<li>写出代码结构明显不一样。由于RAC将Cocoa中KVO，UIKit Event，delegate，selector等都增加了RAC支持，所以都不用去做很多跨函数的事，比如KVO个对象然后在回调里面xxx，从storyboard里面连个UIButton的IBAction出来xxx，或是设个UITextField的delegate出来去取输入的文本xxx。但在RAC下就像上面比喻的建迷宫，把这些大都放在“-viewDidLoad:”就可以了，当然像UITableView的delegate和data source这么大规模的代理模式就还是老老实实写吧。<br>简洁。举个栗子：</li>\n</ul>\n<p>我就想干这么个事:</p>\n<blockquote>\n<p>一个label一个text field，下面输啥上面显示啥</p>\n</blockquote>\n<p>　　老写法大概做法是这个vc实现UITextFieldDelegate协议，把这个text field的delegate设到vc上面，然后在要改变text的那个delegate方法里面取当前text field的text值，再赋给label上；</p>\n<p>使用RAC的话就一句话（当然得把这俩控件都IBOutlet出来）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RAC(self.outputLabel, text) = self.inputTextField.rac_textSignal;</span><br></pre></td></tr></table></figure>\n<p>看着就挺爽。</p>\n<p>复杂的栗子先不举了。</p>\n<p>　　总之吧，等今后维护RAC的开发者和使用者把更多的Cocoa的东西归入RAC的框架中，这个框架基本上都可以凌驾于Cocoa这个框架了，意思是甚至用不着知道那些delegate啊KVO啊苹果告诉你是咋用的，用RAC封装的就行了。RAC对于值的显示大都是和property“绑定”的关系，像使用storyboard构建页面时，对于有响应的控件基本都得IBOutlet出来作为一个property，而不是像原来一样连个IBAction出来或者连个delegate出来。对于视图层到model层之间的绑定就显得有些生硬了，相当于视图直接耦合了model，于是应运而生M-V-VM结构，说白了就是在View和Model之间增加了一个ViewModel来解耦，这样View里面要做的基本就是绑定VM以及一些纯视图的操作（比如用什么动画效果展示一个数据）；VM里面是和View相关的数据部分的储存和操作，比如说一个UITableView的data source，一个对email输入合法性的验证方法，当然还有的是对真正Model层的调用和结果的刷新，由于View已经和VM绑定，这样VM在刷新的时候只刷新自己的属性就得了。</p>\n<p>　　其实重要的还是写代码思维方式的变化，如果全工程都使用RAC来实现，对于同一个业务逻辑终于可以在同一块代码里完成了，将UI事件，逻辑处理，文件或数据库操作，异步网络请求，UI结果显示，这一大套统统用函数式编程的思路嵌套起来，进入页面时搭建好这所有的关系，用户点击后妥妥的等着这一套联系一个个的按期望的逻辑和次序触发，最后显示给用户。感觉就像是搭好了一个精致的游乐场，然后不紧不慢地打开大门：@”Come on 熊孩子们！”</p>\n<p>PS：写这个blog的时候用的RAC版本是2.2.3，现在RAC3.0-dev正开发中，还会有很多变化，可能没写完就出新了，需要修改的我会update。</p>\n"},{"title":"Reactive Cocoa Tutorial [1] = 神奇的Macros","date":"2014-03-06T14:11:04.000Z","_content":"Reactive Cocoa Tutorial 系列，转载请注明该文源地址 -- by sunnyxx\n\n---\n\n## 先说说RAC中必须要知道的宏：\n\n```\nRAC(TARGET, [KEYPATH, [NIL_VALUE]])\n```\n使用：\n```\nRAC(self.outputLabel, text) = self.inputTextField.rac_textSignal;\nRAC(self.outputLabel, text, @\"收到nil时就显示我\") = self.inputTextField.rac_textSignal;\n```\n　　这个宏是最常用的，`RAC()`总是出现在等号左边，等号右边是一个`RACSignal`，表示的意义是将一个对象的一个`属性`和一个`signal`绑定，signal每产生一个value（id类型），都会自动执行：\n\n```\n[TARGET setValue:value ?: NIL_VALUE forKeyPath:KEYPATH];\n```\n　　数字值会升级为`NSNumber *`，当setValue:forKeyPath时会自动降级成基本类型（int, float ,BOOL等），所以RAC绑定一个基本类型的值是没有问题的\n\n```\n　　· RACObserve(TARGET, KEYPATH)\n```\n　　作用是观察TARGET的KEYPATH属性，相当于`KVO`，产生一个`RACSignal`\n\n　　最常用的使用，和RAC宏绑定属性：\n```\nRAC(self.outputLabel, text) = RACObserve(self.model, name);\n```\n　　上面的代码将label的输出和model的name属性绑定，实现联动，name但凡有变化都会使得label输出\n\n```\n@weakify(Obj);\n@strongify(Obj);\n```\n　　这对宏在 `RACEXTScope.h` 中定义，RACFramework好像没有默认引入，需要单独import\n\n　　**他们的作用主要是在block内部管理对self的引用**：\n\n``` objc\n@weakify(self); // 定义了一个__weak的self_weak_变量\n[RACObserve(self, name) subscribeNext:^(NSString *name) {\n    @strongify(self); // 局域定义了一个__strong的self指针指向self_weak\n    self.outputLabel.text = name;\n}];\n```\n　　这个宏为什么这么吊，前面加@，其实就是一个啥都没干的@autoreleasepool {}前面的那个@，为了显眼罢了。\n\n　　**这两个宏一定成对出现，先weak再strong**\n\n\n\n## 除了RAC中常用宏的使用，有一些宏的实现方法也很值得观摩。\n\n\n\n　　举个高级点的栗子：\n\n　　要干的一件事，**计算一个可变参数列表的长度**。\n\n　　第一反应就是用参数列表的api，`va_start` `va_arg` `va_end`遍历一遍计算个和，但仔细想想，对于可变参数这个事，在**编译前**其实就已经确定了，代码里括号里有多少个参数一目了然。\n\n　　RAC中`Racmetamarcos.h`中就有一系列宏来完成这件事，硬是在预处理之后就拿到了可变参数个数：\n```\n#define metamacro_argcount(...) \\\n    metamacro_at(20, __VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n```\n这个宏由几个工具宏一层层展开，现在模拟一下展开过程：\n\n假如我们要计算的如下：\n```\nint count = metamacro_argcount(a, b, c);\n```\n于是乎**第一层**展开后：\n```\nint count = metamacro_at(20, a, b, c, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n```\n再看metamacro_at的定义：\n```\n#define metamacro_at(N, ...) metamacro_concat(metamacro_at, N)(__VA_ARGS__)\n// 下面是metamacro_concat做的事（简写一层）\n#define metamacro_concat_(A, B) A ## B\n```\n于是乎**第二层**展开后：\n```\nint count = metamacro_at20(a, b, c, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1);\n```\n再看metamacro_at20这个宏干的事儿：\n```\n#define metamacro_at20(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, ...) metamacro_head(__VA_ARGS__)\n```\n于是乎**第三层**展开后，相当于截断了前20个参数，留下剩下几个：\n```\nint count = metamacro_head(3, 2, 1);\n```\n这个metamacro_head：\n```\n#define metamacro_head(...) metamacro_head_(__VA_ARGS__, 0)\n#define metamacro_head_(FIRST, ...) FIRST\n```\n　　后面加个0，然后取参数列表第一个，于是乎：\n```\nint count = 3;\n```\n　　**大功告成。**\n\n　　反正我看完之后感觉挺震惊，宏还能这么用，这样带来的好处不止是将计算在预处理时搞定，不拖延到运行时恶心cpu；但更重要的是编译检查。比如某些可变参数的实现要求可以填2个参数，可以填3个参数，其他的都不行，这样，也只有这样的宏的实现，才能在编译前就确定了错误。\n\n## 除了上面，还有一个神奇的宏的使用：\n\n　　当使用诸如`RAC(self, outputLabel)`或`RACObserve(self, name)`时，发现写完逗号之后，**输入第二个property的时候会出现完全正确的代码提示**！这相当神奇。\n![自动代码提示][1]\n\n\n探究一下，关键的关键是如下一个宏：\n```\n#define keypath(...) \\\n    metamacro_if_eq(1, metamacro_argcount(__VA_ARGS__))(keypath1(__VA_ARGS__))(keypath2(__VA_ARGS__))\n```\n这个`metamacro_argcount`上面说过，是计算**可变参数**个数，所以`metamacro_if_eq`的作用就是判断参数个数，如果个数是1就执行后面的keypath1，若不是1就执行keypath2。\n\n所以重点说一下keypath2：\n```\n#define keypath2(OBJ, PATH) \\\n    (((void)(NO && ((void)OBJ.PATH, NO)), # PATH))\n```\n　　乍一看真挺懵，先化简，由于Objc里面keypath是诸如\"outputLabel.text\"的字符串，所以这个宏的返回值应该是个字符串，可以简化成：\n```\n#define keypath2(OBJ, PATH) (???????, # PATH)\n```\n先不管\"??????\"是啥，这里不得不说C语言中一个不大常见的语法（第一个忽略）：\n```\nint a = 0, b = 0;\na = 1, b = 2;\nint c = (a, b);\n```\n这些都是**逗号表达式**的合理用法，第三个最不常用了，c将被b赋值，而a是一个未使用的值，编译器会给出warning。\n\n去除warning的方法很简单，强转成void就行了：\n```\nint c = ((void)a, b);\n```\n再看上面简化的keypath2宏，返回的就是PATH的字符串字面值了(单#号会将传入值转成字面字符串)\n\n```\n(((void)(NO && ((void)OBJ.PATH, NO)), # PATH))\n```\n对传入的第一个参数OBJ和第二个正要输入的PATH做了`点`操作，这也正是为什么输入第二个参数时编辑器会给出正确的代码提示。强转void就像上面说的去除了warning。\n\n　但至于为什么加入与`NO`做`&&`，我不太能理解，我测试时其实没有时已经完成了功能，可能是作者为了屏蔽某些隐藏的问题吧。\n\n　　这个宏的巧妙的地方就在于使得编译器以为我们要输入“点”出来的属性，保证了输入值的合法性（输了不存在的property直接报错的），同时利用了逗号表达式取逗号最后值的语法返回了正确的keypath。\n\n\n\n## 总之\nRAC对宏的使用达到了很高的水平，还有诸如`RACTuplePack`，`RACTupleUnpack`的宏就不细说了，值得研究。\n\n---\nPS：上面介绍的metamacro和@strongify等宏确切来说来自RAC依赖的extobjc，作者是Justin Spahr-Summers，正是RAC作者之一。\n\n\n  [1]: http://images.cnitblog.com/blog/401798/201402/112147518936541.png\n","source":"_posts/rac_1_macros.md","raw":"title: Reactive Cocoa Tutorial [1] = 神奇的Macros\ndate: 2014-03-06 22:11:04\ntags: Reactive Cocoa Tutorial\n---\nReactive Cocoa Tutorial 系列，转载请注明该文源地址 -- by sunnyxx\n\n---\n\n## 先说说RAC中必须要知道的宏：\n\n```\nRAC(TARGET, [KEYPATH, [NIL_VALUE]])\n```\n使用：\n```\nRAC(self.outputLabel, text) = self.inputTextField.rac_textSignal;\nRAC(self.outputLabel, text, @\"收到nil时就显示我\") = self.inputTextField.rac_textSignal;\n```\n　　这个宏是最常用的，`RAC()`总是出现在等号左边，等号右边是一个`RACSignal`，表示的意义是将一个对象的一个`属性`和一个`signal`绑定，signal每产生一个value（id类型），都会自动执行：\n\n```\n[TARGET setValue:value ?: NIL_VALUE forKeyPath:KEYPATH];\n```\n　　数字值会升级为`NSNumber *`，当setValue:forKeyPath时会自动降级成基本类型（int, float ,BOOL等），所以RAC绑定一个基本类型的值是没有问题的\n\n```\n　　· RACObserve(TARGET, KEYPATH)\n```\n　　作用是观察TARGET的KEYPATH属性，相当于`KVO`，产生一个`RACSignal`\n\n　　最常用的使用，和RAC宏绑定属性：\n```\nRAC(self.outputLabel, text) = RACObserve(self.model, name);\n```\n　　上面的代码将label的输出和model的name属性绑定，实现联动，name但凡有变化都会使得label输出\n\n```\n@weakify(Obj);\n@strongify(Obj);\n```\n　　这对宏在 `RACEXTScope.h` 中定义，RACFramework好像没有默认引入，需要单独import\n\n　　**他们的作用主要是在block内部管理对self的引用**：\n\n``` objc\n@weakify(self); // 定义了一个__weak的self_weak_变量\n[RACObserve(self, name) subscribeNext:^(NSString *name) {\n    @strongify(self); // 局域定义了一个__strong的self指针指向self_weak\n    self.outputLabel.text = name;\n}];\n```\n　　这个宏为什么这么吊，前面加@，其实就是一个啥都没干的@autoreleasepool {}前面的那个@，为了显眼罢了。\n\n　　**这两个宏一定成对出现，先weak再strong**\n\n\n\n## 除了RAC中常用宏的使用，有一些宏的实现方法也很值得观摩。\n\n\n\n　　举个高级点的栗子：\n\n　　要干的一件事，**计算一个可变参数列表的长度**。\n\n　　第一反应就是用参数列表的api，`va_start` `va_arg` `va_end`遍历一遍计算个和，但仔细想想，对于可变参数这个事，在**编译前**其实就已经确定了，代码里括号里有多少个参数一目了然。\n\n　　RAC中`Racmetamarcos.h`中就有一系列宏来完成这件事，硬是在预处理之后就拿到了可变参数个数：\n```\n#define metamacro_argcount(...) \\\n    metamacro_at(20, __VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n```\n这个宏由几个工具宏一层层展开，现在模拟一下展开过程：\n\n假如我们要计算的如下：\n```\nint count = metamacro_argcount(a, b, c);\n```\n于是乎**第一层**展开后：\n```\nint count = metamacro_at(20, a, b, c, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n```\n再看metamacro_at的定义：\n```\n#define metamacro_at(N, ...) metamacro_concat(metamacro_at, N)(__VA_ARGS__)\n// 下面是metamacro_concat做的事（简写一层）\n#define metamacro_concat_(A, B) A ## B\n```\n于是乎**第二层**展开后：\n```\nint count = metamacro_at20(a, b, c, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1);\n```\n再看metamacro_at20这个宏干的事儿：\n```\n#define metamacro_at20(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, ...) metamacro_head(__VA_ARGS__)\n```\n于是乎**第三层**展开后，相当于截断了前20个参数，留下剩下几个：\n```\nint count = metamacro_head(3, 2, 1);\n```\n这个metamacro_head：\n```\n#define metamacro_head(...) metamacro_head_(__VA_ARGS__, 0)\n#define metamacro_head_(FIRST, ...) FIRST\n```\n　　后面加个0，然后取参数列表第一个，于是乎：\n```\nint count = 3;\n```\n　　**大功告成。**\n\n　　反正我看完之后感觉挺震惊，宏还能这么用，这样带来的好处不止是将计算在预处理时搞定，不拖延到运行时恶心cpu；但更重要的是编译检查。比如某些可变参数的实现要求可以填2个参数，可以填3个参数，其他的都不行，这样，也只有这样的宏的实现，才能在编译前就确定了错误。\n\n## 除了上面，还有一个神奇的宏的使用：\n\n　　当使用诸如`RAC(self, outputLabel)`或`RACObserve(self, name)`时，发现写完逗号之后，**输入第二个property的时候会出现完全正确的代码提示**！这相当神奇。\n![自动代码提示][1]\n\n\n探究一下，关键的关键是如下一个宏：\n```\n#define keypath(...) \\\n    metamacro_if_eq(1, metamacro_argcount(__VA_ARGS__))(keypath1(__VA_ARGS__))(keypath2(__VA_ARGS__))\n```\n这个`metamacro_argcount`上面说过，是计算**可变参数**个数，所以`metamacro_if_eq`的作用就是判断参数个数，如果个数是1就执行后面的keypath1，若不是1就执行keypath2。\n\n所以重点说一下keypath2：\n```\n#define keypath2(OBJ, PATH) \\\n    (((void)(NO && ((void)OBJ.PATH, NO)), # PATH))\n```\n　　乍一看真挺懵，先化简，由于Objc里面keypath是诸如\"outputLabel.text\"的字符串，所以这个宏的返回值应该是个字符串，可以简化成：\n```\n#define keypath2(OBJ, PATH) (???????, # PATH)\n```\n先不管\"??????\"是啥，这里不得不说C语言中一个不大常见的语法（第一个忽略）：\n```\nint a = 0, b = 0;\na = 1, b = 2;\nint c = (a, b);\n```\n这些都是**逗号表达式**的合理用法，第三个最不常用了，c将被b赋值，而a是一个未使用的值，编译器会给出warning。\n\n去除warning的方法很简单，强转成void就行了：\n```\nint c = ((void)a, b);\n```\n再看上面简化的keypath2宏，返回的就是PATH的字符串字面值了(单#号会将传入值转成字面字符串)\n\n```\n(((void)(NO && ((void)OBJ.PATH, NO)), # PATH))\n```\n对传入的第一个参数OBJ和第二个正要输入的PATH做了`点`操作，这也正是为什么输入第二个参数时编辑器会给出正确的代码提示。强转void就像上面说的去除了warning。\n\n　但至于为什么加入与`NO`做`&&`，我不太能理解，我测试时其实没有时已经完成了功能，可能是作者为了屏蔽某些隐藏的问题吧。\n\n　　这个宏的巧妙的地方就在于使得编译器以为我们要输入“点”出来的属性，保证了输入值的合法性（输了不存在的property直接报错的），同时利用了逗号表达式取逗号最后值的语法返回了正确的keypath。\n\n\n\n## 总之\nRAC对宏的使用达到了很高的水平，还有诸如`RACTuplePack`，`RACTupleUnpack`的宏就不细说了，值得研究。\n\n---\nPS：上面介绍的metamacro和@strongify等宏确切来说来自RAC依赖的extobjc，作者是Justin Spahr-Summers，正是RAC作者之一。\n\n\n  [1]: http://images.cnitblog.com/blog/401798/201402/112147518936541.png\n","slug":"rac_1_macros","published":1,"updated":"2016-03-27T09:17:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxmh0020ev12w6ac93kl","content":"<p>Reactive Cocoa Tutorial 系列，转载请注明该文源地址 – by sunnyxx</p>\n<hr>\n<h2 id=\"先说说RAC中必须要知道的宏：\"><a href=\"#先说说RAC中必须要知道的宏：\" class=\"headerlink\" title=\"先说说RAC中必须要知道的宏：\"></a>先说说RAC中必须要知道的宏：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RAC(TARGET, [KEYPATH, [NIL_VALUE]])</span><br></pre></td></tr></table></figure>\n<p>使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RAC(self.outputLabel, text) = self.inputTextField.rac_textSignal;</span><br><span class=\"line\">RAC(self.outputLabel, text, @&quot;收到nil时就显示我&quot;) = self.inputTextField.rac_textSignal;</span><br></pre></td></tr></table></figure></p>\n<p>　　这个宏是最常用的，<code>RAC()</code>总是出现在等号左边，等号右边是一个<code>RACSignal</code>，表示的意义是将一个对象的一个<code>属性</code>和一个<code>signal</code>绑定，signal每产生一个value（id类型），都会自动执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[TARGET setValue:value ?: NIL_VALUE forKeyPath:KEYPATH];</span><br></pre></td></tr></table></figure>\n<p>　　数字值会升级为<code>NSNumber *</code>，当setValue:forKeyPath时会自动降级成基本类型（int, float ,BOOL等），所以RAC绑定一个基本类型的值是没有问题的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　· RACObserve(TARGET, KEYPATH)</span><br></pre></td></tr></table></figure>\n<p>　　作用是观察TARGET的KEYPATH属性，相当于<code>KVO</code>，产生一个<code>RACSignal</code></p>\n<p>　　最常用的使用，和RAC宏绑定属性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RAC(self.outputLabel, text) = RACObserve(self.model, name);</span><br></pre></td></tr></table></figure></p>\n<p>　　上面的代码将label的输出和model的name属性绑定，实现联动，name但凡有变化都会使得label输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@weakify(Obj);</span><br><span class=\"line\">@strongify(Obj);</span><br></pre></td></tr></table></figure>\n<p>　　这对宏在 <code>RACEXTScope.h</code> 中定义，RACFramework好像没有默认引入，需要单独import</p>\n<p>　　<strong>他们的作用主要是在block内部管理对self的引用</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@weakify(<span class=\"keyword\">self</span>); <span class=\"comment\">// 定义了一个__weak的self_weak_变量</span></span><br><span class=\"line\">[RACObserve(<span class=\"keyword\">self</span>, name) subscribeNext:^(<span class=\"built_in\">NSString</span> *name) &#123;</span><br><span class=\"line\">    @strongify(<span class=\"keyword\">self</span>); <span class=\"comment\">// 局域定义了一个__strong的self指针指向self_weak</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.outputLabel.text = name;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>　　这个宏为什么这么吊，前面加@，其实就是一个啥都没干的@autoreleasepool {}前面的那个@，为了显眼罢了。</p>\n<p>　　<strong>这两个宏一定成对出现，先weak再strong</strong></p>\n<h2 id=\"除了RAC中常用宏的使用，有一些宏的实现方法也很值得观摩。\"><a href=\"#除了RAC中常用宏的使用，有一些宏的实现方法也很值得观摩。\" class=\"headerlink\" title=\"除了RAC中常用宏的使用，有一些宏的实现方法也很值得观摩。\"></a>除了RAC中常用宏的使用，有一些宏的实现方法也很值得观摩。</h2><p>　　举个高级点的栗子：</p>\n<p>　　要干的一件事，<strong>计算一个可变参数列表的长度</strong>。</p>\n<p>　　第一反应就是用参数列表的api，<code>va_start</code> <code>va_arg</code> <code>va_end</code>遍历一遍计算个和，但仔细想想，对于可变参数这个事，在<strong>编译前</strong>其实就已经确定了，代码里括号里有多少个参数一目了然。</p>\n<p>　　RAC中<code>Racmetamarcos.h</code>中就有一系列宏来完成这件事，硬是在预处理之后就拿到了可变参数个数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define metamacro_argcount(...) \\</span><br><span class=\"line\">    metamacro_at(20, __VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)</span><br></pre></td></tr></table></figure></p>\n<p>这个宏由几个工具宏一层层展开，现在模拟一下展开过程：</p>\n<p>假如我们要计算的如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int count = metamacro_argcount(a, b, c);</span><br></pre></td></tr></table></figure></p>\n<p>于是乎<strong>第一层</strong>展开后：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int count = metamacro_at(20, a, b, c, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)</span><br></pre></td></tr></table></figure></p>\n<p>再看metamacro_at的定义：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define metamacro_at(N, ...) metamacro_concat(metamacro_at, N)(__VA_ARGS__)</span><br><span class=\"line\">// 下面是metamacro_concat做的事（简写一层）</span><br><span class=\"line\">#define metamacro_concat_(A, B) A ## B</span><br></pre></td></tr></table></figure></p>\n<p>于是乎<strong>第二层</strong>展开后：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int count = metamacro_at20(a, b, c, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1);</span><br></pre></td></tr></table></figure></p>\n<p>再看metamacro_at20这个宏干的事儿：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define metamacro_at20(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, ...) metamacro_head(__VA_ARGS__)</span><br></pre></td></tr></table></figure></p>\n<p>于是乎<strong>第三层</strong>展开后，相当于截断了前20个参数，留下剩下几个：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int count = metamacro_head(3, 2, 1);</span><br></pre></td></tr></table></figure></p>\n<p>这个metamacro_head：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define metamacro_head(...) metamacro_head_(__VA_ARGS__, 0)</span><br><span class=\"line\">#define metamacro_head_(FIRST, ...) FIRST</span><br></pre></td></tr></table></figure></p>\n<p>　　后面加个0，然后取参数列表第一个，于是乎：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int count = 3;</span><br></pre></td></tr></table></figure></p>\n<p>　　<strong>大功告成。</strong></p>\n<p>　　反正我看完之后感觉挺震惊，宏还能这么用，这样带来的好处不止是将计算在预处理时搞定，不拖延到运行时恶心cpu；但更重要的是编译检查。比如某些可变参数的实现要求可以填2个参数，可以填3个参数，其他的都不行，这样，也只有这样的宏的实现，才能在编译前就确定了错误。</p>\n<h2 id=\"除了上面，还有一个神奇的宏的使用：\"><a href=\"#除了上面，还有一个神奇的宏的使用：\" class=\"headerlink\" title=\"除了上面，还有一个神奇的宏的使用：\"></a>除了上面，还有一个神奇的宏的使用：</h2><p>　　当使用诸如<code>RAC(self, outputLabel)</code>或<code>RACObserve(self, name)</code>时，发现写完逗号之后，<strong>输入第二个property的时候会出现完全正确的代码提示</strong>！这相当神奇。<br><img src=\"http://images.cnitblog.com/blog/401798/201402/112147518936541.png\" alt=\"自动代码提示\"></p>\n<p>探究一下，关键的关键是如下一个宏：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define keypath(...) \\</span><br><span class=\"line\">    metamacro_if_eq(1, metamacro_argcount(__VA_ARGS__))(keypath1(__VA_ARGS__))(keypath2(__VA_ARGS__))</span><br></pre></td></tr></table></figure></p>\n<p>这个<code>metamacro_argcount</code>上面说过，是计算<strong>可变参数</strong>个数，所以<code>metamacro_if_eq</code>的作用就是判断参数个数，如果个数是1就执行后面的keypath1，若不是1就执行keypath2。</p>\n<p>所以重点说一下keypath2：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define keypath2(OBJ, PATH) \\</span><br><span class=\"line\">    (((void)(NO &amp;&amp; ((void)OBJ.PATH, NO)), # PATH))</span><br></pre></td></tr></table></figure></p>\n<p>　　乍一看真挺懵，先化简，由于Objc里面keypath是诸如”outputLabel.text”的字符串，所以这个宏的返回值应该是个字符串，可以简化成：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define keypath2(OBJ, PATH) (???????, # PATH)</span><br></pre></td></tr></table></figure></p>\n<p>先不管”??????”是啥，这里不得不说C语言中一个不大常见的语法（第一个忽略）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 0, b = 0;</span><br><span class=\"line\">a = 1, b = 2;</span><br><span class=\"line\">int c = (a, b);</span><br></pre></td></tr></table></figure></p>\n<p>这些都是<strong>逗号表达式</strong>的合理用法，第三个最不常用了，c将被b赋值，而a是一个未使用的值，编译器会给出warning。</p>\n<p>去除warning的方法很简单，强转成void就行了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int c = ((void)a, b);</span><br></pre></td></tr></table></figure></p>\n<p>再看上面简化的keypath2宏，返回的就是PATH的字符串字面值了(单#号会将传入值转成字面字符串)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(((void)(NO &amp;&amp; ((void)OBJ.PATH, NO)), # PATH))</span><br></pre></td></tr></table></figure>\n<p>对传入的第一个参数OBJ和第二个正要输入的PATH做了<code>点</code>操作，这也正是为什么输入第二个参数时编辑器会给出正确的代码提示。强转void就像上面说的去除了warning。</p>\n<p>　但至于为什么加入与<code>NO</code>做<code>&amp;&amp;</code>，我不太能理解，我测试时其实没有时已经完成了功能，可能是作者为了屏蔽某些隐藏的问题吧。</p>\n<p>　　这个宏的巧妙的地方就在于使得编译器以为我们要输入“点”出来的属性，保证了输入值的合法性（输了不存在的property直接报错的），同时利用了逗号表达式取逗号最后值的语法返回了正确的keypath。</p>\n<h2 id=\"总之\"><a href=\"#总之\" class=\"headerlink\" title=\"总之\"></a>总之</h2><p>RAC对宏的使用达到了很高的水平，还有诸如<code>RACTuplePack</code>，<code>RACTupleUnpack</code>的宏就不细说了，值得研究。</p>\n<hr>\n<p>PS：上面介绍的metamacro和@strongify等宏确切来说来自RAC依赖的extobjc，作者是Justin Spahr-Summers，正是RAC作者之一。</p>\n","excerpt":"","more":"<p>Reactive Cocoa Tutorial 系列，转载请注明该文源地址 – by sunnyxx</p>\n<hr>\n<h2 id=\"先说说RAC中必须要知道的宏：\"><a href=\"#先说说RAC中必须要知道的宏：\" class=\"headerlink\" title=\"先说说RAC中必须要知道的宏：\"></a>先说说RAC中必须要知道的宏：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RAC(TARGET, [KEYPATH, [NIL_VALUE]])</span><br></pre></td></tr></table></figure>\n<p>使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RAC(self.outputLabel, text) = self.inputTextField.rac_textSignal;</span><br><span class=\"line\">RAC(self.outputLabel, text, @&quot;收到nil时就显示我&quot;) = self.inputTextField.rac_textSignal;</span><br></pre></td></tr></table></figure></p>\n<p>　　这个宏是最常用的，<code>RAC()</code>总是出现在等号左边，等号右边是一个<code>RACSignal</code>，表示的意义是将一个对象的一个<code>属性</code>和一个<code>signal</code>绑定，signal每产生一个value（id类型），都会自动执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[TARGET setValue:value ?: NIL_VALUE forKeyPath:KEYPATH];</span><br></pre></td></tr></table></figure>\n<p>　　数字值会升级为<code>NSNumber *</code>，当setValue:forKeyPath时会自动降级成基本类型（int, float ,BOOL等），所以RAC绑定一个基本类型的值是没有问题的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　· RACObserve(TARGET, KEYPATH)</span><br></pre></td></tr></table></figure>\n<p>　　作用是观察TARGET的KEYPATH属性，相当于<code>KVO</code>，产生一个<code>RACSignal</code></p>\n<p>　　最常用的使用，和RAC宏绑定属性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RAC(self.outputLabel, text) = RACObserve(self.model, name);</span><br></pre></td></tr></table></figure></p>\n<p>　　上面的代码将label的输出和model的name属性绑定，实现联动，name但凡有变化都会使得label输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@weakify(Obj);</span><br><span class=\"line\">@strongify(Obj);</span><br></pre></td></tr></table></figure>\n<p>　　这对宏在 <code>RACEXTScope.h</code> 中定义，RACFramework好像没有默认引入，需要单独import</p>\n<p>　　<strong>他们的作用主要是在block内部管理对self的引用</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@weakify(<span class=\"keyword\">self</span>); <span class=\"comment\">// 定义了一个__weak的self_weak_变量</span></span><br><span class=\"line\">[RACObserve(<span class=\"keyword\">self</span>, name) subscribeNext:^(<span class=\"built_in\">NSString</span> *name) &#123;</span><br><span class=\"line\">    @strongify(<span class=\"keyword\">self</span>); <span class=\"comment\">// 局域定义了一个__strong的self指针指向self_weak</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.outputLabel.text = name;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>　　这个宏为什么这么吊，前面加@，其实就是一个啥都没干的@autoreleasepool {}前面的那个@，为了显眼罢了。</p>\n<p>　　<strong>这两个宏一定成对出现，先weak再strong</strong></p>\n<h2 id=\"除了RAC中常用宏的使用，有一些宏的实现方法也很值得观摩。\"><a href=\"#除了RAC中常用宏的使用，有一些宏的实现方法也很值得观摩。\" class=\"headerlink\" title=\"除了RAC中常用宏的使用，有一些宏的实现方法也很值得观摩。\"></a>除了RAC中常用宏的使用，有一些宏的实现方法也很值得观摩。</h2><p>　　举个高级点的栗子：</p>\n<p>　　要干的一件事，<strong>计算一个可变参数列表的长度</strong>。</p>\n<p>　　第一反应就是用参数列表的api，<code>va_start</code> <code>va_arg</code> <code>va_end</code>遍历一遍计算个和，但仔细想想，对于可变参数这个事，在<strong>编译前</strong>其实就已经确定了，代码里括号里有多少个参数一目了然。</p>\n<p>　　RAC中<code>Racmetamarcos.h</code>中就有一系列宏来完成这件事，硬是在预处理之后就拿到了可变参数个数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define metamacro_argcount(...) \\</span><br><span class=\"line\">    metamacro_at(20, __VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)</span><br></pre></td></tr></table></figure></p>\n<p>这个宏由几个工具宏一层层展开，现在模拟一下展开过程：</p>\n<p>假如我们要计算的如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int count = metamacro_argcount(a, b, c);</span><br></pre></td></tr></table></figure></p>\n<p>于是乎<strong>第一层</strong>展开后：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int count = metamacro_at(20, a, b, c, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)</span><br></pre></td></tr></table></figure></p>\n<p>再看metamacro_at的定义：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define metamacro_at(N, ...) metamacro_concat(metamacro_at, N)(__VA_ARGS__)</span><br><span class=\"line\">// 下面是metamacro_concat做的事（简写一层）</span><br><span class=\"line\">#define metamacro_concat_(A, B) A ## B</span><br></pre></td></tr></table></figure></p>\n<p>于是乎<strong>第二层</strong>展开后：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int count = metamacro_at20(a, b, c, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1);</span><br></pre></td></tr></table></figure></p>\n<p>再看metamacro_at20这个宏干的事儿：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define metamacro_at20(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, ...) metamacro_head(__VA_ARGS__)</span><br></pre></td></tr></table></figure></p>\n<p>于是乎<strong>第三层</strong>展开后，相当于截断了前20个参数，留下剩下几个：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int count = metamacro_head(3, 2, 1);</span><br></pre></td></tr></table></figure></p>\n<p>这个metamacro_head：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define metamacro_head(...) metamacro_head_(__VA_ARGS__, 0)</span><br><span class=\"line\">#define metamacro_head_(FIRST, ...) FIRST</span><br></pre></td></tr></table></figure></p>\n<p>　　后面加个0，然后取参数列表第一个，于是乎：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int count = 3;</span><br></pre></td></tr></table></figure></p>\n<p>　　<strong>大功告成。</strong></p>\n<p>　　反正我看完之后感觉挺震惊，宏还能这么用，这样带来的好处不止是将计算在预处理时搞定，不拖延到运行时恶心cpu；但更重要的是编译检查。比如某些可变参数的实现要求可以填2个参数，可以填3个参数，其他的都不行，这样，也只有这样的宏的实现，才能在编译前就确定了错误。</p>\n<h2 id=\"除了上面，还有一个神奇的宏的使用：\"><a href=\"#除了上面，还有一个神奇的宏的使用：\" class=\"headerlink\" title=\"除了上面，还有一个神奇的宏的使用：\"></a>除了上面，还有一个神奇的宏的使用：</h2><p>　　当使用诸如<code>RAC(self, outputLabel)</code>或<code>RACObserve(self, name)</code>时，发现写完逗号之后，<strong>输入第二个property的时候会出现完全正确的代码提示</strong>！这相当神奇。<br><img src=\"http://images.cnitblog.com/blog/401798/201402/112147518936541.png\" alt=\"自动代码提示\"></p>\n<p>探究一下，关键的关键是如下一个宏：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define keypath(...) \\</span><br><span class=\"line\">    metamacro_if_eq(1, metamacro_argcount(__VA_ARGS__))(keypath1(__VA_ARGS__))(keypath2(__VA_ARGS__))</span><br></pre></td></tr></table></figure></p>\n<p>这个<code>metamacro_argcount</code>上面说过，是计算<strong>可变参数</strong>个数，所以<code>metamacro_if_eq</code>的作用就是判断参数个数，如果个数是1就执行后面的keypath1，若不是1就执行keypath2。</p>\n<p>所以重点说一下keypath2：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define keypath2(OBJ, PATH) \\</span><br><span class=\"line\">    (((void)(NO &amp;&amp; ((void)OBJ.PATH, NO)), # PATH))</span><br></pre></td></tr></table></figure></p>\n<p>　　乍一看真挺懵，先化简，由于Objc里面keypath是诸如”outputLabel.text”的字符串，所以这个宏的返回值应该是个字符串，可以简化成：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define keypath2(OBJ, PATH) (???????, # PATH)</span><br></pre></td></tr></table></figure></p>\n<p>先不管”??????”是啥，这里不得不说C语言中一个不大常见的语法（第一个忽略）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 0, b = 0;</span><br><span class=\"line\">a = 1, b = 2;</span><br><span class=\"line\">int c = (a, b);</span><br></pre></td></tr></table></figure></p>\n<p>这些都是<strong>逗号表达式</strong>的合理用法，第三个最不常用了，c将被b赋值，而a是一个未使用的值，编译器会给出warning。</p>\n<p>去除warning的方法很简单，强转成void就行了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int c = ((void)a, b);</span><br></pre></td></tr></table></figure></p>\n<p>再看上面简化的keypath2宏，返回的就是PATH的字符串字面值了(单#号会将传入值转成字面字符串)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(((void)(NO &amp;&amp; ((void)OBJ.PATH, NO)), # PATH))</span><br></pre></td></tr></table></figure>\n<p>对传入的第一个参数OBJ和第二个正要输入的PATH做了<code>点</code>操作，这也正是为什么输入第二个参数时编辑器会给出正确的代码提示。强转void就像上面说的去除了warning。</p>\n<p>　但至于为什么加入与<code>NO</code>做<code>&amp;&amp;</code>，我不太能理解，我测试时其实没有时已经完成了功能，可能是作者为了屏蔽某些隐藏的问题吧。</p>\n<p>　　这个宏的巧妙的地方就在于使得编译器以为我们要输入“点”出来的属性，保证了输入值的合法性（输了不存在的property直接报错的），同时利用了逗号表达式取逗号最后值的语法返回了正确的keypath。</p>\n<h2 id=\"总之\"><a href=\"#总之\" class=\"headerlink\" title=\"总之\"></a>总之</h2><p>RAC对宏的使用达到了很高的水平，还有诸如<code>RACTuplePack</code>，<code>RACTupleUnpack</code>的宏就不细说了，值得研究。</p>\n<hr>\n<p>PS：上面介绍的metamacro和@strongify等宏确切来说来自RAC依赖的extobjc，作者是Justin Spahr-Summers，正是RAC作者之一。</p>\n"},{"title":"Reactive Cocoa Tutorial [2] = 百变RACStream","date":"2014-03-06T14:34:27.000Z","_content":"Reactive Cocoa Tutorial 系列，转载请注明该文源地址 -- by sunny\n\n## Overview\n　　在RAC下开发干的最多的事就是建立RACSignal和subscribe RACSignal了，它是RAC的核心所在。本篇介绍了RAC的运作原理和设计思路，从函数式编程形成的RACStream继而介绍它的子类 - RAC最核心的部分RACSignal。\n\n## 函数式编程\n　　我们知道Reactive Cocoa是函数式编程(Functional Programing)(FP)思想的实现。FP有一套成熟的理论，这里只讲讲我个人理解吧。\n　　我觉得FP就是“**像计算函数表达式一样来解决一个问题**”，举个栗子，中学题：\n\n``` c\n已知：f(x) = 2sin(x + π/2)， 求 f(π/2)的值。\n```\n其中x是这个函数的输入，f(x)为计算的输出结果，求f(π/2)时给定了x自然能计算出个结果来（说实话我真忘了咋算了）\n当然，仔细看这个函数，其实是可以分解成几个小函数的：\n\n``` c\nf1(x) = x + π/2\nf2(x) = sin(x)\nf3(x) = 2x\n```\n而原来的f(x)可以被小函数组合：\n\n``` c\nf(x) = f3(f2(f1(x)))\n```\n　　所以不难得出这么个推论：要是我手上有足够的**基本函数**，我就能用上面的组合的方法组合出任意一个**复杂的函数**了。再想想事实上这些年来学数学的过程不就是在一个个积累基本函数的过程嘛，从基本运算，到三角函数，到乘方开方，再到微积分。基本函数越来越多，能解决的数学问题也越来越复杂。\n\n　　再来看一个函数是怎么构成的，FP理论里叫`monads`，十分抽象，没读懂，但能理解出来：一个函数只要有一个对于输入值的运算方法和一个返回值，就够了。也容易理解，给它一个输入，干点事情，给出一个输出，就行了，当然现实情况要复杂得多（比如说输出值本身就是个函数？）有些函数是有输入的条件的，比如原来数学解个函数时候经常跟个作用域或者限制条件，比如`f(x) = 10 / x , (x不为0)`，要是传个0这个函数就认为计算错误。\n\n　　对于像上面栗子的函数，每个函数都能接收上一个函数输出的结果，作为自己的输入，这样才能嵌套生成最终结果，同时，计算的顺序也是一定从里向外，所以换个写法可以写成：\n\n```\nstart ---x--> f1(x) --(temp value1)--> f2(temp value1) --(temp value2)--> f3(temp value2) ---> result\n```\n　　于是乎**嵌套**就被表示成了**序列**，来个高大上的名字怎么样，就叫**流（Stream）**\n\n## RACStream\n\n　　这就是`RACStream`所表示的含义。\n\n　　按照上面说的，其实`RACStream`的名字有点点歧义，对于一个`RACStream`对象，它在意义上等同于上面的f1(x),f2(x),f3(x)，而不是那一大串整体，表示整体的应该是最外层的和f(x)对应的那个对象，叫个RACStreamComponent比较好？理解时候得注意下。\n\n　　所以作为一个基本函数的RACStream应该至少应该有：\n\n 1. 怎么传入值\n 2. 怎么返回值\n 3. 怎么与其他函数组合\n 4. 怎么实现函数的作用域(监测输入值来做处理)\n 5. 这函数叫啥- -\n\n\n得益于在Objc下实现，所以输入输出的“值”都用个`id`类型就行了，遇到多个值的组合就用`RACTurple`（可以把多个值压包和解包，类比WINRAR），1和2解决\n\nRACStream从实例变量来看只有一个`name`，当然它也只应该有个name - -，5解决\n\n　　里面重点问题就是上面的3和4了。由于**函数组合之后仍然是个函数**，所以也很容易理解**两个Stream对象的组合其实就是生成一个新的Stream对**象，它返回了分别由两个子Stream先后运算产生的最终结果\n\n 　　观摩一下RACStream定义的基本方法：\n\n``` objc\n+ (instancetype)empty;\n+ (instancetype)return:(id)value;\n- (instancetype)bind:(RACStreamBindBlock (^)(void))block; // for 4\n- (instancetype)concat:(RACStream *)stream; // for 3\n- (instancetype)zipWith:(RACStream *)stream; // for 3\n```\n　　RACStream作为一个描述抽象的父类，这几个基本方法并没有实现，是由具体子类来实现，RACStream的两个子类分别是`RACSignal`和`RACSequence`\n\n- `+empty` 是一个不返回值，立刻结束(Completed)的函数，意思是执行它之后除了立刻结束啥都不会发生，可以理解为RAC里面的nil。\n- `+return:` 是一个直接返回给定值，然后立刻结束的函数，比如 f(x) = 213\n- `-bind:`是一个非常重要的函数，在Rac Doc中被描述为‘**basic primitives, particularly**’，它是RACStream监测“值”和控制“运行状态”的基本方法，个人认为看注释文档不能理解它是干嘛的，而且bind英语“捆绑，绑定，强迫，约束”这几个意思也感觉对不上，我觉得叫“**绑架**”倒是更贴切一点。在-bind：之后，之前的RACStream就处于被“绑架”的状态，被绑架的RACStream每产生一个值，都要经过“绑架者”来决定：\n\n1. 是否使这个RACStream结束（被绑架者是否还能继续活着）\n2. 用什么新的RACStream来替换被绑架的RACStream，传出的结果也成了新RACStream产生的值（绑匪可以选择再抓一个人质放之前那个前面）\n\n 　　举个具体栗子，RACStream的 - take：方法，这个方法使一个RACStream只取前N次的值（有缩减）：\n\n``` objc\n- (instancetype)take:(NSUInteger)count {\n    Class class = self.class;\n\n    return [[self bind:^{ // self被绑架\n        __block NSUInteger taken = 0;\n\n        return ^ id (id value, BOOL *stop) { // 这个block在被绑架的self每输出一个值得时候触发\n            RACStream *result = class.empty;\n\n            if (taken < count) result = [class return:value]; // 未达到N次时将原值原原本本的传递出去\n            if (++taken >= count) *stop = YES; // 达到第N次值后干掉了被绑架的self\n\n            return result; // 将被绑架的self替换为result\n        };\n    }]];\n}\n```\n`-concat:` 和 `-zipWith:` 就是将两个RACStream连接起来的基本方法了：\n\n`[A concat:B]`中A和B像`皇上`和`太子`的关系，A是皇上，B是太子。皇上健在的时候统治天下发号施令（value），太子就候着，不发号施令（value），当皇上挂了（completed），太子登基当皇上，此时发出的号令（value）是太子的。\n`[C zipWith:D]`可以比喻成一对`平等恩爱的夫妻`，两个人是“绑在一起“的关系来组成一个家庭，决定一件事（value）时必须两个人都提出意见（当且仅当C和D同时都产生了值的时候，一个value才被输出，CD只有其中一个有值时会挂起等待另一个的值，所以输出都是一对值（RACTuple）），当夫妻只要一个人先挂了（completed）这个家庭（组合起来的RACStream）就宣布解散（也就是无法凑成一对输出时就终止）\n\n## 然后呢？\n\n除了上面几个基本方法，RACStream还有不少的Operation方法，这些操作方法的实现大都是组合基本的方法来达到特定的目的，虽然是RACStream这个基类实现的，但我觉得还是放在后面介绍RACSignal的时候作为它的使用方法来说比较合适，毕竟绝大多数编程的对象的都是RACStream的两个子类，后面再展开介绍好了。\n","source":"_posts/rac_2_racstream.md","raw":"title: Reactive Cocoa Tutorial [2] = 百变RACStream\ndate: 2014-03-06 22:34:27\ntags: Reactive Cocoa Tutorial\n---\nReactive Cocoa Tutorial 系列，转载请注明该文源地址 -- by sunny\n\n## Overview\n　　在RAC下开发干的最多的事就是建立RACSignal和subscribe RACSignal了，它是RAC的核心所在。本篇介绍了RAC的运作原理和设计思路，从函数式编程形成的RACStream继而介绍它的子类 - RAC最核心的部分RACSignal。\n\n## 函数式编程\n　　我们知道Reactive Cocoa是函数式编程(Functional Programing)(FP)思想的实现。FP有一套成熟的理论，这里只讲讲我个人理解吧。\n　　我觉得FP就是“**像计算函数表达式一样来解决一个问题**”，举个栗子，中学题：\n\n``` c\n已知：f(x) = 2sin(x + π/2)， 求 f(π/2)的值。\n```\n其中x是这个函数的输入，f(x)为计算的输出结果，求f(π/2)时给定了x自然能计算出个结果来（说实话我真忘了咋算了）\n当然，仔细看这个函数，其实是可以分解成几个小函数的：\n\n``` c\nf1(x) = x + π/2\nf2(x) = sin(x)\nf3(x) = 2x\n```\n而原来的f(x)可以被小函数组合：\n\n``` c\nf(x) = f3(f2(f1(x)))\n```\n　　所以不难得出这么个推论：要是我手上有足够的**基本函数**，我就能用上面的组合的方法组合出任意一个**复杂的函数**了。再想想事实上这些年来学数学的过程不就是在一个个积累基本函数的过程嘛，从基本运算，到三角函数，到乘方开方，再到微积分。基本函数越来越多，能解决的数学问题也越来越复杂。\n\n　　再来看一个函数是怎么构成的，FP理论里叫`monads`，十分抽象，没读懂，但能理解出来：一个函数只要有一个对于输入值的运算方法和一个返回值，就够了。也容易理解，给它一个输入，干点事情，给出一个输出，就行了，当然现实情况要复杂得多（比如说输出值本身就是个函数？）有些函数是有输入的条件的，比如原来数学解个函数时候经常跟个作用域或者限制条件，比如`f(x) = 10 / x , (x不为0)`，要是传个0这个函数就认为计算错误。\n\n　　对于像上面栗子的函数，每个函数都能接收上一个函数输出的结果，作为自己的输入，这样才能嵌套生成最终结果，同时，计算的顺序也是一定从里向外，所以换个写法可以写成：\n\n```\nstart ---x--> f1(x) --(temp value1)--> f2(temp value1) --(temp value2)--> f3(temp value2) ---> result\n```\n　　于是乎**嵌套**就被表示成了**序列**，来个高大上的名字怎么样，就叫**流（Stream）**\n\n## RACStream\n\n　　这就是`RACStream`所表示的含义。\n\n　　按照上面说的，其实`RACStream`的名字有点点歧义，对于一个`RACStream`对象，它在意义上等同于上面的f1(x),f2(x),f3(x)，而不是那一大串整体，表示整体的应该是最外层的和f(x)对应的那个对象，叫个RACStreamComponent比较好？理解时候得注意下。\n\n　　所以作为一个基本函数的RACStream应该至少应该有：\n\n 1. 怎么传入值\n 2. 怎么返回值\n 3. 怎么与其他函数组合\n 4. 怎么实现函数的作用域(监测输入值来做处理)\n 5. 这函数叫啥- -\n\n\n得益于在Objc下实现，所以输入输出的“值”都用个`id`类型就行了，遇到多个值的组合就用`RACTurple`（可以把多个值压包和解包，类比WINRAR），1和2解决\n\nRACStream从实例变量来看只有一个`name`，当然它也只应该有个name - -，5解决\n\n　　里面重点问题就是上面的3和4了。由于**函数组合之后仍然是个函数**，所以也很容易理解**两个Stream对象的组合其实就是生成一个新的Stream对**象，它返回了分别由两个子Stream先后运算产生的最终结果\n\n 　　观摩一下RACStream定义的基本方法：\n\n``` objc\n+ (instancetype)empty;\n+ (instancetype)return:(id)value;\n- (instancetype)bind:(RACStreamBindBlock (^)(void))block; // for 4\n- (instancetype)concat:(RACStream *)stream; // for 3\n- (instancetype)zipWith:(RACStream *)stream; // for 3\n```\n　　RACStream作为一个描述抽象的父类，这几个基本方法并没有实现，是由具体子类来实现，RACStream的两个子类分别是`RACSignal`和`RACSequence`\n\n- `+empty` 是一个不返回值，立刻结束(Completed)的函数，意思是执行它之后除了立刻结束啥都不会发生，可以理解为RAC里面的nil。\n- `+return:` 是一个直接返回给定值，然后立刻结束的函数，比如 f(x) = 213\n- `-bind:`是一个非常重要的函数，在Rac Doc中被描述为‘**basic primitives, particularly**’，它是RACStream监测“值”和控制“运行状态”的基本方法，个人认为看注释文档不能理解它是干嘛的，而且bind英语“捆绑，绑定，强迫，约束”这几个意思也感觉对不上，我觉得叫“**绑架**”倒是更贴切一点。在-bind：之后，之前的RACStream就处于被“绑架”的状态，被绑架的RACStream每产生一个值，都要经过“绑架者”来决定：\n\n1. 是否使这个RACStream结束（被绑架者是否还能继续活着）\n2. 用什么新的RACStream来替换被绑架的RACStream，传出的结果也成了新RACStream产生的值（绑匪可以选择再抓一个人质放之前那个前面）\n\n 　　举个具体栗子，RACStream的 - take：方法，这个方法使一个RACStream只取前N次的值（有缩减）：\n\n``` objc\n- (instancetype)take:(NSUInteger)count {\n    Class class = self.class;\n\n    return [[self bind:^{ // self被绑架\n        __block NSUInteger taken = 0;\n\n        return ^ id (id value, BOOL *stop) { // 这个block在被绑架的self每输出一个值得时候触发\n            RACStream *result = class.empty;\n\n            if (taken < count) result = [class return:value]; // 未达到N次时将原值原原本本的传递出去\n            if (++taken >= count) *stop = YES; // 达到第N次值后干掉了被绑架的self\n\n            return result; // 将被绑架的self替换为result\n        };\n    }]];\n}\n```\n`-concat:` 和 `-zipWith:` 就是将两个RACStream连接起来的基本方法了：\n\n`[A concat:B]`中A和B像`皇上`和`太子`的关系，A是皇上，B是太子。皇上健在的时候统治天下发号施令（value），太子就候着，不发号施令（value），当皇上挂了（completed），太子登基当皇上，此时发出的号令（value）是太子的。\n`[C zipWith:D]`可以比喻成一对`平等恩爱的夫妻`，两个人是“绑在一起“的关系来组成一个家庭，决定一件事（value）时必须两个人都提出意见（当且仅当C和D同时都产生了值的时候，一个value才被输出，CD只有其中一个有值时会挂起等待另一个的值，所以输出都是一对值（RACTuple）），当夫妻只要一个人先挂了（completed）这个家庭（组合起来的RACStream）就宣布解散（也就是无法凑成一对输出时就终止）\n\n## 然后呢？\n\n除了上面几个基本方法，RACStream还有不少的Operation方法，这些操作方法的实现大都是组合基本的方法来达到特定的目的，虽然是RACStream这个基类实现的，但我觉得还是放在后面介绍RACSignal的时候作为它的使用方法来说比较合适，毕竟绝大多数编程的对象的都是RACStream的两个子类，后面再展开介绍好了。\n","slug":"rac_2_racstream","published":1,"updated":"2016-03-27T09:16:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxmk0023ev12ypp0qc8a","content":"<p>Reactive Cocoa Tutorial 系列，转载请注明该文源地址 – by sunny</p>\n<h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p>　　在RAC下开发干的最多的事就是建立RACSignal和subscribe RACSignal了，它是RAC的核心所在。本篇介绍了RAC的运作原理和设计思路，从函数式编程形成的RACStream继而介绍它的子类 - RAC最核心的部分RACSignal。</p>\n<h2 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h2><p>　　我们知道Reactive Cocoa是函数式编程(Functional Programing)(FP)思想的实现。FP有一套成熟的理论，这里只讲讲我个人理解吧。<br>　　我觉得FP就是“<strong>像计算函数表达式一样来解决一个问题</strong>”，举个栗子，中学题：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">已知：f(x) = <span class=\"number\">2</span><span class=\"built_in\">sin</span>(x + π/<span class=\"number\">2</span>)， 求 f(π/<span class=\"number\">2</span>)的值。</span><br></pre></td></tr></table></figure>\n<p>其中x是这个函数的输入，f(x)为计算的输出结果，求f(π/2)时给定了x自然能计算出个结果来（说实话我真忘了咋算了）<br>当然，仔细看这个函数，其实是可以分解成几个小函数的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1(x) = x + π/<span class=\"number\">2</span></span><br><span class=\"line\">f2(x) = <span class=\"built_in\">sin</span>(x)</span><br><span class=\"line\">f3(x) = <span class=\"number\">2</span>x</span><br></pre></td></tr></table></figure>\n<p>而原来的f(x)可以被小函数组合：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(x) = f3(f2(f1(x)))</span><br></pre></td></tr></table></figure>\n<p>　　所以不难得出这么个推论：要是我手上有足够的<strong>基本函数</strong>，我就能用上面的组合的方法组合出任意一个<strong>复杂的函数</strong>了。再想想事实上这些年来学数学的过程不就是在一个个积累基本函数的过程嘛，从基本运算，到三角函数，到乘方开方，再到微积分。基本函数越来越多，能解决的数学问题也越来越复杂。</p>\n<p>　　再来看一个函数是怎么构成的，FP理论里叫<code>monads</code>，十分抽象，没读懂，但能理解出来：一个函数只要有一个对于输入值的运算方法和一个返回值，就够了。也容易理解，给它一个输入，干点事情，给出一个输出，就行了，当然现实情况要复杂得多（比如说输出值本身就是个函数？）有些函数是有输入的条件的，比如原来数学解个函数时候经常跟个作用域或者限制条件，比如<code>f(x) = 10 / x , (x不为0)</code>，要是传个0这个函数就认为计算错误。</p>\n<p>　　对于像上面栗子的函数，每个函数都能接收上一个函数输出的结果，作为自己的输入，这样才能嵌套生成最终结果，同时，计算的顺序也是一定从里向外，所以换个写法可以写成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start ---x--&gt; f1(x) --(temp value1)--&gt; f2(temp value1) --(temp value2)--&gt; f3(temp value2) ---&gt; result</span><br></pre></td></tr></table></figure>\n<p>　　于是乎<strong>嵌套</strong>就被表示成了<strong>序列</strong>，来个高大上的名字怎么样，就叫<strong>流（Stream）</strong></p>\n<h2 id=\"RACStream\"><a href=\"#RACStream\" class=\"headerlink\" title=\"RACStream\"></a>RACStream</h2><p>　　这就是<code>RACStream</code>所表示的含义。</p>\n<p>　　按照上面说的，其实<code>RACStream</code>的名字有点点歧义，对于一个<code>RACStream</code>对象，它在意义上等同于上面的f1(x),f2(x),f3(x)，而不是那一大串整体，表示整体的应该是最外层的和f(x)对应的那个对象，叫个RACStreamComponent比较好？理解时候得注意下。</p>\n<p>　　所以作为一个基本函数的RACStream应该至少应该有：</p>\n<ol>\n<li>怎么传入值</li>\n<li>怎么返回值</li>\n<li>怎么与其他函数组合</li>\n<li>怎么实现函数的作用域(监测输入值来做处理)</li>\n<li>这函数叫啥- -</li>\n</ol>\n<p>得益于在Objc下实现，所以输入输出的“值”都用个<code>id</code>类型就行了，遇到多个值的组合就用<code>RACTurple</code>（可以把多个值压包和解包，类比WINRAR），1和2解决</p>\n<p>RACStream从实例变量来看只有一个<code>name</code>，当然它也只应该有个name - -，5解决</p>\n<p>　　里面重点问题就是上面的3和4了。由于<strong>函数组合之后仍然是个函数</strong>，所以也很容易理解<strong>两个Stream对象的组合其实就是生成一个新的Stream对</strong>象，它返回了分别由两个子Stream先后运算产生的最终结果</p>\n<p> 　　观摩一下RACStream定义的基本方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (instancetype)empty;</span><br><span class=\"line\">+ (instancetype)<span class=\"keyword\">return</span>:(<span class=\"keyword\">id</span>)value;</span><br><span class=\"line\">- (instancetype)bind:(RACStreamBindBlock (^)(<span class=\"keyword\">void</span>))block; <span class=\"comment\">// for 4</span></span><br><span class=\"line\">- (instancetype)concat:(RACStream *)stream; <span class=\"comment\">// for 3</span></span><br><span class=\"line\">- (instancetype)zipWith:(RACStream *)stream; <span class=\"comment\">// for 3</span></span><br></pre></td></tr></table></figure>\n<p>　　RACStream作为一个描述抽象的父类，这几个基本方法并没有实现，是由具体子类来实现，RACStream的两个子类分别是<code>RACSignal</code>和<code>RACSequence</code></p>\n<ul>\n<li><code>+empty</code> 是一个不返回值，立刻结束(Completed)的函数，意思是执行它之后除了立刻结束啥都不会发生，可以理解为RAC里面的nil。</li>\n<li><code>+return:</code> 是一个直接返回给定值，然后立刻结束的函数，比如 f(x) = 213</li>\n<li><code>-bind:</code>是一个非常重要的函数，在Rac Doc中被描述为‘<strong>basic primitives, particularly</strong>’，它是RACStream监测“值”和控制“运行状态”的基本方法，个人认为看注释文档不能理解它是干嘛的，而且bind英语“捆绑，绑定，强迫，约束”这几个意思也感觉对不上，我觉得叫“<strong>绑架</strong>”倒是更贴切一点。在-bind：之后，之前的RACStream就处于被“绑架”的状态，被绑架的RACStream每产生一个值，都要经过“绑架者”来决定：</li>\n</ul>\n<ol>\n<li>是否使这个RACStream结束（被绑架者是否还能继续活着）</li>\n<li><p>用什么新的RACStream来替换被绑架的RACStream，传出的结果也成了新RACStream产生的值（绑匪可以选择再抓一个人质放之前那个前面）</p>\n<p>　　举个具体栗子，RACStream的 - take：方法，这个方法使一个RACStream只取前N次的值（有缩减）：</p>\n</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)take:(<span class=\"built_in\">NSUInteger</span>)count &#123;</span><br><span class=\"line\">    Class class = <span class=\"keyword\">self</span>.class;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[<span class=\"keyword\">self</span> bind:^&#123; <span class=\"comment\">// self被绑架</span></span><br><span class=\"line\">        __block <span class=\"built_in\">NSUInteger</span> taken = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ^ <span class=\"keyword\">id</span> (<span class=\"keyword\">id</span> value, <span class=\"built_in\">BOOL</span> *stop) &#123; <span class=\"comment\">// 这个block在被绑架的self每输出一个值得时候触发</span></span><br><span class=\"line\">            RACStream *result = class.empty;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (taken &lt; count) result = [class <span class=\"keyword\">return</span>:value]; <span class=\"comment\">// 未达到N次时将原值原原本本的传递出去</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++taken &gt;= count) *stop = <span class=\"literal\">YES</span>; <span class=\"comment\">// 达到第N次值后干掉了被绑架的self</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> result; <span class=\"comment\">// 将被绑架的self替换为result</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;]];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>-concat:</code> 和 <code>-zipWith:</code> 就是将两个RACStream连接起来的基本方法了：</p>\n<p><code>[A concat:B]</code>中A和B像<code>皇上</code>和<code>太子</code>的关系，A是皇上，B是太子。皇上健在的时候统治天下发号施令（value），太子就候着，不发号施令（value），当皇上挂了（completed），太子登基当皇上，此时发出的号令（value）是太子的。<br><code>[C zipWith:D]</code>可以比喻成一对<code>平等恩爱的夫妻</code>，两个人是“绑在一起“的关系来组成一个家庭，决定一件事（value）时必须两个人都提出意见（当且仅当C和D同时都产生了值的时候，一个value才被输出，CD只有其中一个有值时会挂起等待另一个的值，所以输出都是一对值（RACTuple）），当夫妻只要一个人先挂了（completed）这个家庭（组合起来的RACStream）就宣布解散（也就是无法凑成一对输出时就终止）</p>\n<h2 id=\"然后呢？\"><a href=\"#然后呢？\" class=\"headerlink\" title=\"然后呢？\"></a>然后呢？</h2><p>除了上面几个基本方法，RACStream还有不少的Operation方法，这些操作方法的实现大都是组合基本的方法来达到特定的目的，虽然是RACStream这个基类实现的，但我觉得还是放在后面介绍RACSignal的时候作为它的使用方法来说比较合适，毕竟绝大多数编程的对象的都是RACStream的两个子类，后面再展开介绍好了。</p>\n","excerpt":"","more":"<p>Reactive Cocoa Tutorial 系列，转载请注明该文源地址 – by sunny</p>\n<h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p>　　在RAC下开发干的最多的事就是建立RACSignal和subscribe RACSignal了，它是RAC的核心所在。本篇介绍了RAC的运作原理和设计思路，从函数式编程形成的RACStream继而介绍它的子类 - RAC最核心的部分RACSignal。</p>\n<h2 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h2><p>　　我们知道Reactive Cocoa是函数式编程(Functional Programing)(FP)思想的实现。FP有一套成熟的理论，这里只讲讲我个人理解吧。<br>　　我觉得FP就是“<strong>像计算函数表达式一样来解决一个问题</strong>”，举个栗子，中学题：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">已知：f(x) = <span class=\"number\">2</span><span class=\"built_in\">sin</span>(x + π/<span class=\"number\">2</span>)， 求 f(π/<span class=\"number\">2</span>)的值。</span><br></pre></td></tr></table></figure>\n<p>其中x是这个函数的输入，f(x)为计算的输出结果，求f(π/2)时给定了x自然能计算出个结果来（说实话我真忘了咋算了）<br>当然，仔细看这个函数，其实是可以分解成几个小函数的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1(x) = x + π/<span class=\"number\">2</span></span><br><span class=\"line\">f2(x) = <span class=\"built_in\">sin</span>(x)</span><br><span class=\"line\">f3(x) = <span class=\"number\">2</span>x</span><br></pre></td></tr></table></figure>\n<p>而原来的f(x)可以被小函数组合：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(x) = f3(f2(f1(x)))</span><br></pre></td></tr></table></figure>\n<p>　　所以不难得出这么个推论：要是我手上有足够的<strong>基本函数</strong>，我就能用上面的组合的方法组合出任意一个<strong>复杂的函数</strong>了。再想想事实上这些年来学数学的过程不就是在一个个积累基本函数的过程嘛，从基本运算，到三角函数，到乘方开方，再到微积分。基本函数越来越多，能解决的数学问题也越来越复杂。</p>\n<p>　　再来看一个函数是怎么构成的，FP理论里叫<code>monads</code>，十分抽象，没读懂，但能理解出来：一个函数只要有一个对于输入值的运算方法和一个返回值，就够了。也容易理解，给它一个输入，干点事情，给出一个输出，就行了，当然现实情况要复杂得多（比如说输出值本身就是个函数？）有些函数是有输入的条件的，比如原来数学解个函数时候经常跟个作用域或者限制条件，比如<code>f(x) = 10 / x , (x不为0)</code>，要是传个0这个函数就认为计算错误。</p>\n<p>　　对于像上面栗子的函数，每个函数都能接收上一个函数输出的结果，作为自己的输入，这样才能嵌套生成最终结果，同时，计算的顺序也是一定从里向外，所以换个写法可以写成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start ---x--&gt; f1(x) --(temp value1)--&gt; f2(temp value1) --(temp value2)--&gt; f3(temp value2) ---&gt; result</span><br></pre></td></tr></table></figure>\n<p>　　于是乎<strong>嵌套</strong>就被表示成了<strong>序列</strong>，来个高大上的名字怎么样，就叫<strong>流（Stream）</strong></p>\n<h2 id=\"RACStream\"><a href=\"#RACStream\" class=\"headerlink\" title=\"RACStream\"></a>RACStream</h2><p>　　这就是<code>RACStream</code>所表示的含义。</p>\n<p>　　按照上面说的，其实<code>RACStream</code>的名字有点点歧义，对于一个<code>RACStream</code>对象，它在意义上等同于上面的f1(x),f2(x),f3(x)，而不是那一大串整体，表示整体的应该是最外层的和f(x)对应的那个对象，叫个RACStreamComponent比较好？理解时候得注意下。</p>\n<p>　　所以作为一个基本函数的RACStream应该至少应该有：</p>\n<ol>\n<li>怎么传入值</li>\n<li>怎么返回值</li>\n<li>怎么与其他函数组合</li>\n<li>怎么实现函数的作用域(监测输入值来做处理)</li>\n<li>这函数叫啥- -</li>\n</ol>\n<p>得益于在Objc下实现，所以输入输出的“值”都用个<code>id</code>类型就行了，遇到多个值的组合就用<code>RACTurple</code>（可以把多个值压包和解包，类比WINRAR），1和2解决</p>\n<p>RACStream从实例变量来看只有一个<code>name</code>，当然它也只应该有个name - -，5解决</p>\n<p>　　里面重点问题就是上面的3和4了。由于<strong>函数组合之后仍然是个函数</strong>，所以也很容易理解<strong>两个Stream对象的组合其实就是生成一个新的Stream对</strong>象，它返回了分别由两个子Stream先后运算产生的最终结果</p>\n<p> 　　观摩一下RACStream定义的基本方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (instancetype)empty;</span><br><span class=\"line\">+ (instancetype)<span class=\"keyword\">return</span>:(<span class=\"keyword\">id</span>)value;</span><br><span class=\"line\">- (instancetype)bind:(RACStreamBindBlock (^)(<span class=\"keyword\">void</span>))block; <span class=\"comment\">// for 4</span></span><br><span class=\"line\">- (instancetype)concat:(RACStream *)stream; <span class=\"comment\">// for 3</span></span><br><span class=\"line\">- (instancetype)zipWith:(RACStream *)stream; <span class=\"comment\">// for 3</span></span><br></pre></td></tr></table></figure>\n<p>　　RACStream作为一个描述抽象的父类，这几个基本方法并没有实现，是由具体子类来实现，RACStream的两个子类分别是<code>RACSignal</code>和<code>RACSequence</code></p>\n<ul>\n<li><code>+empty</code> 是一个不返回值，立刻结束(Completed)的函数，意思是执行它之后除了立刻结束啥都不会发生，可以理解为RAC里面的nil。</li>\n<li><code>+return:</code> 是一个直接返回给定值，然后立刻结束的函数，比如 f(x) = 213</li>\n<li><code>-bind:</code>是一个非常重要的函数，在Rac Doc中被描述为‘<strong>basic primitives, particularly</strong>’，它是RACStream监测“值”和控制“运行状态”的基本方法，个人认为看注释文档不能理解它是干嘛的，而且bind英语“捆绑，绑定，强迫，约束”这几个意思也感觉对不上，我觉得叫“<strong>绑架</strong>”倒是更贴切一点。在-bind：之后，之前的RACStream就处于被“绑架”的状态，被绑架的RACStream每产生一个值，都要经过“绑架者”来决定：</li>\n</ul>\n<ol>\n<li>是否使这个RACStream结束（被绑架者是否还能继续活着）</li>\n<li><p>用什么新的RACStream来替换被绑架的RACStream，传出的结果也成了新RACStream产生的值（绑匪可以选择再抓一个人质放之前那个前面）</p>\n<p>　　举个具体栗子，RACStream的 - take：方法，这个方法使一个RACStream只取前N次的值（有缩减）：</p>\n</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)take:(<span class=\"built_in\">NSUInteger</span>)count &#123;</span><br><span class=\"line\">    Class class = <span class=\"keyword\">self</span>.class;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[<span class=\"keyword\">self</span> bind:^&#123; <span class=\"comment\">// self被绑架</span></span><br><span class=\"line\">        __block <span class=\"built_in\">NSUInteger</span> taken = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ^ <span class=\"keyword\">id</span> (<span class=\"keyword\">id</span> value, <span class=\"built_in\">BOOL</span> *stop) &#123; <span class=\"comment\">// 这个block在被绑架的self每输出一个值得时候触发</span></span><br><span class=\"line\">            RACStream *result = class.empty;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (taken &lt; count) result = [class <span class=\"keyword\">return</span>:value]; <span class=\"comment\">// 未达到N次时将原值原原本本的传递出去</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++taken &gt;= count) *stop = <span class=\"literal\">YES</span>; <span class=\"comment\">// 达到第N次值后干掉了被绑架的self</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> result; <span class=\"comment\">// 将被绑架的self替换为result</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;]];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>-concat:</code> 和 <code>-zipWith:</code> 就是将两个RACStream连接起来的基本方法了：</p>\n<p><code>[A concat:B]</code>中A和B像<code>皇上</code>和<code>太子</code>的关系，A是皇上，B是太子。皇上健在的时候统治天下发号施令（value），太子就候着，不发号施令（value），当皇上挂了（completed），太子登基当皇上，此时发出的号令（value）是太子的。<br><code>[C zipWith:D]</code>可以比喻成一对<code>平等恩爱的夫妻</code>，两个人是“绑在一起“的关系来组成一个家庭，决定一件事（value）时必须两个人都提出意见（当且仅当C和D同时都产生了值的时候，一个value才被输出，CD只有其中一个有值时会挂起等待另一个的值，所以输出都是一对值（RACTuple）），当夫妻只要一个人先挂了（completed）这个家庭（组合起来的RACStream）就宣布解散（也就是无法凑成一对输出时就终止）</p>\n<h2 id=\"然后呢？\"><a href=\"#然后呢？\" class=\"headerlink\" title=\"然后呢？\"></a>然后呢？</h2><p>除了上面几个基本方法，RACStream还有不少的Operation方法，这些操作方法的实现大都是组合基本的方法来达到特定的目的，虽然是RACStream这个基类实现的，但我觉得还是放在后面介绍RACSignal的时候作为它的使用方法来说比较合适，毕竟绝大多数编程的对象的都是RACStream的两个子类，后面再展开介绍好了。</p>\n"},{"title":"Reactive Cocoa Tutorial [3] = RACSignal的巧克力工厂","date":"2014-03-06T14:45:43.000Z","_content":"Reactive Cocoa Tutorial 系列，转载请注明该文源地址 http://blog.sunnyxx.com/2014/03/06/rac_3_racsignal/  -- by sunnyxx\n\n## Overview\n\n　　上一篇介绍了函数式编程和`RACStream`，使得函数得以串联起来，而它的具体子类，也是RAC编程中最重要的部分，`RACSignal`就是使得算式得以逐步运算并使其有意义的关键所在，本节主要介绍`RACSignal`的机理，具体的使用放到接下来的几节。\n\n\n<img src=\"http://pic.jschina.com.cn/0/12/03/96/12039600_602173.jpg\" width=\"400px\"/>\n\n\n## 巧克力工厂的运作模式\n\n　　RACStream实现了一个嵌套函数的结构，如f(x) = f1(f2(f3(x)))，但好像是考试卷子上的一道题，没有人去做它，没得出个结果的话这道题是没有意义的。\n\n　　OK，现在起将这个事儿都比喻成一个巧克力工厂，f(x)的结果是一块巧克力，f1,f2,f3代表巧克力生产的几个步骤，如果这个工厂不开工，它是没有意义的。\n\n　　再说RACSignal，引用RAC doc的描述：\n　　\n> “A signal, represented by the RACSignal class, is a push-driven\n> stream.”\n\n　　我觉得这个`push-driven`要想解释清楚，需要和RACSequence的`pull-driven`放在一起来看。在巧克力工厂，push-driven是“生产一个吃一个”，而pull-driven是“吃完一个才生产下一个”，对于工厂来说前者是主动模式：生产了巧克力就“push”给各个供销商，后者是被动模式：各个供销商过来“pull”产品时才给你现做巧克力。\n\n### Status\n\n　　所以，对于RACSigna的push-driven的生产模式，首先，当工厂发现没有供销商签合同准备要巧克力的时候，工厂当然没有必要开动生产；只要当有一个以上准备收货的经销商时，工厂才开动生产。这就是RACSignal的休眠（cold）和激活（hot）状态，也就是所谓的冷信号和热信号。一般情况下，一个RACSignal创建之后都处于cold状态，有人去subscribe才被激活。\n\n### Event\n\nRACSignal能产生且只能产生三种事件：next、completed，error。\n- next 表示这个 Signal 产生了一个值（成功生产了一块巧克力）\n- completed 表示 Signal 结束，结束信号只标志成功结束，不带值（一个批次的订单完成了）\n- error 表示 Signal 中出现错误，立刻结束（一个机器坏了，生产线立刻停止运转）\n\n工厂厂长存了所有供销商的 QQ，每当发生上面三件事情的一件时，都用 QQ 挨个儿发消息告诉他们，于是供销商就能根据生产状态决定要做点什么。当订单完成或者失败后，厂长就会把这个供销商的 QQ 删了，以后发消息的时候也就没必要通知他了。\n\n### Side Effects\nRACSignal在被subscribe的时候可能会产生副作用，先举个官方的栗子：\n\n``` objc\n__block int aNumber = 0;\n\n// Signal that will have the side effect of incrementing `aNumber` block\n// variable for each subscription before sending it.\nRACSignal *aSignal = [RACSignal createSignal:^ RACDisposable * (id<RACSubscriber> subscriber) {\n    aNumber++;\n    [subscriber sendNext:@(aNumber)];\n    [subscriber sendCompleted];\n    return nil;\n}];\n// This will print \"subscriber one: 1\"\n[aSignal subscribeNext:^(id x) {\n    NSLog(@\"subscriber one: %@\", x);\n}];\n// This will print \"subscriber two: 2\"\n[aSignal subscribeNext:^(id x) {\n    NSLog(@\"subscriber two: %@\", x);\n}];\n```\n上面的signal在作用域外部引用了一个int变量，同时在signal的运算过程中作为`next`事件的值返回，这就造成了所谓的`副作用`，因为第二个订阅者的订阅而影响了输出值。\n\n我的理解来看，这个事儿做的就不太地道，一个正经的函数式编程中的函数是不应该因为进行了运算而导致后面运算的值不统一的。但对于实际应用的情况来看也到无可厚非，比如用户点击了“登录”按钮，编程时把登录这个业务写为一个login的RACSignal，当然，第一次调用登录和再点一次第二次调用登录的结果肯定不一样了。所以说RAC式编程减少了大部分对临时状态值的定义，但不是全部哦。\n\n怎么办呢？我觉得最好的办法就是“约定”，RAC design guide里面介绍了对于一个signal的命名法则：\n\n> Hot signals without side effects 最好使用property，如“textChanged”，不太理解什么情况用到这个，权当做一个静态的属性来看就行。\n    Cold signals without side effects 使用名词类型的方法名，如“-currentText”，“currentModels”，同时表明了返回值是个啥（这个尤其得注意，RACSignal的next值是id类型，所以全得是靠约定才知道具体返回类型）\n    Signals with side effects 这种就是像login一样有副作用的了，推荐使用动词类型的方法名，用对动词基本就能知道是不是有副作用了，比如“-loginSignal”和“-saveToFile”大概就知道前面一个很可能有副作用，后面一个多存几次文件应该没副作用\n\n　　当然，也可以`multicast`一个event，使得某些特殊的情况来共享一个副作用，后面再具体讲，先一个官方的简单的栗子：\n\n``` objc\n// This signal starts a new request on each subscription.\nRACSignal *networkRequest = [RACSignal createSignal:^(id<RACSubscriber> subscriber) {\n    AFHTTPRequestOperation *operation = [client\n        HTTPRequestOperationWithRequest:request\n        success:^(AFHTTPRequestOperation *operation, id response) {\n            [subscriber sendNext:response];\n            [subscriber sendCompleted];\n        }\n        failure:^(AFHTTPRequestOperation *operation, NSError *error) {\n            [subscriber sendError:error];\n        }];\n\n    [client enqueueHTTPRequestOperation:operation];\n    return [RACDisposable disposableWithBlock:^{\n        [operation cancel];\n    }];\n}];\n\n// Starts a single request, no matter how many subscriptions `connection.signal`\n// gets. This is equivalent to the -replay operator, or similar to\n// +startEagerlyWithScheduler:block:.\nRACMulticastConnection *connection = [networkRequest multicast:[RACReplaySubject subject]];\n[connection connect];\n\n[connection.signal subscribeNext:^(id response) {\n    NSLog(@\"subscriber one: %@\", response);\n}];\n\n[connection.signal subscribeNext:^(id response) {\n    NSLog(@\"subscriber two: %@\", response);\n}];\n```\n当地一个订阅者subscribeNext的时候触发了AFNetworkingOperation的创建和执行，开始网络请求，此时又来了个订阅者订阅这个Signal，按理说这个网络请求会被“副作用”，重新发一遍，但做了上面的处理之后，这两个订阅者接收到了同样的一个请求的内容。\n\n### RACScheduler - 生产线\n\nRACScheduler是RAC里面对线程的简单封装，事件可以在指定的scheduler上分发和执行，不特殊指定的话，事件的分发和执行都在一个默认的后台线程里面做，大多数情况也就不用动了，有一些特殊的signal必须在主线程调用，使用-deliverOn：可以切换调用的线程。\n\n但值得特殊了解的事实是：\n\n> However, RAC guarantees that no two signal events will ever arrive concurrently. While an event is being processed, no other events will be delivered. The senders of any other events will be forced to wait until the current event has been handled.\n\n意思是订阅者执行时的block一定非并发执行，也就是说不会执行到一半被另一个线程进入，也意味着写subscribeXXX block的时候没必要做加锁处理了。\n\n### 巧克力的生产工艺\n\n　　RACSignal的厂子建好了，运行的模式也都想好了，剩下的就是巧克力的加工工艺了。\n\n　　有了RACStream的嵌套和组装的基础，RACSignal得以使用组件化的工艺来一步步的加工巧克力，从可可，牛奶，糖等原料，混合到这种巧克力适用的液态巧克力，过滤，提纯，冷却，夹心，压模，再到包装，一个巧克力就产出了。对于不同种类的巧克力，比如酒心巧克力，也不过是把其中的某个组件替换成注入酒心罢了。\n\n　　RACSignal的生产组件，也就是它的各式各样的operation，一个具体业务逻辑的实现，其实也就是选择合适operation按合适的顺序组合起来。\n\n　　还举那个用户在textFiled输入并显示到上面的label中的栗子:\n\n``` objc\nRAC(self.outputLabel, text) = self.inputTextField.rac_textSignal;\n```\n　　现在需求变成“用户输入3个字母以上才输出到label，当不足3个时显示提示”，OK，好办：\n\n``` objc\nRAC(self.outputLabel, text) = [[self.inputTextField.rac_textSignal\n    startWith:@\"key is >3\"] /* startWith 一开始返回的初始值 */\n    filter:^BOOL(NSString *value) {\n        return value.length > 3; /* filter使满足条件的值才能传出 */\n}];\n```\n\n需求又增加成“**当输入sunny时显示输入正确**”\n\n``` objc\nRAC(self.outputLabel, text) = [[self.inputTextField.rac_textSignal\n    startWith:@\"key is >3\"] // startWith 一开始返回的初始值\n    filter:^BOOL(NSString *value) { // filter使满足条件的值才能传出\n        return value.length > 3;\n    }]\n    map:(NSString *value) {　// map将一个值转化为另一个值输出\n        return [value isEqualToString:@\"sunny\"] ? @\"bingo!\" : value;\n    }];\n```\n可以看出，基本上一个业务逻辑经过分析后可以拆解成一个个小RACSignal的组合，也就像生产巧克力的一道道工艺了。上面的栗子慢慢感觉就像了一个简陋的输答案的框了。\n\n###然后呢？\n\n接下来的几节就具体介绍一下RACSignal的operation方法，RAC提供了很多操作方法，大概总结为几大类：过滤型、XXX型、XXX型，后面再慢慢道来。\n","source":"_posts/rac_3_racsignal.md","raw":"title: Reactive Cocoa Tutorial [3] = RACSignal的巧克力工厂\ndate: 2014-03-06 22:45:43\ntags: Reactive Cocoa Tutorial\n---\nReactive Cocoa Tutorial 系列，转载请注明该文源地址 http://blog.sunnyxx.com/2014/03/06/rac_3_racsignal/  -- by sunnyxx\n\n## Overview\n\n　　上一篇介绍了函数式编程和`RACStream`，使得函数得以串联起来，而它的具体子类，也是RAC编程中最重要的部分，`RACSignal`就是使得算式得以逐步运算并使其有意义的关键所在，本节主要介绍`RACSignal`的机理，具体的使用放到接下来的几节。\n\n\n<img src=\"http://pic.jschina.com.cn/0/12/03/96/12039600_602173.jpg\" width=\"400px\"/>\n\n\n## 巧克力工厂的运作模式\n\n　　RACStream实现了一个嵌套函数的结构，如f(x) = f1(f2(f3(x)))，但好像是考试卷子上的一道题，没有人去做它，没得出个结果的话这道题是没有意义的。\n\n　　OK，现在起将这个事儿都比喻成一个巧克力工厂，f(x)的结果是一块巧克力，f1,f2,f3代表巧克力生产的几个步骤，如果这个工厂不开工，它是没有意义的。\n\n　　再说RACSignal，引用RAC doc的描述：\n　　\n> “A signal, represented by the RACSignal class, is a push-driven\n> stream.”\n\n　　我觉得这个`push-driven`要想解释清楚，需要和RACSequence的`pull-driven`放在一起来看。在巧克力工厂，push-driven是“生产一个吃一个”，而pull-driven是“吃完一个才生产下一个”，对于工厂来说前者是主动模式：生产了巧克力就“push”给各个供销商，后者是被动模式：各个供销商过来“pull”产品时才给你现做巧克力。\n\n### Status\n\n　　所以，对于RACSigna的push-driven的生产模式，首先，当工厂发现没有供销商签合同准备要巧克力的时候，工厂当然没有必要开动生产；只要当有一个以上准备收货的经销商时，工厂才开动生产。这就是RACSignal的休眠（cold）和激活（hot）状态，也就是所谓的冷信号和热信号。一般情况下，一个RACSignal创建之后都处于cold状态，有人去subscribe才被激活。\n\n### Event\n\nRACSignal能产生且只能产生三种事件：next、completed，error。\n- next 表示这个 Signal 产生了一个值（成功生产了一块巧克力）\n- completed 表示 Signal 结束，结束信号只标志成功结束，不带值（一个批次的订单完成了）\n- error 表示 Signal 中出现错误，立刻结束（一个机器坏了，生产线立刻停止运转）\n\n工厂厂长存了所有供销商的 QQ，每当发生上面三件事情的一件时，都用 QQ 挨个儿发消息告诉他们，于是供销商就能根据生产状态决定要做点什么。当订单完成或者失败后，厂长就会把这个供销商的 QQ 删了，以后发消息的时候也就没必要通知他了。\n\n### Side Effects\nRACSignal在被subscribe的时候可能会产生副作用，先举个官方的栗子：\n\n``` objc\n__block int aNumber = 0;\n\n// Signal that will have the side effect of incrementing `aNumber` block\n// variable for each subscription before sending it.\nRACSignal *aSignal = [RACSignal createSignal:^ RACDisposable * (id<RACSubscriber> subscriber) {\n    aNumber++;\n    [subscriber sendNext:@(aNumber)];\n    [subscriber sendCompleted];\n    return nil;\n}];\n// This will print \"subscriber one: 1\"\n[aSignal subscribeNext:^(id x) {\n    NSLog(@\"subscriber one: %@\", x);\n}];\n// This will print \"subscriber two: 2\"\n[aSignal subscribeNext:^(id x) {\n    NSLog(@\"subscriber two: %@\", x);\n}];\n```\n上面的signal在作用域外部引用了一个int变量，同时在signal的运算过程中作为`next`事件的值返回，这就造成了所谓的`副作用`，因为第二个订阅者的订阅而影响了输出值。\n\n我的理解来看，这个事儿做的就不太地道，一个正经的函数式编程中的函数是不应该因为进行了运算而导致后面运算的值不统一的。但对于实际应用的情况来看也到无可厚非，比如用户点击了“登录”按钮，编程时把登录这个业务写为一个login的RACSignal，当然，第一次调用登录和再点一次第二次调用登录的结果肯定不一样了。所以说RAC式编程减少了大部分对临时状态值的定义，但不是全部哦。\n\n怎么办呢？我觉得最好的办法就是“约定”，RAC design guide里面介绍了对于一个signal的命名法则：\n\n> Hot signals without side effects 最好使用property，如“textChanged”，不太理解什么情况用到这个，权当做一个静态的属性来看就行。\n    Cold signals without side effects 使用名词类型的方法名，如“-currentText”，“currentModels”，同时表明了返回值是个啥（这个尤其得注意，RACSignal的next值是id类型，所以全得是靠约定才知道具体返回类型）\n    Signals with side effects 这种就是像login一样有副作用的了，推荐使用动词类型的方法名，用对动词基本就能知道是不是有副作用了，比如“-loginSignal”和“-saveToFile”大概就知道前面一个很可能有副作用，后面一个多存几次文件应该没副作用\n\n　　当然，也可以`multicast`一个event，使得某些特殊的情况来共享一个副作用，后面再具体讲，先一个官方的简单的栗子：\n\n``` objc\n// This signal starts a new request on each subscription.\nRACSignal *networkRequest = [RACSignal createSignal:^(id<RACSubscriber> subscriber) {\n    AFHTTPRequestOperation *operation = [client\n        HTTPRequestOperationWithRequest:request\n        success:^(AFHTTPRequestOperation *operation, id response) {\n            [subscriber sendNext:response];\n            [subscriber sendCompleted];\n        }\n        failure:^(AFHTTPRequestOperation *operation, NSError *error) {\n            [subscriber sendError:error];\n        }];\n\n    [client enqueueHTTPRequestOperation:operation];\n    return [RACDisposable disposableWithBlock:^{\n        [operation cancel];\n    }];\n}];\n\n// Starts a single request, no matter how many subscriptions `connection.signal`\n// gets. This is equivalent to the -replay operator, or similar to\n// +startEagerlyWithScheduler:block:.\nRACMulticastConnection *connection = [networkRequest multicast:[RACReplaySubject subject]];\n[connection connect];\n\n[connection.signal subscribeNext:^(id response) {\n    NSLog(@\"subscriber one: %@\", response);\n}];\n\n[connection.signal subscribeNext:^(id response) {\n    NSLog(@\"subscriber two: %@\", response);\n}];\n```\n当地一个订阅者subscribeNext的时候触发了AFNetworkingOperation的创建和执行，开始网络请求，此时又来了个订阅者订阅这个Signal，按理说这个网络请求会被“副作用”，重新发一遍，但做了上面的处理之后，这两个订阅者接收到了同样的一个请求的内容。\n\n### RACScheduler - 生产线\n\nRACScheduler是RAC里面对线程的简单封装，事件可以在指定的scheduler上分发和执行，不特殊指定的话，事件的分发和执行都在一个默认的后台线程里面做，大多数情况也就不用动了，有一些特殊的signal必须在主线程调用，使用-deliverOn：可以切换调用的线程。\n\n但值得特殊了解的事实是：\n\n> However, RAC guarantees that no two signal events will ever arrive concurrently. While an event is being processed, no other events will be delivered. The senders of any other events will be forced to wait until the current event has been handled.\n\n意思是订阅者执行时的block一定非并发执行，也就是说不会执行到一半被另一个线程进入，也意味着写subscribeXXX block的时候没必要做加锁处理了。\n\n### 巧克力的生产工艺\n\n　　RACSignal的厂子建好了，运行的模式也都想好了，剩下的就是巧克力的加工工艺了。\n\n　　有了RACStream的嵌套和组装的基础，RACSignal得以使用组件化的工艺来一步步的加工巧克力，从可可，牛奶，糖等原料，混合到这种巧克力适用的液态巧克力，过滤，提纯，冷却，夹心，压模，再到包装，一个巧克力就产出了。对于不同种类的巧克力，比如酒心巧克力，也不过是把其中的某个组件替换成注入酒心罢了。\n\n　　RACSignal的生产组件，也就是它的各式各样的operation，一个具体业务逻辑的实现，其实也就是选择合适operation按合适的顺序组合起来。\n\n　　还举那个用户在textFiled输入并显示到上面的label中的栗子:\n\n``` objc\nRAC(self.outputLabel, text) = self.inputTextField.rac_textSignal;\n```\n　　现在需求变成“用户输入3个字母以上才输出到label，当不足3个时显示提示”，OK，好办：\n\n``` objc\nRAC(self.outputLabel, text) = [[self.inputTextField.rac_textSignal\n    startWith:@\"key is >3\"] /* startWith 一开始返回的初始值 */\n    filter:^BOOL(NSString *value) {\n        return value.length > 3; /* filter使满足条件的值才能传出 */\n}];\n```\n\n需求又增加成“**当输入sunny时显示输入正确**”\n\n``` objc\nRAC(self.outputLabel, text) = [[self.inputTextField.rac_textSignal\n    startWith:@\"key is >3\"] // startWith 一开始返回的初始值\n    filter:^BOOL(NSString *value) { // filter使满足条件的值才能传出\n        return value.length > 3;\n    }]\n    map:(NSString *value) {　// map将一个值转化为另一个值输出\n        return [value isEqualToString:@\"sunny\"] ? @\"bingo!\" : value;\n    }];\n```\n可以看出，基本上一个业务逻辑经过分析后可以拆解成一个个小RACSignal的组合，也就像生产巧克力的一道道工艺了。上面的栗子慢慢感觉就像了一个简陋的输答案的框了。\n\n###然后呢？\n\n接下来的几节就具体介绍一下RACSignal的operation方法，RAC提供了很多操作方法，大概总结为几大类：过滤型、XXX型、XXX型，后面再慢慢道来。\n","slug":"rac_3_racsignal","published":1,"updated":"2016-03-27T09:11:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxmo0025ev12jxjiekp6","content":"<p>Reactive Cocoa Tutorial 系列，转载请注明该文源地址 <a href=\"http://blog.sunnyxx.com/2014/03/06/rac_3_racsignal/\">http://blog.sunnyxx.com/2014/03/06/rac_3_racsignal/</a>  – by sunnyxx</p>\n<h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p>　　上一篇介绍了函数式编程和<code>RACStream</code>，使得函数得以串联起来，而它的具体子类，也是RAC编程中最重要的部分，<code>RACSignal</code>就是使得算式得以逐步运算并使其有意义的关键所在，本节主要介绍<code>RACSignal</code>的机理，具体的使用放到接下来的几节。</p>\n<p><img src=\"http://pic.jschina.com.cn/0/12/03/96/12039600_602173.jpg\" width=\"400px\"></p>\n<h2 id=\"巧克力工厂的运作模式\"><a href=\"#巧克力工厂的运作模式\" class=\"headerlink\" title=\"巧克力工厂的运作模式\"></a>巧克力工厂的运作模式</h2><p>　　RACStream实现了一个嵌套函数的结构，如f(x) = f1(f2(f3(x)))，但好像是考试卷子上的一道题，没有人去做它，没得出个结果的话这道题是没有意义的。</p>\n<p>　　OK，现在起将这个事儿都比喻成一个巧克力工厂，f(x)的结果是一块巧克力，f1,f2,f3代表巧克力生产的几个步骤，如果这个工厂不开工，它是没有意义的。</p>\n<p>　　再说RACSignal，引用RAC doc的描述：\n　　</p>\n<blockquote>\n<p>“A signal, represented by the RACSignal class, is a push-driven<br>stream.”</p>\n</blockquote>\n<p>　　我觉得这个<code>push-driven</code>要想解释清楚，需要和RACSequence的<code>pull-driven</code>放在一起来看。在巧克力工厂，push-driven是“生产一个吃一个”，而pull-driven是“吃完一个才生产下一个”，对于工厂来说前者是主动模式：生产了巧克力就“push”给各个供销商，后者是被动模式：各个供销商过来“pull”产品时才给你现做巧克力。</p>\n<h3 id=\"Status\"><a href=\"#Status\" class=\"headerlink\" title=\"Status\"></a>Status</h3><p>　　所以，对于RACSigna的push-driven的生产模式，首先，当工厂发现没有供销商签合同准备要巧克力的时候，工厂当然没有必要开动生产；只要当有一个以上准备收货的经销商时，工厂才开动生产。这就是RACSignal的休眠（cold）和激活（hot）状态，也就是所谓的冷信号和热信号。一般情况下，一个RACSignal创建之后都处于cold状态，有人去subscribe才被激活。</p>\n<h3 id=\"Event\"><a href=\"#Event\" class=\"headerlink\" title=\"Event\"></a>Event</h3><p>RACSignal能产生且只能产生三种事件：next、completed，error。</p>\n<ul>\n<li>next 表示这个 Signal 产生了一个值（成功生产了一块巧克力）</li>\n<li>completed 表示 Signal 结束，结束信号只标志成功结束，不带值（一个批次的订单完成了）</li>\n<li>error 表示 Signal 中出现错误，立刻结束（一个机器坏了，生产线立刻停止运转）</li>\n</ul>\n<p>工厂厂长存了所有供销商的 QQ，每当发生上面三件事情的一件时，都用 QQ 挨个儿发消息告诉他们，于是供销商就能根据生产状态决定要做点什么。当订单完成或者失败后，厂长就会把这个供销商的 QQ 删了，以后发消息的时候也就没必要通知他了。</p>\n<h3 id=\"Side-Effects\"><a href=\"#Side-Effects\" class=\"headerlink\" title=\"Side Effects\"></a>Side Effects</h3><p>RACSignal在被subscribe的时候可能会产生副作用，先举个官方的栗子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__block <span class=\"keyword\">int</span> aNumber = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Signal that will have the side effect of incrementing `aNumber` block</span></span><br><span class=\"line\"><span class=\"comment\">// variable for each subscription before sending it.</span></span><br><span class=\"line\">RACSignal *aSignal = [RACSignal createSignal:^ RACDisposable * (<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class=\"line\">    aNumber++;</span><br><span class=\"line\">    [subscriber sendNext:@(aNumber)];</span><br><span class=\"line\">    [subscriber sendCompleted];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"><span class=\"comment\">// This will print \"subscriber one: 1\"</span></span><br><span class=\"line\">[aSignal subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"subscriber one: %@\"</span>, x);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"><span class=\"comment\">// This will print \"subscriber two: 2\"</span></span><br><span class=\"line\">[aSignal subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"subscriber two: %@\"</span>, x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>上面的signal在作用域外部引用了一个int变量，同时在signal的运算过程中作为<code>next</code>事件的值返回，这就造成了所谓的<code>副作用</code>，因为第二个订阅者的订阅而影响了输出值。</p>\n<p>我的理解来看，这个事儿做的就不太地道，一个正经的函数式编程中的函数是不应该因为进行了运算而导致后面运算的值不统一的。但对于实际应用的情况来看也到无可厚非，比如用户点击了“登录”按钮，编程时把登录这个业务写为一个login的RACSignal，当然，第一次调用登录和再点一次第二次调用登录的结果肯定不一样了。所以说RAC式编程减少了大部分对临时状态值的定义，但不是全部哦。</p>\n<p>怎么办呢？我觉得最好的办法就是“约定”，RAC design guide里面介绍了对于一个signal的命名法则：</p>\n<blockquote>\n<p>Hot signals without side effects 最好使用property，如“textChanged”，不太理解什么情况用到这个，权当做一个静态的属性来看就行。<br>    Cold signals without side effects 使用名词类型的方法名，如“-currentText”，“currentModels”，同时表明了返回值是个啥（这个尤其得注意，RACSignal的next值是id类型，所以全得是靠约定才知道具体返回类型）<br>    Signals with side effects 这种就是像login一样有副作用的了，推荐使用动词类型的方法名，用对动词基本就能知道是不是有副作用了，比如“-loginSignal”和“-saveToFile”大概就知道前面一个很可能有副作用，后面一个多存几次文件应该没副作用</p>\n</blockquote>\n<p>　　当然，也可以<code>multicast</code>一个event，使得某些特殊的情况来共享一个副作用，后面再具体讲，先一个官方的简单的栗子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This signal starts a new request on each subscription.</span></span><br><span class=\"line\">RACSignal *networkRequest = [RACSignal createSignal:^(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class=\"line\">    AFHTTPRequestOperation *operation = [client</span><br><span class=\"line\">        HTTPRequestOperationWithRequest:request</span><br><span class=\"line\">        success:^(AFHTTPRequestOperation *operation, <span class=\"keyword\">id</span> response) &#123;</span><br><span class=\"line\">            [subscriber sendNext:response];</span><br><span class=\"line\">            [subscriber sendCompleted];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        failure:^(AFHTTPRequestOperation *operation, <span class=\"built_in\">NSError</span> *error) &#123;</span><br><span class=\"line\">            [subscriber sendError:error];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    [client enqueueHTTPRequestOperation:operation];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class=\"line\">        [operation cancel];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Starts a single request, no matter how many subscriptions `connection.signal`</span></span><br><span class=\"line\"><span class=\"comment\">// gets. This is equivalent to the -replay operator, or similar to</span></span><br><span class=\"line\"><span class=\"comment\">// +startEagerlyWithScheduler:block:.</span></span><br><span class=\"line\">RACMulticastConnection *connection = [networkRequest multicast:[RACReplaySubject subject]];</span><br><span class=\"line\">[connection connect];</span><br><span class=\"line\"></span><br><span class=\"line\">[connection.signal subscribeNext:^(<span class=\"keyword\">id</span> response) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"subscriber one: %@\"</span>, response);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[connection.signal subscribeNext:^(<span class=\"keyword\">id</span> response) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"subscriber two: %@\"</span>, response);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>当地一个订阅者subscribeNext的时候触发了AFNetworkingOperation的创建和执行，开始网络请求，此时又来了个订阅者订阅这个Signal，按理说这个网络请求会被“副作用”，重新发一遍，但做了上面的处理之后，这两个订阅者接收到了同样的一个请求的内容。</p>\n<h3 id=\"RACScheduler-生产线\"><a href=\"#RACScheduler-生产线\" class=\"headerlink\" title=\"RACScheduler - 生产线\"></a>RACScheduler - 生产线</h3><p>RACScheduler是RAC里面对线程的简单封装，事件可以在指定的scheduler上分发和执行，不特殊指定的话，事件的分发和执行都在一个默认的后台线程里面做，大多数情况也就不用动了，有一些特殊的signal必须在主线程调用，使用-deliverOn：可以切换调用的线程。</p>\n<p>但值得特殊了解的事实是：</p>\n<blockquote>\n<p>However, RAC guarantees that no two signal events will ever arrive concurrently. While an event is being processed, no other events will be delivered. The senders of any other events will be forced to wait until the current event has been handled.</p>\n</blockquote>\n<p>意思是订阅者执行时的block一定非并发执行，也就是说不会执行到一半被另一个线程进入，也意味着写subscribeXXX block的时候没必要做加锁处理了。</p>\n<h3 id=\"巧克力的生产工艺\"><a href=\"#巧克力的生产工艺\" class=\"headerlink\" title=\"巧克力的生产工艺\"></a>巧克力的生产工艺</h3><p>　　RACSignal的厂子建好了，运行的模式也都想好了，剩下的就是巧克力的加工工艺了。</p>\n<p>　　有了RACStream的嵌套和组装的基础，RACSignal得以使用组件化的工艺来一步步的加工巧克力，从可可，牛奶，糖等原料，混合到这种巧克力适用的液态巧克力，过滤，提纯，冷却，夹心，压模，再到包装，一个巧克力就产出了。对于不同种类的巧克力，比如酒心巧克力，也不过是把其中的某个组件替换成注入酒心罢了。</p>\n<p>　　RACSignal的生产组件，也就是它的各式各样的operation，一个具体业务逻辑的实现，其实也就是选择合适operation按合适的顺序组合起来。</p>\n<p>　　还举那个用户在textFiled输入并显示到上面的label中的栗子:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RAC(<span class=\"keyword\">self</span>.outputLabel, text) = <span class=\"keyword\">self</span>.inputTextField.rac_textSignal;</span><br></pre></td></tr></table></figure>\n<p>　　现在需求变成“用户输入3个字母以上才输出到label，当不足3个时显示提示”，OK，好办：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RAC(<span class=\"keyword\">self</span>.outputLabel, text) = [[<span class=\"keyword\">self</span>.inputTextField.rac_textSignal</span><br><span class=\"line\">    startWith:<span class=\"string\">@\"key is &gt;3\"</span>] <span class=\"comment\">/* startWith 一开始返回的初始值 */</span></span><br><span class=\"line\">    filter:^<span class=\"built_in\">BOOL</span>(<span class=\"built_in\">NSString</span> *value) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.length &gt; <span class=\"number\">3</span>; <span class=\"comment\">/* filter使满足条件的值才能传出 */</span></span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>需求又增加成“<strong>当输入sunny时显示输入正确</strong>”</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RAC(<span class=\"keyword\">self</span>.outputLabel, text) = [[<span class=\"keyword\">self</span>.inputTextField.rac_textSignal</span><br><span class=\"line\">    startWith:<span class=\"string\">@\"key is &gt;3\"</span>] <span class=\"comment\">// startWith 一开始返回的初始值</span></span><br><span class=\"line\">    filter:^<span class=\"built_in\">BOOL</span>(<span class=\"built_in\">NSString</span> *value) &#123; <span class=\"comment\">// filter使满足条件的值才能传出</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.length &gt; <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">    map:(<span class=\"built_in\">NSString</span> *value) &#123;　<span class=\"comment\">// map将一个值转化为另一个值输出</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [value isEqualToString:<span class=\"string\">@\"sunny\"</span>] ? <span class=\"string\">@\"bingo!\"</span> : value;</span><br><span class=\"line\">    &#125;];</span><br></pre></td></tr></table></figure>\n<p>可以看出，基本上一个业务逻辑经过分析后可以拆解成一个个小RACSignal的组合，也就像生产巧克力的一道道工艺了。上面的栗子慢慢感觉就像了一个简陋的输答案的框了。</p>\n<p>###然后呢？</p>\n<p>接下来的几节就具体介绍一下RACSignal的operation方法，RAC提供了很多操作方法，大概总结为几大类：过滤型、XXX型、XXX型，后面再慢慢道来。</p>\n","excerpt":"","more":"<p>Reactive Cocoa Tutorial 系列，转载请注明该文源地址 <a href=\"http://blog.sunnyxx.com/2014/03/06/rac_3_racsignal/\">http://blog.sunnyxx.com/2014/03/06/rac_3_racsignal/</a>  – by sunnyxx</p>\n<h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p>　　上一篇介绍了函数式编程和<code>RACStream</code>，使得函数得以串联起来，而它的具体子类，也是RAC编程中最重要的部分，<code>RACSignal</code>就是使得算式得以逐步运算并使其有意义的关键所在，本节主要介绍<code>RACSignal</code>的机理，具体的使用放到接下来的几节。</p>\n<p><img src=\"http://pic.jschina.com.cn/0/12/03/96/12039600_602173.jpg\" width=\"400px\"/></p>\n<h2 id=\"巧克力工厂的运作模式\"><a href=\"#巧克力工厂的运作模式\" class=\"headerlink\" title=\"巧克力工厂的运作模式\"></a>巧克力工厂的运作模式</h2><p>　　RACStream实现了一个嵌套函数的结构，如f(x) = f1(f2(f3(x)))，但好像是考试卷子上的一道题，没有人去做它，没得出个结果的话这道题是没有意义的。</p>\n<p>　　OK，现在起将这个事儿都比喻成一个巧克力工厂，f(x)的结果是一块巧克力，f1,f2,f3代表巧克力生产的几个步骤，如果这个工厂不开工，它是没有意义的。</p>\n<p>　　再说RACSignal，引用RAC doc的描述：\n　　</p>\n<blockquote>\n<p>“A signal, represented by the RACSignal class, is a push-driven<br>stream.”</p>\n</blockquote>\n<p>　　我觉得这个<code>push-driven</code>要想解释清楚，需要和RACSequence的<code>pull-driven</code>放在一起来看。在巧克力工厂，push-driven是“生产一个吃一个”，而pull-driven是“吃完一个才生产下一个”，对于工厂来说前者是主动模式：生产了巧克力就“push”给各个供销商，后者是被动模式：各个供销商过来“pull”产品时才给你现做巧克力。</p>\n<h3 id=\"Status\"><a href=\"#Status\" class=\"headerlink\" title=\"Status\"></a>Status</h3><p>　　所以，对于RACSigna的push-driven的生产模式，首先，当工厂发现没有供销商签合同准备要巧克力的时候，工厂当然没有必要开动生产；只要当有一个以上准备收货的经销商时，工厂才开动生产。这就是RACSignal的休眠（cold）和激活（hot）状态，也就是所谓的冷信号和热信号。一般情况下，一个RACSignal创建之后都处于cold状态，有人去subscribe才被激活。</p>\n<h3 id=\"Event\"><a href=\"#Event\" class=\"headerlink\" title=\"Event\"></a>Event</h3><p>RACSignal能产生且只能产生三种事件：next、completed，error。</p>\n<ul>\n<li>next 表示这个 Signal 产生了一个值（成功生产了一块巧克力）</li>\n<li>completed 表示 Signal 结束，结束信号只标志成功结束，不带值（一个批次的订单完成了）</li>\n<li>error 表示 Signal 中出现错误，立刻结束（一个机器坏了，生产线立刻停止运转）</li>\n</ul>\n<p>工厂厂长存了所有供销商的 QQ，每当发生上面三件事情的一件时，都用 QQ 挨个儿发消息告诉他们，于是供销商就能根据生产状态决定要做点什么。当订单完成或者失败后，厂长就会把这个供销商的 QQ 删了，以后发消息的时候也就没必要通知他了。</p>\n<h3 id=\"Side-Effects\"><a href=\"#Side-Effects\" class=\"headerlink\" title=\"Side Effects\"></a>Side Effects</h3><p>RACSignal在被subscribe的时候可能会产生副作用，先举个官方的栗子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__block <span class=\"keyword\">int</span> aNumber = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Signal that will have the side effect of incrementing `aNumber` block</span></span><br><span class=\"line\"><span class=\"comment\">// variable for each subscription before sending it.</span></span><br><span class=\"line\">RACSignal *aSignal = [RACSignal createSignal:^ RACDisposable * (<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class=\"line\">    aNumber++;</span><br><span class=\"line\">    [subscriber sendNext:@(aNumber)];</span><br><span class=\"line\">    [subscriber sendCompleted];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"><span class=\"comment\">// This will print \"subscriber one: 1\"</span></span><br><span class=\"line\">[aSignal subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"subscriber one: %@\"</span>, x);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"><span class=\"comment\">// This will print \"subscriber two: 2\"</span></span><br><span class=\"line\">[aSignal subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"subscriber two: %@\"</span>, x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>上面的signal在作用域外部引用了一个int变量，同时在signal的运算过程中作为<code>next</code>事件的值返回，这就造成了所谓的<code>副作用</code>，因为第二个订阅者的订阅而影响了输出值。</p>\n<p>我的理解来看，这个事儿做的就不太地道，一个正经的函数式编程中的函数是不应该因为进行了运算而导致后面运算的值不统一的。但对于实际应用的情况来看也到无可厚非，比如用户点击了“登录”按钮，编程时把登录这个业务写为一个login的RACSignal，当然，第一次调用登录和再点一次第二次调用登录的结果肯定不一样了。所以说RAC式编程减少了大部分对临时状态值的定义，但不是全部哦。</p>\n<p>怎么办呢？我觉得最好的办法就是“约定”，RAC design guide里面介绍了对于一个signal的命名法则：</p>\n<blockquote>\n<p>Hot signals without side effects 最好使用property，如“textChanged”，不太理解什么情况用到这个，权当做一个静态的属性来看就行。<br>    Cold signals without side effects 使用名词类型的方法名，如“-currentText”，“currentModels”，同时表明了返回值是个啥（这个尤其得注意，RACSignal的next值是id类型，所以全得是靠约定才知道具体返回类型）<br>    Signals with side effects 这种就是像login一样有副作用的了，推荐使用动词类型的方法名，用对动词基本就能知道是不是有副作用了，比如“-loginSignal”和“-saveToFile”大概就知道前面一个很可能有副作用，后面一个多存几次文件应该没副作用</p>\n</blockquote>\n<p>　　当然，也可以<code>multicast</code>一个event，使得某些特殊的情况来共享一个副作用，后面再具体讲，先一个官方的简单的栗子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This signal starts a new request on each subscription.</span></span><br><span class=\"line\">RACSignal *networkRequest = [RACSignal createSignal:^(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class=\"line\">    AFHTTPRequestOperation *operation = [client</span><br><span class=\"line\">        HTTPRequestOperationWithRequest:request</span><br><span class=\"line\">        success:^(AFHTTPRequestOperation *operation, <span class=\"keyword\">id</span> response) &#123;</span><br><span class=\"line\">            [subscriber sendNext:response];</span><br><span class=\"line\">            [subscriber sendCompleted];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        failure:^(AFHTTPRequestOperation *operation, <span class=\"built_in\">NSError</span> *error) &#123;</span><br><span class=\"line\">            [subscriber sendError:error];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    [client enqueueHTTPRequestOperation:operation];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class=\"line\">        [operation cancel];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Starts a single request, no matter how many subscriptions `connection.signal`</span></span><br><span class=\"line\"><span class=\"comment\">// gets. This is equivalent to the -replay operator, or similar to</span></span><br><span class=\"line\"><span class=\"comment\">// +startEagerlyWithScheduler:block:.</span></span><br><span class=\"line\">RACMulticastConnection *connection = [networkRequest multicast:[RACReplaySubject subject]];</span><br><span class=\"line\">[connection connect];</span><br><span class=\"line\"></span><br><span class=\"line\">[connection.signal subscribeNext:^(<span class=\"keyword\">id</span> response) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"subscriber one: %@\"</span>, response);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[connection.signal subscribeNext:^(<span class=\"keyword\">id</span> response) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"subscriber two: %@\"</span>, response);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>当地一个订阅者subscribeNext的时候触发了AFNetworkingOperation的创建和执行，开始网络请求，此时又来了个订阅者订阅这个Signal，按理说这个网络请求会被“副作用”，重新发一遍，但做了上面的处理之后，这两个订阅者接收到了同样的一个请求的内容。</p>\n<h3 id=\"RACScheduler-生产线\"><a href=\"#RACScheduler-生产线\" class=\"headerlink\" title=\"RACScheduler - 生产线\"></a>RACScheduler - 生产线</h3><p>RACScheduler是RAC里面对线程的简单封装，事件可以在指定的scheduler上分发和执行，不特殊指定的话，事件的分发和执行都在一个默认的后台线程里面做，大多数情况也就不用动了，有一些特殊的signal必须在主线程调用，使用-deliverOn：可以切换调用的线程。</p>\n<p>但值得特殊了解的事实是：</p>\n<blockquote>\n<p>However, RAC guarantees that no two signal events will ever arrive concurrently. While an event is being processed, no other events will be delivered. The senders of any other events will be forced to wait until the current event has been handled.</p>\n</blockquote>\n<p>意思是订阅者执行时的block一定非并发执行，也就是说不会执行到一半被另一个线程进入，也意味着写subscribeXXX block的时候没必要做加锁处理了。</p>\n<h3 id=\"巧克力的生产工艺\"><a href=\"#巧克力的生产工艺\" class=\"headerlink\" title=\"巧克力的生产工艺\"></a>巧克力的生产工艺</h3><p>　　RACSignal的厂子建好了，运行的模式也都想好了，剩下的就是巧克力的加工工艺了。</p>\n<p>　　有了RACStream的嵌套和组装的基础，RACSignal得以使用组件化的工艺来一步步的加工巧克力，从可可，牛奶，糖等原料，混合到这种巧克力适用的液态巧克力，过滤，提纯，冷却，夹心，压模，再到包装，一个巧克力就产出了。对于不同种类的巧克力，比如酒心巧克力，也不过是把其中的某个组件替换成注入酒心罢了。</p>\n<p>　　RACSignal的生产组件，也就是它的各式各样的operation，一个具体业务逻辑的实现，其实也就是选择合适operation按合适的顺序组合起来。</p>\n<p>　　还举那个用户在textFiled输入并显示到上面的label中的栗子:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RAC(<span class=\"keyword\">self</span>.outputLabel, text) = <span class=\"keyword\">self</span>.inputTextField.rac_textSignal;</span><br></pre></td></tr></table></figure>\n<p>　　现在需求变成“用户输入3个字母以上才输出到label，当不足3个时显示提示”，OK，好办：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RAC(<span class=\"keyword\">self</span>.outputLabel, text) = [[<span class=\"keyword\">self</span>.inputTextField.rac_textSignal</span><br><span class=\"line\">    startWith:<span class=\"string\">@\"key is &gt;3\"</span>] <span class=\"comment\">/* startWith 一开始返回的初始值 */</span></span><br><span class=\"line\">    filter:^<span class=\"built_in\">BOOL</span>(<span class=\"built_in\">NSString</span> *value) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.length &gt; <span class=\"number\">3</span>; <span class=\"comment\">/* filter使满足条件的值才能传出 */</span></span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>需求又增加成“<strong>当输入sunny时显示输入正确</strong>”</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RAC(<span class=\"keyword\">self</span>.outputLabel, text) = [[<span class=\"keyword\">self</span>.inputTextField.rac_textSignal</span><br><span class=\"line\">    startWith:<span class=\"string\">@\"key is &gt;3\"</span>] <span class=\"comment\">// startWith 一开始返回的初始值</span></span><br><span class=\"line\">    filter:^<span class=\"built_in\">BOOL</span>(<span class=\"built_in\">NSString</span> *value) &#123; <span class=\"comment\">// filter使满足条件的值才能传出</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.length &gt; <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">    map:(<span class=\"built_in\">NSString</span> *value) &#123;　<span class=\"comment\">// map将一个值转化为另一个值输出</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [value isEqualToString:<span class=\"string\">@\"sunny\"</span>] ? <span class=\"string\">@\"bingo!\"</span> : value;</span><br><span class=\"line\">    &#125;];</span><br></pre></td></tr></table></figure>\n<p>可以看出，基本上一个业务逻辑经过分析后可以拆解成一个个小RACSignal的组合，也就像生产巧克力的一道道工艺了。上面的栗子慢慢感觉就像了一个简陋的输答案的框了。</p>\n<p>###然后呢？</p>\n<p>接下来的几节就具体介绍一下RACSignal的operation方法，RAC提供了很多操作方法，大概总结为几大类：过滤型、XXX型、XXX型，后面再慢慢道来。</p>\n"},{"title":"Reactive Cocoa Tutorial [4] = 只取所需的Filters","date":"2014-04-19T01:30:28.000Z","_content":"\n# 我是前言\n这是[Reactive Cocoa Tutorial系列](http://blog.sunnyxx.com/tags/Reactive%20Cocoa%20Tutorial/)其中的一篇，[上一篇](http://blog.sunnyxx.com/2014/03/06/rac_3_racsignal/)简单介绍了RAC中最重要的`RACSignal`，下面几篇文章将主要从它的`Operations`下手，这也是工程中使用RAC的重点。从简到难，本篇文章先介绍RAC消息流的`过滤器-Filters`类别的相关方法。\n\n-----\n\n#RAC中的Filters\n\n## 画个范围\n一个Signal源可以产生一系列next值，但并非所有值都是需要的，具体的Subscriber可以选择在原有Signal上套用Filter操作来过滤掉不需要的值。  \n我的定义：RAC中如果一个`Operation`将处理后的值集合是处理前值集合的`子集`，我们就可以把它归为`Filter`类型。  \n\n当然通过之前介绍的基础操作完全可以自己拼出个想要的filter来，RAC为了方便使用已经实现了几个常用的filter，经过总结，这些filter大概可以分成两类：`next值过滤类型`和`起止点过滤类型`\n\n## 值过滤类型Filters\n### filter: (BOOL (^)(id value))\nRAC中的filter同名方法`- filter:(BOOL (^)(id value))`，简单明了，将一个value用block做test，返回YES的才会通过，它的内部实现使用了`- flattenMap:`，将原来的`Signal`经过过滤转化成只返回过滤值的`Signal`，用法也不难理解：    \n\n``` objc\n[[self.inputTextField.rac_textSignal filter:^BOOL(NSString *value) {\n    return [value hasPrefix:@\"sunny\"];\n}] subscribeNext:^(NSString *value) {\n    NSLog(@\"This value has prefix `sunny` : %@\", value);\n}];\n```\n\n此外，还有几个这个方法的衍生方法：   \n\n### - ignore: (id)\n忽略给定的值，注意，这里忽略的既可以是地址相同的对象，也可以是`- isEqual:`结果相同的值，也就是说自己写的Model对象可以通过重写`- isEqual:`方法来使`- ignore:`生效。常用的值的判断没有问题，如下：      \n\n\n``` objc\n[[self.inputTextField.rac_textSignal ignore:@\"sunny\"] subscribeNext:^(NSString *value) {\n    NSLog(@\"`sunny` could never appear : %@\", value);\n}];\n```\n\n### - ignoreValues\n这个比较极端，忽略所有值，只关心Signal结束，也就是只取`Comletion`和`Error`两个消息，中间所有值都丢弃。   \n注意，这个操作应该出现在Signal有终止条件的的情况下，如`rac_textSignal`这样除`dealloc`外没有终止条件的Signal上就不太可能用到。   \n\n\n### - distinctUntilChanged\n也是一个**相当常用**的Filter（但它不是- filter:的衍生方法），它将这一次的值与上一次做比较，当相同时（也包括`- isEqual:`）被忽略掉。   \n比如UI上一个Label绑定了一个值，根据值更新显示的内容:\n\n``` objc\nRAC(self.label, text) = [RACObserve(self.user, username) distinctUntilChanged];\nself.user.username = @\"sunnyxx\"; // 1st\nself.user.username = @\"sunnyxx\"; // 2nd\nself.user.username = @\"sunnyxx\"; // 3rd\n```\n\n如果不增加`distinctUntilChanged`的话对于连续的相同的输入值就会有不必要的处理，这个栗子只是简单的UI刷新，但遇到如写数据库，发网络请求的情况时，代价就不能购忽略了。  \n\n所以，对于相同值可以忽略的情况，果断加上它吧。   \n\n## 起止点过滤类型\n除了被动的当next值来的时候做判断，也可以主动的提前选择开始和结束条件，分为两种类型：\n`take型（取）`和`skip型(跳)`\n\n### - take: (NSUInteger)\n从开始一共取N次的next值，不包括`Competion`和`Error`，如：   \n\n``` objc\n[[[RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    [subscriber sendNext:@\"1\"];\n    [subscriber sendNext:@\"2\"];\n    [subscriber sendNext:@\"3\"];\n    [subscriber sendCompleted];\n    return nil;\n}] take:2] subscribeNext:^(id x) {\n    NSLog(@\"only 1 and 2 will be print: %@\", x);\n}];\n```\n\n### - takeLast: (NSUInteger)\n取最后N次的next值，注意，由于一开始不能知道这个Signal将有多少个next值，所以RAC实现它的方法是将所有next值都存起来，然后**原Signal完成时**再将后N个**依次**发送给接收者，但Error发生时依然是立刻发送的。\n###- takeUntil:(RACSignal *)\n当给定的signal完成前一直取值。最简单的栗子就是`UITextField`的`rac_textSignal`的实现（删减版本）:\n\n``` objc\n- (RACSignal *)rac_textSignal {\n\t@weakify(self);\n\treturn [[[[[RACSignal\n\t\tconcat:[self rac_signalForControlEvents:UIControlEventEditingChanged]]\n\t\tmap:^(UITextField *x) {\n\t\t\treturn x.text;\n\t\t}]\n\t\ttakeUntil:self.rac_willDeallocSignal] // bingo!\n}\n```\n\n也就是这个Signal一直到textField执行`dealloc`时才停止\n\n### - takeUntilBlock:(BOOL (^)(id x))  \n对于每个next值，运行block，当block返回YES时停止取值，如：\n\n``` objc\n[[self.inputTextField.rac_textSignal takeUntilBlock:^BOOL(NSString *value) {\n    return [value isEqualToString:@\"stop\"];\n}] subscribeNext:^(NSString *value) {\n    NSLog(@\"current value is not `stop`: %@\", value);\n}];\n```\n\n### - takeWhileBlock:(BOOL (^)(id x))\n上面的反向逻辑，对于每个next值，block返回\tYES时才取值\n\n\n### - skip:(NSUInteger)   \n从开始跳过N次的next值，简单的栗子：  \n\n``` objc\n[[[RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    [subscriber sendNext:@\"1\"];\n    [subscriber sendNext:@\"2\"];\n    [subscriber sendNext:@\"3\"];\n    [subscriber sendCompleted];\n    return nil;\n}] skip:1] subscribeNext:^(id x) {\n    NSLog(@\"only 2 and 3 will be print: %@\", x);\n}];\n```\n\n### - skipUntilBlock:(BOOL (^)(id x))  \n和`- takeUntilBlock:`同理，一直跳，直到block为YES\n### - skipWhileBlock:(BOOL (^)(id x))\n和`- takeWhileBlock:`同理，一直跳，直到block为NO\n\n-----\n\n# 总结\n本章介绍了RAC中Filter类型的Operation，总结一下：\n\n- 适用场景：需要一个next值集合的`子集`时\n- Filter类型：值过滤型和起止点过滤型\n- 值过滤型常用方法： `-filter:`，`-ignore:`，`-distinctUnitlChanged`\n- 起止点过滤型常用方法：`take`系列和`skip`系列\n\n\n\n# References\n\nhttps://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/BasicOperators.md#filtering\n\n---\n原创文章，转载请注明源地址，[blog.sunnyxx.com](blog.sunnyxx.com)\n","source":"_posts/rac_4_filters.md","raw":"title: Reactive Cocoa Tutorial [4] = 只取所需的Filters\ndate: 2014-04-19 09:30:28\ntags: Reactive Cocoa Tutorial\n---\n\n# 我是前言\n这是[Reactive Cocoa Tutorial系列](http://blog.sunnyxx.com/tags/Reactive%20Cocoa%20Tutorial/)其中的一篇，[上一篇](http://blog.sunnyxx.com/2014/03/06/rac_3_racsignal/)简单介绍了RAC中最重要的`RACSignal`，下面几篇文章将主要从它的`Operations`下手，这也是工程中使用RAC的重点。从简到难，本篇文章先介绍RAC消息流的`过滤器-Filters`类别的相关方法。\n\n-----\n\n#RAC中的Filters\n\n## 画个范围\n一个Signal源可以产生一系列next值，但并非所有值都是需要的，具体的Subscriber可以选择在原有Signal上套用Filter操作来过滤掉不需要的值。  \n我的定义：RAC中如果一个`Operation`将处理后的值集合是处理前值集合的`子集`，我们就可以把它归为`Filter`类型。  \n\n当然通过之前介绍的基础操作完全可以自己拼出个想要的filter来，RAC为了方便使用已经实现了几个常用的filter，经过总结，这些filter大概可以分成两类：`next值过滤类型`和`起止点过滤类型`\n\n## 值过滤类型Filters\n### filter: (BOOL (^)(id value))\nRAC中的filter同名方法`- filter:(BOOL (^)(id value))`，简单明了，将一个value用block做test，返回YES的才会通过，它的内部实现使用了`- flattenMap:`，将原来的`Signal`经过过滤转化成只返回过滤值的`Signal`，用法也不难理解：    \n\n``` objc\n[[self.inputTextField.rac_textSignal filter:^BOOL(NSString *value) {\n    return [value hasPrefix:@\"sunny\"];\n}] subscribeNext:^(NSString *value) {\n    NSLog(@\"This value has prefix `sunny` : %@\", value);\n}];\n```\n\n此外，还有几个这个方法的衍生方法：   \n\n### - ignore: (id)\n忽略给定的值，注意，这里忽略的既可以是地址相同的对象，也可以是`- isEqual:`结果相同的值，也就是说自己写的Model对象可以通过重写`- isEqual:`方法来使`- ignore:`生效。常用的值的判断没有问题，如下：      \n\n\n``` objc\n[[self.inputTextField.rac_textSignal ignore:@\"sunny\"] subscribeNext:^(NSString *value) {\n    NSLog(@\"`sunny` could never appear : %@\", value);\n}];\n```\n\n### - ignoreValues\n这个比较极端，忽略所有值，只关心Signal结束，也就是只取`Comletion`和`Error`两个消息，中间所有值都丢弃。   \n注意，这个操作应该出现在Signal有终止条件的的情况下，如`rac_textSignal`这样除`dealloc`外没有终止条件的Signal上就不太可能用到。   \n\n\n### - distinctUntilChanged\n也是一个**相当常用**的Filter（但它不是- filter:的衍生方法），它将这一次的值与上一次做比较，当相同时（也包括`- isEqual:`）被忽略掉。   \n比如UI上一个Label绑定了一个值，根据值更新显示的内容:\n\n``` objc\nRAC(self.label, text) = [RACObserve(self.user, username) distinctUntilChanged];\nself.user.username = @\"sunnyxx\"; // 1st\nself.user.username = @\"sunnyxx\"; // 2nd\nself.user.username = @\"sunnyxx\"; // 3rd\n```\n\n如果不增加`distinctUntilChanged`的话对于连续的相同的输入值就会有不必要的处理，这个栗子只是简单的UI刷新，但遇到如写数据库，发网络请求的情况时，代价就不能购忽略了。  \n\n所以，对于相同值可以忽略的情况，果断加上它吧。   \n\n## 起止点过滤类型\n除了被动的当next值来的时候做判断，也可以主动的提前选择开始和结束条件，分为两种类型：\n`take型（取）`和`skip型(跳)`\n\n### - take: (NSUInteger)\n从开始一共取N次的next值，不包括`Competion`和`Error`，如：   \n\n``` objc\n[[[RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    [subscriber sendNext:@\"1\"];\n    [subscriber sendNext:@\"2\"];\n    [subscriber sendNext:@\"3\"];\n    [subscriber sendCompleted];\n    return nil;\n}] take:2] subscribeNext:^(id x) {\n    NSLog(@\"only 1 and 2 will be print: %@\", x);\n}];\n```\n\n### - takeLast: (NSUInteger)\n取最后N次的next值，注意，由于一开始不能知道这个Signal将有多少个next值，所以RAC实现它的方法是将所有next值都存起来，然后**原Signal完成时**再将后N个**依次**发送给接收者，但Error发生时依然是立刻发送的。\n###- takeUntil:(RACSignal *)\n当给定的signal完成前一直取值。最简单的栗子就是`UITextField`的`rac_textSignal`的实现（删减版本）:\n\n``` objc\n- (RACSignal *)rac_textSignal {\n\t@weakify(self);\n\treturn [[[[[RACSignal\n\t\tconcat:[self rac_signalForControlEvents:UIControlEventEditingChanged]]\n\t\tmap:^(UITextField *x) {\n\t\t\treturn x.text;\n\t\t}]\n\t\ttakeUntil:self.rac_willDeallocSignal] // bingo!\n}\n```\n\n也就是这个Signal一直到textField执行`dealloc`时才停止\n\n### - takeUntilBlock:(BOOL (^)(id x))  \n对于每个next值，运行block，当block返回YES时停止取值，如：\n\n``` objc\n[[self.inputTextField.rac_textSignal takeUntilBlock:^BOOL(NSString *value) {\n    return [value isEqualToString:@\"stop\"];\n}] subscribeNext:^(NSString *value) {\n    NSLog(@\"current value is not `stop`: %@\", value);\n}];\n```\n\n### - takeWhileBlock:(BOOL (^)(id x))\n上面的反向逻辑，对于每个next值，block返回\tYES时才取值\n\n\n### - skip:(NSUInteger)   \n从开始跳过N次的next值，简单的栗子：  \n\n``` objc\n[[[RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    [subscriber sendNext:@\"1\"];\n    [subscriber sendNext:@\"2\"];\n    [subscriber sendNext:@\"3\"];\n    [subscriber sendCompleted];\n    return nil;\n}] skip:1] subscribeNext:^(id x) {\n    NSLog(@\"only 2 and 3 will be print: %@\", x);\n}];\n```\n\n### - skipUntilBlock:(BOOL (^)(id x))  \n和`- takeUntilBlock:`同理，一直跳，直到block为YES\n### - skipWhileBlock:(BOOL (^)(id x))\n和`- takeWhileBlock:`同理，一直跳，直到block为NO\n\n-----\n\n# 总结\n本章介绍了RAC中Filter类型的Operation，总结一下：\n\n- 适用场景：需要一个next值集合的`子集`时\n- Filter类型：值过滤型和起止点过滤型\n- 值过滤型常用方法： `-filter:`，`-ignore:`，`-distinctUnitlChanged`\n- 起止点过滤型常用方法：`take`系列和`skip`系列\n\n\n\n# References\n\nhttps://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/BasicOperators.md#filtering\n\n---\n原创文章，转载请注明源地址，[blog.sunnyxx.com](blog.sunnyxx.com)\n","slug":"rac_4_filters","published":1,"updated":"2016-03-27T08:32:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxmq0028ev12v71tv0e4","content":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>这是<a href=\"http://blog.sunnyxx.com/tags/Reactive%20Cocoa%20Tutorial/\">Reactive Cocoa Tutorial系列</a>其中的一篇，<a href=\"http://blog.sunnyxx.com/2014/03/06/rac_3_racsignal/\">上一篇</a>简单介绍了RAC中最重要的<code>RACSignal</code>，下面几篇文章将主要从它的<code>Operations</code>下手，这也是工程中使用RAC的重点。从简到难，本篇文章先介绍RAC消息流的<code>过滤器-Filters</code>类别的相关方法。</p>\n<hr>\n<p>#RAC中的Filters</p>\n<h2 id=\"画个范围\"><a href=\"#画个范围\" class=\"headerlink\" title=\"画个范围\"></a>画个范围</h2><p>一个Signal源可以产生一系列next值，但并非所有值都是需要的，具体的Subscriber可以选择在原有Signal上套用Filter操作来过滤掉不需要的值。<br>我的定义：RAC中如果一个<code>Operation</code>将处理后的值集合是处理前值集合的<code>子集</code>，我们就可以把它归为<code>Filter</code>类型。  </p>\n<p>当然通过之前介绍的基础操作完全可以自己拼出个想要的filter来，RAC为了方便使用已经实现了几个常用的filter，经过总结，这些filter大概可以分成两类：<code>next值过滤类型</code>和<code>起止点过滤类型</code></p>\n<h2 id=\"值过滤类型Filters\"><a href=\"#值过滤类型Filters\" class=\"headerlink\" title=\"值过滤类型Filters\"></a>值过滤类型Filters</h2><h3 id=\"filter-BOOL-id-value\"><a href=\"#filter-BOOL-id-value\" class=\"headerlink\" title=\"filter: (BOOL (^)(id value))\"></a>filter: (BOOL (^)(id value))</h3><p>RAC中的filter同名方法<code>- filter:(BOOL (^)(id value))</code>，简单明了，将一个value用block做test，返回YES的才会通过，它的内部实现使用了<code>- flattenMap:</code>，将原来的<code>Signal</code>经过过滤转化成只返回过滤值的<code>Signal</code>，用法也不难理解：    </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"keyword\">self</span>.inputTextField.rac_textSignal filter:^<span class=\"built_in\">BOOL</span>(<span class=\"built_in\">NSString</span> *value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [value hasPrefix:<span class=\"string\">@\"sunny\"</span>];</span><br><span class=\"line\">&#125;] subscribeNext:^(<span class=\"built_in\">NSString</span> *value) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"This value has prefix `sunny` : %@\"</span>, value);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>此外，还有几个这个方法的衍生方法：   </p>\n<h3 id=\"ignore-id\"><a href=\"#ignore-id\" class=\"headerlink\" title=\"- ignore: (id)\"></a>- ignore: (id)</h3><p>忽略给定的值，注意，这里忽略的既可以是地址相同的对象，也可以是<code>- isEqual:</code>结果相同的值，也就是说自己写的Model对象可以通过重写<code>- isEqual:</code>方法来使<code>- ignore:</code>生效。常用的值的判断没有问题，如下：      </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"keyword\">self</span>.inputTextField.rac_textSignal ignore:<span class=\"string\">@\"sunny\"</span>] subscribeNext:^(<span class=\"built_in\">NSString</span> *value) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"`sunny` could never appear : %@\"</span>, value);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h3 id=\"ignoreValues\"><a href=\"#ignoreValues\" class=\"headerlink\" title=\"- ignoreValues\"></a>- ignoreValues</h3><p>这个比较极端，忽略所有值，只关心Signal结束，也就是只取<code>Comletion</code>和<code>Error</code>两个消息，中间所有值都丢弃。<br>注意，这个操作应该出现在Signal有终止条件的的情况下，如<code>rac_textSignal</code>这样除<code>dealloc</code>外没有终止条件的Signal上就不太可能用到。   </p>\n<h3 id=\"distinctUntilChanged\"><a href=\"#distinctUntilChanged\" class=\"headerlink\" title=\"- distinctUntilChanged\"></a>- distinctUntilChanged</h3><p>也是一个<strong>相当常用</strong>的Filter（但它不是- filter:的衍生方法），它将这一次的值与上一次做比较，当相同时（也包括<code>- isEqual:</code>）被忽略掉。<br>比如UI上一个Label绑定了一个值，根据值更新显示的内容:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RAC(<span class=\"keyword\">self</span>.label, text) = [RACObserve(<span class=\"keyword\">self</span>.user, username) distinctUntilChanged];</span><br><span class=\"line\"><span class=\"keyword\">self</span>.user.username = <span class=\"string\">@\"sunnyxx\"</span>; <span class=\"comment\">// 1st</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.user.username = <span class=\"string\">@\"sunnyxx\"</span>; <span class=\"comment\">// 2nd</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.user.username = <span class=\"string\">@\"sunnyxx\"</span>; <span class=\"comment\">// 3rd</span></span><br></pre></td></tr></table></figure>\n<p>如果不增加<code>distinctUntilChanged</code>的话对于连续的相同的输入值就会有不必要的处理，这个栗子只是简单的UI刷新，但遇到如写数据库，发网络请求的情况时，代价就不能购忽略了。  </p>\n<p>所以，对于相同值可以忽略的情况，果断加上它吧。   </p>\n<h2 id=\"起止点过滤类型\"><a href=\"#起止点过滤类型\" class=\"headerlink\" title=\"起止点过滤类型\"></a>起止点过滤类型</h2><p>除了被动的当next值来的时候做判断，也可以主动的提前选择开始和结束条件，分为两种类型：<br><code>take型（取）</code>和<code>skip型(跳)</code></p>\n<h3 id=\"take-NSUInteger\"><a href=\"#take-NSUInteger\" class=\"headerlink\" title=\"- take: (NSUInteger)\"></a>- take: (NSUInteger)</h3><p>从开始一共取N次的next值，不包括<code>Competion</code>和<code>Error</code>，如：   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[[RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"1\"</span>];</span><br><span class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"2\"</span>];</span><br><span class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"3\"</span>];</span><br><span class=\"line\">    [subscriber sendCompleted];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;] take:<span class=\"number\">2</span>] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"only 1 and 2 will be print: %@\"</span>, x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h3 id=\"takeLast-NSUInteger\"><a href=\"#takeLast-NSUInteger\" class=\"headerlink\" title=\"- takeLast: (NSUInteger)\"></a>- takeLast: (NSUInteger)</h3><p>取最后N次的next值，注意，由于一开始不能知道这个Signal将有多少个next值，所以RAC实现它的方法是将所有next值都存起来，然后<strong>原Signal完成时</strong>再将后N个<strong>依次</strong>发送给接收者，但Error发生时依然是立刻发送的。</p>\n<p>###- takeUntil:(RACSignal *)<br>当给定的signal完成前一直取值。最简单的栗子就是<code>UITextField</code>的<code>rac_textSignal</code>的实现（删减版本）:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (RACSignal *)rac_textSignal &#123;</span><br><span class=\"line\">\t@weakify(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> [[[[[RACSignal</span><br><span class=\"line\">\t\tconcat:[<span class=\"keyword\">self</span> rac_signalForControlEvents:<span class=\"built_in\">UIControlEventEditingChanged</span>]]</span><br><span class=\"line\">\t\tmap:^(<span class=\"built_in\">UITextField</span> *x) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> x.text;</span><br><span class=\"line\">\t\t&#125;]</span><br><span class=\"line\">\t\ttakeUntil:<span class=\"keyword\">self</span>.rac_willDeallocSignal] <span class=\"comment\">// bingo!</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是这个Signal一直到textField执行<code>dealloc</code>时才停止</p>\n<h3 id=\"takeUntilBlock-BOOL-id-x\"><a href=\"#takeUntilBlock-BOOL-id-x\" class=\"headerlink\" title=\"- takeUntilBlock:(BOOL (^)(id x))\"></a>- takeUntilBlock:(BOOL (^)(id x))</h3><p>对于每个next值，运行block，当block返回YES时停止取值，如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"keyword\">self</span>.inputTextField.rac_textSignal takeUntilBlock:^<span class=\"built_in\">BOOL</span>(<span class=\"built_in\">NSString</span> *value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [value isEqualToString:<span class=\"string\">@\"stop\"</span>];</span><br><span class=\"line\">&#125;] subscribeNext:^(<span class=\"built_in\">NSString</span> *value) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"current value is not `stop`: %@\"</span>, value);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h3 id=\"takeWhileBlock-BOOL-id-x\"><a href=\"#takeWhileBlock-BOOL-id-x\" class=\"headerlink\" title=\"- takeWhileBlock:(BOOL (^)(id x))\"></a>- takeWhileBlock:(BOOL (^)(id x))</h3><p>上面的反向逻辑，对于每个next值，block返回    YES时才取值</p>\n<h3 id=\"skip-NSUInteger\"><a href=\"#skip-NSUInteger\" class=\"headerlink\" title=\"- skip:(NSUInteger)\"></a>- skip:(NSUInteger)</h3><p>从开始跳过N次的next值，简单的栗子：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[[RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"1\"</span>];</span><br><span class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"2\"</span>];</span><br><span class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"3\"</span>];</span><br><span class=\"line\">    [subscriber sendCompleted];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;] skip:<span class=\"number\">1</span>] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"only 2 and 3 will be print: %@\"</span>, x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h3 id=\"skipUntilBlock-BOOL-id-x\"><a href=\"#skipUntilBlock-BOOL-id-x\" class=\"headerlink\" title=\"- skipUntilBlock:(BOOL (^)(id x))\"></a>- skipUntilBlock:(BOOL (^)(id x))</h3><p>和<code>- takeUntilBlock:</code>同理，一直跳，直到block为YES</p>\n<h3 id=\"skipWhileBlock-BOOL-id-x\"><a href=\"#skipWhileBlock-BOOL-id-x\" class=\"headerlink\" title=\"- skipWhileBlock:(BOOL (^)(id x))\"></a>- skipWhileBlock:(BOOL (^)(id x))</h3><p>和<code>- takeWhileBlock:</code>同理，一直跳，直到block为NO</p>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本章介绍了RAC中Filter类型的Operation，总结一下：</p>\n<ul>\n<li>适用场景：需要一个next值集合的<code>子集</code>时</li>\n<li>Filter类型：值过滤型和起止点过滤型</li>\n<li>值过滤型常用方法： <code>-filter:</code>，<code>-ignore:</code>，<code>-distinctUnitlChanged</code></li>\n<li>起止点过滤型常用方法：<code>take</code>系列和<code>skip</code>系列</li>\n</ul>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/BasicOperators.md#filtering\" target=\"_blank\" rel=\"external\">https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/BasicOperators.md#filtering</a></p>\n<hr>\n<p>原创文章，转载请注明源地址，<a href=\"blog.sunnyxx.com\">blog.sunnyxx.com</a></p>\n","excerpt":"","more":"<h1 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h1><p>这是<a href=\"http://blog.sunnyxx.com/tags/Reactive%20Cocoa%20Tutorial/\">Reactive Cocoa Tutorial系列</a>其中的一篇，<a href=\"http://blog.sunnyxx.com/2014/03/06/rac_3_racsignal/\">上一篇</a>简单介绍了RAC中最重要的<code>RACSignal</code>，下面几篇文章将主要从它的<code>Operations</code>下手，这也是工程中使用RAC的重点。从简到难，本篇文章先介绍RAC消息流的<code>过滤器-Filters</code>类别的相关方法。</p>\n<hr>\n<p>#RAC中的Filters</p>\n<h2 id=\"画个范围\"><a href=\"#画个范围\" class=\"headerlink\" title=\"画个范围\"></a>画个范围</h2><p>一个Signal源可以产生一系列next值，但并非所有值都是需要的，具体的Subscriber可以选择在原有Signal上套用Filter操作来过滤掉不需要的值。<br>我的定义：RAC中如果一个<code>Operation</code>将处理后的值集合是处理前值集合的<code>子集</code>，我们就可以把它归为<code>Filter</code>类型。  </p>\n<p>当然通过之前介绍的基础操作完全可以自己拼出个想要的filter来，RAC为了方便使用已经实现了几个常用的filter，经过总结，这些filter大概可以分成两类：<code>next值过滤类型</code>和<code>起止点过滤类型</code></p>\n<h2 id=\"值过滤类型Filters\"><a href=\"#值过滤类型Filters\" class=\"headerlink\" title=\"值过滤类型Filters\"></a>值过滤类型Filters</h2><h3 id=\"filter-BOOL-id-value\"><a href=\"#filter-BOOL-id-value\" class=\"headerlink\" title=\"filter: (BOOL (^)(id value))\"></a>filter: (BOOL (^)(id value))</h3><p>RAC中的filter同名方法<code>- filter:(BOOL (^)(id value))</code>，简单明了，将一个value用block做test，返回YES的才会通过，它的内部实现使用了<code>- flattenMap:</code>，将原来的<code>Signal</code>经过过滤转化成只返回过滤值的<code>Signal</code>，用法也不难理解：    </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"keyword\">self</span>.inputTextField.rac_textSignal filter:^<span class=\"built_in\">BOOL</span>(<span class=\"built_in\">NSString</span> *value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [value hasPrefix:<span class=\"string\">@\"sunny\"</span>];</span><br><span class=\"line\">&#125;] subscribeNext:^(<span class=\"built_in\">NSString</span> *value) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"This value has prefix `sunny` : %@\"</span>, value);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>此外，还有几个这个方法的衍生方法：   </p>\n<h3 id=\"ignore-id\"><a href=\"#ignore-id\" class=\"headerlink\" title=\"- ignore: (id)\"></a>- ignore: (id)</h3><p>忽略给定的值，注意，这里忽略的既可以是地址相同的对象，也可以是<code>- isEqual:</code>结果相同的值，也就是说自己写的Model对象可以通过重写<code>- isEqual:</code>方法来使<code>- ignore:</code>生效。常用的值的判断没有问题，如下：      </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"keyword\">self</span>.inputTextField.rac_textSignal ignore:<span class=\"string\">@\"sunny\"</span>] subscribeNext:^(<span class=\"built_in\">NSString</span> *value) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"`sunny` could never appear : %@\"</span>, value);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h3 id=\"ignoreValues\"><a href=\"#ignoreValues\" class=\"headerlink\" title=\"- ignoreValues\"></a>- ignoreValues</h3><p>这个比较极端，忽略所有值，只关心Signal结束，也就是只取<code>Comletion</code>和<code>Error</code>两个消息，中间所有值都丢弃。<br>注意，这个操作应该出现在Signal有终止条件的的情况下，如<code>rac_textSignal</code>这样除<code>dealloc</code>外没有终止条件的Signal上就不太可能用到。   </p>\n<h3 id=\"distinctUntilChanged\"><a href=\"#distinctUntilChanged\" class=\"headerlink\" title=\"- distinctUntilChanged\"></a>- distinctUntilChanged</h3><p>也是一个<strong>相当常用</strong>的Filter（但它不是- filter:的衍生方法），它将这一次的值与上一次做比较，当相同时（也包括<code>- isEqual:</code>）被忽略掉。<br>比如UI上一个Label绑定了一个值，根据值更新显示的内容:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RAC(<span class=\"keyword\">self</span>.label, text) = [RACObserve(<span class=\"keyword\">self</span>.user, username) distinctUntilChanged];</span><br><span class=\"line\"><span class=\"keyword\">self</span>.user.username = <span class=\"string\">@\"sunnyxx\"</span>; <span class=\"comment\">// 1st</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.user.username = <span class=\"string\">@\"sunnyxx\"</span>; <span class=\"comment\">// 2nd</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.user.username = <span class=\"string\">@\"sunnyxx\"</span>; <span class=\"comment\">// 3rd</span></span><br></pre></td></tr></table></figure>\n<p>如果不增加<code>distinctUntilChanged</code>的话对于连续的相同的输入值就会有不必要的处理，这个栗子只是简单的UI刷新，但遇到如写数据库，发网络请求的情况时，代价就不能购忽略了。  </p>\n<p>所以，对于相同值可以忽略的情况，果断加上它吧。   </p>\n<h2 id=\"起止点过滤类型\"><a href=\"#起止点过滤类型\" class=\"headerlink\" title=\"起止点过滤类型\"></a>起止点过滤类型</h2><p>除了被动的当next值来的时候做判断，也可以主动的提前选择开始和结束条件，分为两种类型：<br><code>take型（取）</code>和<code>skip型(跳)</code></p>\n<h3 id=\"take-NSUInteger\"><a href=\"#take-NSUInteger\" class=\"headerlink\" title=\"- take: (NSUInteger)\"></a>- take: (NSUInteger)</h3><p>从开始一共取N次的next值，不包括<code>Competion</code>和<code>Error</code>，如：   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[[RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"1\"</span>];</span><br><span class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"2\"</span>];</span><br><span class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"3\"</span>];</span><br><span class=\"line\">    [subscriber sendCompleted];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;] take:<span class=\"number\">2</span>] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"only 1 and 2 will be print: %@\"</span>, x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h3 id=\"takeLast-NSUInteger\"><a href=\"#takeLast-NSUInteger\" class=\"headerlink\" title=\"- takeLast: (NSUInteger)\"></a>- takeLast: (NSUInteger)</h3><p>取最后N次的next值，注意，由于一开始不能知道这个Signal将有多少个next值，所以RAC实现它的方法是将所有next值都存起来，然后<strong>原Signal完成时</strong>再将后N个<strong>依次</strong>发送给接收者，但Error发生时依然是立刻发送的。</p>\n<p>###- takeUntil:(RACSignal *)<br>当给定的signal完成前一直取值。最简单的栗子就是<code>UITextField</code>的<code>rac_textSignal</code>的实现（删减版本）:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (RACSignal *)rac_textSignal &#123;</span><br><span class=\"line\">\t@weakify(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> [[[[[RACSignal</span><br><span class=\"line\">\t\tconcat:[<span class=\"keyword\">self</span> rac_signalForControlEvents:<span class=\"built_in\">UIControlEventEditingChanged</span>]]</span><br><span class=\"line\">\t\tmap:^(<span class=\"built_in\">UITextField</span> *x) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> x.text;</span><br><span class=\"line\">\t\t&#125;]</span><br><span class=\"line\">\t\ttakeUntil:<span class=\"keyword\">self</span>.rac_willDeallocSignal] <span class=\"comment\">// bingo!</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是这个Signal一直到textField执行<code>dealloc</code>时才停止</p>\n<h3 id=\"takeUntilBlock-BOOL-id-x\"><a href=\"#takeUntilBlock-BOOL-id-x\" class=\"headerlink\" title=\"- takeUntilBlock:(BOOL (^)(id x))\"></a>- takeUntilBlock:(BOOL (^)(id x))</h3><p>对于每个next值，运行block，当block返回YES时停止取值，如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"keyword\">self</span>.inputTextField.rac_textSignal takeUntilBlock:^<span class=\"built_in\">BOOL</span>(<span class=\"built_in\">NSString</span> *value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [value isEqualToString:<span class=\"string\">@\"stop\"</span>];</span><br><span class=\"line\">&#125;] subscribeNext:^(<span class=\"built_in\">NSString</span> *value) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"current value is not `stop`: %@\"</span>, value);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h3 id=\"takeWhileBlock-BOOL-id-x\"><a href=\"#takeWhileBlock-BOOL-id-x\" class=\"headerlink\" title=\"- takeWhileBlock:(BOOL (^)(id x))\"></a>- takeWhileBlock:(BOOL (^)(id x))</h3><p>上面的反向逻辑，对于每个next值，block返回    YES时才取值</p>\n<h3 id=\"skip-NSUInteger\"><a href=\"#skip-NSUInteger\" class=\"headerlink\" title=\"- skip:(NSUInteger)\"></a>- skip:(NSUInteger)</h3><p>从开始跳过N次的next值，简单的栗子：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[[RACSignal createSignal:^RACDisposable *(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"1\"</span>];</span><br><span class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"2\"</span>];</span><br><span class=\"line\">    [subscriber sendNext:<span class=\"string\">@\"3\"</span>];</span><br><span class=\"line\">    [subscriber sendCompleted];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;] skip:<span class=\"number\">1</span>] subscribeNext:^(<span class=\"keyword\">id</span> x) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"only 2 and 3 will be print: %@\"</span>, x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h3 id=\"skipUntilBlock-BOOL-id-x\"><a href=\"#skipUntilBlock-BOOL-id-x\" class=\"headerlink\" title=\"- skipUntilBlock:(BOOL (^)(id x))\"></a>- skipUntilBlock:(BOOL (^)(id x))</h3><p>和<code>- takeUntilBlock:</code>同理，一直跳，直到block为YES</p>\n<h3 id=\"skipWhileBlock-BOOL-id-x\"><a href=\"#skipWhileBlock-BOOL-id-x\" class=\"headerlink\" title=\"- skipWhileBlock:(BOOL (^)(id x))\"></a>- skipWhileBlock:(BOOL (^)(id x))</h3><p>和<code>- takeWhileBlock:</code>同理，一直跳，直到block为NO</p>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本章介绍了RAC中Filter类型的Operation，总结一下：</p>\n<ul>\n<li>适用场景：需要一个next值集合的<code>子集</code>时</li>\n<li>Filter类型：值过滤型和起止点过滤型</li>\n<li>值过滤型常用方法： <code>-filter:</code>，<code>-ignore:</code>，<code>-distinctUnitlChanged</code></li>\n<li>起止点过滤型常用方法：<code>take</code>系列和<code>skip</code>系列</li>\n</ul>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/BasicOperators.md#filtering\">https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/BasicOperators.md#filtering</a></p>\n<hr>\n<p>原创文章，转载请注明源地址，<a href=\"blog.sunnyxx.com\">blog.sunnyxx.com</a></p>\n"},{"title":"神经病院objc runtime入院考试","date":"2014-11-06T15:07:21.000Z","_content":"\n《神经病眼中的objc runtime》北京线下分享活动顺利完成，为了配合讲解编造的几个runtime考题发出来分享下：  \n\n1. 为分享内容配合讲解用，可不是为了面试别人的哦（容易被抽）\n2. 这几个题分别对应了runtime中几个隐蔽的知识点，挺非主流的，没必要深究\n3. 答案在本页末尾给出，有同学针对这几道题写了讲解，所以就一笔带过了\n4. 分享的具体内容争取找个时间写个blog总结下\n\n# 神经病院objc runtime入院考试\n\n(1) 下面的代码输出什么？  \n\n``` objc\n@implementation Son : Father\n- (id)init {\n    self = [super init];\n    if (self) {\n        NSLog(@\"%@\", NSStringFromClass([self class]));\n        NSLog(@\"%@\", NSStringFromClass([super class]));\n    }\n    return self;\n}\n@end\n```\n\n(2) 下面代码的结果？  \n\n``` objc\nBOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];\nBOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];\nBOOL res3 = [(id)[Sark class] isKindOfClass:[Sark class]];\nBOOL res4 = [(id)[Sark class] isMemberOfClass:[Sark class]];\n```\n\n(3) 下面的代码会？Compile Error / Runtime Crash / NSLog...?  \n\n``` objc\n@interface NSObject (Sark)\n+ (void)foo;\n@end\n@implementation NSObject (Sark)\n- (void)foo {\n    NSLog(@\"IMP: -[NSObject (Sark) foo]\");\n}\n@end\n// 测试代码\n[NSObject foo];\n[[NSObject new] foo];\n```\n\n(4) 下面的代码会？Compile Error / Runtime Crash / NSLog...?  \n\n``` objc\n@interface Sark : NSObject\n@property (nonatomic, copy) NSString *name;\n@end\n@implementation Sark\n- (void)speak {\n    NSLog(@\"my name's %@\", self.name);\n}\n@end\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    id cls = [Sark class];\n    void *obj = &cls;\n    [(__bridge id)obj speak];\n}\n@end\n```\n\n# 答案\n\n(1) Son / Son 因为super为编译器标示符，向super发送的消息被编译成`objc_msgSendSuper`，但仍以self作为reveiver  \n(2) YES / NO / NO / NO `<NSObject>`协议有一套类方法的隐藏实现，所以编译运行正常；由于NSObject meta class的父类为NSObject class，所以只有第一句为YES  \n(3) 编译运行正常，两行代码都执行`-foo`。 [NSObject foo]方法查找路线为 NSObject meta class --super-> NSObject class，和第二题知识点很相似。  \n(4)编译运行正常，输出ViewController中的`self`对象。 编译运行正常，调用了`-speak`方法，由于\n\n``` objc\nid cls = [Sark class];\nvoid *obj = &cls;\n```\n\n`obj`已经满足了构成一个objc对象的全部要求（首地址指向ClassObject），遂能够正常走消息机制；  \n由于这个人造的对象在栈上，而取`self.name`的操作本质上是self指针在内存向高位地址偏移（32位下一个指针是4字节），按viewDidLoad执行时各个变量入栈顺序从高到底为（self, _cmd, self.class, self, obj）（前两个是方法隐含入参，随后两个为super调用的两个压栈参数），遂栈低地址的obj+4取到了self。\n","source":"_posts/runtime-nuts.md","raw":"title: 神经病院objc runtime入院考试\ndate: 2014-11-06 23:07:21\ntags: wtf\n---\n\n《神经病眼中的objc runtime》北京线下分享活动顺利完成，为了配合讲解编造的几个runtime考题发出来分享下：  \n\n1. 为分享内容配合讲解用，可不是为了面试别人的哦（容易被抽）\n2. 这几个题分别对应了runtime中几个隐蔽的知识点，挺非主流的，没必要深究\n3. 答案在本页末尾给出，有同学针对这几道题写了讲解，所以就一笔带过了\n4. 分享的具体内容争取找个时间写个blog总结下\n\n# 神经病院objc runtime入院考试\n\n(1) 下面的代码输出什么？  \n\n``` objc\n@implementation Son : Father\n- (id)init {\n    self = [super init];\n    if (self) {\n        NSLog(@\"%@\", NSStringFromClass([self class]));\n        NSLog(@\"%@\", NSStringFromClass([super class]));\n    }\n    return self;\n}\n@end\n```\n\n(2) 下面代码的结果？  \n\n``` objc\nBOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];\nBOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];\nBOOL res3 = [(id)[Sark class] isKindOfClass:[Sark class]];\nBOOL res4 = [(id)[Sark class] isMemberOfClass:[Sark class]];\n```\n\n(3) 下面的代码会？Compile Error / Runtime Crash / NSLog...?  \n\n``` objc\n@interface NSObject (Sark)\n+ (void)foo;\n@end\n@implementation NSObject (Sark)\n- (void)foo {\n    NSLog(@\"IMP: -[NSObject (Sark) foo]\");\n}\n@end\n// 测试代码\n[NSObject foo];\n[[NSObject new] foo];\n```\n\n(4) 下面的代码会？Compile Error / Runtime Crash / NSLog...?  \n\n``` objc\n@interface Sark : NSObject\n@property (nonatomic, copy) NSString *name;\n@end\n@implementation Sark\n- (void)speak {\n    NSLog(@\"my name's %@\", self.name);\n}\n@end\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    id cls = [Sark class];\n    void *obj = &cls;\n    [(__bridge id)obj speak];\n}\n@end\n```\n\n# 答案\n\n(1) Son / Son 因为super为编译器标示符，向super发送的消息被编译成`objc_msgSendSuper`，但仍以self作为reveiver  \n(2) YES / NO / NO / NO `<NSObject>`协议有一套类方法的隐藏实现，所以编译运行正常；由于NSObject meta class的父类为NSObject class，所以只有第一句为YES  \n(3) 编译运行正常，两行代码都执行`-foo`。 [NSObject foo]方法查找路线为 NSObject meta class --super-> NSObject class，和第二题知识点很相似。  \n(4)编译运行正常，输出ViewController中的`self`对象。 编译运行正常，调用了`-speak`方法，由于\n\n``` objc\nid cls = [Sark class];\nvoid *obj = &cls;\n```\n\n`obj`已经满足了构成一个objc对象的全部要求（首地址指向ClassObject），遂能够正常走消息机制；  \n由于这个人造的对象在栈上，而取`self.name`的操作本质上是self指针在内存向高位地址偏移（32位下一个指针是4字节），按viewDidLoad执行时各个变量入栈顺序从高到底为（self, _cmd, self.class, self, obj）（前两个是方法隐含入参，随后两个为super调用的两个压栈参数），遂栈低地址的obj+4取到了self。\n","slug":"runtime-nuts","published":1,"updated":"2016-03-27T07:51:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxmr002aev12pa6rj0pw","content":"<p>《神经病眼中的objc runtime》北京线下分享活动顺利完成，为了配合讲解编造的几个runtime考题发出来分享下：  </p>\n<ol>\n<li>为分享内容配合讲解用，可不是为了面试别人的哦（容易被抽）</li>\n<li>这几个题分别对应了runtime中几个隐蔽的知识点，挺非主流的，没必要深究</li>\n<li>答案在本页末尾给出，有同学针对这几道题写了讲解，所以就一笔带过了</li>\n<li>分享的具体内容争取找个时间写个blog总结下</li>\n</ol>\n<h1 id=\"神经病院objc-runtime入院考试\"><a href=\"#神经病院objc-runtime入院考试\" class=\"headerlink\" title=\"神经病院objc runtime入院考试\"></a>神经病院objc runtime入院考试</h1><p>(1) 下面的代码输出什么？  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Son</span> : <span class=\"title\">Father</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">self</span> class]));</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">super</span> class]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>(2) 下面代码的结果？  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">BOOL</span> res1 = [(<span class=\"keyword\">id</span>)[<span class=\"built_in\">NSObject</span> class] isKindOfClass:[<span class=\"built_in\">NSObject</span> class]];</span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> res2 = [(<span class=\"keyword\">id</span>)[<span class=\"built_in\">NSObject</span> class] isMemberOfClass:[<span class=\"built_in\">NSObject</span> class]];</span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> res3 = [(<span class=\"keyword\">id</span>)[Sark class] isKindOfClass:[Sark class]];</span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> res4 = [(<span class=\"keyword\">id</span>)[Sark class] isMemberOfClass:[Sark class]];</span><br></pre></td></tr></table></figure>\n<p>(3) 下面的代码会？Compile Error / Runtime Crash / NSLog…?  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span> (<span class=\"title\">Sark</span>)</span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)foo;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSObject</span> (<span class=\"title\">Sark</span>)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)foo &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"IMP: -[NSObject (Sark) foo]\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"comment\">// 测试代码</span></span><br><span class=\"line\">[<span class=\"built_in\">NSObject</span> foo];</span><br><span class=\"line\">[[<span class=\"built_in\">NSObject</span> new] foo];</span><br></pre></td></tr></table></figure>\n<p>(4) 下面的代码会？Compile Error / Runtime Crash / NSLog…?  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Sark</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)speak &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"my name's %@\"</span>, <span class=\"keyword\">self</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"keyword\">id</span> cls = [Sark class];</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *obj = &amp;cls;</span><br><span class=\"line\">    [(__bridge <span class=\"keyword\">id</span>)obj speak];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案\"></a>答案</h1><p>(1) Son / Son 因为super为编译器标示符，向super发送的消息被编译成<code>objc_msgSendSuper</code>，但仍以self作为reveiver<br>(2) YES / NO / NO / NO <code>&lt;NSObject&gt;</code>协议有一套类方法的隐藏实现，所以编译运行正常；由于NSObject meta class的父类为NSObject class，所以只有第一句为YES<br>(3) 编译运行正常，两行代码都执行<code>-foo</code>。 [NSObject foo]方法查找路线为 NSObject meta class –super-&gt; NSObject class，和第二题知识点很相似。<br>(4)编译运行正常，输出ViewController中的<code>self</code>对象。 编译运行正常，调用了<code>-speak</code>方法，由于</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> cls = [Sark class];</span><br><span class=\"line\"><span class=\"keyword\">void</span> *obj = &amp;cls;</span><br></pre></td></tr></table></figure>\n<p><code>obj</code>已经满足了构成一个objc对象的全部要求（首地址指向ClassObject），遂能够正常走消息机制；<br>由于这个人造的对象在栈上，而取<code>self.name</code>的操作本质上是self指针在内存向高位地址偏移（32位下一个指针是4字节），按viewDidLoad执行时各个变量入栈顺序从高到底为（self, _cmd, self.class, self, obj）（前两个是方法隐含入参，随后两个为super调用的两个压栈参数），遂栈低地址的obj+4取到了self。</p>\n","excerpt":"","more":"<p>《神经病眼中的objc runtime》北京线下分享活动顺利完成，为了配合讲解编造的几个runtime考题发出来分享下：  </p>\n<ol>\n<li>为分享内容配合讲解用，可不是为了面试别人的哦（容易被抽）</li>\n<li>这几个题分别对应了runtime中几个隐蔽的知识点，挺非主流的，没必要深究</li>\n<li>答案在本页末尾给出，有同学针对这几道题写了讲解，所以就一笔带过了</li>\n<li>分享的具体内容争取找个时间写个blog总结下</li>\n</ol>\n<h1 id=\"神经病院objc-runtime入院考试\"><a href=\"#神经病院objc-runtime入院考试\" class=\"headerlink\" title=\"神经病院objc runtime入院考试\"></a>神经病院objc runtime入院考试</h1><p>(1) 下面的代码输出什么？  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Son</span> : <span class=\"title\">Father</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">self</span> class]));</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">super</span> class]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>(2) 下面代码的结果？  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">BOOL</span> res1 = [(<span class=\"keyword\">id</span>)[<span class=\"built_in\">NSObject</span> class] isKindOfClass:[<span class=\"built_in\">NSObject</span> class]];</span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> res2 = [(<span class=\"keyword\">id</span>)[<span class=\"built_in\">NSObject</span> class] isMemberOfClass:[<span class=\"built_in\">NSObject</span> class]];</span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> res3 = [(<span class=\"keyword\">id</span>)[Sark class] isKindOfClass:[Sark class]];</span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> res4 = [(<span class=\"keyword\">id</span>)[Sark class] isMemberOfClass:[Sark class]];</span><br></pre></td></tr></table></figure>\n<p>(3) 下面的代码会？Compile Error / Runtime Crash / NSLog…?  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span> (<span class=\"title\">Sark</span>)</span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)foo;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSObject</span> (<span class=\"title\">Sark</span>)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)foo &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"IMP: -[NSObject (Sark) foo]\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"comment\">// 测试代码</span></span><br><span class=\"line\">[<span class=\"built_in\">NSObject</span> foo];</span><br><span class=\"line\">[[<span class=\"built_in\">NSObject</span> new] foo];</span><br></pre></td></tr></table></figure>\n<p>(4) 下面的代码会？Compile Error / Runtime Crash / NSLog…?  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Sark</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Sark</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)speak &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"my name's %@\"</span>, <span class=\"keyword\">self</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"keyword\">id</span> cls = [Sark class];</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *obj = &amp;cls;</span><br><span class=\"line\">    [(__bridge <span class=\"keyword\">id</span>)obj speak];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案\"></a>答案</h1><p>(1) Son / Son 因为super为编译器标示符，向super发送的消息被编译成<code>objc_msgSendSuper</code>，但仍以self作为reveiver<br>(2) YES / NO / NO / NO <code>&lt;NSObject&gt;</code>协议有一套类方法的隐藏实现，所以编译运行正常；由于NSObject meta class的父类为NSObject class，所以只有第一句为YES<br>(3) 编译运行正常，两行代码都执行<code>-foo</code>。 [NSObject foo]方法查找路线为 NSObject meta class –super-&gt; NSObject class，和第二题知识点很相似。<br>(4)编译运行正常，输出ViewController中的<code>self</code>对象。 编译运行正常，调用了<code>-speak</code>方法，由于</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> cls = [Sark class];</span><br><span class=\"line\"><span class=\"keyword\">void</span> *obj = &amp;cls;</span><br></pre></td></tr></table></figure>\n<p><code>obj</code>已经满足了构成一个objc对象的全部要求（首地址指向ClassObject），遂能够正常走消息机制；<br>由于这个人造的对象在栈上，而取<code>self.name</code>的操作本质上是self指针在内存向高位地址偏移（32位下一个指针是4字节），按viewDidLoad执行时各个变量入栈顺序从高到底为（self, _cmd, self.class, self, obj）（前两个是方法隐含入参，随后两个为super调用的两个压栈参数），遂栈低地址的obj+4取到了self。</p>\n"},{"title":"ARC对self的内存管理","date":"2015-01-17T02:59:56.000Z","_content":"\n记录下前两天的一次讨论，源于网络库**YTKNetwork**中[\"YTKRequest.m\"](https://github.com/yuantiku/YTKNetwork/blob/master/YTKNetwork/YTKRequest.m)的`- start`方法其中的几行代码：  \n\n``` objc\n- (void)start {\n    // ......\n    YTKRequest *strongSelf = self;\n    [strongSelf.delegate requestFinished:strongSelf];\n    if (strongSelf.successCompletionBlock) {\n        strongSelf.successCompletionBlock(strongSelf);\n    }\n    [strongSelf clearCompletionBlock];\n}\n```\n\n看起来比较有违常理，所以和猿题库的@晨钰Lancy，@唐巧以及网易的@老汉一起讨论了下这个问题。  \n\n---\n\n具体的问题大概是这样：\n\n1. 调用方（如view controller）实例化并强引用`YTKRequest`对象，将自己作为其delegate\n2. 调用方调用`YTKRequest`的`- start`方法发起网络请求\n3. 调用方在`- requestFinished:`中执行了`self.request = nil;`\n4. `YTKRequest`中，`- start`方法在回调完`- requestFinished:`后**BAD_ACCESS**了\n\n也就是说，`- start`方法还未返回时，self就被外部释放了。作者发现了这个潜在的问题，所以在方法局部增设了一个`strongSelf`的强引用来保证self的生命周期延续到方法结束。问题是解决了，但是更希望知道原因。  \n\n简化说明就是：  \n\n``` objc\n- (void)foo {\n    // self被delegate持有\n    [self.delegate callout]; // 外部释放了这个对象\n    // 这里self野指针\n}\n```\n\n---\n\n现在想想还是比较不符合常理，入参的self居然不能保证这个函数执行完成。后来查阅了下文档，发现是ARC的(gao)机(de)制(gui)，clang的[《这篇ARC文档》](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#self)中有明确的解释，总结如下：  \n\n- ARC下，self既不是strong也不是weak，而是`unsafe_unretained`的，也就是说，入参的self被表示为：（init系列方法的self除外）\n\n``` objc\n- (void)start {\n   const __unsafe_unretained YTKRequest *self;\n   // ...\n}\n```\n\n- 在方法调用时，ARC不会对self做retain或release，生命周期全由**它的调用方来保证**，如果调用方没有保证，就会出现上面的crash\n- ARC这样做的原因是**性能优化**，objc中100%的方法（不是函数）调用第一个参数都是self，同时，99%的情况下，调用方都不会在方法执行时把这个对象释放，所以相比于在每个方法中插入对self的引用计数管理：\n\n``` objc\n- (void)start {\n    objc_retain(self);\n    // 其中的代码self一定不会被释放\n    objc_release(self);\n}\n```\n\n优化了的性能还真是比较可观。  \n而且，ARC也用了挺多方法来避免开发者进行额外的引用计数控制，比如方法的**命名约定**，通过判断方法是否以如`init`，`alloc`，`new`，`copy`等关键字开头来决定其内存管理方式。  \n\n---   \n\n**One more thing**\n\n在写test时发现，下面两种调用方法会导致不同结果：\n\n``` objc\n- (void)viewDidLoad {\n    // 1\n    [_request start]; // crash\n    // 2\n    [self.request start]; // 正常\n}\n```\n\n因为`self.request`是一次方法调用，返回的结果被`objc_retainAutoreleasedReturnValue`方法在局部进行了一次强引用，关于这个方法可以看之前写过的关于Autorelease的[《这篇文章》](http://blog.sunnyxx.com/2014/10/15/behind-autorelease/)\n","source":"_posts/self-in-arc.md","raw":"title: ARC对self的内存管理\ndate: 2015-01-17 10:59:56\ntags: objc刨根问底\n---\n\n记录下前两天的一次讨论，源于网络库**YTKNetwork**中[\"YTKRequest.m\"](https://github.com/yuantiku/YTKNetwork/blob/master/YTKNetwork/YTKRequest.m)的`- start`方法其中的几行代码：  \n\n``` objc\n- (void)start {\n    // ......\n    YTKRequest *strongSelf = self;\n    [strongSelf.delegate requestFinished:strongSelf];\n    if (strongSelf.successCompletionBlock) {\n        strongSelf.successCompletionBlock(strongSelf);\n    }\n    [strongSelf clearCompletionBlock];\n}\n```\n\n看起来比较有违常理，所以和猿题库的@晨钰Lancy，@唐巧以及网易的@老汉一起讨论了下这个问题。  \n\n---\n\n具体的问题大概是这样：\n\n1. 调用方（如view controller）实例化并强引用`YTKRequest`对象，将自己作为其delegate\n2. 调用方调用`YTKRequest`的`- start`方法发起网络请求\n3. 调用方在`- requestFinished:`中执行了`self.request = nil;`\n4. `YTKRequest`中，`- start`方法在回调完`- requestFinished:`后**BAD_ACCESS**了\n\n也就是说，`- start`方法还未返回时，self就被外部释放了。作者发现了这个潜在的问题，所以在方法局部增设了一个`strongSelf`的强引用来保证self的生命周期延续到方法结束。问题是解决了，但是更希望知道原因。  \n\n简化说明就是：  \n\n``` objc\n- (void)foo {\n    // self被delegate持有\n    [self.delegate callout]; // 外部释放了这个对象\n    // 这里self野指针\n}\n```\n\n---\n\n现在想想还是比较不符合常理，入参的self居然不能保证这个函数执行完成。后来查阅了下文档，发现是ARC的(gao)机(de)制(gui)，clang的[《这篇ARC文档》](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#self)中有明确的解释，总结如下：  \n\n- ARC下，self既不是strong也不是weak，而是`unsafe_unretained`的，也就是说，入参的self被表示为：（init系列方法的self除外）\n\n``` objc\n- (void)start {\n   const __unsafe_unretained YTKRequest *self;\n   // ...\n}\n```\n\n- 在方法调用时，ARC不会对self做retain或release，生命周期全由**它的调用方来保证**，如果调用方没有保证，就会出现上面的crash\n- ARC这样做的原因是**性能优化**，objc中100%的方法（不是函数）调用第一个参数都是self，同时，99%的情况下，调用方都不会在方法执行时把这个对象释放，所以相比于在每个方法中插入对self的引用计数管理：\n\n``` objc\n- (void)start {\n    objc_retain(self);\n    // 其中的代码self一定不会被释放\n    objc_release(self);\n}\n```\n\n优化了的性能还真是比较可观。  \n而且，ARC也用了挺多方法来避免开发者进行额外的引用计数控制，比如方法的**命名约定**，通过判断方法是否以如`init`，`alloc`，`new`，`copy`等关键字开头来决定其内存管理方式。  \n\n---   \n\n**One more thing**\n\n在写test时发现，下面两种调用方法会导致不同结果：\n\n``` objc\n- (void)viewDidLoad {\n    // 1\n    [_request start]; // crash\n    // 2\n    [self.request start]; // 正常\n}\n```\n\n因为`self.request`是一次方法调用，返回的结果被`objc_retainAutoreleasedReturnValue`方法在局部进行了一次强引用，关于这个方法可以看之前写过的关于Autorelease的[《这篇文章》](http://blog.sunnyxx.com/2014/10/15/behind-autorelease/)\n","slug":"self-in-arc","published":1,"updated":"2016-03-27T07:48:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxmt002dev12oy0e5293","content":"<p>记录下前两天的一次讨论，源于网络库<strong>YTKNetwork</strong>中<a href=\"https://github.com/yuantiku/YTKNetwork/blob/master/YTKNetwork/YTKRequest.m\" target=\"_blank\" rel=\"external\">“YTKRequest.m”</a>的<code>- start</code>方法其中的几行代码：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)start &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">    YTKRequest *strongSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    [strongSelf.delegate requestFinished:strongSelf];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (strongSelf.successCompletionBlock) &#123;</span><br><span class=\"line\">        strongSelf.successCompletionBlock(strongSelf);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [strongSelf clearCompletionBlock];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看起来比较有违常理，所以和猿题库的@晨钰Lancy，@唐巧以及网易的@老汉一起讨论了下这个问题。  </p>\n<hr>\n<p>具体的问题大概是这样：</p>\n<ol>\n<li>调用方（如view controller）实例化并强引用<code>YTKRequest</code>对象，将自己作为其delegate</li>\n<li>调用方调用<code>YTKRequest</code>的<code>- start</code>方法发起网络请求</li>\n<li>调用方在<code>- requestFinished:</code>中执行了<code>self.request = nil;</code></li>\n<li><code>YTKRequest</code>中，<code>- start</code>方法在回调完<code>- requestFinished:</code>后<strong>BAD_ACCESS</strong>了</li>\n</ol>\n<p>也就是说，<code>- start</code>方法还未返回时，self就被外部释放了。作者发现了这个潜在的问题，所以在方法局部增设了一个<code>strongSelf</code>的强引用来保证self的生命周期延续到方法结束。问题是解决了，但是更希望知道原因。  </p>\n<p>简化说明就是：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)foo &#123;</span><br><span class=\"line\">    <span class=\"comment\">// self被delegate持有</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.delegate callout]; <span class=\"comment\">// 外部释放了这个对象</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里self野指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>现在想想还是比较不符合常理，入参的self居然不能保证这个函数执行完成。后来查阅了下文档，发现是ARC的(gao)机(de)制(gui)，clang的<a href=\"http://clang.llvm.org/docs/AutomaticReferenceCounting.html#self\" target=\"_blank\" rel=\"external\">《这篇ARC文档》</a>中有明确的解释，总结如下：  </p>\n<ul>\n<li>ARC下，self既不是strong也不是weak，而是<code>unsafe_unretained</code>的，也就是说，入参的self被表示为：（init系列方法的self除外）</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)start &#123;</span><br><span class=\"line\">   <span class=\"keyword\">const</span> __unsafe_unretained YTKRequest *<span class=\"keyword\">self</span>;</span><br><span class=\"line\">   <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在方法调用时，ARC不会对self做retain或release，生命周期全由<strong>它的调用方来保证</strong>，如果调用方没有保证，就会出现上面的crash</li>\n<li>ARC这样做的原因是<strong>性能优化</strong>，objc中100%的方法（不是函数）调用第一个参数都是self，同时，99%的情况下，调用方都不会在方法执行时把这个对象释放，所以相比于在每个方法中插入对self的引用计数管理：</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)start &#123;</span><br><span class=\"line\">    objc_retain(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 其中的代码self一定不会被释放</span></span><br><span class=\"line\">    objc_release(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优化了的性能还真是比较可观。<br>而且，ARC也用了挺多方法来避免开发者进行额外的引用计数控制，比如方法的<strong>命名约定</strong>，通过判断方法是否以如<code>init</code>，<code>alloc</code>，<code>new</code>，<code>copy</code>等关键字开头来决定其内存管理方式。  </p>\n<hr>\n<p><strong>One more thing</strong></p>\n<p>在写test时发现，下面两种调用方法会导致不同结果：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1</span></span><br><span class=\"line\">    [_request start]; <span class=\"comment\">// crash</span></span><br><span class=\"line\">    <span class=\"comment\">// 2</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.request start]; <span class=\"comment\">// 正常</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为<code>self.request</code>是一次方法调用，返回的结果被<code>objc_retainAutoreleasedReturnValue</code>方法在局部进行了一次强引用，关于这个方法可以看之前写过的关于Autorelease的<a href=\"http://blog.sunnyxx.com/2014/10/15/behind-autorelease/\">《这篇文章》</a></p>\n","excerpt":"","more":"<p>记录下前两天的一次讨论，源于网络库<strong>YTKNetwork</strong>中<a href=\"https://github.com/yuantiku/YTKNetwork/blob/master/YTKNetwork/YTKRequest.m\">“YTKRequest.m”</a>的<code>- start</code>方法其中的几行代码：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)start &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">    YTKRequest *strongSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    [strongSelf.delegate requestFinished:strongSelf];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (strongSelf.successCompletionBlock) &#123;</span><br><span class=\"line\">        strongSelf.successCompletionBlock(strongSelf);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [strongSelf clearCompletionBlock];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看起来比较有违常理，所以和猿题库的@晨钰Lancy，@唐巧以及网易的@老汉一起讨论了下这个问题。  </p>\n<hr>\n<p>具体的问题大概是这样：</p>\n<ol>\n<li>调用方（如view controller）实例化并强引用<code>YTKRequest</code>对象，将自己作为其delegate</li>\n<li>调用方调用<code>YTKRequest</code>的<code>- start</code>方法发起网络请求</li>\n<li>调用方在<code>- requestFinished:</code>中执行了<code>self.request = nil;</code></li>\n<li><code>YTKRequest</code>中，<code>- start</code>方法在回调完<code>- requestFinished:</code>后<strong>BAD_ACCESS</strong>了</li>\n</ol>\n<p>也就是说，<code>- start</code>方法还未返回时，self就被外部释放了。作者发现了这个潜在的问题，所以在方法局部增设了一个<code>strongSelf</code>的强引用来保证self的生命周期延续到方法结束。问题是解决了，但是更希望知道原因。  </p>\n<p>简化说明就是：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)foo &#123;</span><br><span class=\"line\">    <span class=\"comment\">// self被delegate持有</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.delegate callout]; <span class=\"comment\">// 外部释放了这个对象</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里self野指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>现在想想还是比较不符合常理，入参的self居然不能保证这个函数执行完成。后来查阅了下文档，发现是ARC的(gao)机(de)制(gui)，clang的<a href=\"http://clang.llvm.org/docs/AutomaticReferenceCounting.html#self\">《这篇ARC文档》</a>中有明确的解释，总结如下：  </p>\n<ul>\n<li>ARC下，self既不是strong也不是weak，而是<code>unsafe_unretained</code>的，也就是说，入参的self被表示为：（init系列方法的self除外）</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)start &#123;</span><br><span class=\"line\">   <span class=\"keyword\">const</span> __unsafe_unretained YTKRequest *<span class=\"keyword\">self</span>;</span><br><span class=\"line\">   <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在方法调用时，ARC不会对self做retain或release，生命周期全由<strong>它的调用方来保证</strong>，如果调用方没有保证，就会出现上面的crash</li>\n<li>ARC这样做的原因是<strong>性能优化</strong>，objc中100%的方法（不是函数）调用第一个参数都是self，同时，99%的情况下，调用方都不会在方法执行时把这个对象释放，所以相比于在每个方法中插入对self的引用计数管理：</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)start &#123;</span><br><span class=\"line\">    objc_retain(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 其中的代码self一定不会被释放</span></span><br><span class=\"line\">    objc_release(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优化了的性能还真是比较可观。<br>而且，ARC也用了挺多方法来避免开发者进行额外的引用计数控制，比如方法的<strong>命名约定</strong>，通过判断方法是否以如<code>init</code>，<code>alloc</code>，<code>new</code>，<code>copy</code>等关键字开头来决定其内存管理方式。  </p>\n<hr>\n<p><strong>One more thing</strong></p>\n<p>在写test时发现，下面两种调用方法会导致不同结果：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1</span></span><br><span class=\"line\">    [_request start]; <span class=\"comment\">// crash</span></span><br><span class=\"line\">    <span class=\"comment\">// 2</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.request start]; <span class=\"comment\">// 正常</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为<code>self.request</code>是一次方法调用，返回的结果被<code>objc_retainAutoreleasedReturnValue</code>方法在局部进行了一次强引用，关于这个方法可以看之前写过的关于Autorelease的<a href=\"http://blog.sunnyxx.com/2014/10/15/behind-autorelease/\">《这篇文章》</a></p>\n"},{"title":"iOS 开发中的 Self-Manager 模式","date":"2015-12-19T03:53:06.000Z","_content":"\n`Self-Manager` 源于我们团队内部的黑话，“诶？你刚去的创业公司有几个 iOS 开发啊？” “就我一个” “靠，你这是 Self-Manager 啊”\n\n最近，这个思路被我们当做了一种设计模式，即**赋予一个 Widget 更大的权利，让其自己负责自己的事件。**\n举个简单的栗子，这种负责展示头像的视图：\n<img src=\"http://ww1.sinaimg.cn/large/51530583jw1ez4xxydguqj20k40a4ac0.jpg\" width=\"320\">\n它的职责包括：\n1. 通过传入的 URL，加载并展示头像图片\n2. 显示一些附属信息，比如大V的标志\n3. 将用户点击头像的事件传递给外层的 View Controller 跳转到用户信息页面\n\n于是乎这个 Widget 的 API 可以长这个样子：\n\n``` objc\n@interface FDAvatarView : UIView\n// 假设 VIPInfo 是某个 Entity\n- (void)configureWithAvatarURL:(NSURL *)URL VIPInfo:(id)info tapped:(void (^)(void))block;\n@end\n```\n\n使用这个控件的人只需要调用这个 configure 方法就可以配置入参和事件处理。但随之而来的就是一些蛋疼的问题：\n1. configure 的调用者是 superview，上面的例子中也就是一个 UITableViewCell，但 Cell 这层并不知道自己的 ViewController 是谁，于是乎还得向上一级传递这个点击事件，直到能获取到 NavigationController，然后 Push 一个用户信息的页面。\n2. 这个 Avatar View 在 App 的各个地方都可能粗线，而且行为一致，那就意味着事件处理的 block，要散落在各个页面中，同时也带来了很多“只是为向上一层级转发事件”的 **\"Middle Man\"**\n\n为解决这个问题，就需要给这个 View 放权，让其自己 Handle 自己的事件，也就是 `Self-Managed`，为了不破坏 View 的纯洁性，比较好的实践是在 Category 中实现：\n\n``` objc\n@interface FDAvatarView (FDAvatarViewSelfManager)\n- (void)selfManagedConfigureWithAvatarURL:(NSURL *)URL VIPInfo:(id)info uid:(NSString *)uid;\n@end\n```\n\n实现时最好要调用 View 主类提供的 API：\n\n\n``` objc\n@implementation FDAvatarView (FDAvatarViewSelfManager)\n// 为后一个页面的创建增加了个 UID 参数\n- (void)selfManagedConfigureWithAvatarURL:(NSURL *)URL VIPInfo:(id)info UID:(NSString *)UID {\n    [self configureWithAvatarURL:URL VIPInfo:info tapped:^{\n    \t// 假设 App 结构是 Root -> TabBar -> Navigation -> ViewController\n        UITabBarController *tabBarControler = (id)[UIApplication.sharedApplication.delegate.window.rootViewController;\n        UINavigationController *navigationController = tabBarControler.selectedViewController;\n        // 创建用户信息 View Controller\n        FDUserProfileViewController *profileViewController = [FDUserProfileViewController viewControllerWithUID:UID];\n        [navigationController pushViewController:profileViewController animated:YES];\n    }];\n}\n@end\n```\n\n这里用到了类似 AOP 的思路，添加了对 App 层级的耦合，如果觉得这样的耦合方式不妥的话，也可以封装个全局方法去取到当前顶层的 Navigation Controller。\n这样，FDAvatarView 的调用者只需要配置入参，其余的它自己全能搞定了，即使 App 内很多处出现头像，逻辑代码也只有一份。\n\n接下来再来个例子：\n\n<img src=\"http://ww1.sinaimg.cn/large/51530583jw1ez4zzt5l4aj20k60lqgn2.jpg\" width=\"320\">\n\n这个点赞的按钮功能上有几个职责：\n\n1. 显示已有的点赞数\n2. 点击按钮后执行一个小动画，点赞数 +1，同时发送网络请求。\n3. 若已经点赞，点击执行反向操作\n4. 若网络请求发送失败，则回退成点击前的状态\n\n<img src=\"http://ww1.sinaimg.cn/large/51530583jw1ez5055l1exj20k60lu3zz.jpg\" width=\"320\">\n\n这个控件的 API 可以设计成这样：\n\n``` objc\n@interface FDLikeButton : UIButton\n- (void)configureLikeStatus:(BOOL)likeOrNot count:(NSInteger)count animated:(BOOL)animated;\n@end\n```\n\n因为继承自 UIButton，所以外部可以直接设置其 action，就不增加 tappedHandler 的参数了。外部在点击事件中需要调用这个配置方法，播放点赞动画，紧接着发送一个网络请求，若网络请求失败，可以再次调用这个 API 的无动画版本回滚状态。但像上一个例子一样，网络请求和事件处理逻辑相同，但代码却分部在各个页面中，于是给这个 View 增加 Self-Managed 模式的 Category：\n\n``` objc\n@interface FDLikeButton (FDLikeButtonSelfManager)\n- (void)selfManagedConfigureWithLikeStatus:(BOOL)likeOrNot count:(NSInteger)count;\n@end\n```\n\n\n伪代码的实现如下：\n\n``` objc\n@implementation FDLikeButton (FDLikeButtonSelfManager)\n- (void)selfManagedConfigureWithLikeStatus:(BOOL)likeOrNot count:(NSInteger)count {\n    [self configureLikeStatus:likeOrNot count:count animated:NO];\n    [self addTarget:self action:@selector(likeButtonTapped:) forControlEvents:UIControlEventTouchUpInside];\n}\n- (void)likeButtonTapped:(id)sender {\n    // +1 or -1 with animation\n    // Network request ^(NSError *error) {\n    //     if (error) {\n    //         rollback\n    //     }\n    // }\n}\n@end\n```\n\n记得面试题的那篇文章里还调侃说 “面试的时候聊聊设计、架构挺好的，但别整出个往 UIButton 的子类里搞网络请求的奇葩结构就行”，结果就被自己打了个脸。不过从设计上，Self-Manager 模式并没有破坏原有的 MVC 结构，上面两个例子中的 View 依然可以不耦合具体业务逻辑的单拿出来用。使用 Category 的方式把应该写在 ViewController 中的代码移动到 View 的文件中，让功能更加的内聚。\n\n程序的复杂度并不会因哪种酷炫的设计模式所减少，能做到的只是对复杂度的切分和控制，即：\n1. 让一大坨恶心的代码变成几小坨不那么恶心的代码。\n2. 让恶心的代码只在一个地方恶心。\n\nSelf-Manager 模式我们实践的时候写起来很开心，抛砖引玉一下，希望也能解决你的苦恼。\n\n<img src=\"http://ww1.sinaimg.cn/mw600/66b3de17gw1ez4zbk10vaj20go0ciwhd.jpg\" width=\"320\">\n","source":"_posts/self-manager-pattern-in-ios.md","raw":"title: iOS 开发中的 Self-Manager 模式\ndate: 2015-12-19 11:53:06\ntags: ios最佳实践\n---\n\n`Self-Manager` 源于我们团队内部的黑话，“诶？你刚去的创业公司有几个 iOS 开发啊？” “就我一个” “靠，你这是 Self-Manager 啊”\n\n最近，这个思路被我们当做了一种设计模式，即**赋予一个 Widget 更大的权利，让其自己负责自己的事件。**\n举个简单的栗子，这种负责展示头像的视图：\n<img src=\"http://ww1.sinaimg.cn/large/51530583jw1ez4xxydguqj20k40a4ac0.jpg\" width=\"320\">\n它的职责包括：\n1. 通过传入的 URL，加载并展示头像图片\n2. 显示一些附属信息，比如大V的标志\n3. 将用户点击头像的事件传递给外层的 View Controller 跳转到用户信息页面\n\n于是乎这个 Widget 的 API 可以长这个样子：\n\n``` objc\n@interface FDAvatarView : UIView\n// 假设 VIPInfo 是某个 Entity\n- (void)configureWithAvatarURL:(NSURL *)URL VIPInfo:(id)info tapped:(void (^)(void))block;\n@end\n```\n\n使用这个控件的人只需要调用这个 configure 方法就可以配置入参和事件处理。但随之而来的就是一些蛋疼的问题：\n1. configure 的调用者是 superview，上面的例子中也就是一个 UITableViewCell，但 Cell 这层并不知道自己的 ViewController 是谁，于是乎还得向上一级传递这个点击事件，直到能获取到 NavigationController，然后 Push 一个用户信息的页面。\n2. 这个 Avatar View 在 App 的各个地方都可能粗线，而且行为一致，那就意味着事件处理的 block，要散落在各个页面中，同时也带来了很多“只是为向上一层级转发事件”的 **\"Middle Man\"**\n\n为解决这个问题，就需要给这个 View 放权，让其自己 Handle 自己的事件，也就是 `Self-Managed`，为了不破坏 View 的纯洁性，比较好的实践是在 Category 中实现：\n\n``` objc\n@interface FDAvatarView (FDAvatarViewSelfManager)\n- (void)selfManagedConfigureWithAvatarURL:(NSURL *)URL VIPInfo:(id)info uid:(NSString *)uid;\n@end\n```\n\n实现时最好要调用 View 主类提供的 API：\n\n\n``` objc\n@implementation FDAvatarView (FDAvatarViewSelfManager)\n// 为后一个页面的创建增加了个 UID 参数\n- (void)selfManagedConfigureWithAvatarURL:(NSURL *)URL VIPInfo:(id)info UID:(NSString *)UID {\n    [self configureWithAvatarURL:URL VIPInfo:info tapped:^{\n    \t// 假设 App 结构是 Root -> TabBar -> Navigation -> ViewController\n        UITabBarController *tabBarControler = (id)[UIApplication.sharedApplication.delegate.window.rootViewController;\n        UINavigationController *navigationController = tabBarControler.selectedViewController;\n        // 创建用户信息 View Controller\n        FDUserProfileViewController *profileViewController = [FDUserProfileViewController viewControllerWithUID:UID];\n        [navigationController pushViewController:profileViewController animated:YES];\n    }];\n}\n@end\n```\n\n这里用到了类似 AOP 的思路，添加了对 App 层级的耦合，如果觉得这样的耦合方式不妥的话，也可以封装个全局方法去取到当前顶层的 Navigation Controller。\n这样，FDAvatarView 的调用者只需要配置入参，其余的它自己全能搞定了，即使 App 内很多处出现头像，逻辑代码也只有一份。\n\n接下来再来个例子：\n\n<img src=\"http://ww1.sinaimg.cn/large/51530583jw1ez4zzt5l4aj20k60lqgn2.jpg\" width=\"320\">\n\n这个点赞的按钮功能上有几个职责：\n\n1. 显示已有的点赞数\n2. 点击按钮后执行一个小动画，点赞数 +1，同时发送网络请求。\n3. 若已经点赞，点击执行反向操作\n4. 若网络请求发送失败，则回退成点击前的状态\n\n<img src=\"http://ww1.sinaimg.cn/large/51530583jw1ez5055l1exj20k60lu3zz.jpg\" width=\"320\">\n\n这个控件的 API 可以设计成这样：\n\n``` objc\n@interface FDLikeButton : UIButton\n- (void)configureLikeStatus:(BOOL)likeOrNot count:(NSInteger)count animated:(BOOL)animated;\n@end\n```\n\n因为继承自 UIButton，所以外部可以直接设置其 action，就不增加 tappedHandler 的参数了。外部在点击事件中需要调用这个配置方法，播放点赞动画，紧接着发送一个网络请求，若网络请求失败，可以再次调用这个 API 的无动画版本回滚状态。但像上一个例子一样，网络请求和事件处理逻辑相同，但代码却分部在各个页面中，于是给这个 View 增加 Self-Managed 模式的 Category：\n\n``` objc\n@interface FDLikeButton (FDLikeButtonSelfManager)\n- (void)selfManagedConfigureWithLikeStatus:(BOOL)likeOrNot count:(NSInteger)count;\n@end\n```\n\n\n伪代码的实现如下：\n\n``` objc\n@implementation FDLikeButton (FDLikeButtonSelfManager)\n- (void)selfManagedConfigureWithLikeStatus:(BOOL)likeOrNot count:(NSInteger)count {\n    [self configureLikeStatus:likeOrNot count:count animated:NO];\n    [self addTarget:self action:@selector(likeButtonTapped:) forControlEvents:UIControlEventTouchUpInside];\n}\n- (void)likeButtonTapped:(id)sender {\n    // +1 or -1 with animation\n    // Network request ^(NSError *error) {\n    //     if (error) {\n    //         rollback\n    //     }\n    // }\n}\n@end\n```\n\n记得面试题的那篇文章里还调侃说 “面试的时候聊聊设计、架构挺好的，但别整出个往 UIButton 的子类里搞网络请求的奇葩结构就行”，结果就被自己打了个脸。不过从设计上，Self-Manager 模式并没有破坏原有的 MVC 结构，上面两个例子中的 View 依然可以不耦合具体业务逻辑的单拿出来用。使用 Category 的方式把应该写在 ViewController 中的代码移动到 View 的文件中，让功能更加的内聚。\n\n程序的复杂度并不会因哪种酷炫的设计模式所减少，能做到的只是对复杂度的切分和控制，即：\n1. 让一大坨恶心的代码变成几小坨不那么恶心的代码。\n2. 让恶心的代码只在一个地方恶心。\n\nSelf-Manager 模式我们实践的时候写起来很开心，抛砖引玉一下，希望也能解决你的苦恼。\n\n<img src=\"http://ww1.sinaimg.cn/mw600/66b3de17gw1ez4zbk10vaj20go0ciwhd.jpg\" width=\"320\">\n","slug":"self-manager-pattern-in-ios","published":1,"updated":"2016-03-26T09:22:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxmv002fev123tfx87dp","content":"<p><code>Self-Manager</code> 源于我们团队内部的黑话，“诶？你刚去的创业公司有几个 iOS 开发啊？” “就我一个” “靠，你这是 Self-Manager 啊”</p>\n<p>最近，这个思路被我们当做了一种设计模式，即<strong>赋予一个 Widget 更大的权利，让其自己负责自己的事件。</strong><br>举个简单的栗子，这种负责展示头像的视图：<br><img src=\"http://ww1.sinaimg.cn/large/51530583jw1ez4xxydguqj20k40a4ac0.jpg\" width=\"320\"><br>它的职责包括：</p>\n<ol>\n<li>通过传入的 URL，加载并展示头像图片</li>\n<li>显示一些附属信息，比如大V的标志</li>\n<li>将用户点击头像的事件传递给外层的 View Controller 跳转到用户信息页面</li>\n</ol>\n<p>于是乎这个 Widget 的 API 可以长这个样子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">FDAvatarView</span> : <span class=\"title\">UIView</span></span></span><br><span class=\"line\"><span class=\"comment\">// 假设 VIPInfo 是某个 Entity</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)configureWithAvatarURL:(<span class=\"built_in\">NSURL</span> *)URL VIPInfo:(<span class=\"keyword\">id</span>)info tapped:(<span class=\"keyword\">void</span> (^)(<span class=\"keyword\">void</span>))block;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>使用这个控件的人只需要调用这个 configure 方法就可以配置入参和事件处理。但随之而来的就是一些蛋疼的问题：</p>\n<ol>\n<li>configure 的调用者是 superview，上面的例子中也就是一个 UITableViewCell，但 Cell 这层并不知道自己的 ViewController 是谁，于是乎还得向上一级传递这个点击事件，直到能获取到 NavigationController，然后 Push 一个用户信息的页面。</li>\n<li>这个 Avatar View 在 App 的各个地方都可能粗线，而且行为一致，那就意味着事件处理的 block，要散落在各个页面中，同时也带来了很多“只是为向上一层级转发事件”的 <strong>“Middle Man”</strong></li>\n</ol>\n<p>为解决这个问题，就需要给这个 View 放权，让其自己 Handle 自己的事件，也就是 <code>Self-Managed</code>，为了不破坏 View 的纯洁性，比较好的实践是在 Category 中实现：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">FDAvatarView</span> (<span class=\"title\">FDAvatarViewSelfManager</span>)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)selfManagedConfigureWithAvatarURL:(<span class=\"built_in\">NSURL</span> *)URL VIPInfo:(<span class=\"keyword\">id</span>)info uid:(<span class=\"built_in\">NSString</span> *)uid;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>实现时最好要调用 View 主类提供的 API：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">FDAvatarView</span> (<span class=\"title\">FDAvatarViewSelfManager</span>)</span></span><br><span class=\"line\"><span class=\"comment\">// 为后一个页面的创建增加了个 UID 参数</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)selfManagedConfigureWithAvatarURL:(<span class=\"built_in\">NSURL</span> *)URL VIPInfo:(<span class=\"keyword\">id</span>)info <span class=\"built_in\">UID</span>:(<span class=\"built_in\">NSString</span> *)<span class=\"built_in\">UID</span> &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> configureWithAvatarURL:URL VIPInfo:info tapped:^&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 假设 App 结构是 Root -&gt; TabBar -&gt; Navigation -&gt; ViewController</span></span><br><span class=\"line\">        <span class=\"built_in\">UITabBarController</span> *tabBarControler = (<span class=\"keyword\">id</span>)[<span class=\"built_in\">UIApplication</span>.sharedApplication.delegate.window.rootViewController;</span><br><span class=\"line\">        <span class=\"built_in\">UINavigationController</span> *navigationController = tabBarControler.selectedViewController;</span><br><span class=\"line\">        <span class=\"comment\">// 创建用户信息 View Controller</span></span><br><span class=\"line\">        FDUserProfileViewController *profileViewController = [FDUserProfileViewController viewControllerWith<span class=\"built_in\">UID</span>:<span class=\"built_in\">UID</span>];</span><br><span class=\"line\">        [navigationController pushViewController:profileViewController animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>这里用到了类似 AOP 的思路，添加了对 App 层级的耦合，如果觉得这样的耦合方式不妥的话，也可以封装个全局方法去取到当前顶层的 Navigation Controller。<br>这样，FDAvatarView 的调用者只需要配置入参，其余的它自己全能搞定了，即使 App 内很多处出现头像，逻辑代码也只有一份。</p>\n<p>接下来再来个例子：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/51530583jw1ez4zzt5l4aj20k60lqgn2.jpg\" width=\"320\"></p>\n<p>这个点赞的按钮功能上有几个职责：</p>\n<ol>\n<li>显示已有的点赞数</li>\n<li>点击按钮后执行一个小动画，点赞数 +1，同时发送网络请求。</li>\n<li>若已经点赞，点击执行反向操作</li>\n<li>若网络请求发送失败，则回退成点击前的状态</li>\n</ol>\n<p><img src=\"http://ww1.sinaimg.cn/large/51530583jw1ez5055l1exj20k60lu3zz.jpg\" width=\"320\"></p>\n<p>这个控件的 API 可以设计成这样：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">FDLikeButton</span> : <span class=\"title\">UIButton</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)configureLikeStatus:(<span class=\"built_in\">BOOL</span>)likeOrNot count:(<span class=\"built_in\">NSInteger</span>)count animated:(<span class=\"built_in\">BOOL</span>)animated;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>因为继承自 UIButton，所以外部可以直接设置其 action，就不增加 tappedHandler 的参数了。外部在点击事件中需要调用这个配置方法，播放点赞动画，紧接着发送一个网络请求，若网络请求失败，可以再次调用这个 API 的无动画版本回滚状态。但像上一个例子一样，网络请求和事件处理逻辑相同，但代码却分部在各个页面中，于是给这个 View 增加 Self-Managed 模式的 Category：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">FDLikeButton</span> (<span class=\"title\">FDLikeButtonSelfManager</span>)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)selfManagedConfigureWithLikeStatus:(<span class=\"built_in\">BOOL</span>)likeOrNot count:(<span class=\"built_in\">NSInteger</span>)count;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>伪代码的实现如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">FDLikeButton</span> (<span class=\"title\">FDLikeButtonSelfManager</span>)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)selfManagedConfigureWithLikeStatus:(<span class=\"built_in\">BOOL</span>)likeOrNot count:(<span class=\"built_in\">NSInteger</span>)count &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> configureLikeStatus:likeOrNot count:count animated:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(likeButtonTapped:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)likeButtonTapped:(<span class=\"keyword\">id</span>)sender &#123;</span><br><span class=\"line\">    <span class=\"comment\">// +1 or -1 with animation</span></span><br><span class=\"line\">    <span class=\"comment\">// Network request ^(NSError *error) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     if (error) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         rollback</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>记得面试题的那篇文章里还调侃说 “面试的时候聊聊设计、架构挺好的，但别整出个往 UIButton 的子类里搞网络请求的奇葩结构就行”，结果就被自己打了个脸。不过从设计上，Self-Manager 模式并没有破坏原有的 MVC 结构，上面两个例子中的 View 依然可以不耦合具体业务逻辑的单拿出来用。使用 Category 的方式把应该写在 ViewController 中的代码移动到 View 的文件中，让功能更加的内聚。</p>\n<p>程序的复杂度并不会因哪种酷炫的设计模式所减少，能做到的只是对复杂度的切分和控制，即：</p>\n<ol>\n<li>让一大坨恶心的代码变成几小坨不那么恶心的代码。</li>\n<li>让恶心的代码只在一个地方恶心。</li>\n</ol>\n<p>Self-Manager 模式我们实践的时候写起来很开心，抛砖引玉一下，希望也能解决你的苦恼。</p>\n<p><img src=\"http://ww1.sinaimg.cn/mw600/66b3de17gw1ez4zbk10vaj20go0ciwhd.jpg\" width=\"320\"></p>\n","excerpt":"","more":"<p><code>Self-Manager</code> 源于我们团队内部的黑话，“诶？你刚去的创业公司有几个 iOS 开发啊？” “就我一个” “靠，你这是 Self-Manager 啊”</p>\n<p>最近，这个思路被我们当做了一种设计模式，即<strong>赋予一个 Widget 更大的权利，让其自己负责自己的事件。</strong><br>举个简单的栗子，这种负责展示头像的视图：<br><img src=\"http://ww1.sinaimg.cn/large/51530583jw1ez4xxydguqj20k40a4ac0.jpg\" width=\"320\"><br>它的职责包括：</p>\n<ol>\n<li>通过传入的 URL，加载并展示头像图片</li>\n<li>显示一些附属信息，比如大V的标志</li>\n<li>将用户点击头像的事件传递给外层的 View Controller 跳转到用户信息页面</li>\n</ol>\n<p>于是乎这个 Widget 的 API 可以长这个样子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">FDAvatarView</span> : <span class=\"title\">UIView</span></span></span><br><span class=\"line\"><span class=\"comment\">// 假设 VIPInfo 是某个 Entity</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)configureWithAvatarURL:(<span class=\"built_in\">NSURL</span> *)URL VIPInfo:(<span class=\"keyword\">id</span>)info tapped:(<span class=\"keyword\">void</span> (^)(<span class=\"keyword\">void</span>))block;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>使用这个控件的人只需要调用这个 configure 方法就可以配置入参和事件处理。但随之而来的就是一些蛋疼的问题：</p>\n<ol>\n<li>configure 的调用者是 superview，上面的例子中也就是一个 UITableViewCell，但 Cell 这层并不知道自己的 ViewController 是谁，于是乎还得向上一级传递这个点击事件，直到能获取到 NavigationController，然后 Push 一个用户信息的页面。</li>\n<li>这个 Avatar View 在 App 的各个地方都可能粗线，而且行为一致，那就意味着事件处理的 block，要散落在各个页面中，同时也带来了很多“只是为向上一层级转发事件”的 <strong>“Middle Man”</strong></li>\n</ol>\n<p>为解决这个问题，就需要给这个 View 放权，让其自己 Handle 自己的事件，也就是 <code>Self-Managed</code>，为了不破坏 View 的纯洁性，比较好的实践是在 Category 中实现：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">FDAvatarView</span> (<span class=\"title\">FDAvatarViewSelfManager</span>)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)selfManagedConfigureWithAvatarURL:(<span class=\"built_in\">NSURL</span> *)URL VIPInfo:(<span class=\"keyword\">id</span>)info uid:(<span class=\"built_in\">NSString</span> *)uid;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>实现时最好要调用 View 主类提供的 API：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">FDAvatarView</span> (<span class=\"title\">FDAvatarViewSelfManager</span>)</span></span><br><span class=\"line\"><span class=\"comment\">// 为后一个页面的创建增加了个 UID 参数</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)selfManagedConfigureWithAvatarURL:(<span class=\"built_in\">NSURL</span> *)URL VIPInfo:(<span class=\"keyword\">id</span>)info <span class=\"built_in\">UID</span>:(<span class=\"built_in\">NSString</span> *)<span class=\"built_in\">UID</span> &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> configureWithAvatarURL:URL VIPInfo:info tapped:^&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 假设 App 结构是 Root -&gt; TabBar -&gt; Navigation -&gt; ViewController</span></span><br><span class=\"line\">        <span class=\"built_in\">UITabBarController</span> *tabBarControler = (<span class=\"keyword\">id</span>)[<span class=\"built_in\">UIApplication</span>.sharedApplication.delegate.window.rootViewController;</span><br><span class=\"line\">        <span class=\"built_in\">UINavigationController</span> *navigationController = tabBarControler.selectedViewController;</span><br><span class=\"line\">        <span class=\"comment\">// 创建用户信息 View Controller</span></span><br><span class=\"line\">        FDUserProfileViewController *profileViewController = [FDUserProfileViewController viewControllerWith<span class=\"built_in\">UID</span>:<span class=\"built_in\">UID</span>];</span><br><span class=\"line\">        [navigationController pushViewController:profileViewController animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>这里用到了类似 AOP 的思路，添加了对 App 层级的耦合，如果觉得这样的耦合方式不妥的话，也可以封装个全局方法去取到当前顶层的 Navigation Controller。<br>这样，FDAvatarView 的调用者只需要配置入参，其余的它自己全能搞定了，即使 App 内很多处出现头像，逻辑代码也只有一份。</p>\n<p>接下来再来个例子：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/51530583jw1ez4zzt5l4aj20k60lqgn2.jpg\" width=\"320\"></p>\n<p>这个点赞的按钮功能上有几个职责：</p>\n<ol>\n<li>显示已有的点赞数</li>\n<li>点击按钮后执行一个小动画，点赞数 +1，同时发送网络请求。</li>\n<li>若已经点赞，点击执行反向操作</li>\n<li>若网络请求发送失败，则回退成点击前的状态</li>\n</ol>\n<p><img src=\"http://ww1.sinaimg.cn/large/51530583jw1ez5055l1exj20k60lu3zz.jpg\" width=\"320\"></p>\n<p>这个控件的 API 可以设计成这样：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">FDLikeButton</span> : <span class=\"title\">UIButton</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)configureLikeStatus:(<span class=\"built_in\">BOOL</span>)likeOrNot count:(<span class=\"built_in\">NSInteger</span>)count animated:(<span class=\"built_in\">BOOL</span>)animated;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>因为继承自 UIButton，所以外部可以直接设置其 action，就不增加 tappedHandler 的参数了。外部在点击事件中需要调用这个配置方法，播放点赞动画，紧接着发送一个网络请求，若网络请求失败，可以再次调用这个 API 的无动画版本回滚状态。但像上一个例子一样，网络请求和事件处理逻辑相同，但代码却分部在各个页面中，于是给这个 View 增加 Self-Managed 模式的 Category：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">FDLikeButton</span> (<span class=\"title\">FDLikeButtonSelfManager</span>)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)selfManagedConfigureWithLikeStatus:(<span class=\"built_in\">BOOL</span>)likeOrNot count:(<span class=\"built_in\">NSInteger</span>)count;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>伪代码的实现如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">FDLikeButton</span> (<span class=\"title\">FDLikeButtonSelfManager</span>)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)selfManagedConfigureWithLikeStatus:(<span class=\"built_in\">BOOL</span>)likeOrNot count:(<span class=\"built_in\">NSInteger</span>)count &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> configureLikeStatus:likeOrNot count:count animated:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(likeButtonTapped:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)likeButtonTapped:(<span class=\"keyword\">id</span>)sender &#123;</span><br><span class=\"line\">    <span class=\"comment\">// +1 or -1 with animation</span></span><br><span class=\"line\">    <span class=\"comment\">// Network request ^(NSError *error) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     if (error) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         rollback</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>记得面试题的那篇文章里还调侃说 “面试的时候聊聊设计、架构挺好的，但别整出个往 UIButton 的子类里搞网络请求的奇葩结构就行”，结果就被自己打了个脸。不过从设计上，Self-Manager 模式并没有破坏原有的 MVC 结构，上面两个例子中的 View 依然可以不耦合具体业务逻辑的单拿出来用。使用 Category 的方式把应该写在 ViewController 中的代码移动到 View 的文件中，让功能更加的内聚。</p>\n<p>程序的复杂度并不会因哪种酷炫的设计模式所减少，能做到的只是对复杂度的切分和控制，即：</p>\n<ol>\n<li>让一大坨恶心的代码变成几小坨不那么恶心的代码。</li>\n<li>让恶心的代码只在一个地方恶心。</li>\n</ol>\n<p>Self-Manager 模式我们实践的时候写起来很开心，抛砖引玉一下，希望也能解决你的苦恼。</p>\n<p><img src=\"http://ww1.sinaimg.cn/mw600/66b3de17gw1ez4zbk10vaj20go0ciwhd.jpg\" width=\"320\"></p>\n"},{"title":"使用Sublime Text写Markdown","date":"2014-03-16T05:58:03.000Z","_content":"\n默认Sublime Text是不支持Markdown语法高亮和预览的，对于万能的Sublime Text，这点事情一定有插件能解决。  \n\nSublime Text 3 安装`Package Control`，挺不能理解为什么不默认含在app里  \n快捷键**ctrl+`**或者 View > Show Console 菜单打开控制台\n```\nimport urllib.request,os;\npf='Package Control.sublime-package';\nipp=sublime.installed_packages_path();\nurllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));\nopen(os.path.join(ipp,pf),'wb').write(urllib.request.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read())\n```\n安好重启后，用万能快捷键`Ctrl+Shift+P`，调出菜单`Package Control Install`，再输入`Markdown`关键字，就能发现很多Markdown插件。  \n经过反复尝试，还是一个叫`Markdown Editing`的比较好使，直接使编辑器在编辑时所见即所得，只是这个默认灰色的颜色...\n\n![](http://ww4.sinaimg.cn/large/51530583gw1eehp8t8zkfj20r60jzgo9.jpg)\n","source":"_posts/sublime_text_markdown.md","raw":"title: 使用Sublime Text写Markdown\ndate: 2014-03-16 13:58:03\ntags: 开发工具\n---\n\n默认Sublime Text是不支持Markdown语法高亮和预览的，对于万能的Sublime Text，这点事情一定有插件能解决。  \n\nSublime Text 3 安装`Package Control`，挺不能理解为什么不默认含在app里  \n快捷键**ctrl+`**或者 View > Show Console 菜单打开控制台\n```\nimport urllib.request,os;\npf='Package Control.sublime-package';\nipp=sublime.installed_packages_path();\nurllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));\nopen(os.path.join(ipp,pf),'wb').write(urllib.request.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read())\n```\n安好重启后，用万能快捷键`Ctrl+Shift+P`，调出菜单`Package Control Install`，再输入`Markdown`关键字，就能发现很多Markdown插件。  \n经过反复尝试，还是一个叫`Markdown Editing`的比较好使，直接使编辑器在编辑时所见即所得，只是这个默认灰色的颜色...\n\n![](http://ww4.sinaimg.cn/large/51530583gw1eehp8t8zkfj20r60jzgo9.jpg)\n","slug":"sublime_text_markdown","published":1,"updated":"2016-03-27T08:32:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxmx002hev12xh7n2roc","content":"<p>默认Sublime Text是不支持Markdown语法高亮和预览的，对于万能的Sublime Text，这点事情一定有插件能解决。  </p>\n<p>Sublime Text 3 安装<code>Package Control</code>，挺不能理解为什么不默认含在app里<br>快捷键<strong>ctrl+`</strong>或者 View &gt; Show Console 菜单打开控制台<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import urllib.request,os;</span><br><span class=\"line\">pf=&apos;Package Control.sublime-package&apos;;</span><br><span class=\"line\">ipp=sublime.installed_packages_path();</span><br><span class=\"line\">urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));</span><br><span class=\"line\">open(os.path.join(ipp,pf),&apos;wb&apos;).write(urllib.request.urlopen(&apos;http://sublime.wbond.net/&apos;+pf.replace(&apos; &apos;,&apos;%20&apos;)).read())</span><br></pre></td></tr></table></figure></p>\n<p>安好重启后，用万能快捷键<code>Ctrl+Shift+P</code>，调出菜单<code>Package Control Install</code>，再输入<code>Markdown</code>关键字，就能发现很多Markdown插件。<br>经过反复尝试，还是一个叫<code>Markdown Editing</code>的比较好使，直接使编辑器在编辑时所见即所得，只是这个默认灰色的颜色…</p>\n<p><img src=\"http://ww4.sinaimg.cn/large/51530583gw1eehp8t8zkfj20r60jzgo9.jpg\" alt=\"\"></p>\n","excerpt":"","more":"<p>默认Sublime Text是不支持Markdown语法高亮和预览的，对于万能的Sublime Text，这点事情一定有插件能解决。  </p>\n<p>Sublime Text 3 安装<code>Package Control</code>，挺不能理解为什么不默认含在app里<br>快捷键<strong>ctrl+`</strong>或者 View &gt; Show Console 菜单打开控制台<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import urllib.request,os;</span><br><span class=\"line\">pf=&apos;Package Control.sublime-package&apos;;</span><br><span class=\"line\">ipp=sublime.installed_packages_path();</span><br><span class=\"line\">urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));</span><br><span class=\"line\">open(os.path.join(ipp,pf),&apos;wb&apos;).write(urllib.request.urlopen(&apos;http://sublime.wbond.net/&apos;+pf.replace(&apos; &apos;,&apos;%20&apos;)).read())</span><br></pre></td></tr></table></figure></p>\n<p>安好重启后，用万能快捷键<code>Ctrl+Shift+P</code>，调出菜单<code>Package Control Install</code>，再输入<code>Markdown</code>关键字，就能发现很多Markdown插件。<br>经过反复尝试，还是一个叫<code>Markdown Editing</code>的比较好使，直接使编辑器在编辑时所见即所得，只是这个默认灰色的颜色…</p>\n<p><img src=\"http://ww4.sinaimg.cn/large/51530583gw1eehp8t8zkfj20r60jzgo9.jpg\" alt=\"\"></p>\n"},{"title":"实现一个TODO宏","date":"2015-03-01T04:12:12.000Z","_content":"\n实现一个能产生warning的TODO宏，用于在代码里做备忘，效果：\n\n<img src=\"http://ww1.sinaimg.cn/large/51530583jw1eprfhhfis1j20w004mju0.jpg\" width=\"500\">\n<img src=\"http://ww3.sinaimg.cn/large/51530583jw1eprfhhspaqj20nu0bqae6.jpg\" width=\"500\">\n\n下面一步步来实现这个宏。\n\n---\n\n# Let's do it\n\n手动让编译器报警（报错）可以用以下几个方法：  \n\n``` objc\n#warning sunnyxx\n#error sunnyxx\n#pragma message \"sunnyxx\"\n#pragma GCC warning \"sunnyxx\"\n#pragma GCC error \"sunnyxx\"\n```\n\n但我们知道，带`#`的预处理指令是无法被`#define`的。好在**C99**提供了一个`_Pragma`运算符可以把部分`#pragma`指令字符串化：  \n\n``` objc\n#pragma message \"sunnyxx\"\n// 等价于\n_Pragma(\"message \\\"sunnyxx\\\"\") // 需要注意双引号的转义\n// 或\n_Pragma(\"message(\\\"sunnyxx\\\")\") // 需要注意双引号的转义\n```\n\n利用这个特性，我们就可以将warning定义成宏\n\n``` objc\n#define SOME_WARNING _Pragma(\"message(\\\"报告大王！\\\")\")\nint main() {\n    SOME_WARNING // [!]报告大王！\n    return 1;\n}\n\n```\n\n接下来，我们让这个宏能够接受入参，并显示到warning中去，这里会面临宏的基本用法的考验。   \n\n``` objc\n#define STRINGIFY(S) #S\n#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))\n```\n\n个人认为不太可能在一个宏定义中完成这件事，需要用到辅助宏：`STRINGIFY(S)` 将入参转化成字符串，省去了`_Pragma`中全串加转义字符的困扰。    \n这时，一个基本功能的TODO宏就完成了，下面向其中加入**额外的信息**：  \n\n``` objc\n// 两个已有的宏\n#define STRINGIFY(S) #S\n#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))\n// 延迟1次展开的宏\n#define DEFER_STRINGIFY(S) STRINGIFY(S)\n// 下面的宏在第一行用`\\`折行\n#define FORMATTED_MESSAGE(MSG) \"[TODO-\" DEFER_STRINGIFY(__COUNTER__) \"] \" MSG \" \\n\"  \\\n    DEFER_STRINGIFY(__FILE__) \" line \" DEFER_STRINGIFY(__LINE__)\n```\n\n其中涉及到的知识：  \n - 两个常量字符串可以拼接成一个整串 \"123\"\"456\" => \"123456\"\n - 使用到3个**预定义宏**，`__COUNTER__`宏展开次数的计数器，全局唯一；`__FILE__`当前文件完整目录字符串；`__LINE__`在当前文件第几行\n - 在字符串中**预定义宏**应延时展开，如果将上面的`DEFER_STRINGIFY`换成`STRINGIFY`的话，如`__LINE__`就不能被正确展开成行数，而是成了一个常量字符串`\"__LINE__\"`\n - 为了美化，warning message中可以使用`\\n`换行\n\n于是，使用`FORMATTED_MESSAGE(MSG)`宏就可以将带文件路径、序号、行数等信息加入到最终的warning中。  \n\n---\n\n其实到这步已经OK了，为了让这个宏更加抢眼，还可以借鉴RAC，把宏定义成前面加`@`的形式：\n\n``` objc\n#define KEYWORDIFY try {} @catch (...) {}\n```\n\n将最终的宏定义前面加上上面的宏后，使用时就可以加`@`前缀了（空的try-catch会被编译器优化，所以没啥性能损耗）\n\n---\n\n# 最终版本\n\n``` objc\n#define STRINGIFY(S) #S\n#define DEFER_STRINGIFY(S) STRINGIFY(S)\n#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))\n#define FORMATTED_MESSAGE(MSG) \"[TODO-\" DEFER_STRINGIFY(__COUNTER__) \"] \" MSG \" \\n\" \\\nDEFER_STRINGIFY(__FILE__) \" line \" DEFER_STRINGIFY(__LINE__)\n#define KEYWORDIFY try {} @catch (...) {}\n// 最终使用下面的宏\n#define TODO(MSG) KEYWORDIFY PRAGMA_MESSAGE(FORMATTED_MESSAGE(MSG))\n```\n\n---\n\n# What's more\n\n除此之外，还研究了半天如何在宏里面定义一个注释，这样就可以偷偷写`// TODO: ...`的注释，让Xcode导航栏中也出现这个TODO了：\n<img src=\"http://ww4.sinaimg.cn/large/51530583jw1eprhben4m9j20by02oglq.jpg\" width=\"300\">\n但很可惜没有找到一个可行的方法，欢迎一起解决。\nXcode插件[《XTodo》](https://github.com/trawor/XToDo)也是利用这个特性，可以尝试下。\n\n如果需要一个产生error的宏，将这里替换成这样就好了：`_Pragma(STRINGIFY(GCC error(MSG)))`\n\n同时，上面的代码在[《github上》](https://github.com/sunnyxx/TodoMacro)可以找到。也欢迎关注微博[@我就叫Sunny怎么了](http://weibo.com/u/1364395395)一起交流。\n\n\n# References\n\nhttp://clang.llvm.org/docs/UsersManual.html  \nhttps://gcc.gnu.org/onlinedocs/cpp/Pragmas.html\n","source":"_posts/todo-macro.md","raw":"title: 实现一个TODO宏\ndate: 2015-03-01 12:12:12\ntags: wtf\n---\n\n实现一个能产生warning的TODO宏，用于在代码里做备忘，效果：\n\n<img src=\"http://ww1.sinaimg.cn/large/51530583jw1eprfhhfis1j20w004mju0.jpg\" width=\"500\">\n<img src=\"http://ww3.sinaimg.cn/large/51530583jw1eprfhhspaqj20nu0bqae6.jpg\" width=\"500\">\n\n下面一步步来实现这个宏。\n\n---\n\n# Let's do it\n\n手动让编译器报警（报错）可以用以下几个方法：  \n\n``` objc\n#warning sunnyxx\n#error sunnyxx\n#pragma message \"sunnyxx\"\n#pragma GCC warning \"sunnyxx\"\n#pragma GCC error \"sunnyxx\"\n```\n\n但我们知道，带`#`的预处理指令是无法被`#define`的。好在**C99**提供了一个`_Pragma`运算符可以把部分`#pragma`指令字符串化：  \n\n``` objc\n#pragma message \"sunnyxx\"\n// 等价于\n_Pragma(\"message \\\"sunnyxx\\\"\") // 需要注意双引号的转义\n// 或\n_Pragma(\"message(\\\"sunnyxx\\\")\") // 需要注意双引号的转义\n```\n\n利用这个特性，我们就可以将warning定义成宏\n\n``` objc\n#define SOME_WARNING _Pragma(\"message(\\\"报告大王！\\\")\")\nint main() {\n    SOME_WARNING // [!]报告大王！\n    return 1;\n}\n\n```\n\n接下来，我们让这个宏能够接受入参，并显示到warning中去，这里会面临宏的基本用法的考验。   \n\n``` objc\n#define STRINGIFY(S) #S\n#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))\n```\n\n个人认为不太可能在一个宏定义中完成这件事，需要用到辅助宏：`STRINGIFY(S)` 将入参转化成字符串，省去了`_Pragma`中全串加转义字符的困扰。    \n这时，一个基本功能的TODO宏就完成了，下面向其中加入**额外的信息**：  \n\n``` objc\n// 两个已有的宏\n#define STRINGIFY(S) #S\n#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))\n// 延迟1次展开的宏\n#define DEFER_STRINGIFY(S) STRINGIFY(S)\n// 下面的宏在第一行用`\\`折行\n#define FORMATTED_MESSAGE(MSG) \"[TODO-\" DEFER_STRINGIFY(__COUNTER__) \"] \" MSG \" \\n\"  \\\n    DEFER_STRINGIFY(__FILE__) \" line \" DEFER_STRINGIFY(__LINE__)\n```\n\n其中涉及到的知识：  \n - 两个常量字符串可以拼接成一个整串 \"123\"\"456\" => \"123456\"\n - 使用到3个**预定义宏**，`__COUNTER__`宏展开次数的计数器，全局唯一；`__FILE__`当前文件完整目录字符串；`__LINE__`在当前文件第几行\n - 在字符串中**预定义宏**应延时展开，如果将上面的`DEFER_STRINGIFY`换成`STRINGIFY`的话，如`__LINE__`就不能被正确展开成行数，而是成了一个常量字符串`\"__LINE__\"`\n - 为了美化，warning message中可以使用`\\n`换行\n\n于是，使用`FORMATTED_MESSAGE(MSG)`宏就可以将带文件路径、序号、行数等信息加入到最终的warning中。  \n\n---\n\n其实到这步已经OK了，为了让这个宏更加抢眼，还可以借鉴RAC，把宏定义成前面加`@`的形式：\n\n``` objc\n#define KEYWORDIFY try {} @catch (...) {}\n```\n\n将最终的宏定义前面加上上面的宏后，使用时就可以加`@`前缀了（空的try-catch会被编译器优化，所以没啥性能损耗）\n\n---\n\n# 最终版本\n\n``` objc\n#define STRINGIFY(S) #S\n#define DEFER_STRINGIFY(S) STRINGIFY(S)\n#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))\n#define FORMATTED_MESSAGE(MSG) \"[TODO-\" DEFER_STRINGIFY(__COUNTER__) \"] \" MSG \" \\n\" \\\nDEFER_STRINGIFY(__FILE__) \" line \" DEFER_STRINGIFY(__LINE__)\n#define KEYWORDIFY try {} @catch (...) {}\n// 最终使用下面的宏\n#define TODO(MSG) KEYWORDIFY PRAGMA_MESSAGE(FORMATTED_MESSAGE(MSG))\n```\n\n---\n\n# What's more\n\n除此之外，还研究了半天如何在宏里面定义一个注释，这样就可以偷偷写`// TODO: ...`的注释，让Xcode导航栏中也出现这个TODO了：\n<img src=\"http://ww4.sinaimg.cn/large/51530583jw1eprhben4m9j20by02oglq.jpg\" width=\"300\">\n但很可惜没有找到一个可行的方法，欢迎一起解决。\nXcode插件[《XTodo》](https://github.com/trawor/XToDo)也是利用这个特性，可以尝试下。\n\n如果需要一个产生error的宏，将这里替换成这样就好了：`_Pragma(STRINGIFY(GCC error(MSG)))`\n\n同时，上面的代码在[《github上》](https://github.com/sunnyxx/TodoMacro)可以找到。也欢迎关注微博[@我就叫Sunny怎么了](http://weibo.com/u/1364395395)一起交流。\n\n\n# References\n\nhttp://clang.llvm.org/docs/UsersManual.html  \nhttps://gcc.gnu.org/onlinedocs/cpp/Pragmas.html\n","slug":"todo-macro","published":1,"updated":"2016-03-27T07:47:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxmy002jev127vb2kg0j","content":"<p>实现一个能产生warning的TODO宏，用于在代码里做备忘，效果：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/51530583jw1eprfhhfis1j20w004mju0.jpg\" width=\"500\"><br><img src=\"http://ww3.sinaimg.cn/large/51530583jw1eprfhhspaqj20nu0bqae6.jpg\" width=\"500\"></p>\n<p>下面一步步来实现这个宏。</p>\n<hr>\n<h1 id=\"Let’s-do-it\"><a href=\"#Let’s-do-it\" class=\"headerlink\" title=\"Let’s do it\"></a>Let’s do it</h1><p>手动让编译器报警（报错）可以用以下几个方法：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#warning sunnyxx</span></span><br><span class=\"line\"><span class=\"meta\">#error sunnyxx</span></span><br><span class=\"line\"><span class=\"meta\">#pragma message <span class=\"meta-string\">\"sunnyxx\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#pragma GCC warning <span class=\"meta-string\">\"sunnyxx\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#pragma GCC error <span class=\"meta-string\">\"sunnyxx\"</span></span></span><br></pre></td></tr></table></figure>\n<p>但我们知道，带<code>#</code>的预处理指令是无法被<code>#define</code>的。好在<strong>C99</strong>提供了一个<code>_Pragma</code>运算符可以把部分<code>#pragma</code>指令字符串化：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma message <span class=\"meta-string\">\"sunnyxx\"</span></span></span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\">_Pragma(<span class=\"string\">\"message \\\"sunnyxx\\\"\"</span>) <span class=\"comment\">// 需要注意双引号的转义</span></span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\">_Pragma(<span class=\"string\">\"message(\\\"sunnyxx\\\")\"</span>) <span class=\"comment\">// 需要注意双引号的转义</span></span><br></pre></td></tr></table></figure>\n<p>利用这个特性，我们就可以将warning定义成宏</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define SOME_WARNING _Pragma(<span class=\"meta-string\">\"message(\\\"</span>报告大王！\\<span class=\"meta-string\">\")\"</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> main() &#123;</span><br><span class=\"line\">    SOME_WARNING <span class=\"comment\">// [!]报告大王！</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来，我们让这个宏能够接受入参，并显示到warning中去，这里会面临宏的基本用法的考验。   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define STRINGIFY(S) #S</span></span><br><span class=\"line\"><span class=\"meta\">#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))</span></span><br></pre></td></tr></table></figure>\n<p>个人认为不太可能在一个宏定义中完成这件事，需要用到辅助宏：<code>STRINGIFY(S)</code> 将入参转化成字符串，省去了<code>_Pragma</code>中全串加转义字符的困扰。<br>这时，一个基本功能的TODO宏就完成了，下面向其中加入<strong>额外的信息</strong>：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 两个已有的宏</span></span><br><span class=\"line\"><span class=\"meta\">#define STRINGIFY(S) #S</span></span><br><span class=\"line\"><span class=\"meta\">#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))</span></span><br><span class=\"line\"><span class=\"comment\">// 延迟1次展开的宏</span></span><br><span class=\"line\"><span class=\"meta\">#define DEFER_STRINGIFY(S) STRINGIFY(S)</span></span><br><span class=\"line\"><span class=\"comment\">// 下面的宏在第一行用`\\`折行</span></span><br><span class=\"line\"><span class=\"meta\">#define FORMATTED_MESSAGE(MSG) <span class=\"meta-string\">\"[TODO-\"</span> DEFER_STRINGIFY(__COUNTER__) <span class=\"meta-string\">\"] \"</span> MSG <span class=\"meta-string\">\" \\n\"</span>  \\</span></span><br><span class=\"line\">    DEFER_STRINGIFY(__FILE__) <span class=\"string\">\" line \"</span> DEFER_STRINGIFY(__LINE__)</span><br></pre></td></tr></table></figure>\n<p>其中涉及到的知识：  </p>\n<ul>\n<li>两个常量字符串可以拼接成一个整串 “123””456” =&gt; “123456”</li>\n<li>使用到3个<strong>预定义宏</strong>，<code>__COUNTER__</code>宏展开次数的计数器，全局唯一；<code>__FILE__</code>当前文件完整目录字符串；<code>__LINE__</code>在当前文件第几行</li>\n<li>在字符串中<strong>预定义宏</strong>应延时展开，如果将上面的<code>DEFER_STRINGIFY</code>换成<code>STRINGIFY</code>的话，如<code>__LINE__</code>就不能被正确展开成行数，而是成了一个常量字符串<code>&quot;__LINE__&quot;</code></li>\n<li>为了美化，warning message中可以使用<code>\\n</code>换行</li>\n</ul>\n<p>于是，使用<code>FORMATTED_MESSAGE(MSG)</code>宏就可以将带文件路径、序号、行数等信息加入到最终的warning中。  </p>\n<hr>\n<p>其实到这步已经OK了，为了让这个宏更加抢眼，还可以借鉴RAC，把宏定义成前面加<code>@</code>的形式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define KEYWORDIFY try &#123;&#125; @catch (...) &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>将最终的宏定义前面加上上面的宏后，使用时就可以加<code>@</code>前缀了（空的try-catch会被编译器优化，所以没啥性能损耗）</p>\n<hr>\n<h1 id=\"最终版本\"><a href=\"#最终版本\" class=\"headerlink\" title=\"最终版本\"></a>最终版本</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define STRINGIFY(S) #S</span></span><br><span class=\"line\"><span class=\"meta\">#define DEFER_STRINGIFY(S) STRINGIFY(S)</span></span><br><span class=\"line\"><span class=\"meta\">#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))</span></span><br><span class=\"line\"><span class=\"meta\">#define FORMATTED_MESSAGE(MSG) <span class=\"meta-string\">\"[TODO-\"</span> DEFER_STRINGIFY(__COUNTER__) <span class=\"meta-string\">\"] \"</span> MSG <span class=\"meta-string\">\" \\n\"</span> \\</span></span><br><span class=\"line\">DEFER_STRINGIFY(__FILE__) <span class=\"string\">\" line \"</span> DEFER_STRINGIFY(__LINE__)</span><br><span class=\"line\"><span class=\"meta\">#define KEYWORDIFY try &#123;&#125; @catch (...) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 最终使用下面的宏</span></span><br><span class=\"line\"><span class=\"meta\">#define TODO(MSG) KEYWORDIFY PRAGMA_MESSAGE(FORMATTED_MESSAGE(MSG))</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"What’s-more\"><a href=\"#What’s-more\" class=\"headerlink\" title=\"What’s more\"></a>What’s more</h1><p>除此之外，还研究了半天如何在宏里面定义一个注释，这样就可以偷偷写<code>// TODO: ...</code>的注释，让Xcode导航栏中也出现这个TODO了：<br><img src=\"http://ww4.sinaimg.cn/large/51530583jw1eprhben4m9j20by02oglq.jpg\" width=\"300\"><br>但很可惜没有找到一个可行的方法，欢迎一起解决。<br>Xcode插件<a href=\"https://github.com/trawor/XToDo\" target=\"_blank\" rel=\"external\">《XTodo》</a>也是利用这个特性，可以尝试下。</p>\n<p>如果需要一个产生error的宏，将这里替换成这样就好了：<code>_Pragma(STRINGIFY(GCC error(MSG)))</code></p>\n<p>同时，上面的代码在<a href=\"https://github.com/sunnyxx/TodoMacro\" target=\"_blank\" rel=\"external\">《github上》</a>可以找到。也欢迎关注微博<a href=\"http://weibo.com/u/1364395395\" target=\"_blank\" rel=\"external\">@我就叫Sunny怎么了</a>一起交流。</p>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"http://clang.llvm.org/docs/UsersManual.html\" target=\"_blank\" rel=\"external\">http://clang.llvm.org/docs/UsersManual.html</a><br><a href=\"https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html\" target=\"_blank\" rel=\"external\">https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html</a></p>\n","excerpt":"","more":"<p>实现一个能产生warning的TODO宏，用于在代码里做备忘，效果：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/51530583jw1eprfhhfis1j20w004mju0.jpg\" width=\"500\"><br><img src=\"http://ww3.sinaimg.cn/large/51530583jw1eprfhhspaqj20nu0bqae6.jpg\" width=\"500\"></p>\n<p>下面一步步来实现这个宏。</p>\n<hr>\n<h1 id=\"Let’s-do-it\"><a href=\"#Let’s-do-it\" class=\"headerlink\" title=\"Let’s do it\"></a>Let’s do it</h1><p>手动让编译器报警（报错）可以用以下几个方法：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#warning sunnyxx</span></span><br><span class=\"line\"><span class=\"meta\">#error sunnyxx</span></span><br><span class=\"line\"><span class=\"meta\">#pragma message <span class=\"meta-string\">\"sunnyxx\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#pragma GCC warning <span class=\"meta-string\">\"sunnyxx\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#pragma GCC error <span class=\"meta-string\">\"sunnyxx\"</span></span></span><br></pre></td></tr></table></figure>\n<p>但我们知道，带<code>#</code>的预处理指令是无法被<code>#define</code>的。好在<strong>C99</strong>提供了一个<code>_Pragma</code>运算符可以把部分<code>#pragma</code>指令字符串化：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma message <span class=\"meta-string\">\"sunnyxx\"</span></span></span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\">_Pragma(<span class=\"string\">\"message \\\"sunnyxx\\\"\"</span>) <span class=\"comment\">// 需要注意双引号的转义</span></span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\">_Pragma(<span class=\"string\">\"message(\\\"sunnyxx\\\")\"</span>) <span class=\"comment\">// 需要注意双引号的转义</span></span><br></pre></td></tr></table></figure>\n<p>利用这个特性，我们就可以将warning定义成宏</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define SOME_WARNING _Pragma(<span class=\"meta-string\">\"message(\\\"</span>报告大王！\\<span class=\"meta-string\">\")\"</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> main() &#123;</span><br><span class=\"line\">    SOME_WARNING <span class=\"comment\">// [!]报告大王！</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来，我们让这个宏能够接受入参，并显示到warning中去，这里会面临宏的基本用法的考验。   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define STRINGIFY(S) #S</span></span><br><span class=\"line\"><span class=\"meta\">#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))</span></span><br></pre></td></tr></table></figure>\n<p>个人认为不太可能在一个宏定义中完成这件事，需要用到辅助宏：<code>STRINGIFY(S)</code> 将入参转化成字符串，省去了<code>_Pragma</code>中全串加转义字符的困扰。<br>这时，一个基本功能的TODO宏就完成了，下面向其中加入<strong>额外的信息</strong>：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 两个已有的宏</span></span><br><span class=\"line\"><span class=\"meta\">#define STRINGIFY(S) #S</span></span><br><span class=\"line\"><span class=\"meta\">#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))</span></span><br><span class=\"line\"><span class=\"comment\">// 延迟1次展开的宏</span></span><br><span class=\"line\"><span class=\"meta\">#define DEFER_STRINGIFY(S) STRINGIFY(S)</span></span><br><span class=\"line\"><span class=\"comment\">// 下面的宏在第一行用`\\`折行</span></span><br><span class=\"line\"><span class=\"meta\">#define FORMATTED_MESSAGE(MSG) <span class=\"meta-string\">\"[TODO-\"</span> DEFER_STRINGIFY(__COUNTER__) <span class=\"meta-string\">\"] \"</span> MSG <span class=\"meta-string\">\" \\n\"</span>  \\</span></span><br><span class=\"line\">    DEFER_STRINGIFY(__FILE__) <span class=\"string\">\" line \"</span> DEFER_STRINGIFY(__LINE__)</span><br></pre></td></tr></table></figure>\n<p>其中涉及到的知识：  </p>\n<ul>\n<li>两个常量字符串可以拼接成一个整串 “123””456” =&gt; “123456”</li>\n<li>使用到3个<strong>预定义宏</strong>，<code>__COUNTER__</code>宏展开次数的计数器，全局唯一；<code>__FILE__</code>当前文件完整目录字符串；<code>__LINE__</code>在当前文件第几行</li>\n<li>在字符串中<strong>预定义宏</strong>应延时展开，如果将上面的<code>DEFER_STRINGIFY</code>换成<code>STRINGIFY</code>的话，如<code>__LINE__</code>就不能被正确展开成行数，而是成了一个常量字符串<code>&quot;__LINE__&quot;</code></li>\n<li>为了美化，warning message中可以使用<code>\\n</code>换行</li>\n</ul>\n<p>于是，使用<code>FORMATTED_MESSAGE(MSG)</code>宏就可以将带文件路径、序号、行数等信息加入到最终的warning中。  </p>\n<hr>\n<p>其实到这步已经OK了，为了让这个宏更加抢眼，还可以借鉴RAC，把宏定义成前面加<code>@</code>的形式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define KEYWORDIFY try &#123;&#125; @catch (...) &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>将最终的宏定义前面加上上面的宏后，使用时就可以加<code>@</code>前缀了（空的try-catch会被编译器优化，所以没啥性能损耗）</p>\n<hr>\n<h1 id=\"最终版本\"><a href=\"#最终版本\" class=\"headerlink\" title=\"最终版本\"></a>最终版本</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define STRINGIFY(S) #S</span></span><br><span class=\"line\"><span class=\"meta\">#define DEFER_STRINGIFY(S) STRINGIFY(S)</span></span><br><span class=\"line\"><span class=\"meta\">#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))</span></span><br><span class=\"line\"><span class=\"meta\">#define FORMATTED_MESSAGE(MSG) <span class=\"meta-string\">\"[TODO-\"</span> DEFER_STRINGIFY(__COUNTER__) <span class=\"meta-string\">\"] \"</span> MSG <span class=\"meta-string\">\" \\n\"</span> \\</span></span><br><span class=\"line\">DEFER_STRINGIFY(__FILE__) <span class=\"string\">\" line \"</span> DEFER_STRINGIFY(__LINE__)</span><br><span class=\"line\"><span class=\"meta\">#define KEYWORDIFY try &#123;&#125; @catch (...) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 最终使用下面的宏</span></span><br><span class=\"line\"><span class=\"meta\">#define TODO(MSG) KEYWORDIFY PRAGMA_MESSAGE(FORMATTED_MESSAGE(MSG))</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"What’s-more\"><a href=\"#What’s-more\" class=\"headerlink\" title=\"What’s more\"></a>What’s more</h1><p>除此之外，还研究了半天如何在宏里面定义一个注释，这样就可以偷偷写<code>// TODO: ...</code>的注释，让Xcode导航栏中也出现这个TODO了：<br><img src=\"http://ww4.sinaimg.cn/large/51530583jw1eprhben4m9j20by02oglq.jpg\" width=\"300\"><br>但很可惜没有找到一个可行的方法，欢迎一起解决。<br>Xcode插件<a href=\"https://github.com/trawor/XToDo\">《XTodo》</a>也是利用这个特性，可以尝试下。</p>\n<p>如果需要一个产生error的宏，将这里替换成这样就好了：<code>_Pragma(STRINGIFY(GCC error(MSG)))</code></p>\n<p>同时，上面的代码在<a href=\"https://github.com/sunnyxx/TodoMacro\">《github上》</a>可以找到。也欢迎关注微博<a href=\"http://weibo.com/u/1364395395\">@我就叫Sunny怎么了</a>一起交流。</p>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"http://clang.llvm.org/docs/UsersManual.html\">http://clang.llvm.org/docs/UsersManual.html</a><br><a href=\"https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html\">https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html</a></p>\n"},{"title":"Xcode Tip合集","date":"2015-03-29T11:48:42.000Z","_content":"\n最近总结了几个 Xcode 小技巧，在微博上（@我就叫Sunny怎么了）都发过，来个合集：\n\n<img src=\"http://ww3.sinaimg.cn/mw1024/51530583jw1eq8xm0otg5j20qk0wk45d.jpg\" width=\"500\">  \n\n<img src=\"http://ww4.sinaimg.cn/mw1024/51530583jw1eq8xm000o1j20oq0i4786.jpg\" width=\"500\">\n\n<img src=\"http://ww4.sinaimg.cn/mw1024/51530583jw1eq8xlzf1kqj20mw0lcaeg.jpg\" width=\"500\">  \n\n<img src=\"http://ww1.sinaimg.cn/mw1024/51530583gw1eqccw0644jj20ka0lq43i.jpg\" width=\"500\">  \n\n<img src=\"http://ww4.sinaimg.cn/mw1024/51530583gw1eqccvzvkexj20mu0lajv2.jpg\" width=\"500\">  \n\n<img src=\"http://ww3.sinaimg.cn/mw1024/51530583gw1eqccvyqgd1j20ow0sednl.jpg\" width=\"500\">  \n\n<img src=\"http://ww3.sinaimg.cn/mw1024/51530583jw1eqkfye958bj20j60zi7d7.jpg\" width=\"500\">  \n","source":"_posts/xcode-tips.md","raw":"title: Xcode Tip合集\ndate: 2015-03-29 19:48:42\ntags: ios最佳实践\n---\n\n最近总结了几个 Xcode 小技巧，在微博上（@我就叫Sunny怎么了）都发过，来个合集：\n\n<img src=\"http://ww3.sinaimg.cn/mw1024/51530583jw1eq8xm0otg5j20qk0wk45d.jpg\" width=\"500\">  \n\n<img src=\"http://ww4.sinaimg.cn/mw1024/51530583jw1eq8xm000o1j20oq0i4786.jpg\" width=\"500\">\n\n<img src=\"http://ww4.sinaimg.cn/mw1024/51530583jw1eq8xlzf1kqj20mw0lcaeg.jpg\" width=\"500\">  \n\n<img src=\"http://ww1.sinaimg.cn/mw1024/51530583gw1eqccw0644jj20ka0lq43i.jpg\" width=\"500\">  \n\n<img src=\"http://ww4.sinaimg.cn/mw1024/51530583gw1eqccvzvkexj20mu0lajv2.jpg\" width=\"500\">  \n\n<img src=\"http://ww3.sinaimg.cn/mw1024/51530583gw1eqccvyqgd1j20ow0sednl.jpg\" width=\"500\">  \n\n<img src=\"http://ww3.sinaimg.cn/mw1024/51530583jw1eqkfye958bj20j60zi7d7.jpg\" width=\"500\">  \n","slug":"xcode-tips","published":1,"updated":"2016-03-23T13:53:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxn2002mev12w8lybxbh","content":"<p>最近总结了几个 Xcode 小技巧，在微博上（@我就叫Sunny怎么了）都发过，来个合集：</p>\n<p><img src=\"http://ww3.sinaimg.cn/mw1024/51530583jw1eq8xm0otg5j20qk0wk45d.jpg\" width=\"500\">  </p>\n<p><img src=\"http://ww4.sinaimg.cn/mw1024/51530583jw1eq8xm000o1j20oq0i4786.jpg\" width=\"500\"></p>\n<p><img src=\"http://ww4.sinaimg.cn/mw1024/51530583jw1eq8xlzf1kqj20mw0lcaeg.jpg\" width=\"500\">  </p>\n<p><img src=\"http://ww1.sinaimg.cn/mw1024/51530583gw1eqccw0644jj20ka0lq43i.jpg\" width=\"500\">  </p>\n<p><img src=\"http://ww4.sinaimg.cn/mw1024/51530583gw1eqccvzvkexj20mu0lajv2.jpg\" width=\"500\">  </p>\n<p><img src=\"http://ww3.sinaimg.cn/mw1024/51530583gw1eqccvyqgd1j20ow0sednl.jpg\" width=\"500\">  </p>\n<p><img src=\"http://ww3.sinaimg.cn/mw1024/51530583jw1eqkfye958bj20j60zi7d7.jpg\" width=\"500\">  </p>\n","excerpt":"","more":"<p>最近总结了几个 Xcode 小技巧，在微博上（@我就叫Sunny怎么了）都发过，来个合集：</p>\n<p><img src=\"http://ww3.sinaimg.cn/mw1024/51530583jw1eq8xm0otg5j20qk0wk45d.jpg\" width=\"500\">  </p>\n<p><img src=\"http://ww4.sinaimg.cn/mw1024/51530583jw1eq8xm000o1j20oq0i4786.jpg\" width=\"500\"></p>\n<p><img src=\"http://ww4.sinaimg.cn/mw1024/51530583jw1eq8xlzf1kqj20mw0lcaeg.jpg\" width=\"500\">  </p>\n<p><img src=\"http://ww1.sinaimg.cn/mw1024/51530583gw1eqccw0644jj20ka0lq43i.jpg\" width=\"500\">  </p>\n<p><img src=\"http://ww4.sinaimg.cn/mw1024/51530583gw1eqccvzvkexj20mu0lajv2.jpg\" width=\"500\">  </p>\n<p><img src=\"http://ww3.sinaimg.cn/mw1024/51530583gw1eqccvyqgd1j20ow0sednl.jpg\" width=\"500\">  </p>\n<p><img src=\"http://ww3.sinaimg.cn/mw1024/51530583jw1eqkfye958bj20j60zi7d7.jpg\" width=\"500\">  </p>\n"},{"title":"Xcode plugins memo","date":"2014-03-14T15:27:13.000Z","_content":"\n## FuzzyAutocomplete\ngithub：https://github.com/chendo/FuzzyAutocompletePlugin\n![FuzzyAutocomplete](https://raw.github.com/chendo/FuzzyAutocompletePlugin/master/demo.gif)\n\n一个支持**模糊匹配**的代码提示优化插件，支持了xcode5.1\n注意：使用的时候有个输入字母字数小于3就输入不了的bug。  \n效率必备。\n\n## KSImageNamed\ngithub: https://github.com/ksuther/KSImageNamed-Xcode\n![KSImageNamed](https://raw.github.com/ksuther/KSImageNamed-Xcode/master/screenshot.gif)\n输入`imageNamed:`之后快速预览选择图片  \n注意：项目中图片文件数量很多的时候，安装这个插件导致xcode运行明显缓慢，不知道现在版本是否已经修改了这个bug  \n手写UI的尤其适用，我等sb党用的少点。\n\n## HOStringSense\ngithub: https://github.com/holtwick/HOStringSense-for-Xcode\n![HOStringSense](https://github.com/holtwick/HOStringSense-for-Xcode/raw/master/StringDemoAnimation.gif)\n帮助快速输入字符串，尤其是长段复杂的字符串。\n","source":"_posts/xcode_plugins.md","raw":"title: Xcode plugins memo\ndate: 2014-03-14 23:27:13\ntags: xcode\n---\n\n## FuzzyAutocomplete\ngithub：https://github.com/chendo/FuzzyAutocompletePlugin\n![FuzzyAutocomplete](https://raw.github.com/chendo/FuzzyAutocompletePlugin/master/demo.gif)\n\n一个支持**模糊匹配**的代码提示优化插件，支持了xcode5.1\n注意：使用的时候有个输入字母字数小于3就输入不了的bug。  \n效率必备。\n\n## KSImageNamed\ngithub: https://github.com/ksuther/KSImageNamed-Xcode\n![KSImageNamed](https://raw.github.com/ksuther/KSImageNamed-Xcode/master/screenshot.gif)\n输入`imageNamed:`之后快速预览选择图片  \n注意：项目中图片文件数量很多的时候，安装这个插件导致xcode运行明显缓慢，不知道现在版本是否已经修改了这个bug  \n手写UI的尤其适用，我等sb党用的少点。\n\n## HOStringSense\ngithub: https://github.com/holtwick/HOStringSense-for-Xcode\n![HOStringSense](https://github.com/holtwick/HOStringSense-for-Xcode/raw/master/StringDemoAnimation.gif)\n帮助快速输入字符串，尤其是长段复杂的字符串。\n","slug":"xcode_plugins","published":1,"updated":"2016-03-27T08:36:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxn5002oev1218c8w74g","content":"<h2 id=\"FuzzyAutocomplete\"><a href=\"#FuzzyAutocomplete\" class=\"headerlink\" title=\"FuzzyAutocomplete\"></a>FuzzyAutocomplete</h2><p>github：<a href=\"https://github.com/chendo/FuzzyAutocompletePlugin\" target=\"_blank\" rel=\"external\">https://github.com/chendo/FuzzyAutocompletePlugin</a><br><img src=\"https://raw.github.com/chendo/FuzzyAutocompletePlugin/master/demo.gif\" alt=\"FuzzyAutocomplete\"></p>\n<p>一个支持<strong>模糊匹配</strong>的代码提示优化插件，支持了xcode5.1<br>注意：使用的时候有个输入字母字数小于3就输入不了的bug。<br>效率必备。</p>\n<h2 id=\"KSImageNamed\"><a href=\"#KSImageNamed\" class=\"headerlink\" title=\"KSImageNamed\"></a>KSImageNamed</h2><p>github: <a href=\"https://github.com/ksuther/KSImageNamed-Xcode\" target=\"_blank\" rel=\"external\">https://github.com/ksuther/KSImageNamed-Xcode</a><br><img src=\"https://raw.github.com/ksuther/KSImageNamed-Xcode/master/screenshot.gif\" alt=\"KSImageNamed\"><br>输入<code>imageNamed:</code>之后快速预览选择图片<br>注意：项目中图片文件数量很多的时候，安装这个插件导致xcode运行明显缓慢，不知道现在版本是否已经修改了这个bug<br>手写UI的尤其适用，我等sb党用的少点。</p>\n<h2 id=\"HOStringSense\"><a href=\"#HOStringSense\" class=\"headerlink\" title=\"HOStringSense\"></a>HOStringSense</h2><p>github: <a href=\"https://github.com/holtwick/HOStringSense-for-Xcode\" target=\"_blank\" rel=\"external\">https://github.com/holtwick/HOStringSense-for-Xcode</a><br><img src=\"https://github.com/holtwick/HOStringSense-for-Xcode/raw/master/StringDemoAnimation.gif\" alt=\"HOStringSense\"><br>帮助快速输入字符串，尤其是长段复杂的字符串。</p>\n","excerpt":"","more":"<h2 id=\"FuzzyAutocomplete\"><a href=\"#FuzzyAutocomplete\" class=\"headerlink\" title=\"FuzzyAutocomplete\"></a>FuzzyAutocomplete</h2><p>github：<a href=\"https://github.com/chendo/FuzzyAutocompletePlugin\">https://github.com/chendo/FuzzyAutocompletePlugin</a><br><img src=\"https://raw.github.com/chendo/FuzzyAutocompletePlugin/master/demo.gif\" alt=\"FuzzyAutocomplete\"></p>\n<p>一个支持<strong>模糊匹配</strong>的代码提示优化插件，支持了xcode5.1<br>注意：使用的时候有个输入字母字数小于3就输入不了的bug。<br>效率必备。</p>\n<h2 id=\"KSImageNamed\"><a href=\"#KSImageNamed\" class=\"headerlink\" title=\"KSImageNamed\"></a>KSImageNamed</h2><p>github: <a href=\"https://github.com/ksuther/KSImageNamed-Xcode\">https://github.com/ksuther/KSImageNamed-Xcode</a><br><img src=\"https://raw.github.com/ksuther/KSImageNamed-Xcode/master/screenshot.gif\" alt=\"KSImageNamed\"><br>输入<code>imageNamed:</code>之后快速预览选择图片<br>注意：项目中图片文件数量很多的时候，安装这个插件导致xcode运行明显缓慢，不知道现在版本是否已经修改了这个bug<br>手写UI的尤其适用，我等sb党用的少点。</p>\n<h2 id=\"HOStringSense\"><a href=\"#HOStringSense\" class=\"headerlink\" title=\"HOStringSense\"></a>HOStringSense</h2><p>github: <a href=\"https://github.com/holtwick/HOStringSense-for-Xcode\">https://github.com/holtwick/HOStringSense-for-Xcode</a><br><img src=\"https://github.com/holtwick/HOStringSense-for-Xcode/raw/master/StringDemoAnimation.gif\" alt=\"HOStringSense\"><br>帮助快速输入字符串，尤其是长段复杂的字符串。</p>\n"},{"title":"ARC下dealloc过程及.cxx_destruct的探究","date":"2014-04-02T08:39:00.000Z","_content":"\n## 我是前言  \n这次探索源自于自己一直以来对`ARC`的一个疑问，在`MRC`时代，经常写下面的代码：  \n\n``` objc\n- (void)dealloc {\n    self.array = nil;\n    self.string = nil;\n    // ... //\n    // 非Objc对象内存的释放，如CFRelease(...)\n    // ... //\n    [super dealloc];\n}\n```\n\n对象析构时将内部其他对象`release`掉，申请的非Objc对象的内存当然也一并处理掉，最后调用`super`，继续将父类对象做析构。而现如今到了`ARC`时代，只剩下了下面的代码：\n\n``` objc\n- (void)dealloc\n{\n    // ... //\n    // 非Objc对象内存的释放，如CFRelease(...)\n    // ... //\n}\n```\n\n**问题来了：**  \n\n  1. 这个对象实例变量（Ivars）的释放去哪儿了？\n  2. 没有显示的调用`[super dealloc]`，上层的析构去哪儿了？\n\n------\n\n## ARC文档中对dealloc过程的解释\n\n[llvm官方的ARC文档](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#dealloc)中对ARC下的dealloc过程做了简单说明，从中还是能找出些有用的信息：\n\n  >A class may provide a method definition for an instance method named dealloc. This method will be called after the final release of the object but before it is deallocated or any of its instance variables are destroyed. The superclass’s implementation of dealloc will be called automatically when the method returns.\n\n - 大概意思是：dealloc方法在最后一次release后被调用，但此时实例变量（Ivars）并未释放，**父类的dealloc的方法将在子类dealloc方法返回后自动调用**\n\n\n  > The instance variables for an ARC-compiled class will be destroyed at some point after control enters the dealloc method for the root class of the class. The ordering of the destruction of instance variables is unspecified, both within a single class and between subclasses and superclasses.\n\n - 理解：ARC下对象的实例变量在根类[NSObject dealloc]中释放（通常root class都是NSObject），变量释放顺序各种不确定（一个类内的不确定，子类和父类间也不确定，也就是说不用care释放顺序）\n\n所以，不用主调`[super dealloc]`是因为自动调了，后面再说如何实现的；ARC下实例变量在根类NSObject析构时析构，下面就探究下。\n\n------\n\n## NSObject的析构过程\n通过apple的runtime源码，不难发现NSObject执行`dealloc`时调用`_objc_rootDealloc`继而调用`object_dispose`随后调用`objc_destructInstance`方法，前几步都是条件判断和简单的跳转，最后的这个函数如下：\n\n``` objc\nvoid *objc_destructInstance(id obj)\n{\n    if (obj) {\n        Class isa_gen = _object_getClass(obj);\n        class_t *isa = newcls(isa_gen);\n\n        // Read all of the flags at once for performance.\n        bool cxx = hasCxxStructors(isa);\n        bool assoc = !UseGC && _class_instancesHaveAssociatedObjects(isa_gen);\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj);\n        if (assoc) _object_remove_assocations(obj);\n\n        if (!UseGC) objc_clear_deallocating(obj);\n    }\n\n    return obj;\n}\n```\n\n简单明确的干了三件事：\n  1. 执行一个叫`object_cxxDestruct`的东西干了点什么事\n  2. 执行`_object_remove_assocations`去除和这个对象assocate的对象（常用于category中添加带变量的属性，这也是为什么~~<strike>ARC下没必要remove一遍的原因~~</strike> (Edit: 在ARC或MRC下都不需要remove，感谢@sagles的基情提示）\n  3. 执行`objc_clear_deallocating`，清空引用计数表并清除弱引用表，将所有`weak`引用指nil（这也就是weak变量能安全置空的所在）\n\n所以，所探寻的ARC自动释放实例变量的地方就在`cxxDestruct`这个东西里面没跑了。\n\n------\n\n## 探寻隐藏的.cxx_destruct\n\n上面找到的名为`object_cxxDestruct`的方法最终成为下面的调用：\n\n``` objc\nstatic void object_cxxDestructFromClass(id obj, Class cls)\n{\n    void (*dtor)(id);\n\n    // Call cls's dtor first, then superclasses's dtors.\n\n    for ( ; cls != NULL; cls = _class_getSuperclass(cls)) {\n        if (!_class_hasCxxStructors(cls)) return;\n        dtor = (void(*)(id))\n            lookupMethodInClassAndLoadCache(cls, SEL_cxx_destruct);\n        if (dtor != (void(*)(id))_objc_msgForward_internal) {\n            if (PrintCxxCtors) {\n                _objc_inform(\"CXX: calling C++ destructors for class %s\",\n                             _class_getName(cls));\n            }\n            (*dtor)(obj);\n        }\n    }\n}\n```\n\n代码也不难理解，沿着继承链逐层向上搜寻`SEL_cxx_destruct`这个selector，找到函数实现(`void (*)(id)`(函数指针)并执行。  \n搜索这个selector的声明，发现是名为`.cxx_destruct`的方法，以点开头的名字，我想和unix的文件一样，是有**隐藏**属性的\n\n从[这篇文章](http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03)中：\n  >ARC actually creates a -.cxx_destruct method to handle freeing instance variables. This method was originally created for calling C++ destructors automatically when an object was destroyed.\n\n和《Effective Objective-C 2.0》中提到的：\n  >When the compiler saw that an object contained C++ objects, it would generate a method called .cxx_destruct. ARC piggybacks on this method and emits the required cleanup code within it.  \n\n可以了解到，`.cxx_destruct`方法原本是为了C++对象析构的，ARC借用了这个方法插入代码实现了自动内存释放的工作\n\n-----\n\n## 通过实验找出.cxx_destruct  \n最好的办法还是写个测试代码把这个隐藏的方法找出来，其实在runtime中运行已经没什么隐藏可言了，简单的类结构如下：\n\n``` objc\n@interface Father : NSObject\n@property (nonatomic, copy) NSString *name;\n@end\n\n@interface Son : Father\n@property (nonatomic, copy) NSArray *toys;\n@end\n```\n\n只有两个简单的属性，找个地方写简单的测试代码：\n\n``` objc\n// start\n{\n    // before new\n    Son *son = [Son new];\n    son.name = @\"sark\";\n    son.toys = @[@\"sunny\", @\"xx\"];\n    // after new\n}\n// gone\n```\n\n主要目的是为了让这个对象走dealloc方法，新建的son对象过了大括号作用域就会释放了，所以在`after new`这行son对象初始化完成，在`gone`这行son对象被dealloc  \n\n个人一直喜欢使用[NSObject+DLIntrospection](https://github.com/garnett/DLIntrospection)这个扩展作为调试工具，可以轻松打出一个类的方法，变量等等。  \n\n将这个扩展引入工程内，在`after new`处设置一个断点，run，trigger后使用lldb命令用这个扩展输出Son类所有的方法名：\n\n![](http://ww3.sinaimg.cn/large/51530583gw1ef27srhw7lj208b05ujrq.jpg)\n\n发现了这个`.cxx_destruct`方法，经过几次试验，发现：\n  1. 只有在ARC下这个方法才会出现（试验代码的情况下）\n  2. 只有当前类拥有实例变量时（不论是不是用property）这个方法才会出现，且父类的实例变量不会导致子类拥有这个方法\n  3. 出现这个方法和变量是否被赋值，赋值成什么没有关系\n\n-----\n\n## 使用watchpoint定位内存释放时刻\n\n依然在`after new`断点处，输入lldb命令：\n```\nwatchpoint set variable son->_name\n```\n将`name`的变量加入watchpoint，当这个变量被修改时会触发trigger：\n\n![](http://ww3.sinaimg.cn/large/51530583gw1ef28rn41lcj20fs03aq3b.jpg)\n\n从中可以看出，在这个时刻，`_name`从0x00006b98变成了0x0，也就是nil，赶紧看下调用栈：\n\n![](http://ww1.sinaimg.cn/large/51530583gw1ef2911o40zj20a605yweu.jpg)\n\n发现果然跟到了`.cxx_destruct`方法，而且是在`objc_storeStrong`的过程中释放\n\n-----\n\n## 刨根问底.cxx_destruct\n\n知道了ARC下对象实例变量的释放过程在`.cxx_destruct`内完成，但这个函数内部发生了什么，是如何调用`objc_storeStrong`释放变量的呢？  \n从上面的探究中知道，`.cxx_destruct`是编译器生成的代码，那它很可能在clang前端编译时完成，这让我联想到clang的`Code Generation`，因为之前曾经使用`clang -rewrite-objc xxx.m`时查看过官方文档留下了些印象，于是google：\n\n```\n.cxx_destruct site:clang.llvm.org\n```\n\n结果发现clang的`doxygen`文档中`CodeGenModule`模块正是这部分的实现代码，cxx相关的代码生成部分源码在  \nhttp://clang.llvm.org/doxygen/CodeGenModule_8cpp-source.html  \n位于1827行，删减掉离题部分如下：  \n\n\n``` c++\n/// EmitObjCIvarInitializations - Emit information for ivar initialization\n/// for an implementation.\nvoid CodeGenModule::EmitObjCIvarInitializations(ObjCImplementationDecl *D)\n{\n    DeclContext* DC = const_cast<DeclContext*>(dyn_cast<DeclContext>(D));\n    assert(DC && \"EmitObjCIvarInitializations - null DeclContext\");\n    IdentifierInfo *II = &getContext().Idents.get(\".cxx_destruct\");\n    Selector cxxSelector = getContext().Selectors.getSelector(0, &II);\n    ObjCMethodDecl *DTORMethod = ObjCMethodDecl::Create(getContext(),\n                                                        D->getLocation(),\n                                                        D->getLocation(), cxxSelector,\n                                                        getContext().VoidTy, 0,\n                                                        DC, true, false, true,\n                                                        ObjCMethodDecl::Required);\n   D->addInstanceMethod(DTORMethod);\n   CodeGenFunction(*this).GenerateObjCCtorDtorMethod(D, DTORMethod, false);\n}\n```\n\n这个函数大概作用是：获取`.cxx_destruct`的selector，创建Method，并加入到这个Class的方法列表中，最后一行的调用才是真的创建这个方法的实现。这个方法位于  \nhttp://clang.llvm.org/doxygen/CGObjC_8cpp_source.html  \n1354行，包含了构造和析构的cxx方法，继续跟随`.cxx_destruct`，最终调用`emitCXXDestructMethod`函数，代码如下：  \n\n``` c++\nstatic void emitCXXDestructMethod(CodeGenFunction &CGF, ObjCImplementationDecl *impl)\n{\n   CodeGenFunction::RunCleanupsScope scope(CGF);\n\n   llvm::Value *self = CGF.LoadObjCSelf();\n\n   const ObjCInterfaceDecl *iface = impl->getClassInterface();\n   for (const ObjCIvarDecl *ivar = iface->all_declared_ivar_begin(); ivar; ivar = ivar->getNextIvar())\n   {\n     QualType type = ivar->getType();\n\n     // Check whether the ivar is a destructible type.\n     QualType::DestructionKind dtorKind = type.isDestructedType();\n     if (!dtorKind) continue;\n\n     CodeGenFunction::Destroyer *destroyer = 0;\n\n     // Use a call to objc_storeStrong to destroy strong ivars, for the\n     // general benefit of the tools.\n     if (dtorKind == QualType::DK_objc_strong_lifetime) {\n       destroyer = destroyARCStrongWithStore;\n\n     // Otherwise use the default for the destruction kind.\n     } else {\n       destroyer = CGF.getDestroyer(dtorKind);\n     }\n\n     CleanupKind cleanupKind = CGF.getCleanupKind(dtorKind);\n     CGF.EHStack.pushCleanup<DestroyIvar>(cleanupKind, self, ivar, destroyer,\n                                          cleanupKind & EHCleanup);\n   }\n\n   assert(scope.requiresCleanups() && \"nothing to do in .cxx_destruct?\");\n}\n```\n\n分析这段代码以及其中调用后发现：它遍历当前对象所有的实例变量（Ivars)，调用`objc_storeStrong`，从`clang`的ARC文档上可以找到`objc_storeStrong`的示意代码实现如下：\n\n``` c\nid objc_storeStrong(id *object, id value) {\n  value = [value retain];\n  id oldValue = *object;\n  *object = value;\n  [oldValue release];\n  return value;\n}\n```\n\n在`.cxx_destruct`进行形如`objc_storeStrong(&ivar, null)`的调用后，这个实例变量就被`release`和设置成`nil`了  \n注：真实的实现可以参考 http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html 2078行\n\n-----\n\n## 自动调用[super dealloc]的实现  \n按照上面的思路，自动调用`[super dealloc]`也一定是`CodeGen`干的工作了\n位于 http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html 492行  \n`StartObjCMethod`方法中：  \n\n``` c++\n if (ident->isStr(\"dealloc\"))\n    EHStack.pushCleanup<FinishARCDealloc>(getARCCleanupKind());\n```\n\n上面代码可以得知在调用`dealloc`方法时被插入了代码，由`FinishARCDealloc`结构定义：  \n\n``` c++\nstruct FinishARCDealloc : EHScopeStack::Cleanup {\n   void Emit(CodeGenFunction &CGF, Flags flags) override {\n     const ObjCMethodDecl *method = cast<ObjCMethodDecl>(CGF.CurCodeDecl);\n\n     const ObjCImplDecl *impl = cast<ObjCImplDecl>(method->getDeclContext());\n     const ObjCInterfaceDecl *iface = impl->getClassInterface();\n     if (!iface->getSuperClass()) return;\n\n     bool isCategory = isa<ObjCCategoryImplDecl>(impl);\n\n     // Call [super dealloc] if we have a superclass.\n     llvm::Value *self = CGF.LoadObjCSelf();\n\n     CallArgList args;\n     CGF.CGM.getObjCRuntime().GenerateMessageSendSuper(CGF, ReturnValueSlot(),\n                                                       CGF.getContext().VoidTy,\n                                                       method->getSelector(),\n                                                       iface,\n                                                       isCategory,\n                                                       self,\n                                                       /*is class msg*/ false,\n                                                       args,\n                                                       method);\n   }\n};\n```\n\n上面代码基本上就是向父类转发`dealloc`的调用，实现了自动调用`[super dealloc]`方法。  \n\n-----\n## 总结  \n\n  - ARC下对象的成员变量于编译器插入的`.cxx_desctruct`方法自动释放\n  - ARC下`[super dealloc]`方法也由编译器自动插入\n  - 所谓`编译器插入代码`过程需要进一步了解，还不清楚其运作方式\n  - clang的`CodeGen`也值得深入研究一下\n\n-----\n\n## References：\n - http://clang.llvm.org/docs/AutomaticReferenceCounting.html\n - http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03\n - http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html\n\n-----\n\n原创文章，转载请注明源地址，[blog.sunnyxx.com](http://blog.sunnyxx.com)\n","source":"_posts/objc_dig_arc_dealloc.md","raw":"title: ARC下dealloc过程及.cxx_destruct的探究\ndate: 2014-04-02 16:39:00\ntags: objc刨根问底\n---\n\n## 我是前言  \n这次探索源自于自己一直以来对`ARC`的一个疑问，在`MRC`时代，经常写下面的代码：  \n\n``` objc\n- (void)dealloc {\n    self.array = nil;\n    self.string = nil;\n    // ... //\n    // 非Objc对象内存的释放，如CFRelease(...)\n    // ... //\n    [super dealloc];\n}\n```\n\n对象析构时将内部其他对象`release`掉，申请的非Objc对象的内存当然也一并处理掉，最后调用`super`，继续将父类对象做析构。而现如今到了`ARC`时代，只剩下了下面的代码：\n\n``` objc\n- (void)dealloc\n{\n    // ... //\n    // 非Objc对象内存的释放，如CFRelease(...)\n    // ... //\n}\n```\n\n**问题来了：**  \n\n  1. 这个对象实例变量（Ivars）的释放去哪儿了？\n  2. 没有显示的调用`[super dealloc]`，上层的析构去哪儿了？\n\n------\n\n## ARC文档中对dealloc过程的解释\n\n[llvm官方的ARC文档](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#dealloc)中对ARC下的dealloc过程做了简单说明，从中还是能找出些有用的信息：\n\n  >A class may provide a method definition for an instance method named dealloc. This method will be called after the final release of the object but before it is deallocated or any of its instance variables are destroyed. The superclass’s implementation of dealloc will be called automatically when the method returns.\n\n - 大概意思是：dealloc方法在最后一次release后被调用，但此时实例变量（Ivars）并未释放，**父类的dealloc的方法将在子类dealloc方法返回后自动调用**\n\n\n  > The instance variables for an ARC-compiled class will be destroyed at some point after control enters the dealloc method for the root class of the class. The ordering of the destruction of instance variables is unspecified, both within a single class and between subclasses and superclasses.\n\n - 理解：ARC下对象的实例变量在根类[NSObject dealloc]中释放（通常root class都是NSObject），变量释放顺序各种不确定（一个类内的不确定，子类和父类间也不确定，也就是说不用care释放顺序）\n\n所以，不用主调`[super dealloc]`是因为自动调了，后面再说如何实现的；ARC下实例变量在根类NSObject析构时析构，下面就探究下。\n\n------\n\n## NSObject的析构过程\n通过apple的runtime源码，不难发现NSObject执行`dealloc`时调用`_objc_rootDealloc`继而调用`object_dispose`随后调用`objc_destructInstance`方法，前几步都是条件判断和简单的跳转，最后的这个函数如下：\n\n``` objc\nvoid *objc_destructInstance(id obj)\n{\n    if (obj) {\n        Class isa_gen = _object_getClass(obj);\n        class_t *isa = newcls(isa_gen);\n\n        // Read all of the flags at once for performance.\n        bool cxx = hasCxxStructors(isa);\n        bool assoc = !UseGC && _class_instancesHaveAssociatedObjects(isa_gen);\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj);\n        if (assoc) _object_remove_assocations(obj);\n\n        if (!UseGC) objc_clear_deallocating(obj);\n    }\n\n    return obj;\n}\n```\n\n简单明确的干了三件事：\n  1. 执行一个叫`object_cxxDestruct`的东西干了点什么事\n  2. 执行`_object_remove_assocations`去除和这个对象assocate的对象（常用于category中添加带变量的属性，这也是为什么~~<strike>ARC下没必要remove一遍的原因~~</strike> (Edit: 在ARC或MRC下都不需要remove，感谢@sagles的基情提示）\n  3. 执行`objc_clear_deallocating`，清空引用计数表并清除弱引用表，将所有`weak`引用指nil（这也就是weak变量能安全置空的所在）\n\n所以，所探寻的ARC自动释放实例变量的地方就在`cxxDestruct`这个东西里面没跑了。\n\n------\n\n## 探寻隐藏的.cxx_destruct\n\n上面找到的名为`object_cxxDestruct`的方法最终成为下面的调用：\n\n``` objc\nstatic void object_cxxDestructFromClass(id obj, Class cls)\n{\n    void (*dtor)(id);\n\n    // Call cls's dtor first, then superclasses's dtors.\n\n    for ( ; cls != NULL; cls = _class_getSuperclass(cls)) {\n        if (!_class_hasCxxStructors(cls)) return;\n        dtor = (void(*)(id))\n            lookupMethodInClassAndLoadCache(cls, SEL_cxx_destruct);\n        if (dtor != (void(*)(id))_objc_msgForward_internal) {\n            if (PrintCxxCtors) {\n                _objc_inform(\"CXX: calling C++ destructors for class %s\",\n                             _class_getName(cls));\n            }\n            (*dtor)(obj);\n        }\n    }\n}\n```\n\n代码也不难理解，沿着继承链逐层向上搜寻`SEL_cxx_destruct`这个selector，找到函数实现(`void (*)(id)`(函数指针)并执行。  \n搜索这个selector的声明，发现是名为`.cxx_destruct`的方法，以点开头的名字，我想和unix的文件一样，是有**隐藏**属性的\n\n从[这篇文章](http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03)中：\n  >ARC actually creates a -.cxx_destruct method to handle freeing instance variables. This method was originally created for calling C++ destructors automatically when an object was destroyed.\n\n和《Effective Objective-C 2.0》中提到的：\n  >When the compiler saw that an object contained C++ objects, it would generate a method called .cxx_destruct. ARC piggybacks on this method and emits the required cleanup code within it.  \n\n可以了解到，`.cxx_destruct`方法原本是为了C++对象析构的，ARC借用了这个方法插入代码实现了自动内存释放的工作\n\n-----\n\n## 通过实验找出.cxx_destruct  \n最好的办法还是写个测试代码把这个隐藏的方法找出来，其实在runtime中运行已经没什么隐藏可言了，简单的类结构如下：\n\n``` objc\n@interface Father : NSObject\n@property (nonatomic, copy) NSString *name;\n@end\n\n@interface Son : Father\n@property (nonatomic, copy) NSArray *toys;\n@end\n```\n\n只有两个简单的属性，找个地方写简单的测试代码：\n\n``` objc\n// start\n{\n    // before new\n    Son *son = [Son new];\n    son.name = @\"sark\";\n    son.toys = @[@\"sunny\", @\"xx\"];\n    // after new\n}\n// gone\n```\n\n主要目的是为了让这个对象走dealloc方法，新建的son对象过了大括号作用域就会释放了，所以在`after new`这行son对象初始化完成，在`gone`这行son对象被dealloc  \n\n个人一直喜欢使用[NSObject+DLIntrospection](https://github.com/garnett/DLIntrospection)这个扩展作为调试工具，可以轻松打出一个类的方法，变量等等。  \n\n将这个扩展引入工程内，在`after new`处设置一个断点，run，trigger后使用lldb命令用这个扩展输出Son类所有的方法名：\n\n![](http://ww3.sinaimg.cn/large/51530583gw1ef27srhw7lj208b05ujrq.jpg)\n\n发现了这个`.cxx_destruct`方法，经过几次试验，发现：\n  1. 只有在ARC下这个方法才会出现（试验代码的情况下）\n  2. 只有当前类拥有实例变量时（不论是不是用property）这个方法才会出现，且父类的实例变量不会导致子类拥有这个方法\n  3. 出现这个方法和变量是否被赋值，赋值成什么没有关系\n\n-----\n\n## 使用watchpoint定位内存释放时刻\n\n依然在`after new`断点处，输入lldb命令：\n```\nwatchpoint set variable son->_name\n```\n将`name`的变量加入watchpoint，当这个变量被修改时会触发trigger：\n\n![](http://ww3.sinaimg.cn/large/51530583gw1ef28rn41lcj20fs03aq3b.jpg)\n\n从中可以看出，在这个时刻，`_name`从0x00006b98变成了0x0，也就是nil，赶紧看下调用栈：\n\n![](http://ww1.sinaimg.cn/large/51530583gw1ef2911o40zj20a605yweu.jpg)\n\n发现果然跟到了`.cxx_destruct`方法，而且是在`objc_storeStrong`的过程中释放\n\n-----\n\n## 刨根问底.cxx_destruct\n\n知道了ARC下对象实例变量的释放过程在`.cxx_destruct`内完成，但这个函数内部发生了什么，是如何调用`objc_storeStrong`释放变量的呢？  \n从上面的探究中知道，`.cxx_destruct`是编译器生成的代码，那它很可能在clang前端编译时完成，这让我联想到clang的`Code Generation`，因为之前曾经使用`clang -rewrite-objc xxx.m`时查看过官方文档留下了些印象，于是google：\n\n```\n.cxx_destruct site:clang.llvm.org\n```\n\n结果发现clang的`doxygen`文档中`CodeGenModule`模块正是这部分的实现代码，cxx相关的代码生成部分源码在  \nhttp://clang.llvm.org/doxygen/CodeGenModule_8cpp-source.html  \n位于1827行，删减掉离题部分如下：  \n\n\n``` c++\n/// EmitObjCIvarInitializations - Emit information for ivar initialization\n/// for an implementation.\nvoid CodeGenModule::EmitObjCIvarInitializations(ObjCImplementationDecl *D)\n{\n    DeclContext* DC = const_cast<DeclContext*>(dyn_cast<DeclContext>(D));\n    assert(DC && \"EmitObjCIvarInitializations - null DeclContext\");\n    IdentifierInfo *II = &getContext().Idents.get(\".cxx_destruct\");\n    Selector cxxSelector = getContext().Selectors.getSelector(0, &II);\n    ObjCMethodDecl *DTORMethod = ObjCMethodDecl::Create(getContext(),\n                                                        D->getLocation(),\n                                                        D->getLocation(), cxxSelector,\n                                                        getContext().VoidTy, 0,\n                                                        DC, true, false, true,\n                                                        ObjCMethodDecl::Required);\n   D->addInstanceMethod(DTORMethod);\n   CodeGenFunction(*this).GenerateObjCCtorDtorMethod(D, DTORMethod, false);\n}\n```\n\n这个函数大概作用是：获取`.cxx_destruct`的selector，创建Method，并加入到这个Class的方法列表中，最后一行的调用才是真的创建这个方法的实现。这个方法位于  \nhttp://clang.llvm.org/doxygen/CGObjC_8cpp_source.html  \n1354行，包含了构造和析构的cxx方法，继续跟随`.cxx_destruct`，最终调用`emitCXXDestructMethod`函数，代码如下：  \n\n``` c++\nstatic void emitCXXDestructMethod(CodeGenFunction &CGF, ObjCImplementationDecl *impl)\n{\n   CodeGenFunction::RunCleanupsScope scope(CGF);\n\n   llvm::Value *self = CGF.LoadObjCSelf();\n\n   const ObjCInterfaceDecl *iface = impl->getClassInterface();\n   for (const ObjCIvarDecl *ivar = iface->all_declared_ivar_begin(); ivar; ivar = ivar->getNextIvar())\n   {\n     QualType type = ivar->getType();\n\n     // Check whether the ivar is a destructible type.\n     QualType::DestructionKind dtorKind = type.isDestructedType();\n     if (!dtorKind) continue;\n\n     CodeGenFunction::Destroyer *destroyer = 0;\n\n     // Use a call to objc_storeStrong to destroy strong ivars, for the\n     // general benefit of the tools.\n     if (dtorKind == QualType::DK_objc_strong_lifetime) {\n       destroyer = destroyARCStrongWithStore;\n\n     // Otherwise use the default for the destruction kind.\n     } else {\n       destroyer = CGF.getDestroyer(dtorKind);\n     }\n\n     CleanupKind cleanupKind = CGF.getCleanupKind(dtorKind);\n     CGF.EHStack.pushCleanup<DestroyIvar>(cleanupKind, self, ivar, destroyer,\n                                          cleanupKind & EHCleanup);\n   }\n\n   assert(scope.requiresCleanups() && \"nothing to do in .cxx_destruct?\");\n}\n```\n\n分析这段代码以及其中调用后发现：它遍历当前对象所有的实例变量（Ivars)，调用`objc_storeStrong`，从`clang`的ARC文档上可以找到`objc_storeStrong`的示意代码实现如下：\n\n``` c\nid objc_storeStrong(id *object, id value) {\n  value = [value retain];\n  id oldValue = *object;\n  *object = value;\n  [oldValue release];\n  return value;\n}\n```\n\n在`.cxx_destruct`进行形如`objc_storeStrong(&ivar, null)`的调用后，这个实例变量就被`release`和设置成`nil`了  \n注：真实的实现可以参考 http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html 2078行\n\n-----\n\n## 自动调用[super dealloc]的实现  \n按照上面的思路，自动调用`[super dealloc]`也一定是`CodeGen`干的工作了\n位于 http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html 492行  \n`StartObjCMethod`方法中：  \n\n``` c++\n if (ident->isStr(\"dealloc\"))\n    EHStack.pushCleanup<FinishARCDealloc>(getARCCleanupKind());\n```\n\n上面代码可以得知在调用`dealloc`方法时被插入了代码，由`FinishARCDealloc`结构定义：  \n\n``` c++\nstruct FinishARCDealloc : EHScopeStack::Cleanup {\n   void Emit(CodeGenFunction &CGF, Flags flags) override {\n     const ObjCMethodDecl *method = cast<ObjCMethodDecl>(CGF.CurCodeDecl);\n\n     const ObjCImplDecl *impl = cast<ObjCImplDecl>(method->getDeclContext());\n     const ObjCInterfaceDecl *iface = impl->getClassInterface();\n     if (!iface->getSuperClass()) return;\n\n     bool isCategory = isa<ObjCCategoryImplDecl>(impl);\n\n     // Call [super dealloc] if we have a superclass.\n     llvm::Value *self = CGF.LoadObjCSelf();\n\n     CallArgList args;\n     CGF.CGM.getObjCRuntime().GenerateMessageSendSuper(CGF, ReturnValueSlot(),\n                                                       CGF.getContext().VoidTy,\n                                                       method->getSelector(),\n                                                       iface,\n                                                       isCategory,\n                                                       self,\n                                                       /*is class msg*/ false,\n                                                       args,\n                                                       method);\n   }\n};\n```\n\n上面代码基本上就是向父类转发`dealloc`的调用，实现了自动调用`[super dealloc]`方法。  \n\n-----\n## 总结  \n\n  - ARC下对象的成员变量于编译器插入的`.cxx_desctruct`方法自动释放\n  - ARC下`[super dealloc]`方法也由编译器自动插入\n  - 所谓`编译器插入代码`过程需要进一步了解，还不清楚其运作方式\n  - clang的`CodeGen`也值得深入研究一下\n\n-----\n\n## References：\n - http://clang.llvm.org/docs/AutomaticReferenceCounting.html\n - http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03\n - http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html\n\n-----\n\n原创文章，转载请注明源地址，[blog.sunnyxx.com](http://blog.sunnyxx.com)\n","slug":"objc_dig_arc_dealloc","published":1,"updated":"2016-03-27T08:32:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimd6pxn7002qev12lfiuetwb","content":"<h2 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h2><p>这次探索源自于自己一直以来对<code>ARC</code>的一个疑问，在<code>MRC</code>时代，经常写下面的代码：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.array = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.string = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"comment\">// ... //</span></span><br><span class=\"line\">    <span class=\"comment\">// 非Objc对象内存的释放，如CFRelease(...)</span></span><br><span class=\"line\">    <span class=\"comment\">// ... //</span></span><br><span class=\"line\">    [<span class=\"keyword\">super</span> dealloc];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对象析构时将内部其他对象<code>release</code>掉，申请的非Objc对象的内存当然也一并处理掉，最后调用<code>super</code>，继续将父类对象做析构。而现如今到了<code>ARC</code>时代，只剩下了下面的代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... //</span></span><br><span class=\"line\">    <span class=\"comment\">// 非Objc对象内存的释放，如CFRelease(...)</span></span><br><span class=\"line\">    <span class=\"comment\">// ... //</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>问题来了：</strong>  </p>\n<ol>\n<li>这个对象实例变量（Ivars）的释放去哪儿了？</li>\n<li>没有显示的调用<code>[super dealloc]</code>，上层的析构去哪儿了？</li>\n</ol>\n<hr>\n<h2 id=\"ARC文档中对dealloc过程的解释\"><a href=\"#ARC文档中对dealloc过程的解释\" class=\"headerlink\" title=\"ARC文档中对dealloc过程的解释\"></a>ARC文档中对dealloc过程的解释</h2><p><a href=\"http://clang.llvm.org/docs/AutomaticReferenceCounting.html#dealloc\" target=\"_blank\" rel=\"external\">llvm官方的ARC文档</a>中对ARC下的dealloc过程做了简单说明，从中还是能找出些有用的信息：</p>\n<blockquote>\n<p>A class may provide a method definition for an instance method named dealloc. This method will be called after the final release of the object but before it is deallocated or any of its instance variables are destroyed. The superclass’s implementation of dealloc will be called automatically when the method returns.</p>\n</blockquote>\n<ul>\n<li>大概意思是：dealloc方法在最后一次release后被调用，但此时实例变量（Ivars）并未释放，<strong>父类的dealloc的方法将在子类dealloc方法返回后自动调用</strong></li>\n</ul>\n<blockquote>\n<p>The instance variables for an ARC-compiled class will be destroyed at some point after control enters the dealloc method for the root class of the class. The ordering of the destruction of instance variables is unspecified, both within a single class and between subclasses and superclasses.</p>\n</blockquote>\n<ul>\n<li>理解：ARC下对象的实例变量在根类[NSObject dealloc]中释放（通常root class都是NSObject），变量释放顺序各种不确定（一个类内的不确定，子类和父类间也不确定，也就是说不用care释放顺序）</li>\n</ul>\n<p>所以，不用主调<code>[super dealloc]</code>是因为自动调了，后面再说如何实现的；ARC下实例变量在根类NSObject析构时析构，下面就探究下。</p>\n<hr>\n<h2 id=\"NSObject的析构过程\"><a href=\"#NSObject的析构过程\" class=\"headerlink\" title=\"NSObject的析构过程\"></a>NSObject的析构过程</h2><p>通过apple的runtime源码，不难发现NSObject执行<code>dealloc</code>时调用<code>_objc_rootDealloc</code>继而调用<code>object_dispose</code>随后调用<code>objc_destructInstance</code>方法，前几步都是条件判断和简单的跳转，最后的这个函数如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> *objc_destructInstance(<span class=\"keyword\">id</span> obj)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) &#123;</span><br><span class=\"line\">        Class isa_gen = _object_getClass(obj);</span><br><span class=\"line\">        class_t *isa = newcls(isa_gen);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Read all of the flags at once for performance.</span></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> cxx = hasCxxStructors(isa);</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> assoc = !UseGC &amp;&amp; _class_instancesHaveAssociatedObjects(isa_gen);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// This order is important.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cxx) object_cxxDestruct(obj);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!UseGC) objc_clear_deallocating(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单明确的干了三件事：</p>\n<ol>\n<li>执行一个叫<code>object_cxxDestruct</code>的东西干了点什么事</li>\n<li>执行<code>_object_remove_assocations</code>去除和这个对象assocate的对象（常用于category中添加带变量的属性，这也是为什么<del><strike>ARC下没必要remove一遍的原因</strike></del> (Edit: 在ARC或MRC下都不需要remove，感谢@sagles的基情提示）</li>\n<li>执行<code>objc_clear_deallocating</code>，清空引用计数表并清除弱引用表，将所有<code>weak</code>引用指nil（这也就是weak变量能安全置空的所在）</li>\n</ol>\n<p>所以，所探寻的ARC自动释放实例变量的地方就在<code>cxxDestruct</code>这个东西里面没跑了。</p>\n<hr>\n<h2 id=\"探寻隐藏的-cxx-destruct\"><a href=\"#探寻隐藏的-cxx-destruct\" class=\"headerlink\" title=\"探寻隐藏的.cxx_destruct\"></a>探寻隐藏的.cxx_destruct</h2><p>上面找到的名为<code>object_cxxDestruct</code>的方法最终成为下面的调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> object_cxxDestructFromClass(<span class=\"keyword\">id</span> obj, Class cls)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*dtor)(<span class=\"keyword\">id</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Call cls's dtor first, then superclasses's dtors.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( ; cls != <span class=\"literal\">NULL</span>; cls = _class_getSuperclass(cls)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!_class_hasCxxStructors(cls)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        dtor = (<span class=\"keyword\">void</span>(*)(<span class=\"keyword\">id</span>))</span><br><span class=\"line\">            lookupMethodInClassAndLoadCache(cls, SEL_cxx_destruct);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dtor != (<span class=\"keyword\">void</span>(*)(<span class=\"keyword\">id</span>))_objc_msgForward_internal) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (PrintCxxCtors) &#123;</span><br><span class=\"line\">                _objc_inform(<span class=\"string\">\"CXX: calling C++ destructors for class %s\"</span>,</span><br><span class=\"line\">                             _class_getName(cls));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            (*dtor)(obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码也不难理解，沿着继承链逐层向上搜寻<code>SEL_cxx_destruct</code>这个selector，找到函数实现(<code>void (*)(id)</code>(函数指针)并执行。<br>搜索这个selector的声明，发现是名为<code>.cxx_destruct</code>的方法，以点开头的名字，我想和unix的文件一样，是有<strong>隐藏</strong>属性的</p>\n<p>从<a href=\"http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03\" target=\"_blank\" rel=\"external\">这篇文章</a>中：</p>\n<blockquote>\n<p>ARC actually creates a -.cxx_destruct method to handle freeing instance variables. This method was originally created for calling C++ destructors automatically when an object was destroyed.</p>\n</blockquote>\n<p>和《Effective Objective-C 2.0》中提到的：</p>\n<blockquote>\n<p>When the compiler saw that an object contained C++ objects, it would generate a method called .cxx_destruct. ARC piggybacks on this method and emits the required cleanup code within it.  </p>\n</blockquote>\n<p>可以了解到，<code>.cxx_destruct</code>方法原本是为了C++对象析构的，ARC借用了这个方法插入代码实现了自动内存释放的工作</p>\n<hr>\n<h2 id=\"通过实验找出-cxx-destruct\"><a href=\"#通过实验找出-cxx-destruct\" class=\"headerlink\" title=\"通过实验找出.cxx_destruct\"></a>通过实验找出.cxx_destruct</h2><p>最好的办法还是写个测试代码把这个隐藏的方法找出来，其实在runtime中运行已经没什么隐藏可言了，简单的类结构如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Father</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Son</span> : <span class=\"title\">Father</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSArray</span> *toys;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>只有两个简单的属性，找个地方写简单的测试代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// start</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// before new</span></span><br><span class=\"line\">    Son *son = [Son new];</span><br><span class=\"line\">    son.name = <span class=\"string\">@\"sark\"</span>;</span><br><span class=\"line\">    son.toys = @[<span class=\"string\">@\"sunny\"</span>, <span class=\"string\">@\"xx\"</span>];</span><br><span class=\"line\">    <span class=\"comment\">// after new</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// gone</span></span><br></pre></td></tr></table></figure>\n<p>主要目的是为了让这个对象走dealloc方法，新建的son对象过了大括号作用域就会释放了，所以在<code>after new</code>这行son对象初始化完成，在<code>gone</code>这行son对象被dealloc  </p>\n<p>个人一直喜欢使用<a href=\"https://github.com/garnett/DLIntrospection\" target=\"_blank\" rel=\"external\">NSObject+DLIntrospection</a>这个扩展作为调试工具，可以轻松打出一个类的方法，变量等等。  </p>\n<p>将这个扩展引入工程内，在<code>after new</code>处设置一个断点，run，trigger后使用lldb命令用这个扩展输出Son类所有的方法名：</p>\n<p><img src=\"http://ww3.sinaimg.cn/large/51530583gw1ef27srhw7lj208b05ujrq.jpg\" alt=\"\"></p>\n<p>发现了这个<code>.cxx_destruct</code>方法，经过几次试验，发现：</p>\n<ol>\n<li>只有在ARC下这个方法才会出现（试验代码的情况下）</li>\n<li>只有当前类拥有实例变量时（不论是不是用property）这个方法才会出现，且父类的实例变量不会导致子类拥有这个方法</li>\n<li>出现这个方法和变量是否被赋值，赋值成什么没有关系</li>\n</ol>\n<hr>\n<h2 id=\"使用watchpoint定位内存释放时刻\"><a href=\"#使用watchpoint定位内存释放时刻\" class=\"headerlink\" title=\"使用watchpoint定位内存释放时刻\"></a>使用watchpoint定位内存释放时刻</h2><p>依然在<code>after new</code>断点处，输入lldb命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watchpoint set variable son-&gt;_name</span><br></pre></td></tr></table></figure></p>\n<p>将<code>name</code>的变量加入watchpoint，当这个变量被修改时会触发trigger：</p>\n<p><img src=\"http://ww3.sinaimg.cn/large/51530583gw1ef28rn41lcj20fs03aq3b.jpg\" alt=\"\"></p>\n<p>从中可以看出，在这个时刻，<code>_name</code>从0x00006b98变成了0x0，也就是nil，赶紧看下调用栈：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/51530583gw1ef2911o40zj20a605yweu.jpg\" alt=\"\"></p>\n<p>发现果然跟到了<code>.cxx_destruct</code>方法，而且是在<code>objc_storeStrong</code>的过程中释放</p>\n<hr>\n<h2 id=\"刨根问底-cxx-destruct\"><a href=\"#刨根问底-cxx-destruct\" class=\"headerlink\" title=\"刨根问底.cxx_destruct\"></a>刨根问底.cxx_destruct</h2><p>知道了ARC下对象实例变量的释放过程在<code>.cxx_destruct</code>内完成，但这个函数内部发生了什么，是如何调用<code>objc_storeStrong</code>释放变量的呢？<br>从上面的探究中知道，<code>.cxx_destruct</code>是编译器生成的代码，那它很可能在clang前端编译时完成，这让我联想到clang的<code>Code Generation</code>，因为之前曾经使用<code>clang -rewrite-objc xxx.m</code>时查看过官方文档留下了些印象，于是google：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.cxx_destruct site:clang.llvm.org</span><br></pre></td></tr></table></figure>\n<p>结果发现clang的<code>doxygen</code>文档中<code>CodeGenModule</code>模块正是这部分的实现代码，cxx相关的代码生成部分源码在<br><a href=\"http://clang.llvm.org/doxygen/CodeGenModule_8cpp-source.html\" target=\"_blank\" rel=\"external\">http://clang.llvm.org/doxygen/CodeGenModule_8cpp-source.html</a><br>位于1827行，删减掉离题部分如下：  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// EmitObjCIvarInitializations - Emit information for ivar initialization</span></span><br><span class=\"line\"><span class=\"comment\">/// for an implementation.</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> CodeGenModule::EmitObjCIvarInitializations(ObjCImplementationDecl *D)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DeclContext* DC = <span class=\"keyword\">const_cast</span>&lt;DeclContext*&gt;(dyn_cast&lt;DeclContext&gt;(D));</span><br><span class=\"line\">    assert(DC &amp;&amp; <span class=\"string\">\"EmitObjCIvarInitializations - null DeclContext\"</span>);</span><br><span class=\"line\">    IdentifierInfo *II = &amp;getContext().Idents.get(<span class=\"string\">\".cxx_destruct\"</span>);</span><br><span class=\"line\">    Selector cxxSelector = getContext().Selectors.getSelector(<span class=\"number\">0</span>, &amp;II);</span><br><span class=\"line\">    ObjCMethodDecl *DTORMethod = ObjCMethodDecl::Create(getContext(),</span><br><span class=\"line\">                                                        D-&gt;getLocation(),</span><br><span class=\"line\">                                                        D-&gt;getLocation(), cxxSelector,</span><br><span class=\"line\">                                                        getContext().VoidTy, <span class=\"number\">0</span>,</span><br><span class=\"line\">                                                        DC, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>,</span><br><span class=\"line\">                                                        ObjCMethodDecl::Required);</span><br><span class=\"line\">   D-&gt;addInstanceMethod(DTORMethod);</span><br><span class=\"line\">   CodeGenFunction(*<span class=\"keyword\">this</span>).GenerateObjCCtorDtorMethod(D, DTORMethod, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数大概作用是：获取<code>.cxx_destruct</code>的selector，创建Method，并加入到这个Class的方法列表中，最后一行的调用才是真的创建这个方法的实现。这个方法位于<br><a href=\"http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html\" target=\"_blank\" rel=\"external\">http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html</a><br>1354行，包含了构造和析构的cxx方法，继续跟随<code>.cxx_destruct</code>，最终调用<code>emitCXXDestructMethod</code>函数，代码如下：  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">emitCXXDestructMethod</span><span class=\"params\">(CodeGenFunction &amp;CGF, ObjCImplementationDecl *impl)</span></span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">   CodeGenFunction::<span class=\"function\">RunCleanupsScope <span class=\"title\">scope</span><span class=\"params\">(CGF)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   llvm::Value *self = CGF.LoadObjCSelf();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">const</span> ObjCInterfaceDecl *iface = impl-&gt;getClassInterface();</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> ObjCIvarDecl *ivar = iface-&gt;all_declared_ivar_begin(); ivar; ivar = ivar-&gt;getNextIvar())</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     QualType type = ivar-&gt;getType();</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// Check whether the ivar is a destructible type.</span></span><br><span class=\"line\">     QualType::DestructionKind dtorKind = type.isDestructedType();</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (!dtorKind) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">     CodeGenFunction::Destroyer *destroyer = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// Use a call to objc_storeStrong to destroy strong ivars, for the</span></span><br><span class=\"line\">     <span class=\"comment\">// general benefit of the tools.</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (dtorKind == QualType::DK_objc_strong_lifetime) &#123;</span><br><span class=\"line\">       destroyer = destroyARCStrongWithStore;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// Otherwise use the default for the destruction kind.</span></span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       destroyer = CGF.getDestroyer(dtorKind);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     CleanupKind cleanupKind = CGF.getCleanupKind(dtorKind);</span><br><span class=\"line\">     CGF.EHStack.pushCleanup&lt;DestroyIvar&gt;(cleanupKind, self, ivar, destroyer,</span><br><span class=\"line\">                                          cleanupKind &amp; EHCleanup);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   assert(scope.requiresCleanups() &amp;&amp; <span class=\"string\">\"nothing to do in .cxx_destruct?\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析这段代码以及其中调用后发现：它遍历当前对象所有的实例变量（Ivars)，调用<code>objc_storeStrong</code>，从<code>clang</code>的ARC文档上可以找到<code>objc_storeStrong</code>的示意代码实现如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">id <span class=\"title\">objc_storeStrong</span><span class=\"params\">(id *object, id value)</span> </span>&#123;</span><br><span class=\"line\">  value = [value retain];</span><br><span class=\"line\">  id oldValue = *object;</span><br><span class=\"line\">  *object = value;</span><br><span class=\"line\">  [oldValue release];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>.cxx_destruct</code>进行形如<code>objc_storeStrong(&amp;ivar, null)</code>的调用后，这个实例变量就被<code>release</code>和设置成<code>nil</code>了<br>注：真实的实现可以参考 <a href=\"http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html\" target=\"_blank\" rel=\"external\">http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html</a> 2078行</p>\n<hr>\n<h2 id=\"自动调用-super-dealloc-的实现\"><a href=\"#自动调用-super-dealloc-的实现\" class=\"headerlink\" title=\"自动调用[super dealloc]的实现\"></a>自动调用[super dealloc]的实现</h2><p>按照上面的思路，自动调用<code>[super dealloc]</code>也一定是<code>CodeGen</code>干的工作了<br>位于 <a href=\"http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html\" target=\"_blank\" rel=\"external\">http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html</a> 492行<br><code>StartObjCMethod</code>方法中：  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (ident-&gt;isStr(<span class=\"string\">\"dealloc\"</span>))</span><br><span class=\"line\">   EHStack.pushCleanup&lt;FinishARCDealloc&gt;(getARCCleanupKind());</span><br></pre></td></tr></table></figure>\n<p>上面代码可以得知在调用<code>dealloc</code>方法时被插入了代码，由<code>FinishARCDealloc</code>结构定义：  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> FinishARCDealloc : EHScopeStack::Cleanup &#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Emit</span><span class=\"params\">(CodeGenFunction &amp;CGF, Flags flags)</span> override </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">const</span> ObjCMethodDecl *method = cast&lt;ObjCMethodDecl&gt;(CGF.CurCodeDecl);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">const</span> ObjCImplDecl *impl = cast&lt;ObjCImplDecl&gt;(method-&gt;getDeclContext());</span><br><span class=\"line\">     <span class=\"keyword\">const</span> ObjCInterfaceDecl *iface = impl-&gt;getClassInterface();</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (!iface-&gt;getSuperClass()) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">bool</span> isCategory = isa&lt;ObjCCategoryImplDecl&gt;(impl);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// Call [super dealloc] if we have a superclass.</span></span><br><span class=\"line\">     llvm::Value *self = CGF.LoadObjCSelf();</span><br><span class=\"line\"></span><br><span class=\"line\">     CallArgList args;</span><br><span class=\"line\">     CGF.CGM.getObjCRuntime().GenerateMessageSendSuper(CGF, ReturnValueSlot(),</span><br><span class=\"line\">                                                       CGF.getContext().VoidTy,</span><br><span class=\"line\">                                                       method-&gt;getSelector(),</span><br><span class=\"line\">                                                       iface,</span><br><span class=\"line\">                                                       isCategory,</span><br><span class=\"line\">                                                       self,</span><br><span class=\"line\">                                                       <span class=\"comment\">/*is class msg*/</span> <span class=\"literal\">false</span>,</span><br><span class=\"line\">                                                       args,</span><br><span class=\"line\">                                                       method);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面代码基本上就是向父类转发<code>dealloc</code>的调用，实现了自动调用<code>[super dealloc]</code>方法。  </p>\n<hr>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>ARC下对象的成员变量于编译器插入的<code>.cxx_desctruct</code>方法自动释放</li>\n<li>ARC下<code>[super dealloc]</code>方法也由编译器自动插入</li>\n<li>所谓<code>编译器插入代码</code>过程需要进一步了解，还不清楚其运作方式</li>\n<li>clang的<code>CodeGen</code>也值得深入研究一下</li>\n</ul>\n<hr>\n<h2 id=\"References：\"><a href=\"#References：\" class=\"headerlink\" title=\"References：\"></a>References：</h2><ul>\n<li><a href=\"http://clang.llvm.org/docs/AutomaticReferenceCounting.html\" target=\"_blank\" rel=\"external\">http://clang.llvm.org/docs/AutomaticReferenceCounting.html</a></li>\n<li><a href=\"http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03\" target=\"_blank\" rel=\"external\">http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03</a></li>\n<li><a href=\"http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html\" target=\"_blank\" rel=\"external\">http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html</a></li>\n</ul>\n<hr>\n<p>原创文章，转载请注明源地址，<a href=\"http://blog.sunnyxx.com\">blog.sunnyxx.com</a></p>\n","excerpt":"","more":"<h2 id=\"我是前言\"><a href=\"#我是前言\" class=\"headerlink\" title=\"我是前言\"></a>我是前言</h2><p>这次探索源自于自己一直以来对<code>ARC</code>的一个疑问，在<code>MRC</code>时代，经常写下面的代码：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.array = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.string = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"comment\">// ... //</span></span><br><span class=\"line\">    <span class=\"comment\">// 非Objc对象内存的释放，如CFRelease(...)</span></span><br><span class=\"line\">    <span class=\"comment\">// ... //</span></span><br><span class=\"line\">    [<span class=\"keyword\">super</span> dealloc];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对象析构时将内部其他对象<code>release</code>掉，申请的非Objc对象的内存当然也一并处理掉，最后调用<code>super</code>，继续将父类对象做析构。而现如今到了<code>ARC</code>时代，只剩下了下面的代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... //</span></span><br><span class=\"line\">    <span class=\"comment\">// 非Objc对象内存的释放，如CFRelease(...)</span></span><br><span class=\"line\">    <span class=\"comment\">// ... //</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>问题来了：</strong>  </p>\n<ol>\n<li>这个对象实例变量（Ivars）的释放去哪儿了？</li>\n<li>没有显示的调用<code>[super dealloc]</code>，上层的析构去哪儿了？</li>\n</ol>\n<hr>\n<h2 id=\"ARC文档中对dealloc过程的解释\"><a href=\"#ARC文档中对dealloc过程的解释\" class=\"headerlink\" title=\"ARC文档中对dealloc过程的解释\"></a>ARC文档中对dealloc过程的解释</h2><p><a href=\"http://clang.llvm.org/docs/AutomaticReferenceCounting.html#dealloc\">llvm官方的ARC文档</a>中对ARC下的dealloc过程做了简单说明，从中还是能找出些有用的信息：</p>\n<blockquote>\n<p>A class may provide a method definition for an instance method named dealloc. This method will be called after the final release of the object but before it is deallocated or any of its instance variables are destroyed. The superclass’s implementation of dealloc will be called automatically when the method returns.</p>\n</blockquote>\n<ul>\n<li>大概意思是：dealloc方法在最后一次release后被调用，但此时实例变量（Ivars）并未释放，<strong>父类的dealloc的方法将在子类dealloc方法返回后自动调用</strong></li>\n</ul>\n<blockquote>\n<p>The instance variables for an ARC-compiled class will be destroyed at some point after control enters the dealloc method for the root class of the class. The ordering of the destruction of instance variables is unspecified, both within a single class and between subclasses and superclasses.</p>\n</blockquote>\n<ul>\n<li>理解：ARC下对象的实例变量在根类[NSObject dealloc]中释放（通常root class都是NSObject），变量释放顺序各种不确定（一个类内的不确定，子类和父类间也不确定，也就是说不用care释放顺序）</li>\n</ul>\n<p>所以，不用主调<code>[super dealloc]</code>是因为自动调了，后面再说如何实现的；ARC下实例变量在根类NSObject析构时析构，下面就探究下。</p>\n<hr>\n<h2 id=\"NSObject的析构过程\"><a href=\"#NSObject的析构过程\" class=\"headerlink\" title=\"NSObject的析构过程\"></a>NSObject的析构过程</h2><p>通过apple的runtime源码，不难发现NSObject执行<code>dealloc</code>时调用<code>_objc_rootDealloc</code>继而调用<code>object_dispose</code>随后调用<code>objc_destructInstance</code>方法，前几步都是条件判断和简单的跳转，最后的这个函数如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> *objc_destructInstance(<span class=\"keyword\">id</span> obj)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) &#123;</span><br><span class=\"line\">        Class isa_gen = _object_getClass(obj);</span><br><span class=\"line\">        class_t *isa = newcls(isa_gen);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Read all of the flags at once for performance.</span></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> cxx = hasCxxStructors(isa);</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> assoc = !UseGC &amp;&amp; _class_instancesHaveAssociatedObjects(isa_gen);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// This order is important.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cxx) object_cxxDestruct(obj);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!UseGC) objc_clear_deallocating(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单明确的干了三件事：</p>\n<ol>\n<li>执行一个叫<code>object_cxxDestruct</code>的东西干了点什么事</li>\n<li>执行<code>_object_remove_assocations</code>去除和这个对象assocate的对象（常用于category中添加带变量的属性，这也是为什么<del><strike>ARC下没必要remove一遍的原因</del></strike> (Edit: 在ARC或MRC下都不需要remove，感谢@sagles的基情提示）</li>\n<li>执行<code>objc_clear_deallocating</code>，清空引用计数表并清除弱引用表，将所有<code>weak</code>引用指nil（这也就是weak变量能安全置空的所在）</li>\n</ol>\n<p>所以，所探寻的ARC自动释放实例变量的地方就在<code>cxxDestruct</code>这个东西里面没跑了。</p>\n<hr>\n<h2 id=\"探寻隐藏的-cxx-destruct\"><a href=\"#探寻隐藏的-cxx-destruct\" class=\"headerlink\" title=\"探寻隐藏的.cxx_destruct\"></a>探寻隐藏的.cxx_destruct</h2><p>上面找到的名为<code>object_cxxDestruct</code>的方法最终成为下面的调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> object_cxxDestructFromClass(<span class=\"keyword\">id</span> obj, Class cls)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*dtor)(<span class=\"keyword\">id</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Call cls's dtor first, then superclasses's dtors.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( ; cls != <span class=\"literal\">NULL</span>; cls = _class_getSuperclass(cls)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!_class_hasCxxStructors(cls)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        dtor = (<span class=\"keyword\">void</span>(*)(<span class=\"keyword\">id</span>))</span><br><span class=\"line\">            lookupMethodInClassAndLoadCache(cls, SEL_cxx_destruct);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dtor != (<span class=\"keyword\">void</span>(*)(<span class=\"keyword\">id</span>))_objc_msgForward_internal) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (PrintCxxCtors) &#123;</span><br><span class=\"line\">                _objc_inform(<span class=\"string\">\"CXX: calling C++ destructors for class %s\"</span>,</span><br><span class=\"line\">                             _class_getName(cls));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            (*dtor)(obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码也不难理解，沿着继承链逐层向上搜寻<code>SEL_cxx_destruct</code>这个selector，找到函数实现(<code>void (*)(id)</code>(函数指针)并执行。<br>搜索这个selector的声明，发现是名为<code>.cxx_destruct</code>的方法，以点开头的名字，我想和unix的文件一样，是有<strong>隐藏</strong>属性的</p>\n<p>从<a href=\"http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03\">这篇文章</a>中：</p>\n<blockquote>\n<p>ARC actually creates a -.cxx_destruct method to handle freeing instance variables. This method was originally created for calling C++ destructors automatically when an object was destroyed.</p>\n</blockquote>\n<p>和《Effective Objective-C 2.0》中提到的：</p>\n<blockquote>\n<p>When the compiler saw that an object contained C++ objects, it would generate a method called .cxx_destruct. ARC piggybacks on this method and emits the required cleanup code within it.  </p>\n</blockquote>\n<p>可以了解到，<code>.cxx_destruct</code>方法原本是为了C++对象析构的，ARC借用了这个方法插入代码实现了自动内存释放的工作</p>\n<hr>\n<h2 id=\"通过实验找出-cxx-destruct\"><a href=\"#通过实验找出-cxx-destruct\" class=\"headerlink\" title=\"通过实验找出.cxx_destruct\"></a>通过实验找出.cxx_destruct</h2><p>最好的办法还是写个测试代码把这个隐藏的方法找出来，其实在runtime中运行已经没什么隐藏可言了，简单的类结构如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Father</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Son</span> : <span class=\"title\">Father</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSArray</span> *toys;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>只有两个简单的属性，找个地方写简单的测试代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// start</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// before new</span></span><br><span class=\"line\">    Son *son = [Son new];</span><br><span class=\"line\">    son.name = <span class=\"string\">@\"sark\"</span>;</span><br><span class=\"line\">    son.toys = @[<span class=\"string\">@\"sunny\"</span>, <span class=\"string\">@\"xx\"</span>];</span><br><span class=\"line\">    <span class=\"comment\">// after new</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// gone</span></span><br></pre></td></tr></table></figure>\n<p>主要目的是为了让这个对象走dealloc方法，新建的son对象过了大括号作用域就会释放了，所以在<code>after new</code>这行son对象初始化完成，在<code>gone</code>这行son对象被dealloc  </p>\n<p>个人一直喜欢使用<a href=\"https://github.com/garnett/DLIntrospection\">NSObject+DLIntrospection</a>这个扩展作为调试工具，可以轻松打出一个类的方法，变量等等。  </p>\n<p>将这个扩展引入工程内，在<code>after new</code>处设置一个断点，run，trigger后使用lldb命令用这个扩展输出Son类所有的方法名：</p>\n<p><img src=\"http://ww3.sinaimg.cn/large/51530583gw1ef27srhw7lj208b05ujrq.jpg\" alt=\"\"></p>\n<p>发现了这个<code>.cxx_destruct</code>方法，经过几次试验，发现：</p>\n<ol>\n<li>只有在ARC下这个方法才会出现（试验代码的情况下）</li>\n<li>只有当前类拥有实例变量时（不论是不是用property）这个方法才会出现，且父类的实例变量不会导致子类拥有这个方法</li>\n<li>出现这个方法和变量是否被赋值，赋值成什么没有关系</li>\n</ol>\n<hr>\n<h2 id=\"使用watchpoint定位内存释放时刻\"><a href=\"#使用watchpoint定位内存释放时刻\" class=\"headerlink\" title=\"使用watchpoint定位内存释放时刻\"></a>使用watchpoint定位内存释放时刻</h2><p>依然在<code>after new</code>断点处，输入lldb命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watchpoint set variable son-&gt;_name</span><br></pre></td></tr></table></figure></p>\n<p>将<code>name</code>的变量加入watchpoint，当这个变量被修改时会触发trigger：</p>\n<p><img src=\"http://ww3.sinaimg.cn/large/51530583gw1ef28rn41lcj20fs03aq3b.jpg\" alt=\"\"></p>\n<p>从中可以看出，在这个时刻，<code>_name</code>从0x00006b98变成了0x0，也就是nil，赶紧看下调用栈：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/51530583gw1ef2911o40zj20a605yweu.jpg\" alt=\"\"></p>\n<p>发现果然跟到了<code>.cxx_destruct</code>方法，而且是在<code>objc_storeStrong</code>的过程中释放</p>\n<hr>\n<h2 id=\"刨根问底-cxx-destruct\"><a href=\"#刨根问底-cxx-destruct\" class=\"headerlink\" title=\"刨根问底.cxx_destruct\"></a>刨根问底.cxx_destruct</h2><p>知道了ARC下对象实例变量的释放过程在<code>.cxx_destruct</code>内完成，但这个函数内部发生了什么，是如何调用<code>objc_storeStrong</code>释放变量的呢？<br>从上面的探究中知道，<code>.cxx_destruct</code>是编译器生成的代码，那它很可能在clang前端编译时完成，这让我联想到clang的<code>Code Generation</code>，因为之前曾经使用<code>clang -rewrite-objc xxx.m</code>时查看过官方文档留下了些印象，于是google：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.cxx_destruct site:clang.llvm.org</span><br></pre></td></tr></table></figure>\n<p>结果发现clang的<code>doxygen</code>文档中<code>CodeGenModule</code>模块正是这部分的实现代码，cxx相关的代码生成部分源码在<br><a href=\"http://clang.llvm.org/doxygen/CodeGenModule_8cpp-source.html\">http://clang.llvm.org/doxygen/CodeGenModule_8cpp-source.html</a><br>位于1827行，删减掉离题部分如下：  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// EmitObjCIvarInitializations - Emit information for ivar initialization</span></span><br><span class=\"line\"><span class=\"comment\">/// for an implementation.</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> CodeGenModule::EmitObjCIvarInitializations(ObjCImplementationDecl *D)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DeclContext* DC = <span class=\"keyword\">const_cast</span>&lt;DeclContext*&gt;(dyn_cast&lt;DeclContext&gt;(D));</span><br><span class=\"line\">    assert(DC &amp;&amp; <span class=\"string\">\"EmitObjCIvarInitializations - null DeclContext\"</span>);</span><br><span class=\"line\">    IdentifierInfo *II = &amp;getContext().Idents.get(<span class=\"string\">\".cxx_destruct\"</span>);</span><br><span class=\"line\">    Selector cxxSelector = getContext().Selectors.getSelector(<span class=\"number\">0</span>, &amp;II);</span><br><span class=\"line\">    ObjCMethodDecl *DTORMethod = ObjCMethodDecl::Create(getContext(),</span><br><span class=\"line\">                                                        D-&gt;getLocation(),</span><br><span class=\"line\">                                                        D-&gt;getLocation(), cxxSelector,</span><br><span class=\"line\">                                                        getContext().VoidTy, <span class=\"number\">0</span>,</span><br><span class=\"line\">                                                        DC, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>,</span><br><span class=\"line\">                                                        ObjCMethodDecl::Required);</span><br><span class=\"line\">   D-&gt;addInstanceMethod(DTORMethod);</span><br><span class=\"line\">   CodeGenFunction(*<span class=\"keyword\">this</span>).GenerateObjCCtorDtorMethod(D, DTORMethod, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数大概作用是：获取<code>.cxx_destruct</code>的selector，创建Method，并加入到这个Class的方法列表中，最后一行的调用才是真的创建这个方法的实现。这个方法位于<br><a href=\"http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html\">http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html</a><br>1354行，包含了构造和析构的cxx方法，继续跟随<code>.cxx_destruct</code>，最终调用<code>emitCXXDestructMethod</code>函数，代码如下：  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">emitCXXDestructMethod</span><span class=\"params\">(CodeGenFunction &amp;CGF, ObjCImplementationDecl *impl)</span></span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">   CodeGenFunction::<span class=\"function\">RunCleanupsScope <span class=\"title\">scope</span><span class=\"params\">(CGF)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   llvm::Value *self = CGF.LoadObjCSelf();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">const</span> ObjCInterfaceDecl *iface = impl-&gt;getClassInterface();</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> ObjCIvarDecl *ivar = iface-&gt;all_declared_ivar_begin(); ivar; ivar = ivar-&gt;getNextIvar())</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     QualType type = ivar-&gt;getType();</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// Check whether the ivar is a destructible type.</span></span><br><span class=\"line\">     QualType::DestructionKind dtorKind = type.isDestructedType();</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (!dtorKind) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">     CodeGenFunction::Destroyer *destroyer = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// Use a call to objc_storeStrong to destroy strong ivars, for the</span></span><br><span class=\"line\">     <span class=\"comment\">// general benefit of the tools.</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (dtorKind == QualType::DK_objc_strong_lifetime) &#123;</span><br><span class=\"line\">       destroyer = destroyARCStrongWithStore;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// Otherwise use the default for the destruction kind.</span></span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       destroyer = CGF.getDestroyer(dtorKind);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     CleanupKind cleanupKind = CGF.getCleanupKind(dtorKind);</span><br><span class=\"line\">     CGF.EHStack.pushCleanup&lt;DestroyIvar&gt;(cleanupKind, self, ivar, destroyer,</span><br><span class=\"line\">                                          cleanupKind &amp; EHCleanup);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   assert(scope.requiresCleanups() &amp;&amp; <span class=\"string\">\"nothing to do in .cxx_destruct?\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析这段代码以及其中调用后发现：它遍历当前对象所有的实例变量（Ivars)，调用<code>objc_storeStrong</code>，从<code>clang</code>的ARC文档上可以找到<code>objc_storeStrong</code>的示意代码实现如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">id <span class=\"title\">objc_storeStrong</span><span class=\"params\">(id *object, id value)</span> </span>&#123;</span><br><span class=\"line\">  value = [value retain];</span><br><span class=\"line\">  id oldValue = *object;</span><br><span class=\"line\">  *object = value;</span><br><span class=\"line\">  [oldValue release];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>.cxx_destruct</code>进行形如<code>objc_storeStrong(&amp;ivar, null)</code>的调用后，这个实例变量就被<code>release</code>和设置成<code>nil</code>了<br>注：真实的实现可以参考 <a href=\"http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html\">http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html</a> 2078行</p>\n<hr>\n<h2 id=\"自动调用-super-dealloc-的实现\"><a href=\"#自动调用-super-dealloc-的实现\" class=\"headerlink\" title=\"自动调用[super dealloc]的实现\"></a>自动调用[super dealloc]的实现</h2><p>按照上面的思路，自动调用<code>[super dealloc]</code>也一定是<code>CodeGen</code>干的工作了<br>位于 <a href=\"http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html\">http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html</a> 492行<br><code>StartObjCMethod</code>方法中：  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (ident-&gt;isStr(<span class=\"string\">\"dealloc\"</span>))</span><br><span class=\"line\">   EHStack.pushCleanup&lt;FinishARCDealloc&gt;(getARCCleanupKind());</span><br></pre></td></tr></table></figure>\n<p>上面代码可以得知在调用<code>dealloc</code>方法时被插入了代码，由<code>FinishARCDealloc</code>结构定义：  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> FinishARCDealloc : EHScopeStack::Cleanup &#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Emit</span><span class=\"params\">(CodeGenFunction &amp;CGF, Flags flags)</span> override </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">const</span> ObjCMethodDecl *method = cast&lt;ObjCMethodDecl&gt;(CGF.CurCodeDecl);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">const</span> ObjCImplDecl *impl = cast&lt;ObjCImplDecl&gt;(method-&gt;getDeclContext());</span><br><span class=\"line\">     <span class=\"keyword\">const</span> ObjCInterfaceDecl *iface = impl-&gt;getClassInterface();</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (!iface-&gt;getSuperClass()) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">bool</span> isCategory = isa&lt;ObjCCategoryImplDecl&gt;(impl);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// Call [super dealloc] if we have a superclass.</span></span><br><span class=\"line\">     llvm::Value *self = CGF.LoadObjCSelf();</span><br><span class=\"line\"></span><br><span class=\"line\">     CallArgList args;</span><br><span class=\"line\">     CGF.CGM.getObjCRuntime().GenerateMessageSendSuper(CGF, ReturnValueSlot(),</span><br><span class=\"line\">                                                       CGF.getContext().VoidTy,</span><br><span class=\"line\">                                                       method-&gt;getSelector(),</span><br><span class=\"line\">                                                       iface,</span><br><span class=\"line\">                                                       isCategory,</span><br><span class=\"line\">                                                       self,</span><br><span class=\"line\">                                                       <span class=\"comment\">/*is class msg*/</span> <span class=\"literal\">false</span>,</span><br><span class=\"line\">                                                       args,</span><br><span class=\"line\">                                                       method);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面代码基本上就是向父类转发<code>dealloc</code>的调用，实现了自动调用<code>[super dealloc]</code>方法。  </p>\n<hr>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>ARC下对象的成员变量于编译器插入的<code>.cxx_desctruct</code>方法自动释放</li>\n<li>ARC下<code>[super dealloc]</code>方法也由编译器自动插入</li>\n<li>所谓<code>编译器插入代码</code>过程需要进一步了解，还不清楚其运作方式</li>\n<li>clang的<code>CodeGen</code>也值得深入研究一下</li>\n</ul>\n<hr>\n<h2 id=\"References：\"><a href=\"#References：\" class=\"headerlink\" title=\"References：\"></a>References：</h2><ul>\n<li><a href=\"http://clang.llvm.org/docs/AutomaticReferenceCounting.html\">http://clang.llvm.org/docs/AutomaticReferenceCounting.html</a></li>\n<li><a href=\"http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03\">http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03</a></li>\n<li><a href=\"http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html\">http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html</a></li>\n</ul>\n<hr>\n<p>原创文章，转载请注明源地址，<a href=\"http://blog.sunnyxx.com\">blog.sunnyxx.com</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cimd6pxj80000ev120f5jx4co","tag_id":"cimd6pxjk0002ev12q4wqrztu","_id":"cimd6pxjv0007ev12sdbvps5e"},{"post_id":"cimd6pxjv0008ev12icf9ywxj","tag_id":"cimd6pxjr0005ev12bsnmtg2u","_id":"cimd6pxk7000bev12d7mgv7vq"},{"post_id":"cimd6pxjg0001ev12ufix4l5u","tag_id":"cimd6pxjr0005ev12bsnmtg2u","_id":"cimd6pxkb000dev12enbf2j3w"},{"post_id":"cimd6pxjx0009ev12ieb16bo1","tag_id":"cimd6pxjk0002ev12q4wqrztu","_id":"cimd6pxke000gev1294fo8u4u"},{"post_id":"cimd6pxjo0003ev12xnfojjnz","tag_id":"cimd6pxjk0002ev12q4wqrztu","_id":"cimd6pxkg000iev1269xi5ipn"},{"post_id":"cimd6pxjs0006ev12oj9ya2gt","tag_id":"cimd6pxjr0005ev12bsnmtg2u","_id":"cimd6pxki000lev12akfqmk17"},{"post_id":"cimd6pxkh000jev12evi2wo22","tag_id":"cimd6pxjk0002ev12q4wqrztu","_id":"cimd6pxkk000nev125fhfmakz"},{"post_id":"cimd6pxkj000mev12w4stctbm","tag_id":"cimd6pxki000kev129d8dsvp8","_id":"cimd6pxkl000qev12nfyl8vkz"},{"post_id":"cimd6pxk8000cev12hp35dhft","tag_id":"cimd6pxki000kev129d8dsvp8","_id":"cimd6pxkp000sev125gmhfp0n"},{"post_id":"cimd6pxkk000oev12civ6jex8","tag_id":"cimd6pxjk0002ev12q4wqrztu","_id":"cimd6pxkr000vev12w1t7pcoa"},{"post_id":"cimd6pxkb000eev12kka9pkqc","tag_id":"cimd6pxkl000pev12ip1eg0y5","_id":"cimd6pxkv000xev12ncdkg4qc"},{"post_id":"cimd6pxkf000hev12uyx2twh9","tag_id":"cimd6pxkl000pev12ip1eg0y5","_id":"cimd6pxl20011ev12fv4ae73s"},{"post_id":"cimd6pxkw000yev128f3utq3x","tag_id":"cimd6pxjk0002ev12q4wqrztu","_id":"cimd6pxl70013ev12lwsrtk4p"},{"post_id":"cimd6pxl10010ev12viag5x5n","tag_id":"cimd6pxjk0002ev12q4wqrztu","_id":"cimd6pxld0016ev12bi5nrxsk"},{"post_id":"cimd6pxl50012ev12hrgazec6","tag_id":"cimd6pxl0000zev12exdx882n","_id":"cimd6pxlg0018ev12ab47xizc"},{"post_id":"cimd6pxkn000rev121wxmuhoy","tag_id":"cimd6pxl0000zev12exdx882n","_id":"cimd6pxlj001bev12m7byf8gd"},{"post_id":"cimd6pxl90015ev12tncb2xeg","tag_id":"cimd6pxki000kev129d8dsvp8","_id":"cimd6pxlm001dev12842pat7n"},{"post_id":"cimd6pxle0017ev12hhtydqze","tag_id":"cimd6pxjk0002ev12q4wqrztu","_id":"cimd6pxlo001gev12ndzdmfb4"},{"post_id":"cimd6pxkp000tev12doifvsht","tag_id":"cimd6pxl80014ev125o9twcqt","_id":"cimd6pxlr001iev127kppykkx"},{"post_id":"cimd6pxlk001cev128hqmeqfj","tag_id":"cimd6pxjk0002ev12q4wqrztu","_id":"cimd6pxlw001kev12jp0srty0"},{"post_id":"cimd6pxks000wev12eajgfp5w","tag_id":"cimd6pxl80014ev125o9twcqt","_id":"cimd6pxlz001nev12x3uk43fx"},{"post_id":"cimd6pxln001eev12manxriwp","tag_id":"cimd6pxjk0002ev12q4wqrztu","_id":"cimd6pxm2001pev12mzm4vm67"},{"post_id":"cimd6pxlh0019ev12i8o8r92u","tag_id":"cimd6pxlo001fev12oiwk1d02","_id":"cimd6pxm5001rev12urvaqz7w"},{"post_id":"cimd6pxlt001jev12hbpf5a2z","tag_id":"cimd6pxjr0005ev12bsnmtg2u","_id":"cimd6pxm7001tev12btcqnexq"},{"post_id":"cimd6pxlx001mev12bif5jkkk","tag_id":"cimd6pxjk0002ev12q4wqrztu","_id":"cimd6pxma001vev129mcwes6i"},{"post_id":"cimd6pxm1001oev128qbxzzhg","tag_id":"cimd6pxlo001fev12oiwk1d02","_id":"cimd6pxmf001xev1210gf26la"},{"post_id":"cimd6pxlp001hev128k91ejj4","tag_id":"cimd6pxlw001lev126c76rxhv","_id":"cimd6pxmh001zev121u68kze6"},{"post_id":"cimd6pxm3001qev12778qqixj","tag_id":"cimd6pxlo001fev12oiwk1d02","_id":"cimd6pxmj0021ev129lprnacv"},{"post_id":"cimd6pxm5001sev12qarvnp0j","tag_id":"cimd6pxjr0005ev12bsnmtg2u","_id":"cimd6pxmm0024ev122qcicphn"},{"post_id":"cimd6pxm8001uev12wp973vdu","tag_id":"cimd6pxjr0005ev12bsnmtg2u","_id":"cimd6pxmp0026ev12j1s4kzf0"},{"post_id":"cimd6pxmb001wev12pw892v7i","tag_id":"cimd6pxlo001fev12oiwk1d02","_id":"cimd6pxmr0029ev12cynf5cew"},{"post_id":"cimd6pxmo0025ev12jxjiekp6","tag_id":"cimd6pxmk0022ev122bo46yxr","_id":"cimd6pxmt002bev12t3qzc7zx"},{"post_id":"cimd6pxmf001yev12bgw45v75","tag_id":"cimd6pxmk0022ev122bo46yxr","_id":"cimd6pxmv002eev12nqk3mhyd"},{"post_id":"cimd6pxmq0028ev12v71tv0e4","tag_id":"cimd6pxmk0022ev122bo46yxr","_id":"cimd6pxmw002gev125szyhkrj"},{"post_id":"cimd6pxmr002aev12pa6rj0pw","tag_id":"cimd6pxki000kev129d8dsvp8","_id":"cimd6pxmy002iev12u92hxkln"},{"post_id":"cimd6pxmh0020ev12w6ac93kl","tag_id":"cimd6pxmk0022ev122bo46yxr","_id":"cimd6pxn0002kev12bqrab63k"},{"post_id":"cimd6pxmt002dev12oy0e5293","tag_id":"cimd6pxjr0005ev12bsnmtg2u","_id":"cimd6pxn4002nev12qlmeb1hk"},{"post_id":"cimd6pxmv002fev123tfx87dp","tag_id":"cimd6pxjk0002ev12q4wqrztu","_id":"cimd6pxn7002pev12nn204xax"},{"post_id":"cimd6pxmk0023ev12ypp0qc8a","tag_id":"cimd6pxmk0022ev122bo46yxr","_id":"cimd6pxn9002rev12qt2a1pqg"},{"post_id":"cimd6pxmy002jev127vb2kg0j","tag_id":"cimd6pxki000kev129d8dsvp8","_id":"cimd6pxna002tev120u6bpwzd"},{"post_id":"cimd6pxn2002mev12w8lybxbh","tag_id":"cimd6pxjk0002ev12q4wqrztu","_id":"cimd6pxna002uev12fe0kkl4q"},{"post_id":"cimd6pxmx002hev12xh7n2roc","tag_id":"cimd6pxn1002lev120tf26kxa","_id":"cimd6pxna002vev12mzr7opij"},{"post_id":"cimd6pxn7002qev12lfiuetwb","tag_id":"cimd6pxjr0005ev12bsnmtg2u","_id":"cimd6pxna002wev12w3wszpvw"},{"post_id":"cimd6pxn5002oev1218c8w74g","tag_id":"cimd6pxn9002sev12uayylzjn","_id":"cimd6pxna002xev12dw8tltzj"}],"Tag":[{"name":"ios最佳实践","_id":"cimd6pxjk0002ev12q4wqrztu"},{"name":"objc刨根问底","_id":"cimd6pxjr0005ev12bsnmtg2u"},{"name":"wtf","_id":"cimd6pxki000kev129d8dsvp8"},{"name":"hexo","_id":"cimd6pxkl000pev12ip1eg0y5"},{"name":"iOS8","_id":"cimd6pxl0000zev12exdx882n"},{"name":"ios6级考试","_id":"cimd6pxl80014ev125o9twcqt"},{"name":"objc的秘密","_id":"cimd6pxlo001fev12oiwk1d02"},{"name":"iOS9","_id":"cimd6pxlw001lev126c76rxhv"},{"name":"Reactive Cocoa Tutorial","_id":"cimd6pxmk0022ev122bo46yxr"},{"name":"开发工具","_id":"cimd6pxn1002lev120tf26kxa"},{"name":"xcode","_id":"cimd6pxn9002sev12uayylzjn"}]}}